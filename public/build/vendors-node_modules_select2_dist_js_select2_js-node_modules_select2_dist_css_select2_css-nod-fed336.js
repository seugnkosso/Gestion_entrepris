(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_select2_dist_js_select2_js-node_modules_select2_dist_css_select2_css-nod-fed336"],{

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/select2/dist/js/select2.js":
/*!*************************************************!*\
  !*** ./node_modules/select2/dist/js/select2.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Select2 4.1.0-rc.0
 * https://select2.github.io
 *
 * Released under the MIT license
 * https://github.com/select2/select2/blob/master/LICENSE.md
 */
;(function (factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
} (function (jQuery) {
  // This is needed so we can catch the AMD loader configuration and use it
  // The inner file should be wrapped (by `banner.start.js`) in a function that
  // returns the AMD loader references.
  var S2 =(function () {
  // Restore the Select2 AMD loader so it can be used
  // Needed mostly in the language files, where the loader is not inserted
  if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
    var S2 = jQuery.fn.select2.amd;
  }
var S2;(function () { if (!S2 || !S2.requirejs) {
if (!S2) { S2 = {}; } else { require = S2; }
/**
 * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/almond/LICENSE
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name) {
            name = name.split('/');
            lastIndex = name.length - 1;

            // If wanting node ID compatibility, strip .js from end
            // of IDs. Have to do this here, and not in nameToUrl
            // because node allows either .js or non .js to map
            // to same file.
            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
            }

            // Starts with a '.' so need the baseName
            if (name[0].charAt(0) === '.' && baseParts) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that 'directory' and not name of the baseName's
                //module. For instance, baseName of 'one/two/three', maps to
                //'one/two/three.js', but we want the directory, 'one/two' for
                //this normalization.
                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                name = normalizedBaseParts.concat(name);
            }

            //start trimDots
            for (i = 0; i < name.length; i++) {
                part = name[i];
                if (part === '.') {
                    name.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        name.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
            //end trimDots

            name = name.join('/');
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    //Creates a parts array for a relName where first part is plugin ID,
    //second part is resource ID. Assumes relName has already been normalized.
    function makeRelParts(relName) {
        return relName ? splitPrefix(relName) : [];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relParts) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0],
            relResourceName = relParts[1];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relResourceName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relResourceName));
            } else {
                name = normalize(name, relResourceName);
            }
        } else {
            name = normalize(name, relResourceName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i, relParts,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;
        relParts = makeRelParts(relName);

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relParts);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, makeRelParts(callback)).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

S2.requirejs = requirejs;S2.require = require;S2.define = define;
}
}());
S2.define("almond", function(){});

/* global jQuery:false, $:false */
S2.define('jquery',[],function () {
  var _$ = jQuery || $;

  if (_$ == null && console && console.error) {
    console.error(
      'Select2: An instance of jQuery or a jQuery-compatible library was not ' +
      'found. Make sure that you are including jQuery before Select2 on your ' +
      'web page.'
    );
  }

  return _$;
});

S2.define('select2/utils',[
  'jquery'
], function ($) {
  var Utils = {};

  Utils.Extend = function (ChildClass, SuperClass) {
    var __hasProp = {}.hasOwnProperty;

    function BaseConstructor () {
      this.constructor = ChildClass;
    }

    for (var key in SuperClass) {
      if (__hasProp.call(SuperClass, key)) {
        ChildClass[key] = SuperClass[key];
      }
    }

    BaseConstructor.prototype = SuperClass.prototype;
    ChildClass.prototype = new BaseConstructor();
    ChildClass.__super__ = SuperClass.prototype;

    return ChildClass;
  };

  function getMethods (theClass) {
    var proto = theClass.prototype;

    var methods = [];

    for (var methodName in proto) {
      var m = proto[methodName];

      if (typeof m !== 'function') {
        continue;
      }

      if (methodName === 'constructor') {
        continue;
      }

      methods.push(methodName);
    }

    return methods;
  }

  Utils.Decorate = function (SuperClass, DecoratorClass) {
    var decoratedMethods = getMethods(DecoratorClass);
    var superMethods = getMethods(SuperClass);

    function DecoratedClass () {
      var unshift = Array.prototype.unshift;

      var argCount = DecoratorClass.prototype.constructor.length;

      var calledConstructor = SuperClass.prototype.constructor;

      if (argCount > 0) {
        unshift.call(arguments, SuperClass.prototype.constructor);

        calledConstructor = DecoratorClass.prototype.constructor;
      }

      calledConstructor.apply(this, arguments);
    }

    DecoratorClass.displayName = SuperClass.displayName;

    function ctr () {
      this.constructor = DecoratedClass;
    }

    DecoratedClass.prototype = new ctr();

    for (var m = 0; m < superMethods.length; m++) {
      var superMethod = superMethods[m];

      DecoratedClass.prototype[superMethod] =
        SuperClass.prototype[superMethod];
    }

    var calledMethod = function (methodName) {
      // Stub out the original method if it's not decorating an actual method
      var originalMethod = function () {};

      if (methodName in DecoratedClass.prototype) {
        originalMethod = DecoratedClass.prototype[methodName];
      }

      var decoratedMethod = DecoratorClass.prototype[methodName];

      return function () {
        var unshift = Array.prototype.unshift;

        unshift.call(arguments, originalMethod);

        return decoratedMethod.apply(this, arguments);
      };
    };

    for (var d = 0; d < decoratedMethods.length; d++) {
      var decoratedMethod = decoratedMethods[d];

      DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
    }

    return DecoratedClass;
  };

  var Observable = function () {
    this.listeners = {};
  };

  Observable.prototype.on = function (event, callback) {
    this.listeners = this.listeners || {};

    if (event in this.listeners) {
      this.listeners[event].push(callback);
    } else {
      this.listeners[event] = [callback];
    }
  };

  Observable.prototype.trigger = function (event) {
    var slice = Array.prototype.slice;
    var params = slice.call(arguments, 1);

    this.listeners = this.listeners || {};

    // Params should always come in as an array
    if (params == null) {
      params = [];
    }

    // If there are no arguments to the event, use a temporary object
    if (params.length === 0) {
      params.push({});
    }

    // Set the `_type` of the first object to the event
    params[0]._type = event;

    if (event in this.listeners) {
      this.invoke(this.listeners[event], slice.call(arguments, 1));
    }

    if ('*' in this.listeners) {
      this.invoke(this.listeners['*'], arguments);
    }
  };

  Observable.prototype.invoke = function (listeners, params) {
    for (var i = 0, len = listeners.length; i < len; i++) {
      listeners[i].apply(this, params);
    }
  };

  Utils.Observable = Observable;

  Utils.generateChars = function (length) {
    var chars = '';

    for (var i = 0; i < length; i++) {
      var randomChar = Math.floor(Math.random() * 36);
      chars += randomChar.toString(36);
    }

    return chars;
  };

  Utils.bind = function (func, context) {
    return function () {
      func.apply(context, arguments);
    };
  };

  Utils._convertData = function (data) {
    for (var originalKey in data) {
      var keys = originalKey.split('-');

      var dataLevel = data;

      if (keys.length === 1) {
        continue;
      }

      for (var k = 0; k < keys.length; k++) {
        var key = keys[k];

        // Lowercase the first letter
        // By default, dash-separated becomes camelCase
        key = key.substring(0, 1).toLowerCase() + key.substring(1);

        if (!(key in dataLevel)) {
          dataLevel[key] = {};
        }

        if (k == keys.length - 1) {
          dataLevel[key] = data[originalKey];
        }

        dataLevel = dataLevel[key];
      }

      delete data[originalKey];
    }

    return data;
  };

  Utils.hasScroll = function (index, el) {
    // Adapted from the function created by @ShadowScripter
    // and adapted by @BillBarry on the Stack Exchange Code Review website.
    // The original code can be found at
    // http://codereview.stackexchange.com/q/13338
    // and was designed to be used with the Sizzle selector engine.

    var $el = $(el);
    var overflowX = el.style.overflowX;
    var overflowY = el.style.overflowY;

    //Check both x and y declarations
    if (overflowX === overflowY &&
        (overflowY === 'hidden' || overflowY === 'visible')) {
      return false;
    }

    if (overflowX === 'scroll' || overflowY === 'scroll') {
      return true;
    }

    return ($el.innerHeight() < el.scrollHeight ||
      $el.innerWidth() < el.scrollWidth);
  };

  Utils.escapeMarkup = function (markup) {
    var replaceMap = {
      '\\': '&#92;',
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      '\'': '&#39;',
      '/': '&#47;'
    };

    // Do not try to escape the markup if it's not a string
    if (typeof markup !== 'string') {
      return markup;
    }

    return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
      return replaceMap[match];
    });
  };

  // Cache objects in Utils.__cache instead of $.data (see #4346)
  Utils.__cache = {};

  var id = 0;
  Utils.GetUniqueElementId = function (element) {
    // Get a unique element Id. If element has no id,
    // creates a new unique number, stores it in the id
    // attribute and returns the new id with a prefix.
    // If an id already exists, it simply returns it with a prefix.

    var select2Id = element.getAttribute('data-select2-id');

    if (select2Id != null) {
      return select2Id;
    }

    // If element has id, use it.
    if (element.id) {
      select2Id = 'select2-data-' + element.id;
    } else {
      select2Id = 'select2-data-' + (++id).toString() +
        '-' + Utils.generateChars(4);
    }

    element.setAttribute('data-select2-id', select2Id);

    return select2Id;
  };

  Utils.StoreData = function (element, name, value) {
    // Stores an item in the cache for a specified element.
    // name is the cache key.
    var id = Utils.GetUniqueElementId(element);
    if (!Utils.__cache[id]) {
      Utils.__cache[id] = {};
    }

    Utils.__cache[id][name] = value;
  };

  Utils.GetData = function (element, name) {
    // Retrieves a value from the cache by its key (name)
    // name is optional. If no name specified, return
    // all cache items for the specified element.
    // and for a specified element.
    var id = Utils.GetUniqueElementId(element);
    if (name) {
      if (Utils.__cache[id]) {
        if (Utils.__cache[id][name] != null) {
          return Utils.__cache[id][name];
        }
        return $(element).data(name); // Fallback to HTML5 data attribs.
      }
      return $(element).data(name); // Fallback to HTML5 data attribs.
    } else {
      return Utils.__cache[id];
    }
  };

  Utils.RemoveData = function (element) {
    // Removes all cached items for a specified element.
    var id = Utils.GetUniqueElementId(element);
    if (Utils.__cache[id] != null) {
      delete Utils.__cache[id];
    }

    element.removeAttribute('data-select2-id');
  };

  Utils.copyNonInternalCssClasses = function (dest, src) {
    var classes;

    var destinationClasses = dest.getAttribute('class').trim().split(/\s+/);

    destinationClasses = destinationClasses.filter(function (clazz) {
      // Save all Select2 classes
      return clazz.indexOf('select2-') === 0;
    });

    var sourceClasses = src.getAttribute('class').trim().split(/\s+/);

    sourceClasses = sourceClasses.filter(function (clazz) {
      // Only copy non-Select2 classes
      return clazz.indexOf('select2-') !== 0;
    });

    var replacements = destinationClasses.concat(sourceClasses);

    dest.setAttribute('class', replacements.join(' '));
  };

  return Utils;
});

S2.define('select2/results',[
  'jquery',
  './utils'
], function ($, Utils) {
  function Results ($element, options, dataAdapter) {
    this.$element = $element;
    this.data = dataAdapter;
    this.options = options;

    Results.__super__.constructor.call(this);
  }

  Utils.Extend(Results, Utils.Observable);

  Results.prototype.render = function () {
    var $results = $(
      '<ul class="select2-results__options" role="listbox"></ul>'
    );

    if (this.options.get('multiple')) {
      $results.attr('aria-multiselectable', 'true');
    }

    this.$results = $results;

    return $results;
  };

  Results.prototype.clear = function () {
    this.$results.empty();
  };

  Results.prototype.displayMessage = function (params) {
    var escapeMarkup = this.options.get('escapeMarkup');

    this.clear();
    this.hideLoading();

    var $message = $(
      '<li role="alert" aria-live="assertive"' +
      ' class="select2-results__option"></li>'
    );

    var message = this.options.get('translations').get(params.message);

    $message.append(
      escapeMarkup(
        message(params.args)
      )
    );

    $message[0].className += ' select2-results__message';

    this.$results.append($message);
  };

  Results.prototype.hideMessages = function () {
    this.$results.find('.select2-results__message').remove();
  };

  Results.prototype.append = function (data) {
    this.hideLoading();

    var $options = [];

    if (data.results == null || data.results.length === 0) {
      if (this.$results.children().length === 0) {
        this.trigger('results:message', {
          message: 'noResults'
        });
      }

      return;
    }

    data.results = this.sort(data.results);

    for (var d = 0; d < data.results.length; d++) {
      var item = data.results[d];

      var $option = this.option(item);

      $options.push($option);
    }

    this.$results.append($options);
  };

  Results.prototype.position = function ($results, $dropdown) {
    var $resultsContainer = $dropdown.find('.select2-results');
    $resultsContainer.append($results);
  };

  Results.prototype.sort = function (data) {
    var sorter = this.options.get('sorter');

    return sorter(data);
  };

  Results.prototype.highlightFirstItem = function () {
    var $options = this.$results
      .find('.select2-results__option--selectable');

    var $selected = $options.filter('.select2-results__option--selected');

    // Check if there are any selected options
    if ($selected.length > 0) {
      // If there are selected options, highlight the first
      $selected.first().trigger('mouseenter');
    } else {
      // If there are no selected options, highlight the first option
      // in the dropdown
      $options.first().trigger('mouseenter');
    }

    this.ensureHighlightVisible();
  };

  Results.prototype.setClasses = function () {
    var self = this;

    this.data.current(function (selected) {
      var selectedIds = selected.map(function (s) {
        return s.id.toString();
      });

      var $options = self.$results
        .find('.select2-results__option--selectable');

      $options.each(function () {
        var $option = $(this);

        var item = Utils.GetData(this, 'data');

        // id needs to be converted to a string when comparing
        var id = '' + item.id;

        if ((item.element != null && item.element.selected) ||
            (item.element == null && selectedIds.indexOf(id) > -1)) {
          this.classList.add('select2-results__option--selected');
          $option.attr('aria-selected', 'true');
        } else {
          this.classList.remove('select2-results__option--selected');
          $option.attr('aria-selected', 'false');
        }
      });

    });
  };

  Results.prototype.showLoading = function (params) {
    this.hideLoading();

    var loadingMore = this.options.get('translations').get('searching');

    var loading = {
      disabled: true,
      loading: true,
      text: loadingMore(params)
    };
    var $loading = this.option(loading);
    $loading.className += ' loading-results';

    this.$results.prepend($loading);
  };

  Results.prototype.hideLoading = function () {
    this.$results.find('.loading-results').remove();
  };

  Results.prototype.option = function (data) {
    var option = document.createElement('li');
    option.classList.add('select2-results__option');
    option.classList.add('select2-results__option--selectable');

    var attrs = {
      'role': 'option'
    };

    var matches = window.Element.prototype.matches ||
      window.Element.prototype.msMatchesSelector ||
      window.Element.prototype.webkitMatchesSelector;

    if ((data.element != null && matches.call(data.element, ':disabled')) ||
        (data.element == null && data.disabled)) {
      attrs['aria-disabled'] = 'true';

      option.classList.remove('select2-results__option--selectable');
      option.classList.add('select2-results__option--disabled');
    }

    if (data.id == null) {
      option.classList.remove('select2-results__option--selectable');
    }

    if (data._resultId != null) {
      option.id = data._resultId;
    }

    if (data.title) {
      option.title = data.title;
    }

    if (data.children) {
      attrs.role = 'group';
      attrs['aria-label'] = data.text;

      option.classList.remove('select2-results__option--selectable');
      option.classList.add('select2-results__option--group');
    }

    for (var attr in attrs) {
      var val = attrs[attr];

      option.setAttribute(attr, val);
    }

    if (data.children) {
      var $option = $(option);

      var label = document.createElement('strong');
      label.className = 'select2-results__group';

      this.template(data, label);

      var $children = [];

      for (var c = 0; c < data.children.length; c++) {
        var child = data.children[c];

        var $child = this.option(child);

        $children.push($child);
      }

      var $childrenContainer = $('<ul></ul>', {
        'class': 'select2-results__options select2-results__options--nested',
        'role': 'none'
      });

      $childrenContainer.append($children);

      $option.append(label);
      $option.append($childrenContainer);
    } else {
      this.template(data, option);
    }

    Utils.StoreData(option, 'data', data);

    return option;
  };

  Results.prototype.bind = function (container, $container) {
    var self = this;

    var id = container.id + '-results';

    this.$results.attr('id', id);

    container.on('results:all', function (params) {
      self.clear();
      self.append(params.data);

      if (container.isOpen()) {
        self.setClasses();
        self.highlightFirstItem();
      }
    });

    container.on('results:append', function (params) {
      self.append(params.data);

      if (container.isOpen()) {
        self.setClasses();
      }
    });

    container.on('query', function (params) {
      self.hideMessages();
      self.showLoading(params);
    });

    container.on('select', function () {
      if (!container.isOpen()) {
        return;
      }

      self.setClasses();

      if (self.options.get('scrollAfterSelect')) {
        self.highlightFirstItem();
      }
    });

    container.on('unselect', function () {
      if (!container.isOpen()) {
        return;
      }

      self.setClasses();

      if (self.options.get('scrollAfterSelect')) {
        self.highlightFirstItem();
      }
    });

    container.on('open', function () {
      // When the dropdown is open, aria-expended="true"
      self.$results.attr('aria-expanded', 'true');
      self.$results.attr('aria-hidden', 'false');

      self.setClasses();
      self.ensureHighlightVisible();
    });

    container.on('close', function () {
      // When the dropdown is closed, aria-expended="false"
      self.$results.attr('aria-expanded', 'false');
      self.$results.attr('aria-hidden', 'true');
      self.$results.removeAttr('aria-activedescendant');
    });

    container.on('results:toggle', function () {
      var $highlighted = self.getHighlightedResults();

      if ($highlighted.length === 0) {
        return;
      }

      $highlighted.trigger('mouseup');
    });

    container.on('results:select', function () {
      var $highlighted = self.getHighlightedResults();

      if ($highlighted.length === 0) {
        return;
      }

      var data = Utils.GetData($highlighted[0], 'data');

      if ($highlighted.hasClass('select2-results__option--selected')) {
        self.trigger('close', {});
      } else {
        self.trigger('select', {
          data: data
        });
      }
    });

    container.on('results:previous', function () {
      var $highlighted = self.getHighlightedResults();

      var $options = self.$results.find('.select2-results__option--selectable');

      var currentIndex = $options.index($highlighted);

      // If we are already at the top, don't move further
      // If no options, currentIndex will be -1
      if (currentIndex <= 0) {
        return;
      }

      var nextIndex = currentIndex - 1;

      // If none are highlighted, highlight the first
      if ($highlighted.length === 0) {
        nextIndex = 0;
      }

      var $next = $options.eq(nextIndex);

      $next.trigger('mouseenter');

      var currentOffset = self.$results.offset().top;
      var nextTop = $next.offset().top;
      var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);

      if (nextIndex === 0) {
        self.$results.scrollTop(0);
      } else if (nextTop - currentOffset < 0) {
        self.$results.scrollTop(nextOffset);
      }
    });

    container.on('results:next', function () {
      var $highlighted = self.getHighlightedResults();

      var $options = self.$results.find('.select2-results__option--selectable');

      var currentIndex = $options.index($highlighted);

      var nextIndex = currentIndex + 1;

      // If we are at the last option, stay there
      if (nextIndex >= $options.length) {
        return;
      }

      var $next = $options.eq(nextIndex);

      $next.trigger('mouseenter');

      var currentOffset = self.$results.offset().top +
        self.$results.outerHeight(false);
      var nextBottom = $next.offset().top + $next.outerHeight(false);
      var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;

      if (nextIndex === 0) {
        self.$results.scrollTop(0);
      } else if (nextBottom > currentOffset) {
        self.$results.scrollTop(nextOffset);
      }
    });

    container.on('results:focus', function (params) {
      params.element[0].classList.add('select2-results__option--highlighted');
      params.element[0].setAttribute('aria-selected', 'true');
    });

    container.on('results:message', function (params) {
      self.displayMessage(params);
    });

    if ($.fn.mousewheel) {
      this.$results.on('mousewheel', function (e) {
        var top = self.$results.scrollTop();

        var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;

        var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
        var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();

        if (isAtTop) {
          self.$results.scrollTop(0);

          e.preventDefault();
          e.stopPropagation();
        } else if (isAtBottom) {
          self.$results.scrollTop(
            self.$results.get(0).scrollHeight - self.$results.height()
          );

          e.preventDefault();
          e.stopPropagation();
        }
      });
    }

    this.$results.on('mouseup', '.select2-results__option--selectable',
      function (evt) {
      var $this = $(this);

      var data = Utils.GetData(this, 'data');

      if ($this.hasClass('select2-results__option--selected')) {
        if (self.options.get('multiple')) {
          self.trigger('unselect', {
            originalEvent: evt,
            data: data
          });
        } else {
          self.trigger('close', {});
        }

        return;
      }

      self.trigger('select', {
        originalEvent: evt,
        data: data
      });
    });

    this.$results.on('mouseenter', '.select2-results__option--selectable',
      function (evt) {
      var data = Utils.GetData(this, 'data');

      self.getHighlightedResults()
          .removeClass('select2-results__option--highlighted')
          .attr('aria-selected', 'false');

      self.trigger('results:focus', {
        data: data,
        element: $(this)
      });
    });
  };

  Results.prototype.getHighlightedResults = function () {
    var $highlighted = this.$results
    .find('.select2-results__option--highlighted');

    return $highlighted;
  };

  Results.prototype.destroy = function () {
    this.$results.remove();
  };

  Results.prototype.ensureHighlightVisible = function () {
    var $highlighted = this.getHighlightedResults();

    if ($highlighted.length === 0) {
      return;
    }

    var $options = this.$results.find('.select2-results__option--selectable');

    var currentIndex = $options.index($highlighted);

    var currentOffset = this.$results.offset().top;
    var nextTop = $highlighted.offset().top;
    var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);

    var offsetDelta = nextTop - currentOffset;
    nextOffset -= $highlighted.outerHeight(false) * 2;

    if (currentIndex <= 2) {
      this.$results.scrollTop(0);
    } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
      this.$results.scrollTop(nextOffset);
    }
  };

  Results.prototype.template = function (result, container) {
    var template = this.options.get('templateResult');
    var escapeMarkup = this.options.get('escapeMarkup');

    var content = template(result, container);

    if (content == null) {
      container.style.display = 'none';
    } else if (typeof content === 'string') {
      container.innerHTML = escapeMarkup(content);
    } else {
      $(container).append(content);
    }
  };

  return Results;
});

S2.define('select2/keys',[

], function () {
  var KEYS = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    DELETE: 46
  };

  return KEYS;
});

S2.define('select2/selection/base',[
  'jquery',
  '../utils',
  '../keys'
], function ($, Utils, KEYS) {
  function BaseSelection ($element, options) {
    this.$element = $element;
    this.options = options;

    BaseSelection.__super__.constructor.call(this);
  }

  Utils.Extend(BaseSelection, Utils.Observable);

  BaseSelection.prototype.render = function () {
    var $selection = $(
      '<span class="select2-selection" role="combobox" ' +
      ' aria-haspopup="true" aria-expanded="false">' +
      '</span>'
    );

    this._tabindex = 0;

    if (Utils.GetData(this.$element[0], 'old-tabindex') != null) {
      this._tabindex = Utils.GetData(this.$element[0], 'old-tabindex');
    } else if (this.$element.attr('tabindex') != null) {
      this._tabindex = this.$element.attr('tabindex');
    }

    $selection.attr('title', this.$element.attr('title'));
    $selection.attr('tabindex', this._tabindex);
    $selection.attr('aria-disabled', 'false');

    this.$selection = $selection;

    return $selection;
  };

  BaseSelection.prototype.bind = function (container, $container) {
    var self = this;

    var resultsId = container.id + '-results';

    this.container = container;

    this.$selection.on('focus', function (evt) {
      self.trigger('focus', evt);
    });

    this.$selection.on('blur', function (evt) {
      self._handleBlur(evt);
    });

    this.$selection.on('keydown', function (evt) {
      self.trigger('keypress', evt);

      if (evt.which === KEYS.SPACE) {
        evt.preventDefault();
      }
    });

    container.on('results:focus', function (params) {
      self.$selection.attr('aria-activedescendant', params.data._resultId);
    });

    container.on('selection:update', function (params) {
      self.update(params.data);
    });

    container.on('open', function () {
      // When the dropdown is open, aria-expanded="true"
      self.$selection.attr('aria-expanded', 'true');
      self.$selection.attr('aria-owns', resultsId);

      self._attachCloseHandler(container);
    });

    container.on('close', function () {
      // When the dropdown is closed, aria-expanded="false"
      self.$selection.attr('aria-expanded', 'false');
      self.$selection.removeAttr('aria-activedescendant');
      self.$selection.removeAttr('aria-owns');

      self.$selection.trigger('focus');

      self._detachCloseHandler(container);
    });

    container.on('enable', function () {
      self.$selection.attr('tabindex', self._tabindex);
      self.$selection.attr('aria-disabled', 'false');
    });

    container.on('disable', function () {
      self.$selection.attr('tabindex', '-1');
      self.$selection.attr('aria-disabled', 'true');
    });
  };

  BaseSelection.prototype._handleBlur = function (evt) {
    var self = this;

    // This needs to be delayed as the active element is the body when the tab
    // key is pressed, possibly along with others.
    window.setTimeout(function () {
      // Don't trigger `blur` if the focus is still in the selection
      if (
        (document.activeElement == self.$selection[0]) ||
        ($.contains(self.$selection[0], document.activeElement))
      ) {
        return;
      }

      self.trigger('blur', evt);
    }, 1);
  };

  BaseSelection.prototype._attachCloseHandler = function (container) {

    $(document.body).on('mousedown.select2.' + container.id, function (e) {
      var $target = $(e.target);

      var $select = $target.closest('.select2');

      var $all = $('.select2.select2-container--open');

      $all.each(function () {
        if (this == $select[0]) {
          return;
        }

        var $element = Utils.GetData(this, 'element');

        $element.select2('close');
      });
    });
  };

  BaseSelection.prototype._detachCloseHandler = function (container) {
    $(document.body).off('mousedown.select2.' + container.id);
  };

  BaseSelection.prototype.position = function ($selection, $container) {
    var $selectionContainer = $container.find('.selection');
    $selectionContainer.append($selection);
  };

  BaseSelection.prototype.destroy = function () {
    this._detachCloseHandler(this.container);
  };

  BaseSelection.prototype.update = function (data) {
    throw new Error('The `update` method must be defined in child classes.');
  };

  /**
   * Helper method to abstract the "enabled" (not "disabled") state of this
   * object.
   *
   * @return {true} if the instance is not disabled.
   * @return {false} if the instance is disabled.
   */
  BaseSelection.prototype.isEnabled = function () {
    return !this.isDisabled();
  };

  /**
   * Helper method to abstract the "disabled" state of this object.
   *
   * @return {true} if the disabled option is true.
   * @return {false} if the disabled option is false.
   */
  BaseSelection.prototype.isDisabled = function () {
    return this.options.get('disabled');
  };

  return BaseSelection;
});

S2.define('select2/selection/single',[
  'jquery',
  './base',
  '../utils',
  '../keys'
], function ($, BaseSelection, Utils, KEYS) {
  function SingleSelection () {
    SingleSelection.__super__.constructor.apply(this, arguments);
  }

  Utils.Extend(SingleSelection, BaseSelection);

  SingleSelection.prototype.render = function () {
    var $selection = SingleSelection.__super__.render.call(this);

    $selection[0].classList.add('select2-selection--single');

    $selection.html(
      '<span class="select2-selection__rendered"></span>' +
      '<span class="select2-selection__arrow" role="presentation">' +
        '<b role="presentation"></b>' +
      '</span>'
    );

    return $selection;
  };

  SingleSelection.prototype.bind = function (container, $container) {
    var self = this;

    SingleSelection.__super__.bind.apply(this, arguments);

    var id = container.id + '-container';

    this.$selection.find('.select2-selection__rendered')
      .attr('id', id)
      .attr('role', 'textbox')
      .attr('aria-readonly', 'true');
    this.$selection.attr('aria-labelledby', id);
    this.$selection.attr('aria-controls', id);

    this.$selection.on('mousedown', function (evt) {
      // Only respond to left clicks
      if (evt.which !== 1) {
        return;
      }

      self.trigger('toggle', {
        originalEvent: evt
      });
    });

    this.$selection.on('focus', function (evt) {
      // User focuses on the container
    });

    this.$selection.on('blur', function (evt) {
      // User exits the container
    });

    container.on('focus', function (evt) {
      if (!container.isOpen()) {
        self.$selection.trigger('focus');
      }
    });
  };

  SingleSelection.prototype.clear = function () {
    var $rendered = this.$selection.find('.select2-selection__rendered');
    $rendered.empty();
    $rendered.removeAttr('title'); // clear tooltip on empty
  };

  SingleSelection.prototype.display = function (data, container) {
    var template = this.options.get('templateSelection');
    var escapeMarkup = this.options.get('escapeMarkup');

    return escapeMarkup(template(data, container));
  };

  SingleSelection.prototype.selectionContainer = function () {
    return $('<span></span>');
  };

  SingleSelection.prototype.update = function (data) {
    if (data.length === 0) {
      this.clear();
      return;
    }

    var selection = data[0];

    var $rendered = this.$selection.find('.select2-selection__rendered');
    var formatted = this.display(selection, $rendered);

    $rendered.empty().append(formatted);

    var title = selection.title || selection.text;

    if (title) {
      $rendered.attr('title', title);
    } else {
      $rendered.removeAttr('title');
    }
  };

  return SingleSelection;
});

S2.define('select2/selection/multiple',[
  'jquery',
  './base',
  '../utils'
], function ($, BaseSelection, Utils) {
  function MultipleSelection ($element, options) {
    MultipleSelection.__super__.constructor.apply(this, arguments);
  }

  Utils.Extend(MultipleSelection, BaseSelection);

  MultipleSelection.prototype.render = function () {
    var $selection = MultipleSelection.__super__.render.call(this);

    $selection[0].classList.add('select2-selection--multiple');

    $selection.html(
      '<ul class="select2-selection__rendered"></ul>'
    );

    return $selection;
  };

  MultipleSelection.prototype.bind = function (container, $container) {
    var self = this;

    MultipleSelection.__super__.bind.apply(this, arguments);

    var id = container.id + '-container';
    this.$selection.find('.select2-selection__rendered').attr('id', id);

    this.$selection.on('click', function (evt) {
      self.trigger('toggle', {
        originalEvent: evt
      });
    });

    this.$selection.on(
      'click',
      '.select2-selection__choice__remove',
      function (evt) {
        // Ignore the event if it is disabled
        if (self.isDisabled()) {
          return;
        }

        var $remove = $(this);
        var $selection = $remove.parent();

        var data = Utils.GetData($selection[0], 'data');

        self.trigger('unselect', {
          originalEvent: evt,
          data: data
        });
      }
    );

    this.$selection.on(
      'keydown',
      '.select2-selection__choice__remove',
      function (evt) {
        // Ignore the event if it is disabled
        if (self.isDisabled()) {
          return;
        }

        evt.stopPropagation();
      }
    );
  };

  MultipleSelection.prototype.clear = function () {
    var $rendered = this.$selection.find('.select2-selection__rendered');
    $rendered.empty();
    $rendered.removeAttr('title');
  };

  MultipleSelection.prototype.display = function (data, container) {
    var template = this.options.get('templateSelection');
    var escapeMarkup = this.options.get('escapeMarkup');

    return escapeMarkup(template(data, container));
  };

  MultipleSelection.prototype.selectionContainer = function () {
    var $container = $(
      '<li class="select2-selection__choice">' +
        '<button type="button" class="select2-selection__choice__remove" ' +
        'tabindex="-1">' +
          '<span aria-hidden="true">&times;</span>' +
        '</button>' +
        '<span class="select2-selection__choice__display"></span>' +
      '</li>'
    );

    return $container;
  };

  MultipleSelection.prototype.update = function (data) {
    this.clear();

    if (data.length === 0) {
      return;
    }

    var $selections = [];

    var selectionIdPrefix = this.$selection.find('.select2-selection__rendered')
      .attr('id') + '-choice-';

    for (var d = 0; d < data.length; d++) {
      var selection = data[d];

      var $selection = this.selectionContainer();
      var formatted = this.display(selection, $selection);

      var selectionId = selectionIdPrefix + Utils.generateChars(4) + '-';

      if (selection.id) {
        selectionId += selection.id;
      } else {
        selectionId += Utils.generateChars(4);
      }

      $selection.find('.select2-selection__choice__display')
        .append(formatted)
        .attr('id', selectionId);

      var title = selection.title || selection.text;

      if (title) {
        $selection.attr('title', title);
      }

      var removeItem = this.options.get('translations').get('removeItem');

      var $remove = $selection.find('.select2-selection__choice__remove');

      $remove.attr('title', removeItem());
      $remove.attr('aria-label', removeItem());
      $remove.attr('aria-describedby', selectionId);

      Utils.StoreData($selection[0], 'data', selection);

      $selections.push($selection);
    }

    var $rendered = this.$selection.find('.select2-selection__rendered');

    $rendered.append($selections);
  };

  return MultipleSelection;
});

S2.define('select2/selection/placeholder',[

], function () {
  function Placeholder (decorated, $element, options) {
    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

    decorated.call(this, $element, options);
  }

  Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
    if (typeof placeholder === 'string') {
      placeholder = {
        id: '',
        text: placeholder
      };
    }

    return placeholder;
  };

  Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
    var $placeholder = this.selectionContainer();

    $placeholder.html(this.display(placeholder));
    $placeholder[0].classList.add('select2-selection__placeholder');
    $placeholder[0].classList.remove('select2-selection__choice');

    var placeholderTitle = placeholder.title ||
      placeholder.text ||
      $placeholder.text();

    this.$selection.find('.select2-selection__rendered').attr(
      'title',
      placeholderTitle
    );

    return $placeholder;
  };

  Placeholder.prototype.update = function (decorated, data) {
    var singlePlaceholder = (
      data.length == 1 && data[0].id != this.placeholder.id
    );
    var multipleSelections = data.length > 1;

    if (multipleSelections || singlePlaceholder) {
      return decorated.call(this, data);
    }

    this.clear();

    var $placeholder = this.createPlaceholder(this.placeholder);

    this.$selection.find('.select2-selection__rendered').append($placeholder);
  };

  return Placeholder;
});

S2.define('select2/selection/allowClear',[
  'jquery',
  '../keys',
  '../utils'
], function ($, KEYS, Utils) {
  function AllowClear () { }

  AllowClear.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    if (this.placeholder == null) {
      if (this.options.get('debug') && window.console && console.error) {
        console.error(
          'Select2: The `allowClear` option should be used in combination ' +
          'with the `placeholder` option.'
        );
      }
    }

    this.$selection.on('mousedown', '.select2-selection__clear',
      function (evt) {
        self._handleClear(evt);
    });

    container.on('keypress', function (evt) {
      self._handleKeyboardClear(evt, container);
    });
  };

  AllowClear.prototype._handleClear = function (_, evt) {
    // Ignore the event if it is disabled
    if (this.isDisabled()) {
      return;
    }

    var $clear = this.$selection.find('.select2-selection__clear');

    // Ignore the event if nothing has been selected
    if ($clear.length === 0) {
      return;
    }

    evt.stopPropagation();

    var data = Utils.GetData($clear[0], 'data');

    var previousVal = this.$element.val();
    this.$element.val(this.placeholder.id);

    var unselectData = {
      data: data
    };
    this.trigger('clear', unselectData);
    if (unselectData.prevented) {
      this.$element.val(previousVal);
      return;
    }

    for (var d = 0; d < data.length; d++) {
      unselectData = {
        data: data[d]
      };

      // Trigger the `unselect` event, so people can prevent it from being
      // cleared.
      this.trigger('unselect', unselectData);

      // If the event was prevented, don't clear it out.
      if (unselectData.prevented) {
        this.$element.val(previousVal);
        return;
      }
    }

    this.$element.trigger('input').trigger('change');

    this.trigger('toggle', {});
  };

  AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
    if (container.isOpen()) {
      return;
    }

    if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
      this._handleClear(evt);
    }
  };

  AllowClear.prototype.update = function (decorated, data) {
    decorated.call(this, data);

    this.$selection.find('.select2-selection__clear').remove();
    this.$selection[0].classList.remove('select2-selection--clearable');

    if (this.$selection.find('.select2-selection__placeholder').length > 0 ||
        data.length === 0) {
      return;
    }

    var selectionId = this.$selection.find('.select2-selection__rendered')
      .attr('id');

    var removeAll = this.options.get('translations').get('removeAllItems');

    var $remove = $(
      '<button type="button" class="select2-selection__clear" tabindex="-1">' +
        '<span aria-hidden="true">&times;</span>' +
      '</button>'
    );
    $remove.attr('title', removeAll());
    $remove.attr('aria-label', removeAll());
    $remove.attr('aria-describedby', selectionId);
    Utils.StoreData($remove[0], 'data', data);

    this.$selection.prepend($remove);
    this.$selection[0].classList.add('select2-selection--clearable');
  };

  return AllowClear;
});

S2.define('select2/selection/search',[
  'jquery',
  '../utils',
  '../keys'
], function ($, Utils, KEYS) {
  function Search (decorated, $element, options) {
    decorated.call(this, $element, options);
  }

  Search.prototype.render = function (decorated) {
    var searchLabel = this.options.get('translations').get('search');
    var $search = $(
      '<span class="select2-search select2-search--inline">' +
        '<textarea class="select2-search__field"'+
        ' type="search" tabindex="-1"' +
        ' autocorrect="off" autocapitalize="none"' +
        ' spellcheck="false" role="searchbox" aria-autocomplete="list" >' +
        '</textarea>' +
      '</span>'
    );

    this.$searchContainer = $search;
    this.$search = $search.find('textarea');

    this.$search.prop('autocomplete', this.options.get('autocomplete'));
    this.$search.attr('aria-label', searchLabel());

    var $rendered = decorated.call(this);

    this._transferTabIndex();
    $rendered.append(this.$searchContainer);

    return $rendered;
  };

  Search.prototype.bind = function (decorated, container, $container) {
    var self = this;

    var resultsId = container.id + '-results';
    var selectionId = container.id + '-container';

    decorated.call(this, container, $container);

    self.$search.attr('aria-describedby', selectionId);

    container.on('open', function () {
      self.$search.attr('aria-controls', resultsId);
      self.$search.trigger('focus');
    });

    container.on('close', function () {
      self.$search.val('');
      self.resizeSearch();
      self.$search.removeAttr('aria-controls');
      self.$search.removeAttr('aria-activedescendant');
      self.$search.trigger('focus');
    });

    container.on('enable', function () {
      self.$search.prop('disabled', false);

      self._transferTabIndex();
    });

    container.on('disable', function () {
      self.$search.prop('disabled', true);
    });

    container.on('focus', function (evt) {
      self.$search.trigger('focus');
    });

    container.on('results:focus', function (params) {
      if (params.data._resultId) {
        self.$search.attr('aria-activedescendant', params.data._resultId);
      } else {
        self.$search.removeAttr('aria-activedescendant');
      }
    });

    this.$selection.on('focusin', '.select2-search--inline', function (evt) {
      self.trigger('focus', evt);
    });

    this.$selection.on('focusout', '.select2-search--inline', function (evt) {
      self._handleBlur(evt);
    });

    this.$selection.on('keydown', '.select2-search--inline', function (evt) {
      evt.stopPropagation();

      self.trigger('keypress', evt);

      self._keyUpPrevented = evt.isDefaultPrevented();

      var key = evt.which;

      if (key === KEYS.BACKSPACE && self.$search.val() === '') {
        var $previousChoice = self.$selection
          .find('.select2-selection__choice').last();

        if ($previousChoice.length > 0) {
          var item = Utils.GetData($previousChoice[0], 'data');

          self.searchRemoveChoice(item);

          evt.preventDefault();
        }
      }
    });

    this.$selection.on('click', '.select2-search--inline', function (evt) {
      if (self.$search.val()) {
        evt.stopPropagation();
      }
    });

    // Try to detect the IE version should the `documentMode` property that
    // is stored on the document. This is only implemented in IE and is
    // slightly cleaner than doing a user agent check.
    // This property is not available in Edge, but Edge also doesn't have
    // this bug.
    var msie = document.documentMode;
    var disableInputEvents = msie && msie <= 11;

    // Workaround for browsers which do not support the `input` event
    // This will prevent double-triggering of events for browsers which support
    // both the `keyup` and `input` events.
    this.$selection.on(
      'input.searchcheck',
      '.select2-search--inline',
      function (evt) {
        // IE will trigger the `input` event when a placeholder is used on a
        // search box. To get around this issue, we are forced to ignore all
        // `input` events in IE and keep using `keyup`.
        if (disableInputEvents) {
          self.$selection.off('input.search input.searchcheck');
          return;
        }

        // Unbind the duplicated `keyup` event
        self.$selection.off('keyup.search');
      }
    );

    this.$selection.on(
      'keyup.search input.search',
      '.select2-search--inline',
      function (evt) {
        // IE will trigger the `input` event when a placeholder is used on a
        // search box. To get around this issue, we are forced to ignore all
        // `input` events in IE and keep using `keyup`.
        if (disableInputEvents && evt.type === 'input') {
          self.$selection.off('input.search input.searchcheck');
          return;
        }

        var key = evt.which;

        // We can freely ignore events from modifier keys
        if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
          return;
        }

        // Tabbing will be handled during the `keydown` phase
        if (key == KEYS.TAB) {
          return;
        }

        self.handleSearch(evt);
      }
    );
  };

  /**
   * This method will transfer the tabindex attribute from the rendered
   * selection to the search box. This allows for the search box to be used as
   * the primary focus instead of the selection container.
   *
   * @private
   */
  Search.prototype._transferTabIndex = function (decorated) {
    this.$search.attr('tabindex', this.$selection.attr('tabindex'));
    this.$selection.attr('tabindex', '-1');
  };

  Search.prototype.createPlaceholder = function (decorated, placeholder) {
    this.$search.attr('placeholder', placeholder.text);
  };

  Search.prototype.update = function (decorated, data) {
    var searchHadFocus = this.$search[0] == document.activeElement;

    this.$search.attr('placeholder', '');

    decorated.call(this, data);

    this.resizeSearch();
    if (searchHadFocus) {
      this.$search.trigger('focus');
    }
  };

  Search.prototype.handleSearch = function () {
    this.resizeSearch();

    if (!this._keyUpPrevented) {
      var input = this.$search.val();

      this.trigger('query', {
        term: input
      });
    }

    this._keyUpPrevented = false;
  };

  Search.prototype.searchRemoveChoice = function (decorated, item) {
    this.trigger('unselect', {
      data: item
    });

    this.$search.val(item.text);
    this.handleSearch();
  };

  Search.prototype.resizeSearch = function () {
    this.$search.css('width', '25px');

    var width = '100%';

    if (this.$search.attr('placeholder') === '') {
      var minimumWidth = this.$search.val().length + 1;

      width = (minimumWidth * 0.75) + 'em';
    }

    this.$search.css('width', width);
  };

  return Search;
});

S2.define('select2/selection/selectionCss',[
  '../utils'
], function (Utils) {
  function SelectionCSS () { }

  SelectionCSS.prototype.render = function (decorated) {
    var $selection = decorated.call(this);

    var selectionCssClass = this.options.get('selectionCssClass') || '';

    if (selectionCssClass.indexOf(':all:') !== -1) {
      selectionCssClass = selectionCssClass.replace(':all:', '');

      Utils.copyNonInternalCssClasses($selection[0], this.$element[0]);
    }

    $selection.addClass(selectionCssClass);

    return $selection;
  };

  return SelectionCSS;
});

S2.define('select2/selection/eventRelay',[
  'jquery'
], function ($) {
  function EventRelay () { }

  EventRelay.prototype.bind = function (decorated, container, $container) {
    var self = this;
    var relayEvents = [
      'open', 'opening',
      'close', 'closing',
      'select', 'selecting',
      'unselect', 'unselecting',
      'clear', 'clearing'
    ];

    var preventableEvents = [
      'opening', 'closing', 'selecting', 'unselecting', 'clearing'
    ];

    decorated.call(this, container, $container);

    container.on('*', function (name, params) {
      // Ignore events that should not be relayed
      if (relayEvents.indexOf(name) === -1) {
        return;
      }

      // The parameters should always be an object
      params = params || {};

      // Generate the jQuery event for the Select2 event
      var evt = $.Event('select2:' + name, {
        params: params
      });

      self.$element.trigger(evt);

      // Only handle preventable events if it was one
      if (preventableEvents.indexOf(name) === -1) {
        return;
      }

      params.prevented = evt.isDefaultPrevented();
    });
  };

  return EventRelay;
});

S2.define('select2/translation',[
  'jquery',
  'require'
], function ($, require) {
  function Translation (dict) {
    this.dict = dict || {};
  }

  Translation.prototype.all = function () {
    return this.dict;
  };

  Translation.prototype.get = function (key) {
    return this.dict[key];
  };

  Translation.prototype.extend = function (translation) {
    this.dict = $.extend({}, translation.all(), this.dict);
  };

  // Static functions

  Translation._cache = {};

  Translation.loadPath = function (path) {
    if (!(path in Translation._cache)) {
      var translations = require(path);

      Translation._cache[path] = translations;
    }

    return new Translation(Translation._cache[path]);
  };

  return Translation;
});

S2.define('select2/diacritics',[

], function () {
  var diacritics = {
    '\u24B6': 'A',
    '\uFF21': 'A',
    '\u00C0': 'A',
    '\u00C1': 'A',
    '\u00C2': 'A',
    '\u1EA6': 'A',
    '\u1EA4': 'A',
    '\u1EAA': 'A',
    '\u1EA8': 'A',
    '\u00C3': 'A',
    '\u0100': 'A',
    '\u0102': 'A',
    '\u1EB0': 'A',
    '\u1EAE': 'A',
    '\u1EB4': 'A',
    '\u1EB2': 'A',
    '\u0226': 'A',
    '\u01E0': 'A',
    '\u00C4': 'A',
    '\u01DE': 'A',
    '\u1EA2': 'A',
    '\u00C5': 'A',
    '\u01FA': 'A',
    '\u01CD': 'A',
    '\u0200': 'A',
    '\u0202': 'A',
    '\u1EA0': 'A',
    '\u1EAC': 'A',
    '\u1EB6': 'A',
    '\u1E00': 'A',
    '\u0104': 'A',
    '\u023A': 'A',
    '\u2C6F': 'A',
    '\uA732': 'AA',
    '\u00C6': 'AE',
    '\u01FC': 'AE',
    '\u01E2': 'AE',
    '\uA734': 'AO',
    '\uA736': 'AU',
    '\uA738': 'AV',
    '\uA73A': 'AV',
    '\uA73C': 'AY',
    '\u24B7': 'B',
    '\uFF22': 'B',
    '\u1E02': 'B',
    '\u1E04': 'B',
    '\u1E06': 'B',
    '\u0243': 'B',
    '\u0182': 'B',
    '\u0181': 'B',
    '\u24B8': 'C',
    '\uFF23': 'C',
    '\u0106': 'C',
    '\u0108': 'C',
    '\u010A': 'C',
    '\u010C': 'C',
    '\u00C7': 'C',
    '\u1E08': 'C',
    '\u0187': 'C',
    '\u023B': 'C',
    '\uA73E': 'C',
    '\u24B9': 'D',
    '\uFF24': 'D',
    '\u1E0A': 'D',
    '\u010E': 'D',
    '\u1E0C': 'D',
    '\u1E10': 'D',
    '\u1E12': 'D',
    '\u1E0E': 'D',
    '\u0110': 'D',
    '\u018B': 'D',
    '\u018A': 'D',
    '\u0189': 'D',
    '\uA779': 'D',
    '\u01F1': 'DZ',
    '\u01C4': 'DZ',
    '\u01F2': 'Dz',
    '\u01C5': 'Dz',
    '\u24BA': 'E',
    '\uFF25': 'E',
    '\u00C8': 'E',
    '\u00C9': 'E',
    '\u00CA': 'E',
    '\u1EC0': 'E',
    '\u1EBE': 'E',
    '\u1EC4': 'E',
    '\u1EC2': 'E',
    '\u1EBC': 'E',
    '\u0112': 'E',
    '\u1E14': 'E',
    '\u1E16': 'E',
    '\u0114': 'E',
    '\u0116': 'E',
    '\u00CB': 'E',
    '\u1EBA': 'E',
    '\u011A': 'E',
    '\u0204': 'E',
    '\u0206': 'E',
    '\u1EB8': 'E',
    '\u1EC6': 'E',
    '\u0228': 'E',
    '\u1E1C': 'E',
    '\u0118': 'E',
    '\u1E18': 'E',
    '\u1E1A': 'E',
    '\u0190': 'E',
    '\u018E': 'E',
    '\u24BB': 'F',
    '\uFF26': 'F',
    '\u1E1E': 'F',
    '\u0191': 'F',
    '\uA77B': 'F',
    '\u24BC': 'G',
    '\uFF27': 'G',
    '\u01F4': 'G',
    '\u011C': 'G',
    '\u1E20': 'G',
    '\u011E': 'G',
    '\u0120': 'G',
    '\u01E6': 'G',
    '\u0122': 'G',
    '\u01E4': 'G',
    '\u0193': 'G',
    '\uA7A0': 'G',
    '\uA77D': 'G',
    '\uA77E': 'G',
    '\u24BD': 'H',
    '\uFF28': 'H',
    '\u0124': 'H',
    '\u1E22': 'H',
    '\u1E26': 'H',
    '\u021E': 'H',
    '\u1E24': 'H',
    '\u1E28': 'H',
    '\u1E2A': 'H',
    '\u0126': 'H',
    '\u2C67': 'H',
    '\u2C75': 'H',
    '\uA78D': 'H',
    '\u24BE': 'I',
    '\uFF29': 'I',
    '\u00CC': 'I',
    '\u00CD': 'I',
    '\u00CE': 'I',
    '\u0128': 'I',
    '\u012A': 'I',
    '\u012C': 'I',
    '\u0130': 'I',
    '\u00CF': 'I',
    '\u1E2E': 'I',
    '\u1EC8': 'I',
    '\u01CF': 'I',
    '\u0208': 'I',
    '\u020A': 'I',
    '\u1ECA': 'I',
    '\u012E': 'I',
    '\u1E2C': 'I',
    '\u0197': 'I',
    '\u24BF': 'J',
    '\uFF2A': 'J',
    '\u0134': 'J',
    '\u0248': 'J',
    '\u24C0': 'K',
    '\uFF2B': 'K',
    '\u1E30': 'K',
    '\u01E8': 'K',
    '\u1E32': 'K',
    '\u0136': 'K',
    '\u1E34': 'K',
    '\u0198': 'K',
    '\u2C69': 'K',
    '\uA740': 'K',
    '\uA742': 'K',
    '\uA744': 'K',
    '\uA7A2': 'K',
    '\u24C1': 'L',
    '\uFF2C': 'L',
    '\u013F': 'L',
    '\u0139': 'L',
    '\u013D': 'L',
    '\u1E36': 'L',
    '\u1E38': 'L',
    '\u013B': 'L',
    '\u1E3C': 'L',
    '\u1E3A': 'L',
    '\u0141': 'L',
    '\u023D': 'L',
    '\u2C62': 'L',
    '\u2C60': 'L',
    '\uA748': 'L',
    '\uA746': 'L',
    '\uA780': 'L',
    '\u01C7': 'LJ',
    '\u01C8': 'Lj',
    '\u24C2': 'M',
    '\uFF2D': 'M',
    '\u1E3E': 'M',
    '\u1E40': 'M',
    '\u1E42': 'M',
    '\u2C6E': 'M',
    '\u019C': 'M',
    '\u24C3': 'N',
    '\uFF2E': 'N',
    '\u01F8': 'N',
    '\u0143': 'N',
    '\u00D1': 'N',
    '\u1E44': 'N',
    '\u0147': 'N',
    '\u1E46': 'N',
    '\u0145': 'N',
    '\u1E4A': 'N',
    '\u1E48': 'N',
    '\u0220': 'N',
    '\u019D': 'N',
    '\uA790': 'N',
    '\uA7A4': 'N',
    '\u01CA': 'NJ',
    '\u01CB': 'Nj',
    '\u24C4': 'O',
    '\uFF2F': 'O',
    '\u00D2': 'O',
    '\u00D3': 'O',
    '\u00D4': 'O',
    '\u1ED2': 'O',
    '\u1ED0': 'O',
    '\u1ED6': 'O',
    '\u1ED4': 'O',
    '\u00D5': 'O',
    '\u1E4C': 'O',
    '\u022C': 'O',
    '\u1E4E': 'O',
    '\u014C': 'O',
    '\u1E50': 'O',
    '\u1E52': 'O',
    '\u014E': 'O',
    '\u022E': 'O',
    '\u0230': 'O',
    '\u00D6': 'O',
    '\u022A': 'O',
    '\u1ECE': 'O',
    '\u0150': 'O',
    '\u01D1': 'O',
    '\u020C': 'O',
    '\u020E': 'O',
    '\u01A0': 'O',
    '\u1EDC': 'O',
    '\u1EDA': 'O',
    '\u1EE0': 'O',
    '\u1EDE': 'O',
    '\u1EE2': 'O',
    '\u1ECC': 'O',
    '\u1ED8': 'O',
    '\u01EA': 'O',
    '\u01EC': 'O',
    '\u00D8': 'O',
    '\u01FE': 'O',
    '\u0186': 'O',
    '\u019F': 'O',
    '\uA74A': 'O',
    '\uA74C': 'O',
    '\u0152': 'OE',
    '\u01A2': 'OI',
    '\uA74E': 'OO',
    '\u0222': 'OU',
    '\u24C5': 'P',
    '\uFF30': 'P',
    '\u1E54': 'P',
    '\u1E56': 'P',
    '\u01A4': 'P',
    '\u2C63': 'P',
    '\uA750': 'P',
    '\uA752': 'P',
    '\uA754': 'P',
    '\u24C6': 'Q',
    '\uFF31': 'Q',
    '\uA756': 'Q',
    '\uA758': 'Q',
    '\u024A': 'Q',
    '\u24C7': 'R',
    '\uFF32': 'R',
    '\u0154': 'R',
    '\u1E58': 'R',
    '\u0158': 'R',
    '\u0210': 'R',
    '\u0212': 'R',
    '\u1E5A': 'R',
    '\u1E5C': 'R',
    '\u0156': 'R',
    '\u1E5E': 'R',
    '\u024C': 'R',
    '\u2C64': 'R',
    '\uA75A': 'R',
    '\uA7A6': 'R',
    '\uA782': 'R',
    '\u24C8': 'S',
    '\uFF33': 'S',
    '\u1E9E': 'S',
    '\u015A': 'S',
    '\u1E64': 'S',
    '\u015C': 'S',
    '\u1E60': 'S',
    '\u0160': 'S',
    '\u1E66': 'S',
    '\u1E62': 'S',
    '\u1E68': 'S',
    '\u0218': 'S',
    '\u015E': 'S',
    '\u2C7E': 'S',
    '\uA7A8': 'S',
    '\uA784': 'S',
    '\u24C9': 'T',
    '\uFF34': 'T',
    '\u1E6A': 'T',
    '\u0164': 'T',
    '\u1E6C': 'T',
    '\u021A': 'T',
    '\u0162': 'T',
    '\u1E70': 'T',
    '\u1E6E': 'T',
    '\u0166': 'T',
    '\u01AC': 'T',
    '\u01AE': 'T',
    '\u023E': 'T',
    '\uA786': 'T',
    '\uA728': 'TZ',
    '\u24CA': 'U',
    '\uFF35': 'U',
    '\u00D9': 'U',
    '\u00DA': 'U',
    '\u00DB': 'U',
    '\u0168': 'U',
    '\u1E78': 'U',
    '\u016A': 'U',
    '\u1E7A': 'U',
    '\u016C': 'U',
    '\u00DC': 'U',
    '\u01DB': 'U',
    '\u01D7': 'U',
    '\u01D5': 'U',
    '\u01D9': 'U',
    '\u1EE6': 'U',
    '\u016E': 'U',
    '\u0170': 'U',
    '\u01D3': 'U',
    '\u0214': 'U',
    '\u0216': 'U',
    '\u01AF': 'U',
    '\u1EEA': 'U',
    '\u1EE8': 'U',
    '\u1EEE': 'U',
    '\u1EEC': 'U',
    '\u1EF0': 'U',
    '\u1EE4': 'U',
    '\u1E72': 'U',
    '\u0172': 'U',
    '\u1E76': 'U',
    '\u1E74': 'U',
    '\u0244': 'U',
    '\u24CB': 'V',
    '\uFF36': 'V',
    '\u1E7C': 'V',
    '\u1E7E': 'V',
    '\u01B2': 'V',
    '\uA75E': 'V',
    '\u0245': 'V',
    '\uA760': 'VY',
    '\u24CC': 'W',
    '\uFF37': 'W',
    '\u1E80': 'W',
    '\u1E82': 'W',
    '\u0174': 'W',
    '\u1E86': 'W',
    '\u1E84': 'W',
    '\u1E88': 'W',
    '\u2C72': 'W',
    '\u24CD': 'X',
    '\uFF38': 'X',
    '\u1E8A': 'X',
    '\u1E8C': 'X',
    '\u24CE': 'Y',
    '\uFF39': 'Y',
    '\u1EF2': 'Y',
    '\u00DD': 'Y',
    '\u0176': 'Y',
    '\u1EF8': 'Y',
    '\u0232': 'Y',
    '\u1E8E': 'Y',
    '\u0178': 'Y',
    '\u1EF6': 'Y',
    '\u1EF4': 'Y',
    '\u01B3': 'Y',
    '\u024E': 'Y',
    '\u1EFE': 'Y',
    '\u24CF': 'Z',
    '\uFF3A': 'Z',
    '\u0179': 'Z',
    '\u1E90': 'Z',
    '\u017B': 'Z',
    '\u017D': 'Z',
    '\u1E92': 'Z',
    '\u1E94': 'Z',
    '\u01B5': 'Z',
    '\u0224': 'Z',
    '\u2C7F': 'Z',
    '\u2C6B': 'Z',
    '\uA762': 'Z',
    '\u24D0': 'a',
    '\uFF41': 'a',
    '\u1E9A': 'a',
    '\u00E0': 'a',
    '\u00E1': 'a',
    '\u00E2': 'a',
    '\u1EA7': 'a',
    '\u1EA5': 'a',
    '\u1EAB': 'a',
    '\u1EA9': 'a',
    '\u00E3': 'a',
    '\u0101': 'a',
    '\u0103': 'a',
    '\u1EB1': 'a',
    '\u1EAF': 'a',
    '\u1EB5': 'a',
    '\u1EB3': 'a',
    '\u0227': 'a',
    '\u01E1': 'a',
    '\u00E4': 'a',
    '\u01DF': 'a',
    '\u1EA3': 'a',
    '\u00E5': 'a',
    '\u01FB': 'a',
    '\u01CE': 'a',
    '\u0201': 'a',
    '\u0203': 'a',
    '\u1EA1': 'a',
    '\u1EAD': 'a',
    '\u1EB7': 'a',
    '\u1E01': 'a',
    '\u0105': 'a',
    '\u2C65': 'a',
    '\u0250': 'a',
    '\uA733': 'aa',
    '\u00E6': 'ae',
    '\u01FD': 'ae',
    '\u01E3': 'ae',
    '\uA735': 'ao',
    '\uA737': 'au',
    '\uA739': 'av',
    '\uA73B': 'av',
    '\uA73D': 'ay',
    '\u24D1': 'b',
    '\uFF42': 'b',
    '\u1E03': 'b',
    '\u1E05': 'b',
    '\u1E07': 'b',
    '\u0180': 'b',
    '\u0183': 'b',
    '\u0253': 'b',
    '\u24D2': 'c',
    '\uFF43': 'c',
    '\u0107': 'c',
    '\u0109': 'c',
    '\u010B': 'c',
    '\u010D': 'c',
    '\u00E7': 'c',
    '\u1E09': 'c',
    '\u0188': 'c',
    '\u023C': 'c',
    '\uA73F': 'c',
    '\u2184': 'c',
    '\u24D3': 'd',
    '\uFF44': 'd',
    '\u1E0B': 'd',
    '\u010F': 'd',
    '\u1E0D': 'd',
    '\u1E11': 'd',
    '\u1E13': 'd',
    '\u1E0F': 'd',
    '\u0111': 'd',
    '\u018C': 'd',
    '\u0256': 'd',
    '\u0257': 'd',
    '\uA77A': 'd',
    '\u01F3': 'dz',
    '\u01C6': 'dz',
    '\u24D4': 'e',
    '\uFF45': 'e',
    '\u00E8': 'e',
    '\u00E9': 'e',
    '\u00EA': 'e',
    '\u1EC1': 'e',
    '\u1EBF': 'e',
    '\u1EC5': 'e',
    '\u1EC3': 'e',
    '\u1EBD': 'e',
    '\u0113': 'e',
    '\u1E15': 'e',
    '\u1E17': 'e',
    '\u0115': 'e',
    '\u0117': 'e',
    '\u00EB': 'e',
    '\u1EBB': 'e',
    '\u011B': 'e',
    '\u0205': 'e',
    '\u0207': 'e',
    '\u1EB9': 'e',
    '\u1EC7': 'e',
    '\u0229': 'e',
    '\u1E1D': 'e',
    '\u0119': 'e',
    '\u1E19': 'e',
    '\u1E1B': 'e',
    '\u0247': 'e',
    '\u025B': 'e',
    '\u01DD': 'e',
    '\u24D5': 'f',
    '\uFF46': 'f',
    '\u1E1F': 'f',
    '\u0192': 'f',
    '\uA77C': 'f',
    '\u24D6': 'g',
    '\uFF47': 'g',
    '\u01F5': 'g',
    '\u011D': 'g',
    '\u1E21': 'g',
    '\u011F': 'g',
    '\u0121': 'g',
    '\u01E7': 'g',
    '\u0123': 'g',
    '\u01E5': 'g',
    '\u0260': 'g',
    '\uA7A1': 'g',
    '\u1D79': 'g',
    '\uA77F': 'g',
    '\u24D7': 'h',
    '\uFF48': 'h',
    '\u0125': 'h',
    '\u1E23': 'h',
    '\u1E27': 'h',
    '\u021F': 'h',
    '\u1E25': 'h',
    '\u1E29': 'h',
    '\u1E2B': 'h',
    '\u1E96': 'h',
    '\u0127': 'h',
    '\u2C68': 'h',
    '\u2C76': 'h',
    '\u0265': 'h',
    '\u0195': 'hv',
    '\u24D8': 'i',
    '\uFF49': 'i',
    '\u00EC': 'i',
    '\u00ED': 'i',
    '\u00EE': 'i',
    '\u0129': 'i',
    '\u012B': 'i',
    '\u012D': 'i',
    '\u00EF': 'i',
    '\u1E2F': 'i',
    '\u1EC9': 'i',
    '\u01D0': 'i',
    '\u0209': 'i',
    '\u020B': 'i',
    '\u1ECB': 'i',
    '\u012F': 'i',
    '\u1E2D': 'i',
    '\u0268': 'i',
    '\u0131': 'i',
    '\u24D9': 'j',
    '\uFF4A': 'j',
    '\u0135': 'j',
    '\u01F0': 'j',
    '\u0249': 'j',
    '\u24DA': 'k',
    '\uFF4B': 'k',
    '\u1E31': 'k',
    '\u01E9': 'k',
    '\u1E33': 'k',
    '\u0137': 'k',
    '\u1E35': 'k',
    '\u0199': 'k',
    '\u2C6A': 'k',
    '\uA741': 'k',
    '\uA743': 'k',
    '\uA745': 'k',
    '\uA7A3': 'k',
    '\u24DB': 'l',
    '\uFF4C': 'l',
    '\u0140': 'l',
    '\u013A': 'l',
    '\u013E': 'l',
    '\u1E37': 'l',
    '\u1E39': 'l',
    '\u013C': 'l',
    '\u1E3D': 'l',
    '\u1E3B': 'l',
    '\u017F': 'l',
    '\u0142': 'l',
    '\u019A': 'l',
    '\u026B': 'l',
    '\u2C61': 'l',
    '\uA749': 'l',
    '\uA781': 'l',
    '\uA747': 'l',
    '\u01C9': 'lj',
    '\u24DC': 'm',
    '\uFF4D': 'm',
    '\u1E3F': 'm',
    '\u1E41': 'm',
    '\u1E43': 'm',
    '\u0271': 'm',
    '\u026F': 'm',
    '\u24DD': 'n',
    '\uFF4E': 'n',
    '\u01F9': 'n',
    '\u0144': 'n',
    '\u00F1': 'n',
    '\u1E45': 'n',
    '\u0148': 'n',
    '\u1E47': 'n',
    '\u0146': 'n',
    '\u1E4B': 'n',
    '\u1E49': 'n',
    '\u019E': 'n',
    '\u0272': 'n',
    '\u0149': 'n',
    '\uA791': 'n',
    '\uA7A5': 'n',
    '\u01CC': 'nj',
    '\u24DE': 'o',
    '\uFF4F': 'o',
    '\u00F2': 'o',
    '\u00F3': 'o',
    '\u00F4': 'o',
    '\u1ED3': 'o',
    '\u1ED1': 'o',
    '\u1ED7': 'o',
    '\u1ED5': 'o',
    '\u00F5': 'o',
    '\u1E4D': 'o',
    '\u022D': 'o',
    '\u1E4F': 'o',
    '\u014D': 'o',
    '\u1E51': 'o',
    '\u1E53': 'o',
    '\u014F': 'o',
    '\u022F': 'o',
    '\u0231': 'o',
    '\u00F6': 'o',
    '\u022B': 'o',
    '\u1ECF': 'o',
    '\u0151': 'o',
    '\u01D2': 'o',
    '\u020D': 'o',
    '\u020F': 'o',
    '\u01A1': 'o',
    '\u1EDD': 'o',
    '\u1EDB': 'o',
    '\u1EE1': 'o',
    '\u1EDF': 'o',
    '\u1EE3': 'o',
    '\u1ECD': 'o',
    '\u1ED9': 'o',
    '\u01EB': 'o',
    '\u01ED': 'o',
    '\u00F8': 'o',
    '\u01FF': 'o',
    '\u0254': 'o',
    '\uA74B': 'o',
    '\uA74D': 'o',
    '\u0275': 'o',
    '\u0153': 'oe',
    '\u01A3': 'oi',
    '\u0223': 'ou',
    '\uA74F': 'oo',
    '\u24DF': 'p',
    '\uFF50': 'p',
    '\u1E55': 'p',
    '\u1E57': 'p',
    '\u01A5': 'p',
    '\u1D7D': 'p',
    '\uA751': 'p',
    '\uA753': 'p',
    '\uA755': 'p',
    '\u24E0': 'q',
    '\uFF51': 'q',
    '\u024B': 'q',
    '\uA757': 'q',
    '\uA759': 'q',
    '\u24E1': 'r',
    '\uFF52': 'r',
    '\u0155': 'r',
    '\u1E59': 'r',
    '\u0159': 'r',
    '\u0211': 'r',
    '\u0213': 'r',
    '\u1E5B': 'r',
    '\u1E5D': 'r',
    '\u0157': 'r',
    '\u1E5F': 'r',
    '\u024D': 'r',
    '\u027D': 'r',
    '\uA75B': 'r',
    '\uA7A7': 'r',
    '\uA783': 'r',
    '\u24E2': 's',
    '\uFF53': 's',
    '\u00DF': 's',
    '\u015B': 's',
    '\u1E65': 's',
    '\u015D': 's',
    '\u1E61': 's',
    '\u0161': 's',
    '\u1E67': 's',
    '\u1E63': 's',
    '\u1E69': 's',
    '\u0219': 's',
    '\u015F': 's',
    '\u023F': 's',
    '\uA7A9': 's',
    '\uA785': 's',
    '\u1E9B': 's',
    '\u24E3': 't',
    '\uFF54': 't',
    '\u1E6B': 't',
    '\u1E97': 't',
    '\u0165': 't',
    '\u1E6D': 't',
    '\u021B': 't',
    '\u0163': 't',
    '\u1E71': 't',
    '\u1E6F': 't',
    '\u0167': 't',
    '\u01AD': 't',
    '\u0288': 't',
    '\u2C66': 't',
    '\uA787': 't',
    '\uA729': 'tz',
    '\u24E4': 'u',
    '\uFF55': 'u',
    '\u00F9': 'u',
    '\u00FA': 'u',
    '\u00FB': 'u',
    '\u0169': 'u',
    '\u1E79': 'u',
    '\u016B': 'u',
    '\u1E7B': 'u',
    '\u016D': 'u',
    '\u00FC': 'u',
    '\u01DC': 'u',
    '\u01D8': 'u',
    '\u01D6': 'u',
    '\u01DA': 'u',
    '\u1EE7': 'u',
    '\u016F': 'u',
    '\u0171': 'u',
    '\u01D4': 'u',
    '\u0215': 'u',
    '\u0217': 'u',
    '\u01B0': 'u',
    '\u1EEB': 'u',
    '\u1EE9': 'u',
    '\u1EEF': 'u',
    '\u1EED': 'u',
    '\u1EF1': 'u',
    '\u1EE5': 'u',
    '\u1E73': 'u',
    '\u0173': 'u',
    '\u1E77': 'u',
    '\u1E75': 'u',
    '\u0289': 'u',
    '\u24E5': 'v',
    '\uFF56': 'v',
    '\u1E7D': 'v',
    '\u1E7F': 'v',
    '\u028B': 'v',
    '\uA75F': 'v',
    '\u028C': 'v',
    '\uA761': 'vy',
    '\u24E6': 'w',
    '\uFF57': 'w',
    '\u1E81': 'w',
    '\u1E83': 'w',
    '\u0175': 'w',
    '\u1E87': 'w',
    '\u1E85': 'w',
    '\u1E98': 'w',
    '\u1E89': 'w',
    '\u2C73': 'w',
    '\u24E7': 'x',
    '\uFF58': 'x',
    '\u1E8B': 'x',
    '\u1E8D': 'x',
    '\u24E8': 'y',
    '\uFF59': 'y',
    '\u1EF3': 'y',
    '\u00FD': 'y',
    '\u0177': 'y',
    '\u1EF9': 'y',
    '\u0233': 'y',
    '\u1E8F': 'y',
    '\u00FF': 'y',
    '\u1EF7': 'y',
    '\u1E99': 'y',
    '\u1EF5': 'y',
    '\u01B4': 'y',
    '\u024F': 'y',
    '\u1EFF': 'y',
    '\u24E9': 'z',
    '\uFF5A': 'z',
    '\u017A': 'z',
    '\u1E91': 'z',
    '\u017C': 'z',
    '\u017E': 'z',
    '\u1E93': 'z',
    '\u1E95': 'z',
    '\u01B6': 'z',
    '\u0225': 'z',
    '\u0240': 'z',
    '\u2C6C': 'z',
    '\uA763': 'z',
    '\u0386': '\u0391',
    '\u0388': '\u0395',
    '\u0389': '\u0397',
    '\u038A': '\u0399',
    '\u03AA': '\u0399',
    '\u038C': '\u039F',
    '\u038E': '\u03A5',
    '\u03AB': '\u03A5',
    '\u038F': '\u03A9',
    '\u03AC': '\u03B1',
    '\u03AD': '\u03B5',
    '\u03AE': '\u03B7',
    '\u03AF': '\u03B9',
    '\u03CA': '\u03B9',
    '\u0390': '\u03B9',
    '\u03CC': '\u03BF',
    '\u03CD': '\u03C5',
    '\u03CB': '\u03C5',
    '\u03B0': '\u03C5',
    '\u03CE': '\u03C9',
    '\u03C2': '\u03C3',
    '\u2019': '\''
  };

  return diacritics;
});

S2.define('select2/data/base',[
  '../utils'
], function (Utils) {
  function BaseAdapter ($element, options) {
    BaseAdapter.__super__.constructor.call(this);
  }

  Utils.Extend(BaseAdapter, Utils.Observable);

  BaseAdapter.prototype.current = function (callback) {
    throw new Error('The `current` method must be defined in child classes.');
  };

  BaseAdapter.prototype.query = function (params, callback) {
    throw new Error('The `query` method must be defined in child classes.');
  };

  BaseAdapter.prototype.bind = function (container, $container) {
    // Can be implemented in subclasses
  };

  BaseAdapter.prototype.destroy = function () {
    // Can be implemented in subclasses
  };

  BaseAdapter.prototype.generateResultId = function (container, data) {
    var id = container.id + '-result-';

    id += Utils.generateChars(4);

    if (data.id != null) {
      id += '-' + data.id.toString();
    } else {
      id += '-' + Utils.generateChars(4);
    }
    return id;
  };

  return BaseAdapter;
});

S2.define('select2/data/select',[
  './base',
  '../utils',
  'jquery'
], function (BaseAdapter, Utils, $) {
  function SelectAdapter ($element, options) {
    this.$element = $element;
    this.options = options;

    SelectAdapter.__super__.constructor.call(this);
  }

  Utils.Extend(SelectAdapter, BaseAdapter);

  SelectAdapter.prototype.current = function (callback) {
    var self = this;

    var data = Array.prototype.map.call(
      this.$element[0].querySelectorAll(':checked'),
      function (selectedElement) {
        return self.item($(selectedElement));
      }
    );

    callback(data);
  };

  SelectAdapter.prototype.select = function (data) {
    var self = this;

    data.selected = true;

    // If data.element is a DOM node, use it instead
    if (
      data.element != null && data.element.tagName.toLowerCase() === 'option'
    ) {
      data.element.selected = true;

      this.$element.trigger('input').trigger('change');

      return;
    }

    if (this.$element.prop('multiple')) {
      this.current(function (currentData) {
        var val = [];

        data = [data];
        data.push.apply(data, currentData);

        for (var d = 0; d < data.length; d++) {
          var id = data[d].id;

          if (val.indexOf(id) === -1) {
            val.push(id);
          }
        }

        self.$element.val(val);
        self.$element.trigger('input').trigger('change');
      });
    } else {
      var val = data.id;

      this.$element.val(val);
      this.$element.trigger('input').trigger('change');
    }
  };

  SelectAdapter.prototype.unselect = function (data) {
    var self = this;

    if (!this.$element.prop('multiple')) {
      return;
    }

    data.selected = false;

    if (
      data.element != null &&
      data.element.tagName.toLowerCase() === 'option'
    ) {
      data.element.selected = false;

      this.$element.trigger('input').trigger('change');

      return;
    }

    this.current(function (currentData) {
      var val = [];

      for (var d = 0; d < currentData.length; d++) {
        var id = currentData[d].id;

        if (id !== data.id && val.indexOf(id) === -1) {
          val.push(id);
        }
      }

      self.$element.val(val);

      self.$element.trigger('input').trigger('change');
    });
  };

  SelectAdapter.prototype.bind = function (container, $container) {
    var self = this;

    this.container = container;

    container.on('select', function (params) {
      self.select(params.data);
    });

    container.on('unselect', function (params) {
      self.unselect(params.data);
    });
  };

  SelectAdapter.prototype.destroy = function () {
    // Remove anything added to child elements
    this.$element.find('*').each(function () {
      // Remove any custom data set by Select2
      Utils.RemoveData(this);
    });
  };

  SelectAdapter.prototype.query = function (params, callback) {
    var data = [];
    var self = this;

    var $options = this.$element.children();

    $options.each(function () {
      if (
        this.tagName.toLowerCase() !== 'option' &&
        this.tagName.toLowerCase() !== 'optgroup'
      ) {
        return;
      }

      var $option = $(this);

      var option = self.item($option);

      var matches = self.matches(params, option);

      if (matches !== null) {
        data.push(matches);
      }
    });

    callback({
      results: data
    });
  };

  SelectAdapter.prototype.addOptions = function ($options) {
    this.$element.append($options);
  };

  SelectAdapter.prototype.option = function (data) {
    var option;

    if (data.children) {
      option = document.createElement('optgroup');
      option.label = data.text;
    } else {
      option = document.createElement('option');

      if (option.textContent !== undefined) {
        option.textContent = data.text;
      } else {
        option.innerText = data.text;
      }
    }

    if (data.id !== undefined) {
      option.value = data.id;
    }

    if (data.disabled) {
      option.disabled = true;
    }

    if (data.selected) {
      option.selected = true;
    }

    if (data.title) {
      option.title = data.title;
    }

    var normalizedData = this._normalizeItem(data);
    normalizedData.element = option;

    // Override the option's data with the combined data
    Utils.StoreData(option, 'data', normalizedData);

    return $(option);
  };

  SelectAdapter.prototype.item = function ($option) {
    var data = {};

    data = Utils.GetData($option[0], 'data');

    if (data != null) {
      return data;
    }

    var option = $option[0];

    if (option.tagName.toLowerCase() === 'option') {
      data = {
        id: $option.val(),
        text: $option.text(),
        disabled: $option.prop('disabled'),
        selected: $option.prop('selected'),
        title: $option.prop('title')
      };
    } else if (option.tagName.toLowerCase() === 'optgroup') {
      data = {
        text: $option.prop('label'),
        children: [],
        title: $option.prop('title')
      };

      var $children = $option.children('option');
      var children = [];

      for (var c = 0; c < $children.length; c++) {
        var $child = $($children[c]);

        var child = this.item($child);

        children.push(child);
      }

      data.children = children;
    }

    data = this._normalizeItem(data);
    data.element = $option[0];

    Utils.StoreData($option[0], 'data', data);

    return data;
  };

  SelectAdapter.prototype._normalizeItem = function (item) {
    if (item !== Object(item)) {
      item = {
        id: item,
        text: item
      };
    }

    item = $.extend({}, {
      text: ''
    }, item);

    var defaults = {
      selected: false,
      disabled: false
    };

    if (item.id != null) {
      item.id = item.id.toString();
    }

    if (item.text != null) {
      item.text = item.text.toString();
    }

    if (item._resultId == null && item.id && this.container != null) {
      item._resultId = this.generateResultId(this.container, item);
    }

    return $.extend({}, defaults, item);
  };

  SelectAdapter.prototype.matches = function (params, data) {
    var matcher = this.options.get('matcher');

    return matcher(params, data);
  };

  return SelectAdapter;
});

S2.define('select2/data/array',[
  './select',
  '../utils',
  'jquery'
], function (SelectAdapter, Utils, $) {
  function ArrayAdapter ($element, options) {
    this._dataToConvert = options.get('data') || [];

    ArrayAdapter.__super__.constructor.call(this, $element, options);
  }

  Utils.Extend(ArrayAdapter, SelectAdapter);

  ArrayAdapter.prototype.bind = function (container, $container) {
    ArrayAdapter.__super__.bind.call(this, container, $container);

    this.addOptions(this.convertToOptions(this._dataToConvert));
  };

  ArrayAdapter.prototype.select = function (data) {
    var $option = this.$element.find('option').filter(function (i, elm) {
      return elm.value == data.id.toString();
    });

    if ($option.length === 0) {
      $option = this.option(data);

      this.addOptions($option);
    }

    ArrayAdapter.__super__.select.call(this, data);
  };

  ArrayAdapter.prototype.convertToOptions = function (data) {
    var self = this;

    var $existing = this.$element.find('option');
    var existingIds = $existing.map(function () {
      return self.item($(this)).id;
    }).get();

    var $options = [];

    // Filter out all items except for the one passed in the argument
    function onlyItem (item) {
      return function () {
        return $(this).val() == item.id;
      };
    }

    for (var d = 0; d < data.length; d++) {
      var item = this._normalizeItem(data[d]);

      // Skip items which were pre-loaded, only merge the data
      if (existingIds.indexOf(item.id) >= 0) {
        var $existingOption = $existing.filter(onlyItem(item));

        var existingData = this.item($existingOption);
        var newData = $.extend(true, {}, item, existingData);

        var $newOption = this.option(newData);

        $existingOption.replaceWith($newOption);

        continue;
      }

      var $option = this.option(item);

      if (item.children) {
        var $children = this.convertToOptions(item.children);

        $option.append($children);
      }

      $options.push($option);
    }

    return $options;
  };

  return ArrayAdapter;
});

S2.define('select2/data/ajax',[
  './array',
  '../utils',
  'jquery'
], function (ArrayAdapter, Utils, $) {
  function AjaxAdapter ($element, options) {
    this.ajaxOptions = this._applyDefaults(options.get('ajax'));

    if (this.ajaxOptions.processResults != null) {
      this.processResults = this.ajaxOptions.processResults;
    }

    AjaxAdapter.__super__.constructor.call(this, $element, options);
  }

  Utils.Extend(AjaxAdapter, ArrayAdapter);

  AjaxAdapter.prototype._applyDefaults = function (options) {
    var defaults = {
      data: function (params) {
        return $.extend({}, params, {
          q: params.term
        });
      },
      transport: function (params, success, failure) {
        var $request = $.ajax(params);

        $request.then(success);
        $request.fail(failure);

        return $request;
      }
    };

    return $.extend({}, defaults, options, true);
  };

  AjaxAdapter.prototype.processResults = function (results) {
    return results;
  };

  AjaxAdapter.prototype.query = function (params, callback) {
    var matches = [];
    var self = this;

    if (this._request != null) {
      // JSONP requests cannot always be aborted
      if (typeof this._request.abort === 'function') {
        this._request.abort();
      }

      this._request = null;
    }

    var options = $.extend({
      type: 'GET'
    }, this.ajaxOptions);

    if (typeof options.url === 'function') {
      options.url = options.url.call(this.$element, params);
    }

    if (typeof options.data === 'function') {
      options.data = options.data.call(this.$element, params);
    }

    function request () {
      var $request = options.transport(options, function (data) {
        var results = self.processResults(data, params);

        if (self.options.get('debug') && window.console && console.error) {
          // Check to make sure that the response included a `results` key.
          if (!results || !results.results || !Array.isArray(results.results)) {
            console.error(
              'Select2: The AJAX results did not return an array in the ' +
              '`results` key of the response.'
            );
          }
        }

        callback(results);
      }, function () {
        // Attempt to detect if a request was aborted
        // Only works if the transport exposes a status property
        if ('status' in $request &&
            ($request.status === 0 || $request.status === '0')) {
          return;
        }

        self.trigger('results:message', {
          message: 'errorLoading'
        });
      });

      self._request = $request;
    }

    if (this.ajaxOptions.delay && params.term != null) {
      if (this._queryTimeout) {
        window.clearTimeout(this._queryTimeout);
      }

      this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
    } else {
      request();
    }
  };

  return AjaxAdapter;
});

S2.define('select2/data/tags',[
  'jquery'
], function ($) {
  function Tags (decorated, $element, options) {
    var tags = options.get('tags');

    var createTag = options.get('createTag');

    if (createTag !== undefined) {
      this.createTag = createTag;
    }

    var insertTag = options.get('insertTag');

    if (insertTag !== undefined) {
        this.insertTag = insertTag;
    }

    decorated.call(this, $element, options);

    if (Array.isArray(tags)) {
      for (var t = 0; t < tags.length; t++) {
        var tag = tags[t];
        var item = this._normalizeItem(tag);

        var $option = this.option(item);

        this.$element.append($option);
      }
    }
  }

  Tags.prototype.query = function (decorated, params, callback) {
    var self = this;

    this._removeOldTags();

    if (params.term == null || params.page != null) {
      decorated.call(this, params, callback);
      return;
    }

    function wrapper (obj, child) {
      var data = obj.results;

      for (var i = 0; i < data.length; i++) {
        var option = data[i];

        var checkChildren = (
          option.children != null &&
          !wrapper({
            results: option.children
          }, true)
        );

        var optionText = (option.text || '').toUpperCase();
        var paramsTerm = (params.term || '').toUpperCase();

        var checkText = optionText === paramsTerm;

        if (checkText || checkChildren) {
          if (child) {
            return false;
          }

          obj.data = data;
          callback(obj);

          return;
        }
      }

      if (child) {
        return true;
      }

      var tag = self.createTag(params);

      if (tag != null) {
        var $option = self.option(tag);
        $option.attr('data-select2-tag', 'true');

        self.addOptions([$option]);

        self.insertTag(data, tag);
      }

      obj.results = data;

      callback(obj);
    }

    decorated.call(this, params, wrapper);
  };

  Tags.prototype.createTag = function (decorated, params) {
    if (params.term == null) {
      return null;
    }

    var term = params.term.trim();

    if (term === '') {
      return null;
    }

    return {
      id: term,
      text: term
    };
  };

  Tags.prototype.insertTag = function (_, data, tag) {
    data.unshift(tag);
  };

  Tags.prototype._removeOldTags = function (_) {
    var $options = this.$element.find('option[data-select2-tag]');

    $options.each(function () {
      if (this.selected) {
        return;
      }

      $(this).remove();
    });
  };

  return Tags;
});

S2.define('select2/data/tokenizer',[
  'jquery'
], function ($) {
  function Tokenizer (decorated, $element, options) {
    var tokenizer = options.get('tokenizer');

    if (tokenizer !== undefined) {
      this.tokenizer = tokenizer;
    }

    decorated.call(this, $element, options);
  }

  Tokenizer.prototype.bind = function (decorated, container, $container) {
    decorated.call(this, container, $container);

    this.$search =  container.dropdown.$search || container.selection.$search ||
      $container.find('.select2-search__field');
  };

  Tokenizer.prototype.query = function (decorated, params, callback) {
    var self = this;

    function createAndSelect (data) {
      // Normalize the data object so we can use it for checks
      var item = self._normalizeItem(data);

      // Check if the data object already exists as a tag
      // Select it if it doesn't
      var $existingOptions = self.$element.find('option').filter(function () {
        return $(this).val() === item.id;
      });

      // If an existing option wasn't found for it, create the option
      if (!$existingOptions.length) {
        var $option = self.option(item);
        $option.attr('data-select2-tag', true);

        self._removeOldTags();
        self.addOptions([$option]);
      }

      // Select the item, now that we know there is an option for it
      select(item);
    }

    function select (data) {
      self.trigger('select', {
        data: data
      });
    }

    params.term = params.term || '';

    var tokenData = this.tokenizer(params, this.options, createAndSelect);

    if (tokenData.term !== params.term) {
      // Replace the search term if we have the search box
      if (this.$search.length) {
        this.$search.val(tokenData.term);
        this.$search.trigger('focus');
      }

      params.term = tokenData.term;
    }

    decorated.call(this, params, callback);
  };

  Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
    var separators = options.get('tokenSeparators') || [];
    var term = params.term;
    var i = 0;

    var createTag = this.createTag || function (params) {
      return {
        id: params.term,
        text: params.term
      };
    };

    while (i < term.length) {
      var termChar = term[i];

      if (separators.indexOf(termChar) === -1) {
        i++;

        continue;
      }

      var part = term.substr(0, i);
      var partParams = $.extend({}, params, {
        term: part
      });

      var data = createTag(partParams);

      if (data == null) {
        i++;
        continue;
      }

      callback(data);

      // Reset the term to not include the tokenized portion
      term = term.substr(i + 1) || '';
      i = 0;
    }

    return {
      term: term
    };
  };

  return Tokenizer;
});

S2.define('select2/data/minimumInputLength',[

], function () {
  function MinimumInputLength (decorated, $e, options) {
    this.minimumInputLength = options.get('minimumInputLength');

    decorated.call(this, $e, options);
  }

  MinimumInputLength.prototype.query = function (decorated, params, callback) {
    params.term = params.term || '';

    if (params.term.length < this.minimumInputLength) {
      this.trigger('results:message', {
        message: 'inputTooShort',
        args: {
          minimum: this.minimumInputLength,
          input: params.term,
          params: params
        }
      });

      return;
    }

    decorated.call(this, params, callback);
  };

  return MinimumInputLength;
});

S2.define('select2/data/maximumInputLength',[

], function () {
  function MaximumInputLength (decorated, $e, options) {
    this.maximumInputLength = options.get('maximumInputLength');

    decorated.call(this, $e, options);
  }

  MaximumInputLength.prototype.query = function (decorated, params, callback) {
    params.term = params.term || '';

    if (this.maximumInputLength > 0 &&
        params.term.length > this.maximumInputLength) {
      this.trigger('results:message', {
        message: 'inputTooLong',
        args: {
          maximum: this.maximumInputLength,
          input: params.term,
          params: params
        }
      });

      return;
    }

    decorated.call(this, params, callback);
  };

  return MaximumInputLength;
});

S2.define('select2/data/maximumSelectionLength',[

], function (){
  function MaximumSelectionLength (decorated, $e, options) {
    this.maximumSelectionLength = options.get('maximumSelectionLength');

    decorated.call(this, $e, options);
  }

  MaximumSelectionLength.prototype.bind =
    function (decorated, container, $container) {
      var self = this;

      decorated.call(this, container, $container);

      container.on('select', function () {
        self._checkIfMaximumSelected();
      });
  };

  MaximumSelectionLength.prototype.query =
    function (decorated, params, callback) {
      var self = this;

      this._checkIfMaximumSelected(function () {
        decorated.call(self, params, callback);
      });
  };

  MaximumSelectionLength.prototype._checkIfMaximumSelected =
    function (_, successCallback) {
      var self = this;

      this.current(function (currentData) {
        var count = currentData != null ? currentData.length : 0;
        if (self.maximumSelectionLength > 0 &&
          count >= self.maximumSelectionLength) {
          self.trigger('results:message', {
            message: 'maximumSelected',
            args: {
              maximum: self.maximumSelectionLength
            }
          });
          return;
        }

        if (successCallback) {
          successCallback();
        }
      });
  };

  return MaximumSelectionLength;
});

S2.define('select2/dropdown',[
  'jquery',
  './utils'
], function ($, Utils) {
  function Dropdown ($element, options) {
    this.$element = $element;
    this.options = options;

    Dropdown.__super__.constructor.call(this);
  }

  Utils.Extend(Dropdown, Utils.Observable);

  Dropdown.prototype.render = function () {
    var $dropdown = $(
      '<span class="select2-dropdown">' +
        '<span class="select2-results"></span>' +
      '</span>'
    );

    $dropdown.attr('dir', this.options.get('dir'));

    this.$dropdown = $dropdown;

    return $dropdown;
  };

  Dropdown.prototype.bind = function () {
    // Should be implemented in subclasses
  };

  Dropdown.prototype.position = function ($dropdown, $container) {
    // Should be implemented in subclasses
  };

  Dropdown.prototype.destroy = function () {
    // Remove the dropdown from the DOM
    this.$dropdown.remove();
  };

  return Dropdown;
});

S2.define('select2/dropdown/search',[
  'jquery'
], function ($) {
  function Search () { }

  Search.prototype.render = function (decorated) {
    var $rendered = decorated.call(this);
    var searchLabel = this.options.get('translations').get('search');

    var $search = $(
      '<span class="select2-search select2-search--dropdown">' +
        '<input class="select2-search__field" type="search" tabindex="-1"' +
        ' autocorrect="off" autocapitalize="none"' +
        ' spellcheck="false" role="searchbox" aria-autocomplete="list" />' +
      '</span>'
    );

    this.$searchContainer = $search;
    this.$search = $search.find('input');

    this.$search.prop('autocomplete', this.options.get('autocomplete'));
    this.$search.attr('aria-label', searchLabel());

    $rendered.prepend($search);

    return $rendered;
  };

  Search.prototype.bind = function (decorated, container, $container) {
    var self = this;

    var resultsId = container.id + '-results';

    decorated.call(this, container, $container);

    this.$search.on('keydown', function (evt) {
      self.trigger('keypress', evt);

      self._keyUpPrevented = evt.isDefaultPrevented();
    });

    // Workaround for browsers which do not support the `input` event
    // This will prevent double-triggering of events for browsers which support
    // both the `keyup` and `input` events.
    this.$search.on('input', function (evt) {
      // Unbind the duplicated `keyup` event
      $(this).off('keyup');
    });

    this.$search.on('keyup input', function (evt) {
      self.handleSearch(evt);
    });

    container.on('open', function () {
      self.$search.attr('tabindex', 0);
      self.$search.attr('aria-controls', resultsId);

      self.$search.trigger('focus');

      window.setTimeout(function () {
        self.$search.trigger('focus');
      }, 0);
    });

    container.on('close', function () {
      self.$search.attr('tabindex', -1);
      self.$search.removeAttr('aria-controls');
      self.$search.removeAttr('aria-activedescendant');

      self.$search.val('');
      self.$search.trigger('blur');
    });

    container.on('focus', function () {
      if (!container.isOpen()) {
        self.$search.trigger('focus');
      }
    });

    container.on('results:all', function (params) {
      if (params.query.term == null || params.query.term === '') {
        var showSearch = self.showSearch(params);

        if (showSearch) {
          self.$searchContainer[0].classList.remove('select2-search--hide');
        } else {
          self.$searchContainer[0].classList.add('select2-search--hide');
        }
      }
    });

    container.on('results:focus', function (params) {
      if (params.data._resultId) {
        self.$search.attr('aria-activedescendant', params.data._resultId);
      } else {
        self.$search.removeAttr('aria-activedescendant');
      }
    });
  };

  Search.prototype.handleSearch = function (evt) {
    if (!this._keyUpPrevented) {
      var input = this.$search.val();

      this.trigger('query', {
        term: input
      });
    }

    this._keyUpPrevented = false;
  };

  Search.prototype.showSearch = function (_, params) {
    return true;
  };

  return Search;
});

S2.define('select2/dropdown/hidePlaceholder',[

], function () {
  function HidePlaceholder (decorated, $element, options, dataAdapter) {
    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

    decorated.call(this, $element, options, dataAdapter);
  }

  HidePlaceholder.prototype.append = function (decorated, data) {
    data.results = this.removePlaceholder(data.results);

    decorated.call(this, data);
  };

  HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
    if (typeof placeholder === 'string') {
      placeholder = {
        id: '',
        text: placeholder
      };
    }

    return placeholder;
  };

  HidePlaceholder.prototype.removePlaceholder = function (_, data) {
    var modifiedData = data.slice(0);

    for (var d = data.length - 1; d >= 0; d--) {
      var item = data[d];

      if (this.placeholder.id === item.id) {
        modifiedData.splice(d, 1);
      }
    }

    return modifiedData;
  };

  return HidePlaceholder;
});

S2.define('select2/dropdown/infiniteScroll',[
  'jquery'
], function ($) {
  function InfiniteScroll (decorated, $element, options, dataAdapter) {
    this.lastParams = {};

    decorated.call(this, $element, options, dataAdapter);

    this.$loadingMore = this.createLoadingMore();
    this.loading = false;
  }

  InfiniteScroll.prototype.append = function (decorated, data) {
    this.$loadingMore.remove();
    this.loading = false;

    decorated.call(this, data);

    if (this.showLoadingMore(data)) {
      this.$results.append(this.$loadingMore);
      this.loadMoreIfNeeded();
    }
  };

  InfiniteScroll.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('query', function (params) {
      self.lastParams = params;
      self.loading = true;
    });

    container.on('query:append', function (params) {
      self.lastParams = params;
      self.loading = true;
    });

    this.$results.on('scroll', this.loadMoreIfNeeded.bind(this));
  };

  InfiniteScroll.prototype.loadMoreIfNeeded = function () {
    var isLoadMoreVisible = $.contains(
      document.documentElement,
      this.$loadingMore[0]
    );

    if (this.loading || !isLoadMoreVisible) {
      return;
    }

    var currentOffset = this.$results.offset().top +
      this.$results.outerHeight(false);
    var loadingMoreOffset = this.$loadingMore.offset().top +
      this.$loadingMore.outerHeight(false);

    if (currentOffset + 50 >= loadingMoreOffset) {
      this.loadMore();
    }
  };

  InfiniteScroll.prototype.loadMore = function () {
    this.loading = true;

    var params = $.extend({}, {page: 1}, this.lastParams);

    params.page++;

    this.trigger('query:append', params);
  };

  InfiniteScroll.prototype.showLoadingMore = function (_, data) {
    return data.pagination && data.pagination.more;
  };

  InfiniteScroll.prototype.createLoadingMore = function () {
    var $option = $(
      '<li ' +
      'class="select2-results__option select2-results__option--load-more"' +
      'role="option" aria-disabled="true"></li>'
    );

    var message = this.options.get('translations').get('loadingMore');

    $option.html(message(this.lastParams));

    return $option;
  };

  return InfiniteScroll;
});

S2.define('select2/dropdown/attachBody',[
  'jquery',
  '../utils'
], function ($, Utils) {
  function AttachBody (decorated, $element, options) {
    this.$dropdownParent = $(options.get('dropdownParent') || document.body);

    decorated.call(this, $element, options);
  }

  AttachBody.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('open', function () {
      self._showDropdown();
      self._attachPositioningHandler(container);

      // Must bind after the results handlers to ensure correct sizing
      self._bindContainerResultHandlers(container);
    });

    container.on('close', function () {
      self._hideDropdown();
      self._detachPositioningHandler(container);
    });

    this.$dropdownContainer.on('mousedown', function (evt) {
      evt.stopPropagation();
    });
  };

  AttachBody.prototype.destroy = function (decorated) {
    decorated.call(this);

    this.$dropdownContainer.remove();
  };

  AttachBody.prototype.position = function (decorated, $dropdown, $container) {
    // Clone all of the container classes
    $dropdown.attr('class', $container.attr('class'));

    $dropdown[0].classList.remove('select2');
    $dropdown[0].classList.add('select2-container--open');

    $dropdown.css({
      position: 'absolute',
      top: -999999
    });

    this.$container = $container;
  };

  AttachBody.prototype.render = function (decorated) {
    var $container = $('<span></span>');

    var $dropdown = decorated.call(this);
    $container.append($dropdown);

    this.$dropdownContainer = $container;

    return $container;
  };

  AttachBody.prototype._hideDropdown = function (decorated) {
    this.$dropdownContainer.detach();
  };

  AttachBody.prototype._bindContainerResultHandlers =
      function (decorated, container) {

    // These should only be bound once
    if (this._containerResultsHandlersBound) {
      return;
    }

    var self = this;

    container.on('results:all', function () {
      self._positionDropdown();
      self._resizeDropdown();
    });

    container.on('results:append', function () {
      self._positionDropdown();
      self._resizeDropdown();
    });

    container.on('results:message', function () {
      self._positionDropdown();
      self._resizeDropdown();
    });

    container.on('select', function () {
      self._positionDropdown();
      self._resizeDropdown();
    });

    container.on('unselect', function () {
      self._positionDropdown();
      self._resizeDropdown();
    });

    this._containerResultsHandlersBound = true;
  };

  AttachBody.prototype._attachPositioningHandler =
      function (decorated, container) {
    var self = this;

    var scrollEvent = 'scroll.select2.' + container.id;
    var resizeEvent = 'resize.select2.' + container.id;
    var orientationEvent = 'orientationchange.select2.' + container.id;

    var $watchers = this.$container.parents().filter(Utils.hasScroll);
    $watchers.each(function () {
      Utils.StoreData(this, 'select2-scroll-position', {
        x: $(this).scrollLeft(),
        y: $(this).scrollTop()
      });
    });

    $watchers.on(scrollEvent, function (ev) {
      var position = Utils.GetData(this, 'select2-scroll-position');
      $(this).scrollTop(position.y);
    });

    $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,
      function (e) {
      self._positionDropdown();
      self._resizeDropdown();
    });
  };

  AttachBody.prototype._detachPositioningHandler =
      function (decorated, container) {
    var scrollEvent = 'scroll.select2.' + container.id;
    var resizeEvent = 'resize.select2.' + container.id;
    var orientationEvent = 'orientationchange.select2.' + container.id;

    var $watchers = this.$container.parents().filter(Utils.hasScroll);
    $watchers.off(scrollEvent);

    $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
  };

  AttachBody.prototype._positionDropdown = function () {
    var $window = $(window);

    var isCurrentlyAbove = this.$dropdown[0].classList
      .contains('select2-dropdown--above');
    var isCurrentlyBelow = this.$dropdown[0].classList
      .contains('select2-dropdown--below');

    var newDirection = null;

    var offset = this.$container.offset();

    offset.bottom = offset.top + this.$container.outerHeight(false);

    var container = {
      height: this.$container.outerHeight(false)
    };

    container.top = offset.top;
    container.bottom = offset.top + container.height;

    var dropdown = {
      height: this.$dropdown.outerHeight(false)
    };

    var viewport = {
      top: $window.scrollTop(),
      bottom: $window.scrollTop() + $window.height()
    };

    var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);
    var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);

    var css = {
      left: offset.left,
      top: container.bottom
    };

    // Determine what the parent element is to use for calculating the offset
    var $offsetParent = this.$dropdownParent;

    // For statically positioned elements, we need to get the element
    // that is determining the offset
    if ($offsetParent.css('position') === 'static') {
      $offsetParent = $offsetParent.offsetParent();
    }

    var parentOffset = {
      top: 0,
      left: 0
    };

    if (
      $.contains(document.body, $offsetParent[0]) ||
      $offsetParent[0].isConnected
      ) {
      parentOffset = $offsetParent.offset();
    }

    css.top -= parentOffset.top;
    css.left -= parentOffset.left;

    if (!isCurrentlyAbove && !isCurrentlyBelow) {
      newDirection = 'below';
    }

    if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
      newDirection = 'above';
    } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
      newDirection = 'below';
    }

    if (newDirection == 'above' ||
      (isCurrentlyAbove && newDirection !== 'below')) {
      css.top = container.top - parentOffset.top - dropdown.height;
    }

    if (newDirection != null) {
      this.$dropdown[0].classList.remove('select2-dropdown--below');
      this.$dropdown[0].classList.remove('select2-dropdown--above');
      this.$dropdown[0].classList.add('select2-dropdown--' + newDirection);

      this.$container[0].classList.remove('select2-container--below');
      this.$container[0].classList.remove('select2-container--above');
      this.$container[0].classList.add('select2-container--' + newDirection);
    }

    this.$dropdownContainer.css(css);
  };

  AttachBody.prototype._resizeDropdown = function () {
    var css = {
      width: this.$container.outerWidth(false) + 'px'
    };

    if (this.options.get('dropdownAutoWidth')) {
      css.minWidth = css.width;
      css.position = 'relative';
      css.width = 'auto';
    }

    this.$dropdown.css(css);
  };

  AttachBody.prototype._showDropdown = function (decorated) {
    this.$dropdownContainer.appendTo(this.$dropdownParent);

    this._positionDropdown();
    this._resizeDropdown();
  };

  return AttachBody;
});

S2.define('select2/dropdown/minimumResultsForSearch',[

], function () {
  function countResults (data) {
    var count = 0;

    for (var d = 0; d < data.length; d++) {
      var item = data[d];

      if (item.children) {
        count += countResults(item.children);
      } else {
        count++;
      }
    }

    return count;
  }

  function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {
    this.minimumResultsForSearch = options.get('minimumResultsForSearch');

    if (this.minimumResultsForSearch < 0) {
      this.minimumResultsForSearch = Infinity;
    }

    decorated.call(this, $element, options, dataAdapter);
  }

  MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
    if (countResults(params.data.results) < this.minimumResultsForSearch) {
      return false;
    }

    return decorated.call(this, params);
  };

  return MinimumResultsForSearch;
});

S2.define('select2/dropdown/selectOnClose',[
  '../utils'
], function (Utils) {
  function SelectOnClose () { }

  SelectOnClose.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('close', function (params) {
      self._handleSelectOnClose(params);
    });
  };

  SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
    if (params && params.originalSelect2Event != null) {
      var event = params.originalSelect2Event;

      // Don't select an item if the close event was triggered from a select or
      // unselect event
      if (event._type === 'select' || event._type === 'unselect') {
        return;
      }
    }

    var $highlightedResults = this.getHighlightedResults();

    // Only select highlighted results
    if ($highlightedResults.length < 1) {
      return;
    }

    var data = Utils.GetData($highlightedResults[0], 'data');

    // Don't re-select already selected resulte
    if (
      (data.element != null && data.element.selected) ||
      (data.element == null && data.selected)
    ) {
      return;
    }

    this.trigger('select', {
        data: data
    });
  };

  return SelectOnClose;
});

S2.define('select2/dropdown/closeOnSelect',[

], function () {
  function CloseOnSelect () { }

  CloseOnSelect.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('select', function (evt) {
      self._selectTriggered(evt);
    });

    container.on('unselect', function (evt) {
      self._selectTriggered(evt);
    });
  };

  CloseOnSelect.prototype._selectTriggered = function (_, evt) {
    var originalEvent = evt.originalEvent;

    // Don't close if the control key is being held
    if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {
      return;
    }

    this.trigger('close', {
      originalEvent: originalEvent,
      originalSelect2Event: evt
    });
  };

  return CloseOnSelect;
});

S2.define('select2/dropdown/dropdownCss',[
  '../utils'
], function (Utils) {
  function DropdownCSS () { }

  DropdownCSS.prototype.render = function (decorated) {
    var $dropdown = decorated.call(this);

    var dropdownCssClass = this.options.get('dropdownCssClass') || '';

    if (dropdownCssClass.indexOf(':all:') !== -1) {
      dropdownCssClass = dropdownCssClass.replace(':all:', '');

      Utils.copyNonInternalCssClasses($dropdown[0], this.$element[0]);
    }

    $dropdown.addClass(dropdownCssClass);

    return $dropdown;
  };

  return DropdownCSS;
});

S2.define('select2/dropdown/tagsSearchHighlight',[
  '../utils'
], function (Utils) {
  function TagsSearchHighlight () { }

  TagsSearchHighlight.prototype.highlightFirstItem = function (decorated) {
    var $options = this.$results
    .find(
      '.select2-results__option--selectable' +
      ':not(.select2-results__option--selected)'
    );

    if ($options.length > 0) {
      var $firstOption = $options.first();
      var data = Utils.GetData($firstOption[0], 'data');
      var firstElement = data.element;

      if (firstElement && firstElement.getAttribute) {
        if (firstElement.getAttribute('data-select2-tag') === 'true') {
          $firstOption.trigger('mouseenter');

          return;
        }
      }
    }

    decorated.call(this);
  };

  return TagsSearchHighlight;
});

S2.define('select2/i18n/en',[],function () {
  // English
  return {
    errorLoading: function () {
      return 'The results could not be loaded.';
    },
    inputTooLong: function (args) {
      var overChars = args.input.length - args.maximum;

      var message = 'Please delete ' + overChars + ' character';

      if (overChars != 1) {
        message += 's';
      }

      return message;
    },
    inputTooShort: function (args) {
      var remainingChars = args.minimum - args.input.length;

      var message = 'Please enter ' + remainingChars + ' or more characters';

      return message;
    },
    loadingMore: function () {
      return 'Loading more results…';
    },
    maximumSelected: function (args) {
      var message = 'You can only select ' + args.maximum + ' item';

      if (args.maximum != 1) {
        message += 's';
      }

      return message;
    },
    noResults: function () {
      return 'No results found';
    },
    searching: function () {
      return 'Searching…';
    },
    removeAllItems: function () {
      return 'Remove all items';
    },
    removeItem: function () {
      return 'Remove item';
    },
    search: function() {
      return 'Search';
    }
  };
});

S2.define('select2/defaults',[
  'jquery',

  './results',

  './selection/single',
  './selection/multiple',
  './selection/placeholder',
  './selection/allowClear',
  './selection/search',
  './selection/selectionCss',
  './selection/eventRelay',

  './utils',
  './translation',
  './diacritics',

  './data/select',
  './data/array',
  './data/ajax',
  './data/tags',
  './data/tokenizer',
  './data/minimumInputLength',
  './data/maximumInputLength',
  './data/maximumSelectionLength',

  './dropdown',
  './dropdown/search',
  './dropdown/hidePlaceholder',
  './dropdown/infiniteScroll',
  './dropdown/attachBody',
  './dropdown/minimumResultsForSearch',
  './dropdown/selectOnClose',
  './dropdown/closeOnSelect',
  './dropdown/dropdownCss',
  './dropdown/tagsSearchHighlight',

  './i18n/en'
], function ($,

             ResultsList,

             SingleSelection, MultipleSelection, Placeholder, AllowClear,
             SelectionSearch, SelectionCSS, EventRelay,

             Utils, Translation, DIACRITICS,

             SelectData, ArrayData, AjaxData, Tags, Tokenizer,
             MinimumInputLength, MaximumInputLength, MaximumSelectionLength,

             Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,
             AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,
             DropdownCSS, TagsSearchHighlight,

             EnglishTranslation) {
  function Defaults () {
    this.reset();
  }

  Defaults.prototype.apply = function (options) {
    options = $.extend(true, {}, this.defaults, options);

    if (options.dataAdapter == null) {
      if (options.ajax != null) {
        options.dataAdapter = AjaxData;
      } else if (options.data != null) {
        options.dataAdapter = ArrayData;
      } else {
        options.dataAdapter = SelectData;
      }

      if (options.minimumInputLength > 0) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          MinimumInputLength
        );
      }

      if (options.maximumInputLength > 0) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          MaximumInputLength
        );
      }

      if (options.maximumSelectionLength > 0) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          MaximumSelectionLength
        );
      }

      if (options.tags) {
        options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
      }

      if (options.tokenSeparators != null || options.tokenizer != null) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          Tokenizer
        );
      }
    }

    if (options.resultsAdapter == null) {
      options.resultsAdapter = ResultsList;

      if (options.ajax != null) {
        options.resultsAdapter = Utils.Decorate(
          options.resultsAdapter,
          InfiniteScroll
        );
      }

      if (options.placeholder != null) {
        options.resultsAdapter = Utils.Decorate(
          options.resultsAdapter,
          HidePlaceholder
        );
      }

      if (options.selectOnClose) {
        options.resultsAdapter = Utils.Decorate(
          options.resultsAdapter,
          SelectOnClose
        );
      }

      if (options.tags) {
        options.resultsAdapter = Utils.Decorate(
          options.resultsAdapter,
          TagsSearchHighlight
        );
      }
    }

    if (options.dropdownAdapter == null) {
      if (options.multiple) {
        options.dropdownAdapter = Dropdown;
      } else {
        var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);

        options.dropdownAdapter = SearchableDropdown;
      }

      if (options.minimumResultsForSearch !== 0) {
        options.dropdownAdapter = Utils.Decorate(
          options.dropdownAdapter,
          MinimumResultsForSearch
        );
      }

      if (options.closeOnSelect) {
        options.dropdownAdapter = Utils.Decorate(
          options.dropdownAdapter,
          CloseOnSelect
        );
      }

      if (options.dropdownCssClass != null) {
        options.dropdownAdapter = Utils.Decorate(
          options.dropdownAdapter,
          DropdownCSS
        );
      }

      options.dropdownAdapter = Utils.Decorate(
        options.dropdownAdapter,
        AttachBody
      );
    }

    if (options.selectionAdapter == null) {
      if (options.multiple) {
        options.selectionAdapter = MultipleSelection;
      } else {
        options.selectionAdapter = SingleSelection;
      }

      // Add the placeholder mixin if a placeholder was specified
      if (options.placeholder != null) {
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          Placeholder
        );
      }

      if (options.allowClear) {
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          AllowClear
        );
      }

      if (options.multiple) {
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          SelectionSearch
        );
      }

      if (options.selectionCssClass != null) {
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          SelectionCSS
        );
      }

      options.selectionAdapter = Utils.Decorate(
        options.selectionAdapter,
        EventRelay
      );
    }

    // If the defaults were not previously applied from an element, it is
    // possible for the language option to have not been resolved
    options.language = this._resolveLanguage(options.language);

    // Always fall back to English since it will always be complete
    options.language.push('en');

    var uniqueLanguages = [];

    for (var l = 0; l < options.language.length; l++) {
      var language = options.language[l];

      if (uniqueLanguages.indexOf(language) === -1) {
        uniqueLanguages.push(language);
      }
    }

    options.language = uniqueLanguages;

    options.translations = this._processTranslations(
      options.language,
      options.debug
    );

    return options;
  };

  Defaults.prototype.reset = function () {
    function stripDiacritics (text) {
      // Used 'uni range + named function' from http://jsperf.com/diacritics/18
      function match(a) {
        return DIACRITICS[a] || a;
      }

      return text.replace(/[^\u0000-\u007E]/g, match);
    }

    function matcher (params, data) {
      // Always return the object if there is nothing to compare
      if (params.term == null || params.term.trim() === '') {
        return data;
      }

      // Do a recursive check for options with children
      if (data.children && data.children.length > 0) {
        // Clone the data object if there are children
        // This is required as we modify the object to remove any non-matches
        var match = $.extend(true, {}, data);

        // Check each child of the option
        for (var c = data.children.length - 1; c >= 0; c--) {
          var child = data.children[c];

          var matches = matcher(params, child);

          // If there wasn't a match, remove the object in the array
          if (matches == null) {
            match.children.splice(c, 1);
          }
        }

        // If any children matched, return the new object
        if (match.children.length > 0) {
          return match;
        }

        // If there were no matching children, check just the plain object
        return matcher(params, match);
      }

      var original = stripDiacritics(data.text).toUpperCase();
      var term = stripDiacritics(params.term).toUpperCase();

      // Check if the text contains the term
      if (original.indexOf(term) > -1) {
        return data;
      }

      // If it doesn't contain the term, don't return anything
      return null;
    }

    this.defaults = {
      amdLanguageBase: './i18n/',
      autocomplete: 'off',
      closeOnSelect: true,
      debug: false,
      dropdownAutoWidth: false,
      escapeMarkup: Utils.escapeMarkup,
      language: {},
      matcher: matcher,
      minimumInputLength: 0,
      maximumInputLength: 0,
      maximumSelectionLength: 0,
      minimumResultsForSearch: 0,
      selectOnClose: false,
      scrollAfterSelect: false,
      sorter: function (data) {
        return data;
      },
      templateResult: function (result) {
        return result.text;
      },
      templateSelection: function (selection) {
        return selection.text;
      },
      theme: 'default',
      width: 'resolve'
    };
  };

  Defaults.prototype.applyFromElement = function (options, $element) {
    var optionLanguage = options.language;
    var defaultLanguage = this.defaults.language;
    var elementLanguage = $element.prop('lang');
    var parentLanguage = $element.closest('[lang]').prop('lang');

    var languages = Array.prototype.concat.call(
      this._resolveLanguage(elementLanguage),
      this._resolveLanguage(optionLanguage),
      this._resolveLanguage(defaultLanguage),
      this._resolveLanguage(parentLanguage)
    );

    options.language = languages;

    return options;
  };

  Defaults.prototype._resolveLanguage = function (language) {
    if (!language) {
      return [];
    }

    if ($.isEmptyObject(language)) {
      return [];
    }

    if ($.isPlainObject(language)) {
      return [language];
    }

    var languages;

    if (!Array.isArray(language)) {
      languages = [language];
    } else {
      languages = language;
    }

    var resolvedLanguages = [];

    for (var l = 0; l < languages.length; l++) {
      resolvedLanguages.push(languages[l]);

      if (typeof languages[l] === 'string' && languages[l].indexOf('-') > 0) {
        // Extract the region information if it is included
        var languageParts = languages[l].split('-');
        var baseLanguage = languageParts[0];

        resolvedLanguages.push(baseLanguage);
      }
    }

    return resolvedLanguages;
  };

  Defaults.prototype._processTranslations = function (languages, debug) {
    var translations = new Translation();

    for (var l = 0; l < languages.length; l++) {
      var languageData = new Translation();

      var language = languages[l];

      if (typeof language === 'string') {
        try {
          // Try to load it with the original name
          languageData = Translation.loadPath(language);
        } catch (e) {
          try {
            // If we couldn't load it, check if it wasn't the full path
            language = this.defaults.amdLanguageBase + language;
            languageData = Translation.loadPath(language);
          } catch (ex) {
            // The translation could not be loaded at all. Sometimes this is
            // because of a configuration problem, other times this can be
            // because of how Select2 helps load all possible translation files
            if (debug && window.console && console.warn) {
              console.warn(
                'Select2: The language file for "' + language + '" could ' +
                'not be automatically loaded. A fallback will be used instead.'
              );
            }
          }
        }
      } else if ($.isPlainObject(language)) {
        languageData = new Translation(language);
      } else {
        languageData = language;
      }

      translations.extend(languageData);
    }

    return translations;
  };

  Defaults.prototype.set = function (key, value) {
    var camelKey = $.camelCase(key);

    var data = {};
    data[camelKey] = value;

    var convertedData = Utils._convertData(data);

    $.extend(true, this.defaults, convertedData);
  };

  var defaults = new Defaults();

  return defaults;
});

S2.define('select2/options',[
  'jquery',
  './defaults',
  './utils'
], function ($, Defaults, Utils) {
  function Options (options, $element) {
    this.options = options;

    if ($element != null) {
      this.fromElement($element);
    }

    if ($element != null) {
      this.options = Defaults.applyFromElement(this.options, $element);
    }

    this.options = Defaults.apply(this.options);
  }

  Options.prototype.fromElement = function ($e) {
    var excludedData = ['select2'];

    if (this.options.multiple == null) {
      this.options.multiple = $e.prop('multiple');
    }

    if (this.options.disabled == null) {
      this.options.disabled = $e.prop('disabled');
    }

    if (this.options.autocomplete == null && $e.prop('autocomplete')) {
      this.options.autocomplete = $e.prop('autocomplete');
    }

    if (this.options.dir == null) {
      if ($e.prop('dir')) {
        this.options.dir = $e.prop('dir');
      } else if ($e.closest('[dir]').prop('dir')) {
        this.options.dir = $e.closest('[dir]').prop('dir');
      } else {
        this.options.dir = 'ltr';
      }
    }

    $e.prop('disabled', this.options.disabled);
    $e.prop('multiple', this.options.multiple);

    if (Utils.GetData($e[0], 'select2Tags')) {
      if (this.options.debug && window.console && console.warn) {
        console.warn(
          'Select2: The `data-select2-tags` attribute has been changed to ' +
          'use the `data-data` and `data-tags="true"` attributes and will be ' +
          'removed in future versions of Select2.'
        );
      }

      Utils.StoreData($e[0], 'data', Utils.GetData($e[0], 'select2Tags'));
      Utils.StoreData($e[0], 'tags', true);
    }

    if (Utils.GetData($e[0], 'ajaxUrl')) {
      if (this.options.debug && window.console && console.warn) {
        console.warn(
          'Select2: The `data-ajax-url` attribute has been changed to ' +
          '`data-ajax--url` and support for the old attribute will be removed' +
          ' in future versions of Select2.'
        );
      }

      $e.attr('ajax--url', Utils.GetData($e[0], 'ajaxUrl'));
      Utils.StoreData($e[0], 'ajax-Url', Utils.GetData($e[0], 'ajaxUrl'));
    }

    var dataset = {};

    function upperCaseLetter(_, letter) {
      return letter.toUpperCase();
    }

    // Pre-load all of the attributes which are prefixed with `data-`
    for (var attr = 0; attr < $e[0].attributes.length; attr++) {
      var attributeName = $e[0].attributes[attr].name;
      var prefix = 'data-';

      if (attributeName.substr(0, prefix.length) == prefix) {
        // Get the contents of the attribute after `data-`
        var dataName = attributeName.substring(prefix.length);

        // Get the data contents from the consistent source
        // This is more than likely the jQuery data helper
        var dataValue = Utils.GetData($e[0], dataName);

        // camelCase the attribute name to match the spec
        var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter);

        // Store the data attribute contents into the dataset since
        dataset[camelDataName] = dataValue;
      }
    }

    // Prefer the element's `dataset` attribute if it exists
    // jQuery 1.x does not correctly handle data attributes with multiple dashes
    if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
      dataset = $.extend(true, {}, $e[0].dataset, dataset);
    }

    // Prefer our internal data cache if it exists
    var data = $.extend(true, {}, Utils.GetData($e[0]), dataset);

    data = Utils._convertData(data);

    for (var key in data) {
      if (excludedData.indexOf(key) > -1) {
        continue;
      }

      if ($.isPlainObject(this.options[key])) {
        $.extend(this.options[key], data[key]);
      } else {
        this.options[key] = data[key];
      }
    }

    return this;
  };

  Options.prototype.get = function (key) {
    return this.options[key];
  };

  Options.prototype.set = function (key, val) {
    this.options[key] = val;
  };

  return Options;
});

S2.define('select2/core',[
  'jquery',
  './options',
  './utils',
  './keys'
], function ($, Options, Utils, KEYS) {
  var Select2 = function ($element, options) {
    if (Utils.GetData($element[0], 'select2') != null) {
      Utils.GetData($element[0], 'select2').destroy();
    }

    this.$element = $element;

    this.id = this._generateId($element);

    options = options || {};

    this.options = new Options(options, $element);

    Select2.__super__.constructor.call(this);

    // Set up the tabindex

    var tabindex = $element.attr('tabindex') || 0;
    Utils.StoreData($element[0], 'old-tabindex', tabindex);
    $element.attr('tabindex', '-1');

    // Set up containers and adapters

    var DataAdapter = this.options.get('dataAdapter');
    this.dataAdapter = new DataAdapter($element, this.options);

    var $container = this.render();

    this._placeContainer($container);

    var SelectionAdapter = this.options.get('selectionAdapter');
    this.selection = new SelectionAdapter($element, this.options);
    this.$selection = this.selection.render();

    this.selection.position(this.$selection, $container);

    var DropdownAdapter = this.options.get('dropdownAdapter');
    this.dropdown = new DropdownAdapter($element, this.options);
    this.$dropdown = this.dropdown.render();

    this.dropdown.position(this.$dropdown, $container);

    var ResultsAdapter = this.options.get('resultsAdapter');
    this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
    this.$results = this.results.render();

    this.results.position(this.$results, this.$dropdown);

    // Bind events

    var self = this;

    // Bind the container to all of the adapters
    this._bindAdapters();

    // Register any DOM event handlers
    this._registerDomEvents();

    // Register any internal event handlers
    this._registerDataEvents();
    this._registerSelectionEvents();
    this._registerDropdownEvents();
    this._registerResultsEvents();
    this._registerEvents();

    // Set the initial state
    this.dataAdapter.current(function (initialData) {
      self.trigger('selection:update', {
        data: initialData
      });
    });

    // Hide the original select
    $element[0].classList.add('select2-hidden-accessible');
    $element.attr('aria-hidden', 'true');

    // Synchronize any monitored attributes
    this._syncAttributes();

    Utils.StoreData($element[0], 'select2', this);

    // Ensure backwards compatibility with $element.data('select2').
    $element.data('select2', this);
  };

  Utils.Extend(Select2, Utils.Observable);

  Select2.prototype._generateId = function ($element) {
    var id = '';

    if ($element.attr('id') != null) {
      id = $element.attr('id');
    } else if ($element.attr('name') != null) {
      id = $element.attr('name') + '-' + Utils.generateChars(2);
    } else {
      id = Utils.generateChars(4);
    }

    id = id.replace(/(:|\.|\[|\]|,)/g, '');
    id = 'select2-' + id;

    return id;
  };

  Select2.prototype._placeContainer = function ($container) {
    $container.insertAfter(this.$element);

    var width = this._resolveWidth(this.$element, this.options.get('width'));

    if (width != null) {
      $container.css('width', width);
    }
  };

  Select2.prototype._resolveWidth = function ($element, method) {
    var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;

    if (method == 'resolve') {
      var styleWidth = this._resolveWidth($element, 'style');

      if (styleWidth != null) {
        return styleWidth;
      }

      return this._resolveWidth($element, 'element');
    }

    if (method == 'element') {
      var elementWidth = $element.outerWidth(false);

      if (elementWidth <= 0) {
        return 'auto';
      }

      return elementWidth + 'px';
    }

    if (method == 'style') {
      var style = $element.attr('style');

      if (typeof(style) !== 'string') {
        return null;
      }

      var attrs = style.split(';');

      for (var i = 0, l = attrs.length; i < l; i = i + 1) {
        var attr = attrs[i].replace(/\s/g, '');
        var matches = attr.match(WIDTH);

        if (matches !== null && matches.length >= 1) {
          return matches[1];
        }
      }

      return null;
    }

    if (method == 'computedstyle') {
      var computedStyle = window.getComputedStyle($element[0]);

      return computedStyle.width;
    }

    return method;
  };

  Select2.prototype._bindAdapters = function () {
    this.dataAdapter.bind(this, this.$container);
    this.selection.bind(this, this.$container);

    this.dropdown.bind(this, this.$container);
    this.results.bind(this, this.$container);
  };

  Select2.prototype._registerDomEvents = function () {
    var self = this;

    this.$element.on('change.select2', function () {
      self.dataAdapter.current(function (data) {
        self.trigger('selection:update', {
          data: data
        });
      });
    });

    this.$element.on('focus.select2', function (evt) {
      self.trigger('focus', evt);
    });

    this._syncA = Utils.bind(this._syncAttributes, this);
    this._syncS = Utils.bind(this._syncSubtree, this);

    this._observer = new window.MutationObserver(function (mutations) {
      self._syncA();
      self._syncS(mutations);
    });
    this._observer.observe(this.$element[0], {
      attributes: true,
      childList: true,
      subtree: false
    });
  };

  Select2.prototype._registerDataEvents = function () {
    var self = this;

    this.dataAdapter.on('*', function (name, params) {
      self.trigger(name, params);
    });
  };

  Select2.prototype._registerSelectionEvents = function () {
    var self = this;
    var nonRelayEvents = ['toggle', 'focus'];

    this.selection.on('toggle', function () {
      self.toggleDropdown();
    });

    this.selection.on('focus', function (params) {
      self.focus(params);
    });

    this.selection.on('*', function (name, params) {
      if (nonRelayEvents.indexOf(name) !== -1) {
        return;
      }

      self.trigger(name, params);
    });
  };

  Select2.prototype._registerDropdownEvents = function () {
    var self = this;

    this.dropdown.on('*', function (name, params) {
      self.trigger(name, params);
    });
  };

  Select2.prototype._registerResultsEvents = function () {
    var self = this;

    this.results.on('*', function (name, params) {
      self.trigger(name, params);
    });
  };

  Select2.prototype._registerEvents = function () {
    var self = this;

    this.on('open', function () {
      self.$container[0].classList.add('select2-container--open');
    });

    this.on('close', function () {
      self.$container[0].classList.remove('select2-container--open');
    });

    this.on('enable', function () {
      self.$container[0].classList.remove('select2-container--disabled');
    });

    this.on('disable', function () {
      self.$container[0].classList.add('select2-container--disabled');
    });

    this.on('blur', function () {
      self.$container[0].classList.remove('select2-container--focus');
    });

    this.on('query', function (params) {
      if (!self.isOpen()) {
        self.trigger('open', {});
      }

      this.dataAdapter.query(params, function (data) {
        self.trigger('results:all', {
          data: data,
          query: params
        });
      });
    });

    this.on('query:append', function (params) {
      this.dataAdapter.query(params, function (data) {
        self.trigger('results:append', {
          data: data,
          query: params
        });
      });
    });

    this.on('keypress', function (evt) {
      var key = evt.which;

      if (self.isOpen()) {
        if (key === KEYS.ESC || (key === KEYS.UP && evt.altKey)) {
          self.close(evt);

          evt.preventDefault();
        } else if (key === KEYS.ENTER || key === KEYS.TAB) {
          self.trigger('results:select', {});

          evt.preventDefault();
        } else if ((key === KEYS.SPACE && evt.ctrlKey)) {
          self.trigger('results:toggle', {});

          evt.preventDefault();
        } else if (key === KEYS.UP) {
          self.trigger('results:previous', {});

          evt.preventDefault();
        } else if (key === KEYS.DOWN) {
          self.trigger('results:next', {});

          evt.preventDefault();
        }
      } else {
        if (key === KEYS.ENTER || key === KEYS.SPACE ||
            (key === KEYS.DOWN && evt.altKey)) {
          self.open();

          evt.preventDefault();
        }
      }
    });
  };

  Select2.prototype._syncAttributes = function () {
    this.options.set('disabled', this.$element.prop('disabled'));

    if (this.isDisabled()) {
      if (this.isOpen()) {
        this.close();
      }

      this.trigger('disable', {});
    } else {
      this.trigger('enable', {});
    }
  };

  Select2.prototype._isChangeMutation = function (mutations) {
    var self = this;

    if (mutations.addedNodes && mutations.addedNodes.length > 0) {
      for (var n = 0; n < mutations.addedNodes.length; n++) {
        var node = mutations.addedNodes[n];

        if (node.selected) {
          return true;
        }
      }
    } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
      return true;
    } else if (Array.isArray(mutations)) {
      return mutations.some(function (mutation) {
        return self._isChangeMutation(mutation);
      });
    }

    return false;
  };

  Select2.prototype._syncSubtree = function (mutations) {
    var changed = this._isChangeMutation(mutations);
    var self = this;

    // Only re-pull the data if we think there is a change
    if (changed) {
      this.dataAdapter.current(function (currentData) {
        self.trigger('selection:update', {
          data: currentData
        });
      });
    }
  };

  /**
   * Override the trigger method to automatically trigger pre-events when
   * there are events that can be prevented.
   */
  Select2.prototype.trigger = function (name, args) {
    var actualTrigger = Select2.__super__.trigger;
    var preTriggerMap = {
      'open': 'opening',
      'close': 'closing',
      'select': 'selecting',
      'unselect': 'unselecting',
      'clear': 'clearing'
    };

    if (args === undefined) {
      args = {};
    }

    if (name in preTriggerMap) {
      var preTriggerName = preTriggerMap[name];
      var preTriggerArgs = {
        prevented: false,
        name: name,
        args: args
      };

      actualTrigger.call(this, preTriggerName, preTriggerArgs);

      if (preTriggerArgs.prevented) {
        args.prevented = true;

        return;
      }
    }

    actualTrigger.call(this, name, args);
  };

  Select2.prototype.toggleDropdown = function () {
    if (this.isDisabled()) {
      return;
    }

    if (this.isOpen()) {
      this.close();
    } else {
      this.open();
    }
  };

  Select2.prototype.open = function () {
    if (this.isOpen()) {
      return;
    }

    if (this.isDisabled()) {
      return;
    }

    this.trigger('query', {});
  };

  Select2.prototype.close = function (evt) {
    if (!this.isOpen()) {
      return;
    }

    this.trigger('close', { originalEvent : evt });
  };

  /**
   * Helper method to abstract the "enabled" (not "disabled") state of this
   * object.
   *
   * @return {true} if the instance is not disabled.
   * @return {false} if the instance is disabled.
   */
  Select2.prototype.isEnabled = function () {
    return !this.isDisabled();
  };

  /**
   * Helper method to abstract the "disabled" state of this object.
   *
   * @return {true} if the disabled option is true.
   * @return {false} if the disabled option is false.
   */
  Select2.prototype.isDisabled = function () {
    return this.options.get('disabled');
  };

  Select2.prototype.isOpen = function () {
    return this.$container[0].classList.contains('select2-container--open');
  };

  Select2.prototype.hasFocus = function () {
    return this.$container[0].classList.contains('select2-container--focus');
  };

  Select2.prototype.focus = function (data) {
    // No need to re-trigger focus events if we are already focused
    if (this.hasFocus()) {
      return;
    }

    this.$container[0].classList.add('select2-container--focus');
    this.trigger('focus', {});
  };

  Select2.prototype.enable = function (args) {
    if (this.options.get('debug') && window.console && console.warn) {
      console.warn(
        'Select2: The `select2("enable")` method has been deprecated and will' +
        ' be removed in later Select2 versions. Use $element.prop("disabled")' +
        ' instead.'
      );
    }

    if (args == null || args.length === 0) {
      args = [true];
    }

    var disabled = !args[0];

    this.$element.prop('disabled', disabled);
  };

  Select2.prototype.data = function () {
    if (this.options.get('debug') &&
        arguments.length > 0 && window.console && console.warn) {
      console.warn(
        'Select2: Data can no longer be set using `select2("data")`. You ' +
        'should consider setting the value instead using `$element.val()`.'
      );
    }

    var data = [];

    this.dataAdapter.current(function (currentData) {
      data = currentData;
    });

    return data;
  };

  Select2.prototype.val = function (args) {
    if (this.options.get('debug') && window.console && console.warn) {
      console.warn(
        'Select2: The `select2("val")` method has been deprecated and will be' +
        ' removed in later Select2 versions. Use $element.val() instead.'
      );
    }

    if (args == null || args.length === 0) {
      return this.$element.val();
    }

    var newVal = args[0];

    if (Array.isArray(newVal)) {
      newVal = newVal.map(function (obj) {
        return obj.toString();
      });
    }

    this.$element.val(newVal).trigger('input').trigger('change');
  };

  Select2.prototype.destroy = function () {
    Utils.RemoveData(this.$container[0]);
    this.$container.remove();

    this._observer.disconnect();
    this._observer = null;

    this._syncA = null;
    this._syncS = null;

    this.$element.off('.select2');
    this.$element.attr('tabindex',
    Utils.GetData(this.$element[0], 'old-tabindex'));

    this.$element[0].classList.remove('select2-hidden-accessible');
    this.$element.attr('aria-hidden', 'false');
    Utils.RemoveData(this.$element[0]);
    this.$element.removeData('select2');

    this.dataAdapter.destroy();
    this.selection.destroy();
    this.dropdown.destroy();
    this.results.destroy();

    this.dataAdapter = null;
    this.selection = null;
    this.dropdown = null;
    this.results = null;
  };

  Select2.prototype.render = function () {
    var $container = $(
      '<span class="select2 select2-container">' +
        '<span class="selection"></span>' +
        '<span class="dropdown-wrapper" aria-hidden="true"></span>' +
      '</span>'
    );

    $container.attr('dir', this.options.get('dir'));

    this.$container = $container;

    this.$container[0].classList
      .add('select2-container--' + this.options.get('theme'));

    Utils.StoreData($container[0], 'element', this.$element);

    return $container;
  };

  return Select2;
});

S2.define('jquery-mousewheel',[
  'jquery'
], function ($) {
  // Used to shim jQuery.mousewheel for non-full builds.
  return $;
});

S2.define('jquery.select2',[
  'jquery',
  'jquery-mousewheel',

  './select2/core',
  './select2/defaults',
  './select2/utils'
], function ($, _, Select2, Defaults, Utils) {
  if ($.fn.select2 == null) {
    // All methods that should return the element
    var thisMethods = ['open', 'close', 'destroy'];

    $.fn.select2 = function (options) {
      options = options || {};

      if (typeof options === 'object') {
        this.each(function () {
          var instanceOptions = $.extend(true, {}, options);

          var instance = new Select2($(this), instanceOptions);
        });

        return this;
      } else if (typeof options === 'string') {
        var ret;
        var args = Array.prototype.slice.call(arguments, 1);

        this.each(function () {
          var instance = Utils.GetData(this, 'select2');

          if (instance == null && window.console && console.error) {
            console.error(
              'The select2(\'' + options + '\') method was called on an ' +
              'element that is not using Select2.'
            );
          }

          ret = instance[options].apply(instance, args);
        });

        // Check if we should be returning `this`
        if (thisMethods.indexOf(options) > -1) {
          return this;
        }

        return ret;
      } else {
        throw new Error('Invalid arguments for Select2: ' + options);
      }
    };
  }

  if ($.fn.select2.defaults == null) {
    $.fn.select2.defaults = Defaults;
  }

  return Select2;
});

  // Return the AMD loader configuration so it can be used outside of this file
  return {
    define: S2.define,
    require: S2.require
  };
}());

  // Autoload the jQuery bindings
  // We know that all of the modules exist above this, so we're safe
  var select2 = S2.require('jquery.select2');

  // Hold the AMD module references on the jQuery function that was just loaded
  // This allows Select2 to use the internal loader outside of this file, such
  // as in the language files.
  jQuery.fn.select2.amd = S2;

  // Return the Select2 instance for anyone who is importing it.
  return select2;
}));


/***/ }),

/***/ "./node_modules/core-js/internals/a-callable.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-callable.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-constructor.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/a-constructor.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");

var $TypeError = TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a constructor');
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-possible-prototype.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw new $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-instance.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/an-instance.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw new $TypeError('Incorrect invocation');
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-method-has-species-support.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-slice.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/array-slice.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = uncurryThis([].slice);


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-constructor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-constructor.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-create.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var arraySpeciesConstructor = __webpack_require__(/*! ../internals/array-species-constructor */ "./node_modules/core-js/internals/array-species-constructor.js");

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/check-correctness-of-iteration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  try {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  } catch (error) { return false; } // workaround of old WebKit + `eval` bug
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/create-property.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in-accessor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in-accessor.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-global-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/define-global-property.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/document-all.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/document-all.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";

var documentAll = typeof document == 'object' && document.all;

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
var IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;

module.exports = {
  all: documentAll,
  IS_HTMLDDA: IS_HTMLDDA
};


/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/internals/does-not-exceed-safe-integer.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/does-not-exceed-safe-integer.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";

var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/engine-is-browser.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-browser.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IS_DENO = __webpack_require__(/*! ../internals/engine-is-deno */ "./node_modules/core-js/internals/engine-is-deno.js");
var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ "./node_modules/core-js/internals/engine-is-node.js");

module.exports = !IS_DENO && !IS_NODE
  && typeof window == 'object'
  && typeof document == 'object';


/***/ }),

/***/ "./node_modules/core-js/internals/engine-is-deno.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-deno.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";

/* global Deno -- Deno case */
module.exports = typeof Deno == 'object' && Deno && typeof Deno.version == 'object';


/***/ }),

/***/ "./node_modules/core-js/internals/engine-is-ios-pebble.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-ios-pebble.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");

module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != 'undefined';


/***/ }),

/***/ "./node_modules/core-js/internals/engine-is-ios.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-ios.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");

// eslint-disable-next-line redos/no-vulnerable -- safe
module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);


/***/ }),

/***/ "./node_modules/core-js/internals/engine-is-node.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-node.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

module.exports = classof(global.process) === 'process';


/***/ }),

/***/ "./node_modules/core-js/internals/engine-is-webos-webkit.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-is-webos-webkit.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");

module.exports = /web0s(?!.*chrome)/i.test(userAgent);


/***/ }),

/***/ "./node_modules/core-js/internals/engine-user-agent.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";

module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';


/***/ }),

/***/ "./node_modules/core-js/internals/engine-v8-version.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-apply.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/function-apply.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-context.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js/internals/function-uncurry-this-clause.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-native.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-native.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-call.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-call.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-name.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-name.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this-accessor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this-accessor.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this-clause.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this-clause.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator-method.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

var $TypeError = TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw new $TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-method.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/get-method.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ "./node_modules/core-js/internals/has-own-property.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/has-own-property.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/host-report-errors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/host-report-errors.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";

module.exports = function (a, b) {
  try {
    // eslint-disable-next-line no-console -- safe
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ "./node_modules/core-js/internals/inspect-source.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js/internals/weak-map-basic-detection.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array-iterator-method.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-callable.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/is-callable.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $documentAll = __webpack_require__(/*! ../internals/document-all */ "./node_modules/core-js/internals/document-all.js");

var documentAll = $documentAll.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = $documentAll.IS_HTMLDDA ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-constructor.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/is-constructor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.test(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js/internals/is-null-or-undefined.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/is-null-or-undefined.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var $documentAll = __webpack_require__(/*! ../internals/document-all */ "./node_modules/core-js/internals/document-all.js");

var documentAll = $documentAll.all;

module.exports = $documentAll.IS_HTMLDDA ? function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;
} : function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/internals/is-symbol.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-symbol.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterate.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/iterate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");

var $TypeError = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw new $TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-close.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-close.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/length-of-array-like.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/length-of-array-like.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/make-built-in.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/make-built-in.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js").CONFIGURABLE);
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ "./node_modules/core-js/internals/math-trunc.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/math-trunc.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ "./node_modules/core-js/internals/microtask.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/microtask.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var macrotask = (__webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js").set);
var Queue = __webpack_require__(/*! ../internals/queue */ "./node_modules/core-js/internals/queue.js");
var IS_IOS = __webpack_require__(/*! ../internals/engine-is-ios */ "./node_modules/core-js/internals/engine-is-ios.js");
var IS_IOS_PEBBLE = __webpack_require__(/*! ../internals/engine-is-ios-pebble */ "./node_modules/core-js/internals/engine-is-ios-pebble.js");
var IS_WEBOS_WEBKIT = __webpack_require__(/*! ../internals/engine-is-webos-webkit */ "./node_modules/core-js/internals/engine-is-webos-webkit.js");
var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ "./node_modules/core-js/internals/engine-is-node.js");

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var microtask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!microtask) {
  var queue = new Queue();

  var flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (fn = queue.get()) try {
      fn();
    } catch (error) {
      if (queue.head) notify();
      throw error;
    }
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    // workaround of WebKit ~ iOS Safari 10.1 bug
    promise.constructor = Promise;
    then = bind(promise.then, promise);
    notify = function () {
      then(flush);
    };
  // Node.js without promises
  } else if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessage
  // - onreadystatechange
  // - setTimeout
  } else {
    // `webpack` dev server bug on IE global methods - use bind(fn, global)
    macrotask = bind(macrotask, global);
    notify = function () {
      macrotask(flush);
    };
  }

  microtask = function (fn) {
    if (!queue.head) notify();
    queue.add(fn);
  };
}

module.exports = microtask;


/***/ }),

/***/ "./node_modules/core-js/internals/new-promise-capability.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/new-promise-capability.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");

var $TypeError = TypeError;

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw new $TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aCallable(resolve);
  this.reject = aCallable(reject);
};

// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/internals/object-is-prototype-of.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-is-prototype-of.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var indexOf = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(/*! ../internals/function-uncurry-this-accessor */ "./node_modules/core-js/internals/function-uncurry-this-accessor.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "./node_modules/core-js/internals/object-to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-string.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ "./node_modules/core-js/internals/ordinary-to-primitive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/internals/perform.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/perform.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/promise-constructor-detection.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/promise-constructor-detection.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var NativePromiseConstructor = __webpack_require__(/*! ../internals/promise-native-constructor */ "./node_modules/core-js/internals/promise-native-constructor.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IS_BROWSER = __webpack_require__(/*! ../internals/engine-is-browser */ "./node_modules/core-js/internals/engine-is-browser.js");
var IS_DENO = __webpack_require__(/*! ../internals/engine-is-deno */ "./node_modules/core-js/internals/engine-is-deno.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var SPECIES = wellKnownSymbol('species');
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global.PromiseRejectionEvent);

var FORCED_PROMISE_CONSTRUCTOR = isForced('Promise', function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
  // We can't detect it synchronously, so just check versions
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
  // We need Promise#{ catch, finally } in the pure version for preventing prototype pollution
  if (IS_PURE && !(NativePromisePrototype['catch'] && NativePromisePrototype['finally'])) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
    // Detect correctness of subclassing with @@species support
    var promise = new NativePromiseConstructor(function (resolve) { resolve(1); });
    var FakePromise = function (exec) {
      exec(function () { /* empty */ }, function () { /* empty */ });
    };
    var constructor = promise.constructor = {};
    constructor[SPECIES] = FakePromise;
    SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
    if (!SUBCLASSING) return true;
  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  } return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT;
});

module.exports = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
  SUBCLASSING: SUBCLASSING
};


/***/ }),

/***/ "./node_modules/core-js/internals/promise-native-constructor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/promise-native-constructor.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = global.Promise;


/***/ }),

/***/ "./node_modules/core-js/internals/promise-resolve.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/promise-resolve.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var newPromiseCapability = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "./node_modules/core-js/internals/promise-statics-incorrect-iteration.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js/internals/promise-statics-incorrect-iteration.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NativePromiseConstructor = __webpack_require__(/*! ../internals/promise-native-constructor */ "./node_modules/core-js/internals/promise-native-constructor.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");
var FORCED_PROMISE_CONSTRUCTOR = (__webpack_require__(/*! ../internals/promise-constructor-detection */ "./node_modules/core-js/internals/promise-constructor-detection.js").CONSTRUCTOR);

module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function (iterable) {
  NativePromiseConstructor.all(iterable).then(undefined, function () { /* empty */ });
});


/***/ }),

/***/ "./node_modules/core-js/internals/queue.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/queue.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";

var Queue = function () {
  this.head = null;
  this.tail = null;
};

Queue.prototype = {
  add: function (item) {
    var entry = { item: item, next: null };
    var tail = this.tail;
    if (tail) tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      var next = this.head = entry.next;
      if (next === null) this.tail = null;
      return entry.item;
    }
  }
};

module.exports = Queue;


/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-species.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/set-species.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineBuiltInAccessor(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn(target, TO_STRING_TAG)) {
    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-store.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.34.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.34.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ "./node_modules/core-js/internals/species-constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/species-constructor.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var aConstructor = __webpack_require__(/*! ../internals/a-constructor */ "./node_modules/core-js/internals/a-constructor.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
};


/***/ }),

/***/ "./node_modules/core-js/internals/symbol-constructor-detection.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/symbol-constructor-detection.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var $String = global.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ "./node_modules/core-js/internals/task.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/task.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var validateArgumentsLength = __webpack_require__(/*! ../internals/validate-arguments-length */ "./node_modules/core-js/internals/validate-arguments-length.js");
var IS_IOS = __webpack_require__(/*! ../internals/engine-is-ios */ "./node_modules/core-js/internals/engine-is-ios.js");
var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ "./node_modules/core-js/internals/engine-is-node.js");

var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var Dispatch = global.Dispatch;
var Function = global.Function;
var MessageChannel = global.MessageChannel;
var String = global.String;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var $location, defer, channel, port;

fails(function () {
  // Deno throws a ReferenceError on `location` access without `--location` flag
  $location = global.location;
});

var run = function (id) {
  if (hasOwn(queue, id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var eventListener = function (event) {
  run(event.data);
};

var globalPostMessageDefer = function (id) {
  // old engines have not location.origin
  global.postMessage(String(id), $location.protocol + '//' + $location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable(handler) ? handler : Function(handler);
    var args = arraySlice(arguments, 1);
    queue[++counter] = function () {
      apply(fn, undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (IS_NODE) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = eventListener;
    defer = bind(port.postMessage, port);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global.addEventListener &&
    isCallable(global.postMessage) &&
    !global.importScripts &&
    $location && $location.protocol !== 'file:' &&
    !fails(globalPostMessageDefer)
  ) {
    defer = globalPostMessageDefer;
    global.addEventListener('message', eventListener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-integer-or-infinity.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer-or-infinity.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var trunc = __webpack_require__(/*! ../internals/math-trunc */ "./node_modules/core-js/internals/math-trunc.js");

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-property-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/to-property-key.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-string-tag-support.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "./node_modules/core-js/internals/try-to-string.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/try-to-string.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "./node_modules/core-js/internals/v8-prototype-define-bug.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/v8-prototype-define-bug.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ "./node_modules/core-js/internals/validate-arguments-length.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/validate-arguments-length.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";

var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw new $TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ "./node_modules/core-js/internals/weak-map-basic-detection.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/weak-map-basic-detection.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.concat.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.concat.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var doesNotExceedSafeInteger = __webpack_require__(/*! ../internals/does-not-exceed-safe-integer */ "./node_modules/core-js/internals/does-not-exceed-safe-integer.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js");

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.promise.all.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.all.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");
var perform = __webpack_require__(/*! ../internals/perform */ "./node_modules/core-js/internals/perform.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var PROMISE_STATICS_INCORRECT_ITERATION = __webpack_require__(/*! ../internals/promise-statics-incorrect-iteration */ "./node_modules/core-js/internals/promise-statics-incorrect-iteration.js");

// `Promise.all` method
// https://tc39.es/ecma262/#sec-promise.all
$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call($promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.promise.catch.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.catch.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var FORCED_PROMISE_CONSTRUCTOR = (__webpack_require__(/*! ../internals/promise-constructor-detection */ "./node_modules/core-js/internals/promise-constructor-detection.js").CONSTRUCTOR);
var NativePromiseConstructor = __webpack_require__(/*! ../internals/promise-native-constructor */ "./node_modules/core-js/internals/promise-native-constructor.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

// `Promise.prototype.catch` method
// https://tc39.es/ecma262/#sec-promise.prototype.catch
$({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
  'catch': function (onRejected) {
    return this.then(undefined, onRejected);
  }
});

// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
if (!IS_PURE && isCallable(NativePromiseConstructor)) {
  var method = getBuiltIn('Promise').prototype['catch'];
  if (NativePromisePrototype['catch'] !== method) {
    defineBuiltIn(NativePromisePrototype, 'catch', method, { unsafe: true });
  }
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.promise.constructor.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.constructor.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var IS_NODE = __webpack_require__(/*! ../internals/engine-is-node */ "./node_modules/core-js/internals/engine-is-node.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var task = (__webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js").set);
var microtask = __webpack_require__(/*! ../internals/microtask */ "./node_modules/core-js/internals/microtask.js");
var hostReportErrors = __webpack_require__(/*! ../internals/host-report-errors */ "./node_modules/core-js/internals/host-report-errors.js");
var perform = __webpack_require__(/*! ../internals/perform */ "./node_modules/core-js/internals/perform.js");
var Queue = __webpack_require__(/*! ../internals/queue */ "./node_modules/core-js/internals/queue.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var NativePromiseConstructor = __webpack_require__(/*! ../internals/promise-native-constructor */ "./node_modules/core-js/internals/promise-native-constructor.js");
var PromiseConstructorDetection = __webpack_require__(/*! ../internals/promise-constructor-detection */ "./node_modules/core-js/internals/promise-constructor-detection.js");
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");

var PROMISE = 'Promise';
var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var setInternalState = InternalStateModule.set;
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var PromiseConstructor = NativePromiseConstructor;
var PromisePrototype = NativePromisePrototype;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;

var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;

var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && isCallable(then = it.then) ? then : false;
};

var callReaction = function (reaction, state) {
  var value = state.value;
  var ok = state.state === FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve = reaction.resolve;
  var reject = reaction.reject;
  var domain = reaction.domain;
  var result, then, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value); // can throw
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject(new TypeError('Promise-chain cycle'));
      } else if (then = isThenable(result)) {
        call(then, result, resolve, reject);
      } else resolve(result);
    } else reject(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject(error);
  }
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask(function () {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  call(task, global, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  call(task, global, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw new TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          call(then, value,
            bind(internalResolve, wrapper, state),
            bind(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED_PROMISE_CONSTRUCTOR) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromisePrototype);
    aCallable(executor);
    call(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };

  PromisePrototype = PromiseConstructor.prototype;

  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };

  // `Promise.prototype.then` method
  // https://tc39.es/ecma262/#sec-promise.prototype.then
  Internal.prototype = defineBuiltIn(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable(onRejected) && onRejected;
    reaction.domain = IS_NODE ? process.domain : undefined;
    if (state.state === PENDING) state.reactions.add(reaction);
    else microtask(function () {
      callReaction(reaction, state);
    });
    return reaction.promise;
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalPromiseState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
    nativeThen = NativePromisePrototype.then;

    if (!NATIVE_PROMISE_SUBCLASSING) {
      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
      defineBuiltIn(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          call(nativeThen, that, resolve, reject);
        }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
      }, { unsafe: true });
    }

    // make `.constructor === Promise` work for native promise-based APIs
    try {
      delete NativePromisePrototype.constructor;
    } catch (error) { /* empty */ }

    // make `instanceof Promise` work for native promise-based APIs
    if (setPrototypeOf) {
      setPrototypeOf(NativePromisePrototype, PromisePrototype);
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);


/***/ }),

/***/ "./node_modules/core-js/modules/es.promise.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(/*! ../modules/es.promise.constructor */ "./node_modules/core-js/modules/es.promise.constructor.js");
__webpack_require__(/*! ../modules/es.promise.all */ "./node_modules/core-js/modules/es.promise.all.js");
__webpack_require__(/*! ../modules/es.promise.catch */ "./node_modules/core-js/modules/es.promise.catch.js");
__webpack_require__(/*! ../modules/es.promise.race */ "./node_modules/core-js/modules/es.promise.race.js");
__webpack_require__(/*! ../modules/es.promise.reject */ "./node_modules/core-js/modules/es.promise.reject.js");
__webpack_require__(/*! ../modules/es.promise.resolve */ "./node_modules/core-js/modules/es.promise.resolve.js");


/***/ }),

/***/ "./node_modules/core-js/modules/es.promise.race.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.race.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");
var perform = __webpack_require__(/*! ../internals/perform */ "./node_modules/core-js/internals/perform.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var PROMISE_STATICS_INCORRECT_ITERATION = __webpack_require__(/*! ../internals/promise-statics-incorrect-iteration */ "./node_modules/core-js/internals/promise-statics-incorrect-iteration.js");

// `Promise.race` method
// https://tc39.es/ecma262/#sec-promise.race
$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      iterate(iterable, function (promise) {
        call($promiseResolve, C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.promise.reject.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.reject.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");
var FORCED_PROMISE_CONSTRUCTOR = (__webpack_require__(/*! ../internals/promise-constructor-detection */ "./node_modules/core-js/internals/promise-constructor-detection.js").CONSTRUCTOR);

// `Promise.reject` method
// https://tc39.es/ecma262/#sec-promise.reject
$({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  reject: function reject(r) {
    var capability = newPromiseCapabilityModule.f(this);
    call(capability.reject, undefined, r);
    return capability.promise;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.promise.resolve.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.resolve.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var NativePromiseConstructor = __webpack_require__(/*! ../internals/promise-native-constructor */ "./node_modules/core-js/internals/promise-native-constructor.js");
var FORCED_PROMISE_CONSTRUCTOR = (__webpack_require__(/*! ../internals/promise-constructor-detection */ "./node_modules/core-js/internals/promise-constructor-detection.js").CONSTRUCTOR);
var promiseResolve = __webpack_require__(/*! ../internals/promise-resolve */ "./node_modules/core-js/internals/promise-resolve.js");

var PromiseConstructorWrapper = getBuiltIn('Promise');
var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;

// `Promise.resolve` method
// https://tc39.es/ecma262/#sec-promise.resolve
$({ target: 'Promise', stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
  resolve: function resolve(x) {
    return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
  }
});


/***/ }),

/***/ "./node_modules/tw-elements/dist/js/tw-elements.es.min.js":
/*!****************************************************************!*\
  !*** ./node_modules/tw-elements/dist/js/tw-elements.es.min.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alert: () => (/* binding */ Ko),
/* harmony export */   Animate: () => (/* binding */ wr),
/* harmony export */   Autocomplete: () => (/* binding */ id),
/* harmony export */   Button: () => (/* binding */ kc),
/* harmony export */   Carousel: () => (/* binding */ Xt),
/* harmony export */   Chart: () => (/* binding */ Lh),
/* harmony export */   Chip: () => (/* binding */ vi),
/* harmony export */   ChipsInput: () => (/* binding */ XA),
/* harmony export */   Clipboard: () => (/* binding */ Uh),
/* harmony export */   Collapse: () => (/* binding */ Qt),
/* harmony export */   Datatable: () => (/* binding */ Hh),
/* harmony export */   Datepicker: () => (/* binding */ og),
/* harmony export */   Datetimepicker: () => (/* binding */ Qh),
/* harmony export */   Dropdown: () => (/* binding */ $t),
/* harmony export */   InfiniteScroll: () => (/* binding */ Xh),
/* harmony export */   Input: () => (/* binding */ V),
/* harmony export */   LazyLoad: () => (/* binding */ or),
/* harmony export */   Lightbox: () => (/* binding */ nn),
/* harmony export */   LoadingManagement: () => (/* binding */ Gh),
/* harmony export */   Modal: () => (/* binding */ zo),
/* harmony export */   MultiRangeSlider: () => (/* binding */ sd),
/* harmony export */   Offcanvas: () => (/* binding */ js),
/* harmony export */   PerfectScrollbar: () => (/* binding */ Bh),
/* harmony export */   Popconfirm: () => (/* binding */ Wh),
/* harmony export */   Popover: () => (/* binding */ nh),
/* harmony export */   Rating: () => (/* binding */ GA),
/* harmony export */   Ripple: () => (/* binding */ ei),
/* harmony export */   ScrollSpy: () => (/* binding */ ah),
/* harmony export */   Select: () => (/* binding */ kr),
/* harmony export */   Sidenav: () => (/* binding */ Ci),
/* harmony export */   SmoothScroll: () => (/* binding */ zh),
/* harmony export */   Stepper: () => (/* binding */ UA),
/* harmony export */   Sticky: () => (/* binding */ td),
/* harmony export */   Tab: () => (/* binding */ lh),
/* harmony export */   Timepicker: () => (/* binding */ Sg),
/* harmony export */   Toast: () => (/* binding */ Xo),
/* harmony export */   Tooltip: () => (/* binding */ ri),
/* harmony export */   Touch: () => (/* binding */ Kh),
/* harmony export */   Validation: () => (/* binding */ jh),
/* harmony export */   initTE: () => (/* binding */ qA)
/* harmony export */ });
/*!
* TW Elements 1.1.0
* 
* TW Elements is an open-source UI kit of advanced components for TailwindCSS.
* Copyright © 2023 MDBootstrap.com
* 
* Unless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
* In addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
* 
* If you would like to purchase a COMMERCIAL, non-AGPL license for TWE, please check out our pricing: https://tw-elements.com/pro/
*/
var hd = Object.defineProperty;
var dd = (s, t, e) => t in s ? hd(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
var wt = (s, t, e) => (dd(s, typeof t != "symbol" ? t + "" : t, e), e);
const In = (() => {
  const s = {};
  let t = 1;
  return {
    set(e, i, n) {
      typeof e[i] > "u" && (e[i] = {
        key: i,
        id: t
      }, t++), s[e[i].id] = n;
    },
    get(e, i) {
      if (!e || typeof e[i] > "u")
        return null;
      const n = e[i];
      return n.key === i ? s[n.id] : null;
    },
    delete(e, i) {
      if (typeof e[i] > "u")
        return;
      const n = e[i];
      n.key === i && (delete s[n.id], delete e[i]);
    }
  };
})(), A = {
  setData(s, t, e) {
    In.set(s, t, e);
  },
  getData(s, t) {
    return In.get(s, t);
  },
  removeData(s, t) {
    In.delete(s, t);
  }
}, ud = 1e6, pd = 1e3, Ho = "transitionend", _d = (s) => s == null ? `${s}` : {}.toString.call(s).match(/\s([a-z]+)/i)[1].toLowerCase(), et = (s) => {
  do
    s += Math.floor(Math.random() * ud);
  while (document.getElementById(s));
  return s;
}, pc = (s) => {
  let t = s.getAttribute("data-te-target");
  if (!t || t === "#") {
    let e = s.getAttribute("href");
    if (!e || !e.includes("#") && !e.startsWith("."))
      return null;
    e.includes("#") && !e.startsWith("#") && (e = `#${e.split("#")[1]}`), t = e && e !== "#" ? e.trim() : null;
  }
  return t;
}, lr = (s) => {
  const t = pc(s);
  return t && document.querySelector(t) ? t : null;
}, te = (s) => {
  const t = pc(s);
  return t ? document.querySelector(t) : null;
}, cn = (s) => {
  if (!s)
    return 0;
  let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(s);
  const i = Number.parseFloat(t), n = Number.parseFloat(e);
  return !i && !n ? 0 : (t = t.split(",")[0], e = e.split(",")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * pd);
}, _c = (s) => {
  s.dispatchEvent(new Event(Ho));
}, Xe = (s) => !s || typeof s != "object" ? !1 : (typeof s.jquery < "u" && (s = s[0]), typeof s.nodeType < "u"), ee = (s) => Xe(s) ? s.jquery ? s[0] : s : typeof s == "string" && s.length > 0 ? document.querySelector(s) : null, I = (s, t, e) => {
  Object.keys(e).forEach((i) => {
    const n = e[i], o = t[i], r = o && Xe(o) ? "element" : _d(o);
    if (!new RegExp(n).test(r))
      throw new Error(
        `${s.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${n}".`
      );
  });
}, Mt = (s) => {
  if (!s || s.getClientRects().length === 0)
    return !1;
  if (s.style && s.parentNode && s.parentNode.style) {
    const t = getComputedStyle(s), e = getComputedStyle(s.parentNode);
    return getComputedStyle(s).getPropertyValue("visibility") === "visible" || t.display !== "none" && e.display !== "none" && t.visibility !== "hidden";
  }
  return !1;
}, be = (s) => !s || s.nodeType !== Node.ELEMENT_NODE || s.classList.contains("disabled") ? !0 : typeof s.disabled < "u" ? s.disabled : s.hasAttribute("disabled") && s.getAttribute("disabled") !== "false", fc = (s) => {
  if (!document.documentElement.attachShadow)
    return null;
  if (typeof s.getRootNode == "function") {
    const t = s.getRootNode();
    return t instanceof ShadowRoot ? t : null;
  }
  return s instanceof ShadowRoot ? s : s.parentNode ? fc(s.parentNode) : null;
}, hn = () => function() {
}, si = (s) => {
  s.offsetHeight;
}, mc = () => {
  const { jQuery: s } = window;
  return s && !document.body.hasAttribute("data-te-no-jquery") ? s : null;
}, Dn = [], gc = (s) => {
  document.readyState === "loading" ? (Dn.length || document.addEventListener("DOMContentLoaded", () => {
    Dn.forEach((t) => t());
  }), Dn.push(s)) : s();
}, W = () => document.documentElement.dir === "rtl", fd = (s) => Array.from(s), $ = (s) => document.createElement(s), ge = (s) => {
  typeof s == "function" && s();
}, bc = (s, t, e = !0) => {
  if (!e) {
    ge(s);
    return;
  }
  const i = 5, n = cn(t) + i;
  let o = !1;
  const r = ({ target: a }) => {
    a === t && (o = !0, t.removeEventListener(Ho, r), ge(s));
  };
  t.addEventListener(Ho, r), setTimeout(() => {
    o || _c(t);
  }, n);
}, vc = (s, t, e, i) => {
  let n = s.indexOf(t);
  if (n === -1)
    return s[!e && i ? s.length - 1 : 0];
  const o = s.length;
  return n += e ? 1 : -1, i && (n = (n + o) % o), s[Math.max(0, Math.min(n, o - 1))];
}, md = /[^.]*(?=\..*)\.|.*/, gd = /\..*/, bd = /::\d+$/, $n = {};
let Hr = 1;
const vd = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, Td = /^(mouseenter|mouseleave)/i, Tc = /* @__PURE__ */ new Set([
  "click",
  "dblclick",
  "mouseup",
  "mousedown",
  "contextmenu",
  "mousewheel",
  "DOMMouseScroll",
  "mouseover",
  "mouseout",
  "mousemove",
  "selectstart",
  "selectend",
  "keydown",
  "keypress",
  "keyup",
  "orientationchange",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointerleave",
  "pointercancel",
  "gesturestart",
  "gesturechange",
  "gestureend",
  "focus",
  "blur",
  "change",
  "reset",
  "select",
  "submit",
  "focusin",
  "focusout",
  "load",
  "unload",
  "beforeunload",
  "resize",
  "move",
  "DOMContentLoaded",
  "readystatechange",
  "error",
  "abort",
  "scroll"
]);
function Ec(s, t) {
  return t && `${t}::${Hr++}` || s.uidEvent || Hr++;
}
function Cc(s) {
  const t = Ec(s);
  return s.uidEvent = t, $n[t] = $n[t] || {}, $n[t];
}
function Ed(s, t) {
  return function e(i) {
    return i.delegateTarget = s, e.oneOff && c.off(s, i.type, t), t.apply(s, [i]);
  };
}
function Cd(s, t, e) {
  return function i(n) {
    const o = s.querySelectorAll(t);
    for (let { target: r } = n; r && r !== this; r = r.parentNode)
      for (let a = o.length; a--; "")
        if (o[a] === r)
          return n.delegateTarget = r, i.oneOff && c.off(s, n.type, e), e.apply(r, [n]);
    return null;
  };
}
function Ac(s, t, e = null) {
  const i = Object.keys(s);
  for (let n = 0, o = i.length; n < o; n++) {
    const r = s[i[n]];
    if (r.originalHandler === t && r.delegationSelector === e)
      return r;
  }
  return null;
}
function yc(s, t, e) {
  const i = typeof t == "string", n = i ? e : t;
  let o = wc(s);
  return Tc.has(o) || (o = s), [i, n, o];
}
function Vr(s, t, e, i, n) {
  if (typeof t != "string" || !s)
    return;
  if (e || (e = i, i = null), Td.test(t)) {
    const g = (m) => function(b) {
      if (!b.relatedTarget || b.relatedTarget !== b.delegateTarget && !b.delegateTarget.contains(b.relatedTarget))
        return m.call(this, b);
    };
    i ? i = g(i) : e = g(e);
  }
  const [o, r, a] = yc(
    t,
    e,
    i
  ), l = Cc(s), p = l[a] || (l[a] = {}), u = Ac(
    p,
    r,
    o ? e : null
  );
  if (u) {
    u.oneOff = u.oneOff && n;
    return;
  }
  const _ = Ec(
    r,
    t.replace(md, "")
  ), f = o ? Cd(s, e, i) : Ed(s, e);
  f.delegationSelector = o ? e : null, f.originalHandler = r, f.oneOff = n, f.uidEvent = _, p[_] = f, s.addEventListener(a, f, o);
}
function Vo(s, t, e, i, n) {
  const o = Ac(t[e], i, n);
  o && (s.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);
}
function Ad(s, t, e, i) {
  const n = t[e] || {};
  Object.keys(n).forEach((o) => {
    if (o.includes(i)) {
      const r = n[o];
      Vo(
        s,
        t,
        e,
        r.originalHandler,
        r.delegationSelector
      );
    }
  });
}
function wc(s) {
  return s = s.replace(gd, ""), vd[s] || s;
}
const c = {
  on(s, t, e, i) {
    Vr(s, t, e, i, !1);
  },
  one(s, t, e, i) {
    Vr(s, t, e, i, !0);
  },
  off(s, t, e, i) {
    if (typeof t != "string" || !s)
      return;
    const [n, o, r] = yc(
      t,
      e,
      i
    ), a = r !== t, l = Cc(s), p = t.startsWith(".");
    if (typeof o < "u") {
      if (!l || !l[r])
        return;
      Vo(
        s,
        l,
        r,
        o,
        n ? e : null
      );
      return;
    }
    p && Object.keys(l).forEach((_) => {
      Ad(
        s,
        l,
        _,
        t.slice(1)
      );
    });
    const u = l[r] || {};
    Object.keys(u).forEach((_) => {
      const f = _.replace(bd, "");
      if (!a || t.includes(f)) {
        const g = u[_];
        Vo(
          s,
          l,
          r,
          g.originalHandler,
          g.delegationSelector
        );
      }
    });
  },
  trigger(s, t, e) {
    if (typeof t != "string" || !s)
      return null;
    const i = mc(), n = wc(t), o = t !== n, r = Tc.has(n);
    let a, l = !0, p = !0, u = !1, _ = null;
    return o && i && (a = i.Event(t, e), i(s).trigger(a), l = !a.isPropagationStopped(), p = !a.isImmediatePropagationStopped(), u = a.isDefaultPrevented()), r ? (_ = document.createEvent("HTMLEvents"), _.initEvent(n, l, !0)) : _ = new CustomEvent(t, {
      bubbles: l,
      cancelable: !0
    }), typeof e < "u" && Object.keys(e).forEach((f) => {
      Object.defineProperty(_, f, {
        get() {
          return e[f];
        }
      });
    }), u && _.preventDefault(), p && s.dispatchEvent(_), _.defaultPrevented && typeof a < "u" && a.preventDefault(), _;
  }
}, K = {
  on(s, t, e, i) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      c.on(s, n[o], e, i);
  },
  off(s, t, e, i) {
    const n = t.split(" ");
    for (let o = 0; o < n.length; o++)
      c.off(s, n[o], e, i);
  }
}, yd = "5.1.3";
class ft {
  constructor(t) {
    t = ee(t), t && (this._element = t, A.setData(this._element, this.constructor.DATA_KEY, this));
  }
  dispose() {
    A.removeData(this._element, this.constructor.DATA_KEY), c.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {
      this[t] = null;
    });
  }
  _queueCallback(t, e, i = !0) {
    bc(t, e, i);
  }
  /** Static */
  static getInstance(t) {
    return A.getData(ee(t), this.DATA_KEY);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static get VERSION() {
    return yd;
  }
  static get NAME() {
    throw new Error(
      'You have to implement the static method "NAME", for each component!'
    );
  }
  static get DATA_KEY() {
    return `te.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
}
const wd = "button", kd = "active";
class kc extends ft {
  // Getters
  static get NAME() {
    return wd;
  }
  // Public
  toggle() {
    this._element.setAttribute(
      "aria-pressed",
      this._element.classList.toggle(kd)
    );
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = kc.getOrCreateInstance(this);
      t === "toggle" && e[t]();
    });
  }
}
var st = "top", ut = "bottom", pt = "right", nt = "left", ji = "auto", ni = [st, ut, pt, nt], Ae = "start", Ge = "end", xc = "clippingParents", cr = "viewport", Be = "popper", Oc = "reference", Wo = /* @__PURE__ */ ni.reduce(function(s, t) {
  return s.concat([t + "-" + Ae, t + "-" + Ge]);
}, []), hr = /* @__PURE__ */ [].concat(ni, [ji]).reduce(function(s, t) {
  return s.concat([t, t + "-" + Ae, t + "-" + Ge]);
}, []), Sc = "beforeRead", Ic = "read", Dc = "afterRead", $c = "beforeMain", Lc = "main", Nc = "afterMain", Mc = "beforeWrite", Rc = "write", Pc = "afterWrite", dn = [Sc, Ic, Dc, $c, Lc, Nc, Mc, Rc, Pc];
function Rt(s) {
  return s ? (s.nodeName || "").toLowerCase() : null;
}
function _t(s) {
  if (s == null)
    return window;
  if (s.toString() !== "[object Window]") {
    var t = s.ownerDocument;
    return t && t.defaultView || window;
  }
  return s;
}
function ye(s) {
  var t = _t(s).Element;
  return s instanceof t || s instanceof Element;
}
function dt(s) {
  var t = _t(s).HTMLElement;
  return s instanceof t || s instanceof HTMLElement;
}
function dr(s) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = _t(s).ShadowRoot;
  return s instanceof t || s instanceof ShadowRoot;
}
function xd(s) {
  var t = s.state;
  Object.keys(t.elements).forEach(function(e) {
    var i = t.styles[e] || {}, n = t.attributes[e] || {}, o = t.elements[e];
    !dt(o) || !Rt(o) || (Object.assign(o.style, i), Object.keys(n).forEach(function(r) {
      var a = n[r];
      a === !1 ? o.removeAttribute(r) : o.setAttribute(r, a === !0 ? "" : a);
    }));
  });
}
function Od(s) {
  var t = s.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(i) {
      var n = t.elements[i], o = t.attributes[i] || {}, r = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : e[i]), a = r.reduce(function(l, p) {
        return l[p] = "", l;
      }, {});
      !dt(n) || !Rt(n) || (Object.assign(n.style, a), Object.keys(o).forEach(function(l) {
        n.removeAttribute(l);
      }));
    });
  };
}
const ur = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: xd,
  effect: Od,
  requires: ["computeStyles"]
};
function Et(s) {
  return s.split("-")[0];
}
var ve = Math.max, un = Math.min, qe = Math.round;
function Fo() {
  var s = navigator.userAgentData;
  return s != null && s.brands && Array.isArray(s.brands) ? s.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function Bc() {
  return !/^((?!chrome|android).)*safari/i.test(Fo());
}
function Ze(s, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var i = s.getBoundingClientRect(), n = 1, o = 1;
  t && dt(s) && (n = s.offsetWidth > 0 && qe(i.width) / s.offsetWidth || 1, o = s.offsetHeight > 0 && qe(i.height) / s.offsetHeight || 1);
  var r = ye(s) ? _t(s) : window, a = r.visualViewport, l = !Bc() && e, p = (i.left + (l && a ? a.offsetLeft : 0)) / n, u = (i.top + (l && a ? a.offsetTop : 0)) / o, _ = i.width / n, f = i.height / o;
  return {
    width: _,
    height: f,
    top: u,
    right: p + _,
    bottom: u + f,
    left: p,
    x: p,
    y: u
  };
}
function pr(s) {
  var t = Ze(s), e = s.offsetWidth, i = s.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {
    x: s.offsetLeft,
    y: s.offsetTop,
    width: e,
    height: i
  };
}
function Hc(s, t) {
  var e = t.getRootNode && t.getRootNode();
  if (s.contains(t))
    return !0;
  if (e && dr(e)) {
    var i = t;
    do {
      if (i && s.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function At(s) {
  return _t(s).getComputedStyle(s);
}
function Sd(s) {
  return ["table", "td", "th"].indexOf(Rt(s)) >= 0;
}
function ie(s) {
  return ((ye(s) ? s.ownerDocument : (
    // $FlowFixMe[prop-missing]
    s.document
  )) || window.document).documentElement;
}
function mn(s) {
  return Rt(s) === "html" ? s : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    s.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    s.parentNode || // DOM Element detected
    (dr(s) ? s.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    ie(s)
  );
}
function Wr(s) {
  return !dt(s) || // https://github.com/popperjs/popper-core/issues/837
  At(s).position === "fixed" ? null : s.offsetParent;
}
function Id(s) {
  var t = /firefox/i.test(Fo()), e = /Trident/i.test(Fo());
  if (e && dt(s)) {
    var i = At(s);
    if (i.position === "fixed")
      return null;
  }
  var n = mn(s);
  for (dr(n) && (n = n.host); dt(n) && ["html", "body"].indexOf(Rt(n)) < 0; ) {
    var o = At(n);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return n;
    n = n.parentNode;
  }
  return null;
}
function Ki(s) {
  for (var t = _t(s), e = Wr(s); e && Sd(e) && At(e).position === "static"; )
    e = Wr(e);
  return e && (Rt(e) === "html" || Rt(e) === "body" && At(e).position === "static") ? t : e || Id(s) || t;
}
function _r(s) {
  return ["top", "bottom"].indexOf(s) >= 0 ? "x" : "y";
}
function Mi(s, t, e) {
  return ve(s, un(t, e));
}
function Dd(s, t, e) {
  var i = Mi(s, t, e);
  return i > e ? e : i;
}
function Vc() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Wc(s) {
  return Object.assign({}, Vc(), s);
}
function Fc(s, t) {
  return t.reduce(function(e, i) {
    return e[i] = s, e;
  }, {});
}
var $d = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, Wc(typeof t != "number" ? t : Fc(t, ni));
};
function Ld(s) {
  var t, e = s.state, i = s.name, n = s.options, o = e.elements.arrow, r = e.modifiersData.popperOffsets, a = Et(e.placement), l = _r(a), p = [nt, pt].indexOf(a) >= 0, u = p ? "height" : "width";
  if (!(!o || !r)) {
    var _ = $d(n.padding, e), f = pr(o), g = l === "y" ? st : nt, m = l === "y" ? ut : pt, b = e.rects.reference[u] + e.rects.reference[l] - r[l] - e.rects.popper[u], v = r[l] - e.rects.reference[l], T = Ki(o), y = T ? l === "y" ? T.clientHeight || 0 : T.clientWidth || 0 : 0, C = b / 2 - v / 2, E = _[g], w = y - f[u] - _[m], k = y / 2 - f[u] / 2 + C, D = Mi(E, k, w), O = l;
    e.modifiersData[i] = (t = {}, t[O] = D, t.centerOffset = D - k, t);
  }
}
function Nd(s) {
  var t = s.state, e = s.options, i = e.element, n = i === void 0 ? "[data-popper-arrow]" : i;
  if (n != null && !(typeof n == "string" && (n = t.elements.popper.querySelector(n), !n))) {
    if ({}.NODE_ENV !== "production" && (dt(n) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !Hc(t.elements.popper, n)) {
      ({}).NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    t.elements.arrow = n;
  }
}
const Yc = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: Ld,
  effect: Nd,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Qe(s) {
  return s.split("-")[1];
}
var Md = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function Rd(s, t) {
  var e = s.x, i = s.y, n = t.devicePixelRatio || 1;
  return {
    x: qe(e * n) / n || 0,
    y: qe(i * n) / n || 0
  };
}
function Fr(s) {
  var t, e = s.popper, i = s.popperRect, n = s.placement, o = s.variation, r = s.offsets, a = s.position, l = s.gpuAcceleration, p = s.adaptive, u = s.roundOffsets, _ = s.isFixed, f = r.x, g = f === void 0 ? 0 : f, m = r.y, b = m === void 0 ? 0 : m, v = typeof u == "function" ? u({
    x: g,
    y: b
  }) : {
    x: g,
    y: b
  };
  g = v.x, b = v.y;
  var T = r.hasOwnProperty("x"), y = r.hasOwnProperty("y"), C = nt, E = st, w = window;
  if (p) {
    var k = Ki(e), D = "clientHeight", O = "clientWidth";
    if (k === _t(e) && (k = ie(e), At(k).position !== "static" && a === "absolute" && (D = "scrollHeight", O = "scrollWidth")), k = k, n === st || (n === nt || n === pt) && o === Ge) {
      E = ut;
      var x = _ && k === w && w.visualViewport ? w.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        k[D]
      );
      b -= x - i.height, b *= l ? 1 : -1;
    }
    if (n === nt || (n === st || n === ut) && o === Ge) {
      C = pt;
      var L = _ && k === w && w.visualViewport ? w.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        k[O]
      );
      g -= L - i.width, g *= l ? 1 : -1;
    }
  }
  var S = Object.assign({
    position: a
  }, p && Md), N = u === !0 ? Rd({
    x: g,
    y: b
  }, _t(e)) : {
    x: g,
    y: b
  };
  if (g = N.x, b = N.y, l) {
    var P;
    return Object.assign({}, S, (P = {}, P[E] = y ? "0" : "", P[C] = T ? "0" : "", P.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + g + "px, " + b + "px)" : "translate3d(" + g + "px, " + b + "px, 0)", P));
  }
  return Object.assign({}, S, (t = {}, t[E] = y ? b + "px" : "", t[C] = T ? g + "px" : "", t.transform = "", t));
}
function Pd(s) {
  var t = s.state, e = s.options, i = e.gpuAcceleration, n = i === void 0 ? !0 : i, o = e.adaptive, r = o === void 0 ? !0 : o, a = e.roundOffsets, l = a === void 0 ? !0 : a;
  if ({}.NODE_ENV !== "production") {
    var p = At(t.elements.popper).transitionProperty || "";
    r && ["transform", "top", "right", "bottom", "left"].some(function(_) {
      return p.indexOf(_) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var u = {
    placement: Et(t.placement),
    variation: Qe(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: n,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Fr(Object.assign({}, u, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: r,
    roundOffsets: l
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Fr(Object.assign({}, u, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const fr = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Pd,
  data: {}
};
var ns = {
  passive: !0
};
function Bd(s) {
  var t = s.state, e = s.instance, i = s.options, n = i.scroll, o = n === void 0 ? !0 : n, r = i.resize, a = r === void 0 ? !0 : r, l = _t(t.elements.popper), p = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && p.forEach(function(u) {
    u.addEventListener("scroll", e.update, ns);
  }), a && l.addEventListener("resize", e.update, ns), function() {
    o && p.forEach(function(u) {
      u.removeEventListener("scroll", e.update, ns);
    }), a && l.removeEventListener("resize", e.update, ns);
  };
}
const mr = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: Bd,
  data: {}
};
var Hd = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Ws(s) {
  return s.replace(/left|right|bottom|top/g, function(t) {
    return Hd[t];
  });
}
var Vd = {
  start: "end",
  end: "start"
};
function Yr(s) {
  return s.replace(/start|end/g, function(t) {
    return Vd[t];
  });
}
function gr(s) {
  var t = _t(s), e = t.pageXOffset, i = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: i
  };
}
function br(s) {
  return Ze(ie(s)).left + gr(s).scrollLeft;
}
function Wd(s, t) {
  var e = _t(s), i = ie(s), n = e.visualViewport, o = i.clientWidth, r = i.clientHeight, a = 0, l = 0;
  if (n) {
    o = n.width, r = n.height;
    var p = Bc();
    (p || !p && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: o,
    height: r,
    x: a + br(s),
    y: l
  };
}
function Fd(s) {
  var t, e = ie(s), i = gr(s), n = (t = s.ownerDocument) == null ? void 0 : t.body, o = ve(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = ve(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -i.scrollLeft + br(s), l = -i.scrollTop;
  return At(n || e).direction === "rtl" && (a += ve(e.clientWidth, n ? n.clientWidth : 0) - o), {
    width: o,
    height: r,
    x: a,
    y: l
  };
}
function vr(s) {
  var t = At(s), e = t.overflow, i = t.overflowX, n = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + n + i);
}
function jc(s) {
  return ["html", "body", "#document"].indexOf(Rt(s)) >= 0 ? s.ownerDocument.body : dt(s) && vr(s) ? s : jc(mn(s));
}
function Ri(s, t) {
  var e;
  t === void 0 && (t = []);
  var i = jc(s), n = i === ((e = s.ownerDocument) == null ? void 0 : e.body), o = _t(i), r = n ? [o].concat(o.visualViewport || [], vr(i) ? i : []) : i, a = t.concat(r);
  return n ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Ri(mn(r)))
  );
}
function Yo(s) {
  return Object.assign({}, s, {
    left: s.x,
    top: s.y,
    right: s.x + s.width,
    bottom: s.y + s.height
  });
}
function Yd(s, t) {
  var e = Ze(s, !1, t === "fixed");
  return e.top = e.top + s.clientTop, e.left = e.left + s.clientLeft, e.bottom = e.top + s.clientHeight, e.right = e.left + s.clientWidth, e.width = s.clientWidth, e.height = s.clientHeight, e.x = e.left, e.y = e.top, e;
}
function jr(s, t, e) {
  return t === cr ? Yo(Wd(s, e)) : ye(t) ? Yd(t, e) : Yo(Fd(ie(s)));
}
function jd(s) {
  var t = Ri(mn(s)), e = ["absolute", "fixed"].indexOf(At(s).position) >= 0, i = e && dt(s) ? Ki(s) : s;
  return ye(i) ? t.filter(function(n) {
    return ye(n) && Hc(n, i) && Rt(n) !== "body";
  }) : [];
}
function Kd(s, t, e, i) {
  var n = t === "clippingParents" ? jd(s) : [].concat(t), o = [].concat(n, [e]), r = o[0], a = o.reduce(function(l, p) {
    var u = jr(s, p, i);
    return l.top = ve(u.top, l.top), l.right = un(u.right, l.right), l.bottom = un(u.bottom, l.bottom), l.left = ve(u.left, l.left), l;
  }, jr(s, r, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function Kc(s) {
  var t = s.reference, e = s.element, i = s.placement, n = i ? Et(i) : null, o = i ? Qe(i) : null, r = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;
  switch (n) {
    case st:
      l = {
        x: r,
        y: t.y - e.height
      };
      break;
    case ut:
      l = {
        x: r,
        y: t.y + t.height
      };
      break;
    case pt:
      l = {
        x: t.x + t.width,
        y: a
      };
      break;
    case nt:
      l = {
        x: t.x - e.width,
        y: a
      };
      break;
    default:
      l = {
        x: t.x,
        y: t.y
      };
  }
  var p = n ? _r(n) : null;
  if (p != null) {
    var u = p === "y" ? "height" : "width";
    switch (o) {
      case Ae:
        l[p] = l[p] - (t[u] / 2 - e[u] / 2);
        break;
      case Ge:
        l[p] = l[p] + (t[u] / 2 - e[u] / 2);
        break;
    }
  }
  return l;
}
function Je(s, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = i === void 0 ? s.placement : i, o = e.strategy, r = o === void 0 ? s.strategy : o, a = e.boundary, l = a === void 0 ? xc : a, p = e.rootBoundary, u = p === void 0 ? cr : p, _ = e.elementContext, f = _ === void 0 ? Be : _, g = e.altBoundary, m = g === void 0 ? !1 : g, b = e.padding, v = b === void 0 ? 0 : b, T = Wc(typeof v != "number" ? v : Fc(v, ni)), y = f === Be ? Oc : Be, C = s.rects.popper, E = s.elements[m ? y : f], w = Kd(ye(E) ? E : E.contextElement || ie(s.elements.popper), l, u, r), k = Ze(s.elements.reference), D = Kc({
    reference: k,
    element: C,
    strategy: "absolute",
    placement: n
  }), O = Yo(Object.assign({}, C, D)), x = f === Be ? O : k, L = {
    top: w.top - x.top + T.top,
    bottom: x.bottom - w.bottom + T.bottom,
    left: w.left - x.left + T.left,
    right: x.right - w.right + T.right
  }, S = s.modifiersData.offset;
  if (f === Be && S) {
    var N = S[n];
    Object.keys(L).forEach(function(P) {
      var ot = [pt, ut].indexOf(P) >= 0 ? 1 : -1, rt = [st, ut].indexOf(P) >= 0 ? "y" : "x";
      L[P] += N[rt] * ot;
    });
  }
  return L;
}
function zd(s, t) {
  t === void 0 && (t = {});
  var e = t, i = e.placement, n = e.boundary, o = e.rootBoundary, r = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, p = l === void 0 ? hr : l, u = Qe(i), _ = u ? a ? Wo : Wo.filter(function(m) {
    return Qe(m) === u;
  }) : ni, f = _.filter(function(m) {
    return p.indexOf(m) >= 0;
  });
  f.length === 0 && (f = _, {}.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var g = f.reduce(function(m, b) {
    return m[b] = Je(s, {
      placement: b,
      boundary: n,
      rootBoundary: o,
      padding: r
    })[Et(b)], m;
  }, {});
  return Object.keys(g).sort(function(m, b) {
    return g[m] - g[b];
  });
}
function Ud(s) {
  if (Et(s) === ji)
    return [];
  var t = Ws(s);
  return [Yr(s), t, Yr(t)];
}
function Xd(s) {
  var t = s.state, e = s.options, i = s.name;
  if (!t.modifiersData[i]._skip) {
    for (var n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !0 : r, l = e.fallbackPlacements, p = e.padding, u = e.boundary, _ = e.rootBoundary, f = e.altBoundary, g = e.flipVariations, m = g === void 0 ? !0 : g, b = e.allowedAutoPlacements, v = t.options.placement, T = Et(v), y = T === v, C = l || (y || !m ? [Ws(v)] : Ud(v)), E = [v].concat(C).reduce(function(Oe, Vt) {
      return Oe.concat(Et(Vt) === ji ? zd(t, {
        placement: Vt,
        boundary: u,
        rootBoundary: _,
        padding: p,
        flipVariations: m,
        allowedAutoPlacements: b
      }) : Vt);
    }, []), w = t.rects.reference, k = t.rects.popper, D = /* @__PURE__ */ new Map(), O = !0, x = E[0], L = 0; L < E.length; L++) {
      var S = E[L], N = Et(S), P = Qe(S) === Ae, ot = [st, ut].indexOf(N) >= 0, rt = ot ? "width" : "height", G = Je(t, {
        placement: S,
        boundary: u,
        rootBoundary: _,
        altBoundary: f,
        padding: p
      }), vt = ot ? P ? pt : nt : P ? ut : st;
      w[rt] > k[rt] && (vt = Ws(vt));
      var Ji = Ws(vt), oe = [];
      if (o && oe.push(G[N] <= 0), a && oe.push(G[vt] <= 0, G[Ji] <= 0), oe.every(function(Oe) {
        return Oe;
      })) {
        x = S, O = !1;
        break;
      }
      D.set(S, oe);
    }
    if (O)
      for (var ts = m ? 3 : 1, kn = function(Vt) {
        var di = E.find(function(is) {
          var re = D.get(is);
          if (re)
            return re.slice(0, Vt).every(function(xn) {
              return xn;
            });
        });
        if (di)
          return x = di, "break";
      }, hi = ts; hi > 0; hi--) {
        var es = kn(hi);
        if (es === "break")
          break;
      }
    t.placement !== x && (t.modifiersData[i]._skip = !0, t.placement = x, t.reset = !0);
  }
}
const zc = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Xd,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Kr(s, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: s.top - t.height - e.y,
    right: s.right - t.width + e.x,
    bottom: s.bottom - t.height + e.y,
    left: s.left - t.width - e.x
  };
}
function zr(s) {
  return [st, pt, ut, nt].some(function(t) {
    return s[t] >= 0;
  });
}
function Gd(s) {
  var t = s.state, e = s.name, i = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, r = Je(t, {
    elementContext: "reference"
  }), a = Je(t, {
    altBoundary: !0
  }), l = Kr(r, i), p = Kr(a, n, o), u = zr(l), _ = zr(p);
  t.modifiersData[e] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: p,
    isReferenceHidden: u,
    hasPopperEscaped: _
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": _
  });
}
const Uc = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Gd
};
function qd(s, t, e) {
  var i = Et(s), n = [nt, st].indexOf(i) >= 0 ? -1 : 1, o = typeof e == "function" ? e(Object.assign({}, t, {
    placement: s
  })) : e, r = o[0], a = o[1];
  return r = r || 0, a = (a || 0) * n, [nt, pt].indexOf(i) >= 0 ? {
    x: a,
    y: r
  } : {
    x: r,
    y: a
  };
}
function Zd(s) {
  var t = s.state, e = s.options, i = s.name, n = e.offset, o = n === void 0 ? [0, 0] : n, r = hr.reduce(function(u, _) {
    return u[_] = qd(_, t.rects, o), u;
  }, {}), a = r[t.placement], l = a.x, p = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += p), t.modifiersData[i] = r;
}
const Xc = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: Zd
};
function Qd(s) {
  var t = s.state, e = s.name;
  t.modifiersData[e] = Kc({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const Tr = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: Qd,
  data: {}
};
function Jd(s) {
  return s === "x" ? "y" : "x";
}
function tu(s) {
  var t = s.state, e = s.options, i = s.name, n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !1 : r, l = e.boundary, p = e.rootBoundary, u = e.altBoundary, _ = e.padding, f = e.tether, g = f === void 0 ? !0 : f, m = e.tetherOffset, b = m === void 0 ? 0 : m, v = Je(t, {
    boundary: l,
    rootBoundary: p,
    padding: _,
    altBoundary: u
  }), T = Et(t.placement), y = Qe(t.placement), C = !y, E = _r(T), w = Jd(E), k = t.modifiersData.popperOffsets, D = t.rects.reference, O = t.rects.popper, x = typeof b == "function" ? b(Object.assign({}, t.rects, {
    placement: t.placement
  })) : b, L = typeof x == "number" ? {
    mainAxis: x,
    altAxis: x
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, x), S = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, N = {
    x: 0,
    y: 0
  };
  if (k) {
    if (o) {
      var P, ot = E === "y" ? st : nt, rt = E === "y" ? ut : pt, G = E === "y" ? "height" : "width", vt = k[E], Ji = vt + v[ot], oe = vt - v[rt], ts = g ? -O[G] / 2 : 0, kn = y === Ae ? D[G] : O[G], hi = y === Ae ? -O[G] : -D[G], es = t.elements.arrow, Oe = g && es ? pr(es) : {
        width: 0,
        height: 0
      }, Vt = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : Vc(), di = Vt[ot], is = Vt[rt], re = Mi(0, D[G], Oe[G]), xn = C ? D[G] / 2 - ts - re - di - L.mainAxis : kn - re - di - L.mainAxis, nd = C ? -D[G] / 2 + ts + re + is + L.mainAxis : hi + re + is + L.mainAxis, On = t.elements.arrow && Ki(t.elements.arrow), od = On ? E === "y" ? On.clientTop || 0 : On.clientLeft || 0 : 0, Ir = (P = S == null ? void 0 : S[E]) != null ? P : 0, rd = vt + xn - Ir - od, ad = vt + nd - Ir, Dr = Mi(g ? un(Ji, rd) : Ji, vt, g ? ve(oe, ad) : oe);
      k[E] = Dr, N[E] = Dr - vt;
    }
    if (a) {
      var $r, ld = E === "x" ? st : nt, cd = E === "x" ? ut : pt, ae = k[w], ss = w === "y" ? "height" : "width", Lr = ae + v[ld], Nr = ae - v[cd], Sn = [st, nt].indexOf(T) !== -1, Mr = ($r = S == null ? void 0 : S[w]) != null ? $r : 0, Rr = Sn ? Lr : ae - D[ss] - O[ss] - Mr + L.altAxis, Pr = Sn ? ae + D[ss] + O[ss] - Mr - L.altAxis : Nr, Br = g && Sn ? Dd(Rr, ae, Pr) : Mi(g ? Rr : Lr, ae, g ? Pr : Nr);
      k[w] = Br, N[w] = Br - ae;
    }
    t.modifiersData[i] = N;
  }
}
const Gc = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: tu,
  requiresIfExists: ["offset"]
};
function eu(s) {
  return {
    scrollLeft: s.scrollLeft,
    scrollTop: s.scrollTop
  };
}
function iu(s) {
  return s === _t(s) || !dt(s) ? gr(s) : eu(s);
}
function su(s) {
  var t = s.getBoundingClientRect(), e = qe(t.width) / s.offsetWidth || 1, i = qe(t.height) / s.offsetHeight || 1;
  return e !== 1 || i !== 1;
}
function nu(s, t, e) {
  e === void 0 && (e = !1);
  var i = dt(t), n = dt(t) && su(t), o = ie(t), r = Ze(s, n, e), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !e) && ((Rt(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  vr(o)) && (a = iu(t)), dt(t) ? (l = Ze(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = br(o))), {
    x: r.left + a.scrollLeft - l.x,
    y: r.top + a.scrollTop - l.y,
    width: r.width,
    height: r.height
  };
}
function ou(s) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), i = [];
  s.forEach(function(o) {
    t.set(o.name, o);
  });
  function n(o) {
    e.add(o.name);
    var r = [].concat(o.requires || [], o.requiresIfExists || []);
    r.forEach(function(a) {
      if (!e.has(a)) {
        var l = t.get(a);
        l && n(l);
      }
    }), i.push(o);
  }
  return s.forEach(function(o) {
    e.has(o.name) || n(o);
  }), i;
}
function ru(s) {
  var t = ou(s);
  return dn.reduce(function(e, i) {
    return e.concat(t.filter(function(n) {
      return n.phase === i;
    }));
  }, []);
}
function au(s) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(s());
      });
    })), t;
  };
}
function Wt(s) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    e[i - 1] = arguments[i];
  return [].concat(e).reduce(function(n, o) {
    return n.replace(/%s/, o);
  }, s);
}
var le = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', lu = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', Ur = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function cu(s) {
  s.forEach(function(t) {
    [].concat(Object.keys(t), Ur).filter(function(e, i, n) {
      return n.indexOf(e) === i;
    }).forEach(function(e) {
      switch (e) {
        case "name":
          typeof t.name != "string" && console.error(Wt(le, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
          break;
        case "enabled":
          typeof t.enabled != "boolean" && console.error(Wt(le, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
          break;
        case "phase":
          dn.indexOf(t.phase) < 0 && console.error(Wt(le, t.name, '"phase"', "either " + dn.join(", "), '"' + String(t.phase) + '"'));
          break;
        case "fn":
          typeof t.fn != "function" && console.error(Wt(le, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "effect":
          t.effect != null && typeof t.effect != "function" && console.error(Wt(le, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "requires":
          t.requires != null && !Array.isArray(t.requires) && console.error(Wt(le, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(t.requiresIfExists) || console.error(Wt(le, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + Ur.map(function(i) {
            return '"' + i + '"';
          }).join(", ") + '; but "' + e + '" was provided.');
      }
      t.requires && t.requires.forEach(function(i) {
        s.find(function(n) {
          return n.name === i;
        }) == null && console.error(Wt(lu, String(t.name), i, i));
      });
    });
  });
}
function hu(s, t) {
  var e = /* @__PURE__ */ new Set();
  return s.filter(function(i) {
    var n = t(i);
    if (!e.has(n))
      return e.add(n), !0;
  });
}
function du(s) {
  var t = s.reduce(function(e, i) {
    var n = e[i.name];
    return e[i.name] = n ? Object.assign({}, n, i, {
      options: Object.assign({}, n.options, i.options),
      data: Object.assign({}, n.data, i.data)
    }) : i, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var Xr = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", uu = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", Gr = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function qr() {
  for (var s = arguments.length, t = new Array(s), e = 0; e < s; e++)
    t[e] = arguments[e];
  return !t.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function gn(s) {
  s === void 0 && (s = {});
  var t = s, e = t.defaultModifiers, i = e === void 0 ? [] : e, n = t.defaultOptions, o = n === void 0 ? Gr : n;
  return function(a, l, p) {
    p === void 0 && (p = o);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Gr, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, _ = [], f = !1, g = {
      state: u,
      setOptions: function(T) {
        var y = typeof T == "function" ? T(u.options) : T;
        b(), u.options = Object.assign({}, o, u.options, y), u.scrollParents = {
          reference: ye(a) ? Ri(a) : a.contextElement ? Ri(a.contextElement) : [],
          popper: Ri(l)
        };
        var C = ru(du([].concat(i, u.options.modifiers)));
        if (u.orderedModifiers = C.filter(function(S) {
          return S.enabled;
        }), {}.NODE_ENV !== "production") {
          var E = hu([].concat(C, u.options.modifiers), function(S) {
            var N = S.name;
            return N;
          });
          if (cu(E), Et(u.options.placement) === ji) {
            var w = u.orderedModifiers.find(function(S) {
              var N = S.name;
              return N === "flip";
            });
            w || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var k = At(l), D = k.marginTop, O = k.marginRight, x = k.marginBottom, L = k.marginLeft;
          [D, O, x, L].some(function(S) {
            return parseFloat(S);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return m(), g.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var T = u.elements, y = T.reference, C = T.popper;
          if (!qr(y, C)) {
            ({}).NODE_ENV !== "production" && console.error(Xr);
            return;
          }
          u.rects = {
            reference: nu(y, Ki(C), u.options.strategy === "fixed"),
            popper: pr(C)
          }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(S) {
            return u.modifiersData[S.name] = Object.assign({}, S.data);
          });
          for (var E = 0, w = 0; w < u.orderedModifiers.length; w++) {
            if ({}.NODE_ENV !== "production" && (E += 1, E > 100)) {
              console.error(uu);
              break;
            }
            if (u.reset === !0) {
              u.reset = !1, w = -1;
              continue;
            }
            var k = u.orderedModifiers[w], D = k.fn, O = k.options, x = O === void 0 ? {} : O, L = k.name;
            typeof D == "function" && (u = D({
              state: u,
              options: x,
              name: L,
              instance: g
            }) || u);
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: au(function() {
        return new Promise(function(v) {
          g.forceUpdate(), v(u);
        });
      }),
      destroy: function() {
        b(), f = !0;
      }
    };
    if (!qr(a, l))
      return {}.NODE_ENV !== "production" && console.error(Xr), g;
    g.setOptions(p).then(function(v) {
      !f && p.onFirstUpdate && p.onFirstUpdate(v);
    });
    function m() {
      u.orderedModifiers.forEach(function(v) {
        var T = v.name, y = v.options, C = y === void 0 ? {} : y, E = v.effect;
        if (typeof E == "function") {
          var w = E({
            state: u,
            name: T,
            instance: g,
            options: C
          }), k = function() {
          };
          _.push(w || k);
        }
      });
    }
    function b() {
      _.forEach(function(v) {
        return v();
      }), _ = [];
    }
    return g;
  };
}
var pu = /* @__PURE__ */ gn(), _u = [mr, Tr, fr, ur], fu = /* @__PURE__ */ gn({
  defaultModifiers: _u
}), mu = [mr, Tr, fr, ur, Xc, zc, Gc, Yc, Uc], se = /* @__PURE__ */ gn({
  defaultModifiers: mu
});
const qc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  afterMain: Nc,
  afterRead: Dc,
  afterWrite: Pc,
  applyStyles: ur,
  arrow: Yc,
  auto: ji,
  basePlacements: ni,
  beforeMain: $c,
  beforeRead: Sc,
  beforeWrite: Mc,
  bottom: ut,
  clippingParents: xc,
  computeStyles: fr,
  createPopper: se,
  createPopperBase: pu,
  createPopperLite: fu,
  detectOverflow: Je,
  end: Ge,
  eventListeners: mr,
  flip: zc,
  hide: Uc,
  left: nt,
  main: Lc,
  modifierPhases: dn,
  offset: Xc,
  placements: hr,
  popper: Be,
  popperGenerator: gn,
  popperOffsets: Tr,
  preventOverflow: Gc,
  read: Ic,
  reference: Oc,
  right: pt,
  start: Ae,
  top: st,
  variationPlacements: Wo,
  viewport: cr,
  write: Rc
}, Symbol.toStringTag, { value: "Module" }));
function Ln(s) {
  return s === "true" ? !0 : s === "false" ? !1 : s === Number(s).toString() ? Number(s) : s === "" || s === "null" ? null : s;
}
function Nn(s) {
  return s.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
const h = {
  setDataAttribute(s, t, e) {
    s.setAttribute(`data-te-${Nn(t)}`, e);
  },
  removeDataAttribute(s, t) {
    s.removeAttribute(`data-te-${Nn(t)}`);
  },
  getDataAttributes(s) {
    if (!s)
      return {};
    const t = {};
    return Object.keys(s.dataset).filter((e) => e.startsWith("te")).forEach((e) => {
      if (e.startsWith("teClass"))
        return;
      let i = e.replace(/^te/, "");
      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = Ln(s.dataset[e]);
    }), t;
  },
  getDataClassAttributes(s) {
    if (!s)
      return {};
    const t = {
      ...s.dataset
    };
    return Object.keys(t).filter((e) => e.startsWith("teClass")).forEach((e) => {
      let i = e.replace(/^teClass/, "");
      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = Ln(t[e]);
    }), t;
  },
  getDataAttribute(s, t) {
    return Ln(
      s.getAttribute(`data-te-${Nn(t)}`)
    );
  },
  offset(s) {
    const t = s.getBoundingClientRect();
    return {
      top: t.top + document.body.scrollTop,
      left: t.left + document.body.scrollLeft
    };
  },
  position(s) {
    return {
      top: s.offsetTop,
      left: s.offsetLeft
    };
  },
  style(s, t) {
    Object.assign(s.style, t);
  },
  toggleClass(s, t) {
    s && Mn(t).forEach((e) => {
      s.classList.contains(e) ? s.classList.remove(e) : s.classList.add(e);
    });
  },
  addClass(s, t) {
    Mn(t).forEach(
      (e) => !s.classList.contains(e) && s.classList.add(e)
    );
  },
  addStyle(s, t) {
    Object.keys(t).forEach((e) => {
      s.style[e] = t[e];
    });
  },
  removeClass(s, t) {
    Mn(t).forEach(
      (e) => s.classList.contains(e) && s.classList.remove(e)
    );
  },
  hasClass(s, t) {
    return s.classList.contains(t);
  },
  maxOffset(s) {
    const t = s.getBoundingClientRect();
    return {
      top: t.top + Math.max(
        document.body.scrollTop,
        document.documentElement.scrollTop,
        window.scrollY
      ),
      left: t.left + Math.max(
        document.body.scrollLeft,
        document.documentElement.scrollLeft,
        window.scrollX
      )
    };
  }
};
function Mn(s) {
  return typeof s == "string" ? s.split(" ") : Array.isArray(s) ? s : !1;
}
const gu = 3, d = {
  closest(s, t) {
    return s.closest(t);
  },
  matches(s, t) {
    return s.matches(t);
  },
  find(s, t = document.documentElement) {
    return [].concat(
      ...Element.prototype.querySelectorAll.call(t, s)
    );
  },
  findOne(s, t = document.documentElement) {
    return Element.prototype.querySelector.call(t, s);
  },
  children(s, t) {
    return [].concat(...s.children).filter((i) => i.matches(t));
  },
  parents(s, t) {
    const e = [];
    let i = s.parentNode;
    for (; i && i.nodeType === Node.ELEMENT_NODE && i.nodeType !== gu; )
      this.matches(i, t) && e.push(i), i = i.parentNode;
    return e;
  },
  prev(s, t) {
    let e = s.previousElementSibling;
    for (; e; ) {
      if (e.matches(t))
        return [e];
      e = e.previousElementSibling;
    }
    return [];
  },
  next(s, t) {
    let e = s.nextElementSibling;
    for (; e; ) {
      if (this.matches(e, t))
        return [e];
      e = e.nextElementSibling;
    }
    return [];
  },
  focusableChildren(s) {
    const t = [
      "a",
      "button",
      "input",
      "textarea",
      "select",
      "details",
      "[tabindex]",
      '[contenteditable="true"]'
    ].map((e) => `${e}:not([tabindex^="-"])`).join(", ");
    return this.find(t, s).filter(
      (e) => !be(e) && Mt(e)
    );
  }
}, Rn = "dropdown", bu = "te.dropdown", xe = `.${bu}`, Er = ".data-api", Fs = "Escape", Zr = "Space", Qr = "Tab", jo = "ArrowUp", Ys = "ArrowDown", vu = 2, Tu = new RegExp(
  `${jo}|${Ys}|${Fs}`
), Eu = `hide${xe}`, Cu = `hidden${xe}`, Au = `show${xe}`, yu = `shown${xe}`, wu = `click${xe}${Er}`, Jr = `keydown${xe}${Er}`, ku = `keyup${xe}${Er}`, Ft = "show", xu = "dropup", Ou = "dropend", Su = "dropstart", Iu = "[data-te-navbar-ref]", os = "[data-te-dropdown-toggle-ref]", Pn = "[data-te-dropdown-menu-ref]", Du = "[data-te-navbar-nav-ref]", $u = "[data-te-dropdown-menu-ref] [data-te-dropdown-item-ref]:not(.disabled):not(:disabled)", Lu = W() ? "top-end" : "top-start", Nu = W() ? "top-start" : "top-end", Mu = W() ? "bottom-end" : "bottom-start", Ru = W() ? "bottom-start" : "bottom-end", Pu = W() ? "left-start" : "right-start", Bu = W() ? "right-start" : "left-start", Hu = [{ opacity: "0" }, { opacity: "1" }], Vu = [{ opacity: "1" }, { opacity: "0" }], ta = {
  iterations: 1,
  easing: "ease",
  fill: "both"
}, Wu = {
  offset: [0, 2],
  boundary: "clippingParents",
  reference: "toggle",
  display: "dynamic",
  popperConfig: null,
  autoClose: !0,
  dropdownAnimation: "on",
  animationDuration: 550
}, Fu = {
  offset: "(array|string|function)",
  boundary: "(string|element)",
  reference: "(string|element|object)",
  display: "string",
  popperConfig: "(null|object|function)",
  autoClose: "(boolean|string)",
  dropdownAnimation: "string",
  animationDuration: "number"
};
class $t extends ft {
  constructor(t, e) {
    super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._fadeOutAnimate = null;
    const i = window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches;
    this._animationCanPlay = this._config.dropdownAnimation === "on" && !i, this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return Wu;
  }
  static get DefaultType() {
    return Fu;
  }
  static get NAME() {
    return Rn;
  }
  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (be(this._element) || this._isShown(this._menu))
      return;
    const t = {
      relatedTarget: this._element
    };
    if (c.trigger(
      this._element,
      Au,
      t
    ).defaultPrevented)
      return;
    const i = $t.getParentFromElement(this._element);
    this._inNavbar ? h.setDataAttribute(this._menu, "popper", "none") : this._createPopper(i), "ontouchstart" in document.documentElement && !i.closest(Du) && [].concat(...document.body.children).forEach((n) => c.on(n, "mouseover", hn)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.setAttribute(`data-te-dropdown-${Ft}`, ""), this._animationCanPlay && this._menu.animate(Hu, {
      ...ta,
      duration: this._config.animationDuration
    }), this._element.setAttribute(`data-te-dropdown-${Ft}`, ""), setTimeout(
      () => {
        c.trigger(this._element, yu, t);
      },
      this._animationCanPlay ? this._config.animationDuration : 0
    );
  }
  hide() {
    if (be(this._element) || !this._isShown(this._menu))
      return;
    const t = {
      relatedTarget: this._element
    };
    this._completeHide(t);
  }
  dispose() {
    this._popper && this._popper.destroy(), super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
  }
  // Private
  _init() {
    this._didInit || (c.on(
      document,
      Jr,
      os,
      $t.dataApiKeydownHandler
    ), c.on(
      document,
      Jr,
      Pn,
      $t.dataApiKeydownHandler
    ), c.on(document, wu, $t.clearMenus), c.on(document, ku, $t.clearMenus), this._didInit = !0);
  }
  _completeHide(t) {
    this._fadeOutAnimate && this._fadeOutAnimate.playState === "running" || c.trigger(
      this._element,
      Eu,
      t
    ).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((i) => c.off(i, "mouseover", hn)), this._animationCanPlay && (this._fadeOutAnimate = this._menu.animate(Vu, {
      ...ta,
      duration: this._config.animationDuration
    })), setTimeout(
      () => {
        this._popper && this._popper.destroy(), this._menu.removeAttribute(`data-te-dropdown-${Ft}`), this._element.removeAttribute(`data-te-dropdown-${Ft}`), this._element.setAttribute("aria-expanded", "false"), h.removeDataAttribute(this._menu, "popper"), c.trigger(this._element, Cu, t);
      },
      this._animationCanPlay ? this._config.animationDuration : 0
    ));
  }
  _getConfig(t) {
    if (t = {
      ...this.constructor.Default,
      ...h.getDataAttributes(this._element),
      ...t
    }, I(Rn, t, this.constructor.DefaultType), typeof t.reference == "object" && !Xe(t.reference) && typeof t.reference.getBoundingClientRect != "function")
      throw new TypeError(
        `${Rn.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
      );
    return t;
  }
  _createPopper(t) {
    if (typeof qc > "u")
      throw new TypeError(
        "Bootstrap's dropdowns require Popper (https://popper.js.org)"
      );
    let e = this._element;
    this._config.reference === "parent" ? e = t : Xe(this._config.reference) ? e = ee(this._config.reference) : typeof this._config.reference == "object" && (e = this._config.reference);
    const i = this._getPopperConfig(), n = i.modifiers.find(
      (o) => o.name === "applyStyles" && o.enabled === !1
    );
    this._popper = se(
      e,
      this._menu,
      i
    ), n && h.setDataAttribute(this._menu, "popper", "static");
  }
  _isShown(t = this._element) {
    return t.dataset[`teDropdown${Ft.charAt(0).toUpperCase() + Ft.slice(1)}`] === "";
  }
  _getMenuElement() {
    return d.next(this._element, Pn)[0];
  }
  _getPlacement() {
    const t = this._element.parentNode;
    if (t.dataset.teDropdownPosition === Ou)
      return Pu;
    if (t.dataset.teDropdownPosition === Su)
      return Bu;
    const e = t.dataset.teDropdownAlignment === "end";
    return t.dataset.teDropdownPosition === xu ? e ? Nu : Lu : e ? Ru : Mu;
  }
  _detectNavbar() {
    return this._element.closest(Iu) !== null;
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _getPopperConfig() {
    const t = {
      placement: this._getPlacement(),
      modifiers: [
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }
      ]
    };
    return this._config.display === "static" && (t.modifiers = [
      {
        name: "applyStyles",
        enabled: !1
      }
    ]), {
      ...t,
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(t) : this._config.popperConfig
    };
  }
  _selectMenuItem({ key: t, target: e }) {
    const i = d.find(
      $u,
      this._menu
    ).filter(Mt);
    i.length && vc(
      i,
      e,
      t === Ys,
      !i.includes(e)
    ).focus();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = $t.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
  static clearMenus(t) {
    if (t && (t.button === vu || t.type === "keyup" && t.key !== Qr))
      return;
    const e = d.find(os);
    for (let i = 0, n = e.length; i < n; i++) {
      const o = $t.getInstance(e[i]);
      if (!o || o._config.autoClose === !1 || !o._isShown())
        continue;
      const r = {
        relatedTarget: o._element
      };
      if (t) {
        const a = t.composedPath(), l = a.includes(o._menu);
        if (a.includes(o._element) || o._config.autoClose === "inside" && !l || o._config.autoClose === "outside" && l || o._menu.contains(t.target) && (t.type === "keyup" && t.key === Qr || /input|select|option|textarea|form/i.test(t.target.tagName)))
          continue;
        t.type === "click" && (r.clickEvent = t);
      }
      o._completeHide(r);
    }
  }
  static getParentFromElement(t) {
    return te(t) || t.parentNode;
  }
  static dataApiKeydownHandler(t) {
    if (/input|textarea/i.test(t.target.tagName) ? t.key === Zr || t.key !== Fs && (t.key !== Ys && t.key !== jo || t.target.closest(Pn)) : !Tu.test(t.key))
      return;
    const e = this.dataset[`teDropdown${Ft.charAt(0).toUpperCase() + Ft.slice(1)}`] === "";
    if (!e && t.key === Fs || (t.preventDefault(), t.stopPropagation(), be(this)))
      return;
    const i = this.matches(os) ? this : d.prev(this, os)[0], n = $t.getOrCreateInstance(i);
    if (t.key === Fs) {
      n.hide();
      return;
    }
    if (t.key === jo || t.key === Ys) {
      e || n.show(), n._selectMenuItem(t);
      return;
    }
    (!e || t.key === Zr) && $t.clearMenus();
  }
}
const Bn = "collapse", Zc = "te.collapse", bn = `.${Zc}`, ea = {
  toggle: !0,
  parent: null
}, Yu = {
  toggle: "boolean",
  parent: "(null|element)"
}, ju = `show${bn}`, Ku = `shown${bn}`, zu = `hide${bn}`, Uu = `hidden${bn}`, Hn = "data-te-collapse-show", ia = "data-te-collapse-collapsed", rs = "data-te-collapse-collapsing", Xu = "data-te-collapse-horizontal", We = "data-te-collapse-item", sa = `:scope [${We}] [${We}]`, Gu = "width", qu = "height", Zu = "[data-te-collapse-item][data-te-collapse-show], [data-te-collapse-item][data-te-collapse-collapsing]", na = "[data-te-collapse-init]", Qu = {
  visible: "!visible",
  hidden: "hidden",
  baseTransition: "overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsing: "h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none",
  collapsingHorizontal: "w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none"
}, Ju = {
  visible: "string",
  hidden: "string",
  baseTransition: "string",
  collapsing: "string",
  collapsingHorizontal: "string"
};
class Qt extends ft {
  constructor(t, e, i) {
    super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._triggerArray = [];
    const n = d.find(na);
    for (let o = 0, r = n.length; o < r; o++) {
      const a = n[o], l = lr(a), p = d.find(l).filter(
        (u) => u === this._element
      );
      l !== null && p.length && (this._selector = l, this._triggerArray.push(a));
    }
    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
  }
  // Getters
  static get Default() {
    return ea;
  }
  static get NAME() {
    return Bn;
  }
  // Public
  toggle() {
    this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (this._isTransitioning || this._isShown())
      return;
    let t = [], e;
    if (this._config.parent) {
      const u = d.find(
        sa,
        this._config.parent
      );
      t = d.find(
        Zu,
        this._config.parent
      ).filter((_) => !u.includes(_));
    }
    const i = d.findOne(this._selector);
    if (t.length) {
      const u = t.find((_) => i !== _);
      if (e = u ? Qt.getInstance(u) : null, e && e._isTransitioning)
        return;
    }
    if (c.trigger(this._element, ju).defaultPrevented)
      return;
    t.forEach((u) => {
      i !== u && Qt.getOrCreateInstance(u, { toggle: !1 }).hide(), e || A.setData(u, Zc, null);
    });
    const o = this._getDimension(), r = o === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    h.removeClass(this._element, this._classes.visible), h.removeClass(this._element, this._classes.hidden), h.addClass(this._element, r), this._element.removeAttribute(We), this._element.setAttribute(rs, ""), this._element.style[o] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
    const a = () => {
      this._isTransitioning = !1, h.removeClass(this._element, this._classes.hidden), h.removeClass(this._element, r), h.addClass(this._element, this._classes.visible), this._element.removeAttribute(rs), this._element.setAttribute(We, ""), this._element.setAttribute(Hn, ""), this._element.style[o] = "", c.trigger(this._element, Ku);
    }, p = `scroll${o[0].toUpperCase() + o.slice(1)}`;
    this._queueCallback(a, this._element, !0), this._element.style[o] = `${this._element[p]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown() || c.trigger(this._element, zu).defaultPrevented)
      return;
    const e = this._getDimension(), i = e === "height" ? this._classes.collapsing : this._classes.collapsingHorizontal;
    this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, si(this._element), h.addClass(this._element, i), h.removeClass(this._element, this._classes.visible), h.removeClass(this._element, this._classes.hidden), this._element.setAttribute(rs, ""), this._element.removeAttribute(We), this._element.removeAttribute(Hn);
    const n = this._triggerArray.length;
    for (let r = 0; r < n; r++) {
      const a = this._triggerArray[r], l = te(a);
      l && !this._isShown(l) && this._addAriaAndCollapsedClass([a], !1);
    }
    this._isTransitioning = !0;
    const o = () => {
      this._isTransitioning = !1, h.removeClass(this._element, i), h.addClass(this._element, this._classes.visible), h.addClass(this._element, this._classes.hidden), this._element.removeAttribute(rs), this._element.setAttribute(We, ""), c.trigger(this._element, Uu);
    };
    this._element.style[e] = "", this._queueCallback(o, this._element, !0);
  }
  _isShown(t = this._element) {
    return t.hasAttribute(Hn);
  }
  // Private
  _getConfig(t) {
    return t = {
      ...ea,
      ...h.getDataAttributes(this._element),
      ...t
    }, t.toggle = !!t.toggle, t.parent = ee(t.parent), I(Bn, t, Yu), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...Qu,
      ...e,
      ...t
    }, I(Bn, t, Ju), t;
  }
  _getDimension() {
    return this._element.hasAttribute(Xu) ? Gu : qu;
  }
  _initializeChildren() {
    if (!this._config.parent)
      return;
    const t = d.find(
      sa,
      this._config.parent
    );
    d.find(na, this._config.parent).filter((e) => !t.includes(e)).forEach((e) => {
      const i = te(e);
      i && this._addAriaAndCollapsedClass([e], this._isShown(i));
    });
  }
  _addAriaAndCollapsedClass(t, e) {
    t.length && t.forEach((i) => {
      e ? i.removeAttribute(ia) : i.setAttribute(`${ia}`, ""), i.setAttribute("aria-expanded", e);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = {};
      typeof t == "string" && /show|hide/.test(t) && (e.toggle = !1);
      const i = Qt.getOrCreateInstance(this, e);
      if (typeof t == "string") {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t]();
      }
    });
  }
}
const oa = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", ra = ".sticky-top";
class ti {
  constructor() {
    this._element = document.body;
  }
  getWidth() {
    const t = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - t);
  }
  hide() {
    const t = this.getWidth();
    this._disableOverFlow(), this._setElementAttributes(
      this._element,
      "paddingRight",
      (e) => e + t
    ), this._setElementAttributes(
      oa,
      "paddingRight",
      (e) => e + t
    ), this._setElementAttributes(
      ra,
      "marginRight",
      (e) => e - t
    );
  }
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
  }
  _setElementAttributes(t, e, i) {
    const n = this.getWidth(), o = (r) => {
      if (r !== this._element && window.innerWidth > r.clientWidth + n)
        return;
      this._saveInitialAttribute(r, e);
      const a = window.getComputedStyle(r)[e];
      r.style[e] = `${i(
        Number.parseFloat(a)
      )}px`;
    };
    this._applyManipulationCallback(t, o);
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(oa, "paddingRight"), this._resetElementAttributes(ra, "marginRight");
  }
  _saveInitialAttribute(t, e) {
    const i = t.style[e];
    i && h.setDataAttribute(t, e, i);
  }
  _resetElementAttributes(t, e) {
    const i = (n) => {
      const o = h.getDataAttribute(n, e);
      typeof o > "u" ? n.style.removeProperty(e) : (h.removeDataAttribute(n, e), n.style[e] = o);
    };
    this._applyManipulationCallback(t, i);
  }
  _applyManipulationCallback(t, e) {
    Xe(t) ? e(t) : d.find(t, this._element).forEach(e);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
}
const tp = {
  isVisible: !0,
  // if false, we use the backdrop helper without adding any element to the dom
  isAnimated: !1,
  rootElement: "body",
  // give the choice to place backdrop under different elements
  clickCallback: null,
  backdropClasses: null
}, ep = {
  isVisible: "boolean",
  isAnimated: "boolean",
  rootElement: "(element|string)",
  clickCallback: "(function|null)",
  backdropClasses: "(array|string|null)"
}, Qc = "backdrop", aa = `mousedown.te.${Qc}`;
class Cr {
  constructor(t) {
    this._config = this._getConfig(t), this._isAppended = !1, this._element = null;
  }
  show(t) {
    if (!this._config.isVisible) {
      ge(t);
      return;
    }
    this._append(), this._config.isAnimated && si(this._getElement());
    const e = this._config.backdropClasses || [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      "fixed",
      "top-0",
      "left-0",
      "z-[1040]",
      "bg-black",
      "w-screen",
      "h-screen"
    ];
    h.removeClass(this._getElement(), "opacity-0"), h.addClass(this._getElement(), e), this._element.setAttribute("data-te-backdrop-show", ""), this._emulateAnimation(() => {
      ge(t);
    });
  }
  hide(t) {
    if (!this._config.isVisible) {
      ge(t);
      return;
    }
    this._element.removeAttribute("data-te-backdrop-show"), this._getElement().classList.add("opacity-0"), this._getElement().classList.remove("opacity-50"), this._emulateAnimation(() => {
      this.dispose(), ge(t);
    });
  }
  // Private
  _getElement() {
    if (!this._element) {
      const t = document.createElement("div");
      t.className = this._config.className, this._config.isAnimated && t.classList.add("opacity-50"), this._element = t;
    }
    return this._element;
  }
  _getConfig(t) {
    return t = {
      ...tp,
      ...typeof t == "object" ? t : {}
    }, t.rootElement = ee(t.rootElement), I(Qc, t, ep), t;
  }
  _append() {
    this._isAppended || (this._config.rootElement.append(this._getElement()), c.on(this._getElement(), aa, () => {
      ge(this._config.clickCallback);
    }), this._isAppended = !0);
  }
  dispose() {
    this._isAppended && (c.off(this._element, aa), this._element.remove(), this._isAppended = !1);
  }
  _emulateAnimation(t) {
    bc(
      t,
      this._getElement(),
      this._config.isAnimated
    );
  }
}
class zi {
  constructor(t, e = {}, i) {
    this._element = t, this._toggler = i, this._event = e.event || "blur", this._condition = e.condition || (() => !0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = (n) => {
      this._condition(n) && !n.shiftKey && n.target === this._lastElement ? (n.preventDefault(), this._firstElement.focus()) : this._condition(n) && n.shiftKey && n.target === this._firstElement && (n.preventDefault(), this._lastElement.focus());
    };
  }
  trap() {
    this._setElements(), this._init(), this._setFocusTrap();
  }
  disable() {
    this._focusableElements.forEach((t) => {
      t.removeEventListener(this._event, this.handler);
    }), this._toggler && this._toggler.focus();
  }
  update() {
    this._setElements(), this._setFocusTrap();
  }
  _init() {
    const t = (e) => {
      !this._firstElement || e.key !== "Tab" || this._focusableElements.includes(e.target) || (e.preventDefault(), this._firstElement.focus(), window.removeEventListener("keydown", t));
    };
    window.addEventListener("keydown", t);
  }
  _filterVisible(t) {
    return t.filter((e) => {
      if (!Mt(e))
        return !1;
      const i = d.parents(e, "*");
      for (let n = 0; n < i.length; n++) {
        const o = window.getComputedStyle(i[n]);
        if (o && (o.display === "none" || o.visibility === "hidden"))
          return !1;
      }
      return !0;
    });
  }
  _setElements() {
    this._focusableElements = d.focusableChildren(this._element), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1];
  }
  _setFocusTrap() {
    this._focusableElements.forEach((t, e) => {
      e === this._focusableElements.length - 1 || e === 0 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler);
    });
  }
}
let la = [];
const vn = (s, t = "hide") => {
  const e = `click.dismiss${s.EVENT_KEY}`, i = s.NAME;
  la.includes(i) || (la.push(i), c.on(
    document,
    e,
    `[data-te-${i}-dismiss]`,
    function(n) {
      if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), be(this))
        return;
      const o = te(this) || this.closest(`.${i}`) || this.closest(`[data-te-${i}-init]`);
      if (!o)
        return;
      s.getOrCreateInstance(o)[t]();
    }
  ));
}, ca = "offcanvas", ip = "te.offcanvas", oi = `.${ip}`, sp = ".data-api", np = `load${oi}${sp}`, op = "Escape", ha = {
  backdrop: !0,
  keyboard: !0,
  scroll: !1
}, rp = {
  backdrop: "boolean",
  keyboard: "boolean",
  scroll: "boolean"
}, da = "show", ap = "[data-te-offcanvas-init][data-te-offcanvas-show]", lp = `show${oi}`, cp = `shown${oi}`, hp = `hide${oi}`, dp = `hidden${oi}`, up = `keydown.dismiss${oi}`;
class js extends ft {
  constructor(t, e) {
    super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(), this._didInit = !1, this._init();
  }
  // Getters
  static get NAME() {
    return ca;
  }
  static get Default() {
    return ha;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    if (this._isShown || c.trigger(this._element, lp, {
      relatedTarget: t
    }).defaultPrevented)
      return;
    this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || new ti().hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.setAttribute(`data-te-offcanvas-${da}`, "");
    const i = () => {
      this._config.scroll || this._focustrap.trap(), c.trigger(this._element, cp, { relatedTarget: t });
    };
    this._queueCallback(i, this._element, !0);
  }
  hide() {
    if (!this._isShown || c.trigger(this._element, hp).defaultPrevented)
      return;
    this._focustrap.disable(), this._element.blur(), this._isShown = !1, this._element.removeAttribute(`data-te-offcanvas-${da}`), this._backdrop.hide();
    const e = () => {
      this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || new ti().reset(), c.trigger(this._element, dp);
    };
    this._queueCallback(e, this._element, !0);
  }
  dispose() {
    this._backdrop.dispose(), this._focustrap.disable(), super.dispose();
  }
  // Private
  _init() {
    this._didInit || (c.on(
      window,
      np,
      () => d.find(ap).forEach(
        (t) => js.getOrCreateInstance(t).show()
      )
    ), this._didInit = !0, vn(js));
  }
  _getConfig(t) {
    return t = {
      ...ha,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, I(ca, t, rp), t;
  }
  _initializeBackDrop() {
    return new Cr({
      isVisible: this._config.backdrop,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      clickCallback: () => this.hide()
    });
  }
  _initializeFocusTrap() {
    return new zi(this._element, {
      event: "keydown",
      condition: (t) => t.key === "Tab"
    });
  }
  _addEventListeners() {
    c.on(this._element, up, (t) => {
      this._config.keyboard && t.key === op && this.hide();
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = js.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const Vn = "alert", pp = "te.alert", Jc = `.${pp}`, _p = `close${Jc}`, fp = `closed${Jc}`, ui = "data-te-alert-show", mp = {
  animation: "boolean",
  autohide: "boolean",
  autoclose: "boolean",
  delay: "number"
}, ua = {
  animation: !0,
  autohide: !0,
  autoclose: !1,
  delay: 1e3
}, gp = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
}, bp = {
  fadeIn: "string",
  fadeOut: "string"
};
class Ko extends ft {
  constructor(t, e, i) {
    super(t), this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._didInit = !1, this._init();
  }
  // Getters
  static get DefaultType() {
    return mp;
  }
  static get Default() {
    return ua;
  }
  static get NAME() {
    return Vn;
  }
  // Public
  close() {
    if (c.trigger(this._element, _p).defaultPrevented)
      return;
    let e = 0;
    this._config.animation && (e = 300, h.addClass(this._element, this._classes.fadeOut)), this._element.removeAttribute(ui), setTimeout(() => {
      this._queueCallback(
        () => this._destroyElement(),
        this._element,
        this._config.animation
      );
    }, e);
  }
  show() {
    if (this._element) {
      if (this._config.autohide && this._setupAutohide(), (this._config.autoclose || this._config.autoclose && this._config.autohide) && this._setupAutoclose(), !this._element.hasAttribute(ui) && (h.removeClass(this._element, "hidden"), h.addClass(this._element, "block"), Mt(this._element))) {
        const t = (e) => {
          h.removeClass(this._element, "hidden"), h.addClass(this._element, "block"), c.off(e.target, "animationend", t);
        };
        this._element.setAttribute(ui, ""), c.on(this._element, "animationend", t);
      }
      this._config.animation && (h.removeClass(this._element, this._classes.fadeOut), h.addClass(this._element, this._classes.fadeIn));
    }
  }
  hide() {
    if (this._element && this._element.hasAttribute(ui)) {
      this._element.removeAttribute(ui);
      const t = (e) => {
        h.addClass(this._element, "hidden"), h.removeClass(this._element, "block"), this._timeout !== null && (clearTimeout(this._timeout), this._timeout = null), c.off(e.target, "animationend", t);
      };
      c.on(this._element, "animationend", t), h.removeClass(this._element, this._classes.fadeIn), h.addClass(this._element, this._classes.fadeOut);
    }
  }
  // Private
  _init() {
    this._didInit || (vn(Ko, "close"), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...ua,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, I(Vn, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...gp,
      ...e,
      ...t
    }, I(Vn, t, bp), t;
  }
  _setupAutohide() {
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _setupAutoclose() {
    this._timeout = setTimeout(() => {
      this.close();
    }, this._config.delay);
  }
  _destroyElement() {
    this._element.remove(), c.trigger(this._element, fp), this.dispose();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Ko.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const Wn = "carousel", vp = "te.carousel", mt = `.${vp}`, th = ".data-api", Tp = "ArrowLeft", Ep = "ArrowRight", Cp = 500, Ap = 40, pa = {
  interval: 5e3,
  keyboard: !0,
  ride: !1,
  pause: "hover",
  wrap: !0,
  touch: !0
}, yp = {
  interval: "(number|boolean)",
  keyboard: "boolean",
  ride: "(boolean|string)",
  pause: "(string|boolean)",
  wrap: "boolean",
  touch: "boolean"
}, wp = {
  pointer: "touch-pan-y",
  block: "!block",
  visible: "data-[te-carousel-fade]:opacity-100 data-[te-carousel-fade]:z-[1]",
  invisible: "data-[te-carousel-fade]:z-0 data-[te-carousel-fade]:opacity-0 data-[te-carousel-fade]:duration-[600ms] data-[te-carousel-fade]:delay-600",
  slideRight: "translate-x-full",
  slideLeft: "-translate-x-full"
}, kp = {
  pointer: "string",
  block: "string",
  visible: "string",
  invisible: "string",
  slideRight: "string",
  slideLeft: "string"
}, ce = "next", he = "prev", fe = "left", Ei = "right", xp = {
  [Tp]: Ei,
  [Ep]: fe
}, Op = `slide${mt}`, Fn = `slid${mt}`, Sp = `keydown${mt}`, Ip = `mouseenter${mt}`, Dp = `mouseleave${mt}`, $p = `touchstart${mt}`, Lp = `touchmove${mt}`, Np = `touchend${mt}`, Mp = `pointerdown${mt}`, Rp = `pointerup${mt}`, Pp = `dragstart${mt}`, Bp = `load${mt}${th}`, Hp = `click${mt}${th}`, _a = "data-te-carousel-init", de = "data-te-carousel-active", Vp = "data-te-carousel-item-end", Yn = "data-te-carousel-item-start", Wp = "data-te-carousel-item-next", Fp = "data-te-carousel-item-prev", Yp = "data-te-carousel-pointer-event", jp = "[data-te-carousel-init]", eh = "[data-te-carousel-active]", Ar = "[data-te-carousel-item]", Se = `${eh}${Ar}`, Kp = `${Ar} img`, zp = "[data-te-carousel-item-next], [data-te-carousel-item-prev]", Up = "[data-te-carousel-indicators]", Xp = "[data-te-target]", Gp = "[data-te-slide], [data-te-slide-to]", qp = "touch", Zp = "pen";
class Xt extends ft {
  constructor(t, e, i) {
    super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._indicatorsElement = d.findOne(
      Up,
      this._element
    ), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = !!window.PointerEvent, this._setActiveElementClass(), this._addEventListeners(), this._didInit = !1, this._init(), this._config.ride === "carousel" && this.cycle();
  }
  // Getters
  static get Default() {
    return pa;
  }
  static get NAME() {
    return Wn;
  }
  // Public
  next() {
    this._slide(ce);
  }
  nextWhenVisible() {
    !document.hidden && Mt(this._element) && this.next();
  }
  prev() {
    this._slide(he);
  }
  pause(t) {
    t || (this._isPaused = !0), d.findOne(zp, this._element) && (_c(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;
  }
  cycle(t) {
    t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval(
      (document.visibilityState ? this.nextWhenVisible : this.next).bind(
        this
      ),
      this._config.interval
    ));
  }
  to(t) {
    this._activeElement = d.findOne(
      Se,
      this._element
    );
    const e = this._getItemIndex(this._activeElement);
    if (t > this._items.length - 1 || t < 0)
      return;
    if (this._isSliding) {
      c.one(this._element, Fn, () => this.to(t));
      return;
    }
    if (e === t) {
      this.pause(), this.cycle();
      return;
    }
    const i = t > e ? ce : he;
    this._slide(i, this._items[t]);
  }
  // Private
  _init() {
    this._didInit || (c.on(
      document,
      Hp,
      Gp,
      Xt.dataApiClickHandler
    ), c.on(window, Bp, () => {
      const t = d.find(jp);
      for (let e = 0, i = t.length; e < i; e++)
        Xt.carouselInterface(
          t[e],
          Xt.getInstance(t[e])
        );
    }), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...pa,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, I(Wn, t, yp), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...wp,
      ...e,
      ...t
    }, I(Wn, t, kp), t;
  }
  _enableCycle() {
    if (this._config.ride) {
      if (this._isSliding) {
        c.one(this._element, Fn, () => this.cycle());
        return;
      }
      this.cycle();
    }
  }
  _applyInitialClasses() {
    const t = d.findOne(
      Se,
      this._element
    );
    t.classList.add(
      this._classes.block,
      ...this._classes.visible.split(" ")
    ), this._setActiveIndicatorElement(t);
  }
  _handleSwipe() {
    const t = Math.abs(this.touchDeltaX);
    if (t <= Ap)
      return;
    const e = t / this.touchDeltaX;
    this.touchDeltaX = 0, e && this._slide(e > 0 ? Ei : fe);
  }
  _setActiveElementClass() {
    this._activeElement = d.findOne(
      Se,
      this._element
    ), h.addClass(this._activeElement, "hidden");
  }
  _addEventListeners() {
    this._config.keyboard && c.on(
      this._element,
      Sp,
      (t) => this._keydown(t)
    ), this._config.pause === "hover" && (c.on(
      this._element,
      Ip,
      (t) => this.pause(t)
    ), c.on(
      this._element,
      Dp,
      (t) => this._enableCycle(t)
    )), this._config.touch && this._touchSupported && this._addTouchEventListeners(), this._applyInitialClasses();
  }
  _addTouchEventListeners() {
    const t = (o) => this._pointerEvent && (o.pointerType === Zp || o.pointerType === qp), e = (o) => {
      t(o) ? this.touchStartX = o.clientX : this._pointerEvent || (this.touchStartX = o.touches[0].clientX);
    }, i = (o) => {
      this.touchDeltaX = o.touches && o.touches.length > 1 ? 0 : o.touches[0].clientX - this.touchStartX;
    }, n = (o) => {
      t(o) && (this.touchDeltaX = o.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(
        (r) => this._enableCycle(r),
        Cp + this._config.interval
      ));
    };
    d.find(Kp, this._element).forEach(
      (o) => {
        c.on(
          o,
          Pp,
          (r) => r.preventDefault()
        );
      }
    ), this._pointerEvent ? (c.on(
      this._element,
      Mp,
      (o) => e(o)
    ), c.on(this._element, Rp, (o) => n(o)), this._element.classList.add(this._classes.pointer), this._element.setAttribute(`${Yp}`, "")) : (c.on(this._element, $p, (o) => e(o)), c.on(this._element, Lp, (o) => i(o)), c.on(this._element, Np, (o) => n(o)));
  }
  _keydown(t) {
    if (/input|textarea/i.test(t.target.tagName))
      return;
    const e = xp[t.key];
    e && (t.preventDefault(), this._slide(e));
  }
  _getItemIndex(t) {
    return this._items = t && t.parentNode ? d.find(Ar, t.parentNode) : [], this._items.indexOf(t);
  }
  _getItemByOrder(t, e) {
    const i = t === ce;
    return vc(
      this._items,
      e,
      i,
      this._config.wrap
    );
  }
  _triggerSlideEvent(t, e) {
    const i = this._getItemIndex(t), n = this._getItemIndex(
      d.findOne(Se, this._element)
    );
    return c.trigger(this._element, Op, {
      relatedTarget: t,
      direction: e,
      from: n,
      to: i
    });
  }
  _setActiveIndicatorElement(t) {
    if (this._indicatorsElement) {
      const e = d.findOne(
        eh,
        this._indicatorsElement
      );
      e.removeAttribute(de), e.removeAttribute("aria-current"), e.classList.remove("!opacity-100");
      const i = d.find(
        Xp,
        this._indicatorsElement
      );
      for (let n = 0; n < i.length; n++)
        if (Number.parseInt(
          i[n].getAttribute("data-te-slide-to"),
          10
        ) === this._getItemIndex(t)) {
          i[n].setAttribute(`${de}`, ""), i[n].setAttribute("aria-current", "true"), i[n].classList.add("!opacity-100");
          break;
        }
    }
  }
  _updateInterval() {
    const t = this._activeElement || d.findOne(Se, this._element);
    if (!t)
      return;
    const e = Number.parseInt(
      t.getAttribute("data-te-interval"),
      10
    );
    e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;
  }
  _slide(t, e) {
    const i = this._directionToOrder(t), n = d.findOne(
      Se,
      this._element
    ), o = this._getItemIndex(n), r = e || this._getItemByOrder(i, n), a = this._getItemIndex(r), l = !!this._interval, p = i === ce, u = p ? Yn : Vp, _ = p ? Wp : Fp, f = this._orderToDirection(i), g = u === Yn ? this._classes.slideLeft : this._classes.slideRight, m = u !== Yn ? this._classes.slideLeft : this._classes.slideRight;
    if (r && r.hasAttribute(de)) {
      this._isSliding = !1;
      return;
    }
    if (this._isSliding || this._triggerSlideEvent(r, f).defaultPrevented || !n || !r)
      return;
    this._isSliding = !0, l && this.pause(), this._setActiveIndicatorElement(r), this._activeElement = r;
    const v = () => {
      c.trigger(this._element, Fn, {
        relatedTarget: r,
        direction: f,
        from: o,
        to: a
      });
    };
    if (this._element.hasAttribute(_a)) {
      r.setAttribute(`${_}`, ""), r.classList.add(this._classes.block, m), si(r), n.setAttribute(`${u}`, ""), n.classList.add(
        g,
        ...this._classes.invisible.split(" ")
      ), n.classList.remove(...this._classes.visible.split(" ")), r.setAttribute(`${u}`, ""), r.classList.add(...this._classes.visible.split(" ")), r.classList.remove(
        this._classes.slideRight,
        this._classes.slideLeft
      );
      const T = () => {
        r.removeAttribute(u), r.removeAttribute(_), r.setAttribute(`${de}`, ""), n.removeAttribute(de), n.classList.remove(
          g,
          ...this._classes.invisible.split(" "),
          this._classes.block
        ), n.removeAttribute(_), n.removeAttribute(u), this._isSliding = !1, setTimeout(v, 0);
      };
      this._queueCallback(T, n, !0);
    } else
      n.removeAttribute(de), n.classList.remove(this._classes.block), r.setAttribute(`${de}`, ""), r.classList.add(this._classes.block), this._isSliding = !1, v();
    l && this.cycle();
  }
  _directionToOrder(t) {
    return [Ei, fe].includes(t) ? W() ? t === fe ? he : ce : t === fe ? ce : he : t;
  }
  _orderToDirection(t) {
    return [ce, he].includes(t) ? W() ? t === he ? fe : Ei : t === he ? Ei : fe : t;
  }
  // Static
  static carouselInterface(t, e) {
    const i = Xt.getOrCreateInstance(t, e);
    let { _config: n } = i;
    typeof e == "object" && (n = {
      ...n,
      ...e
    });
    const o = typeof e == "string" ? e : e.slide;
    if (typeof e == "number") {
      i.to(e);
      return;
    }
    if (typeof o == "string") {
      if (typeof i[o] > "u")
        throw new TypeError(`No method named "${o}"`);
      i[o]();
    } else
      n.interval && n.ride === !0 && i.pause();
  }
  static jQueryInterface(t) {
    return this.each(function() {
      Xt.carouselInterface(this, t);
    });
  }
  static dataApiClickHandler(t) {
    const e = te(this);
    if (!e || !e.hasAttribute(_a))
      return;
    const i = {
      ...h.getDataAttributes(e),
      ...h.getDataAttributes(this)
    }, n = this.getAttribute("data-te-slide-to");
    n && (i.interval = !1), Xt.carouselInterface(e, i), n && Xt.getInstance(e).to(n), t.preventDefault();
  }
}
const jn = "modal", Qp = "te.modal", yt = `.${Qp}`, fa = "Escape", ma = {
  backdrop: !0,
  keyboard: !0,
  focus: !0,
  modalNonInvasive: !1
}, Jp = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  focus: "boolean",
  modalNonInvasive: "boolean"
}, t_ = {
  show: "transform-none",
  static: "scale-[1.02]",
  staticProperties: "transition-scale duration-300 ease-in-out",
  backdrop: "opacity-50 transition-all duration-300 ease-in-out fixed top-0 left-0 z-[1040] bg-black w-screen h-screen"
}, e_ = {
  show: "string",
  static: "string",
  staticProperties: "string",
  backdrop: "string"
}, i_ = `hide${yt}`, s_ = `hidePrevented${yt}`, n_ = `hidden${yt}`, o_ = `show${yt}`, r_ = `shown${yt}`, ga = `resize${yt}`, ba = `click.dismiss${yt}`, va = `keydown.dismiss${yt}`, a_ = `mouseup.dismiss${yt}`, Ta = `mousedown.dismiss${yt}`, Ea = "data-te-modal-open", Ca = "data-te-open", pi = "[data-te-modal-dialog-ref]", l_ = "[data-te-modal-body-ref]";
class zo extends ft {
  constructor(t, e, i) {
    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._dialog = d.findOne(pi, this._element), this._backdrop = this._config.modalNonInvasive ? null : this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new ti(), this._didInit = !1, this._init();
  }
  // Getters
  static get Default() {
    return ma;
  }
  static get NAME() {
    return jn;
  }
  // Public
  toggle(t) {
    return this._isShown ? this.hide() : this.show(t);
  }
  show(t) {
    this._isShown || this._isTransitioning || c.trigger(this._element, o_, {
      relatedTarget: t
    }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), !this._config.modalNonInvasive && this._scrollBar.hide(), document.body.setAttribute(Ea, "true"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), c.on(this._dialog, Ta, () => {
      c.one(this._element, a_, (i) => {
        i.target === this._element && (this._ignoreBackdropClick = !0);
      });
    }), this._showElement(t), !this._config.modalNonInvasive && this._showBackdrop());
  }
  hide() {
    if (!this._isShown || this._isTransitioning || c.trigger(this._element, i_).defaultPrevented)
      return;
    this._isShown = !1;
    const e = this._isAnimated();
    e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.disable(), d.findOne(pi, this._element).classList.remove(this._classes.show), c.off(this._element, ba), c.off(this._dialog, Ta), this._queueCallback(() => this._hideModal(), this._element, e), this._element.removeAttribute(Ca);
  }
  dispose() {
    [window, document, this._dialog].forEach(
      (t) => c.off(t, yt)
    ), this._backdrop && this._backdrop.dispose(), this._focustrap.disable(), super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  // Private
  _init() {
    this._didInit || (vn(zo), this._didInit = !0);
  }
  _initializeBackDrop() {
    return new Cr({
      isVisible: !!this._config.backdrop,
      // 'static' option will be translated to true, and booleans will keep their value
      isAnimated: this._isAnimated(),
      backdropClasses: this._classes.backdrop
    });
  }
  _initializeFocusTrap() {
    return new zi(this._element, {
      event: "keydown",
      condition: (t) => t.key === "Tab"
    });
  }
  _getConfig(t) {
    return t = {
      ...ma,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" ? t : {}
    }, I(jn, t, Jp), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...t_,
      ...e,
      ...t
    }, I(jn, t, e_), t;
  }
  _showElement(t) {
    const e = this._isAnimated(), i = d.findOne(l_, this._dialog);
    (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element), this._element.style.display = "block", this._element.classList.remove("hidden"), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.setAttribute(`${Ca}`, "true"), this._element.scrollTop = 0;
    const n = d.findOne(pi, this._element);
    n.classList.add(this._classes.show), n.classList.remove("opacity-0"), n.classList.add("opacity-100"), i && (i.scrollTop = 0), e && si(this._element);
    const o = () => {
      this._config.focus && this._focustrap.trap(), this._isTransitioning = !1, c.trigger(this._element, r_, {
        relatedTarget: t
      });
    };
    this._queueCallback(o, this._dialog, e);
  }
  _setEscapeEvent() {
    this._isShown ? c.on(document, va, (t) => {
      this._config.keyboard && t.key === fa ? (t.preventDefault(), this.hide()) : !this._config.keyboard && t.key === fa && this._triggerBackdropTransition();
    }) : c.off(this._element, va);
  }
  _setResizeEvent() {
    this._isShown ? c.on(window, ga, () => this._adjustDialog()) : c.off(window, ga);
  }
  _hideModal() {
    const t = d.findOne(pi, this._element);
    t.classList.remove(this._classes.show), t.classList.remove("opacity-100"), t.classList.add("opacity-0");
    const e = cn(t);
    setTimeout(() => {
      this._element.style.display = "none";
    }, e), this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop && this._backdrop.hide(() => {
      document.body.removeAttribute(Ea), this._resetAdjustments(), !this._config.modalNonInvasive && this._scrollBar.reset(), c.trigger(this._element, n_);
    });
  }
  _showBackdrop(t) {
    c.on(this._element, ba, (e) => {
      if (this._ignoreBackdropClick) {
        this._ignoreBackdropClick = !1;
        return;
      }
      e.target === e.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === "static" && this._triggerBackdropTransition());
    }), this._backdrop && this._backdrop.show(t);
  }
  _isAnimated() {
    return !!d.findOne(pi, this._element);
  }
  _triggerBackdropTransition() {
    if (c.trigger(this._element, s_).defaultPrevented)
      return;
    const { classList: e, scrollHeight: i, style: n } = this._element, o = i > document.documentElement.clientHeight;
    if (!o && n.overflowY === "hidden" || e.contains(this._classes.static))
      return;
    o || (n.overflowY = "hidden"), e.add(...this._classes.static.split(" ")), e.add(...this._classes.staticProperties.split(" "));
    const r = cn(this._element);
    this._queueCallback(() => {
      e.remove(this._classes.static), setTimeout(() => {
        e.remove(...this._classes.staticProperties.split(" "));
      }, r), o || this._queueCallback(() => {
        n.overflowY = "";
      }, this._dialog);
    }, this._dialog), this._element.focus();
  }
  // ----------------------------------------------------------------------
  // the following methods are used to handle overflowing modals
  // ----------------------------------------------------------------------
  _adjustDialog() {
    const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), i = e > 0;
    (!i && t && !W() || i && !t && W()) && (this._element.style.paddingLeft = `${e}px`), (i && !t && !W() || !i && t && W()) && (this._element.style.paddingRight = `${e}px`);
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      const i = zo.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
}
const c_ = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), ih = /^aria-[\w-]*$/i, h_ = /^data-te-[\w-]*$/i, d_ = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, u_ = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, p_ = (s, t) => {
  const e = s.nodeName.toLowerCase();
  if (t.includes(e))
    return c_.has(e) ? !!(d_.test(s.nodeValue) || u_.test(s.nodeValue)) : !0;
  const i = t.filter(
    (n) => n instanceof RegExp
  );
  for (let n = 0, o = i.length; n < o; n++)
    if (i[n].test(e))
      return !0;
  return !1;
}, sh = {
  // Global attributes allowed on any supplied element below.
  "*": [
    "class",
    "dir",
    "id",
    "lang",
    "role",
    ih,
    h_
  ],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, __ = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", ih],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
function pn(s, t, e) {
  if (!s.length)
    return s;
  if (e && typeof e == "function")
    return e(s);
  const n = new window.DOMParser().parseFromString(s, "text/html"), o = [].concat(...n.body.querySelectorAll("*"));
  for (let r = 0, a = o.length; r < a; r++) {
    const l = o[r], p = l.nodeName.toLowerCase();
    if (!Object.keys(t).includes(p)) {
      l.remove();
      continue;
    }
    const u = [].concat(...l.attributes), _ = [].concat(
      t["*"] || [],
      t[p] || []
    );
    u.forEach((f) => {
      p_(f, _) || l.removeAttribute(f.nodeName);
    });
  }
  return n.body.innerHTML;
}
const Aa = "tooltip", f_ = "te.tooltip", kt = `.${f_}`, m_ = "te-tooltip", g_ = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), b_ = {
  animation: "boolean",
  template: "string",
  title: "(string|element|function)",
  trigger: "string",
  delay: "(number|object)",
  html: "boolean",
  selector: "(string|boolean)",
  placement: "(string|function)",
  offset: "(array|string|function)",
  container: "(string|element|boolean)",
  fallbackPlacements: "array",
  boundary: "(string|element)",
  customClass: "(string|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  allowList: "object",
  popperConfig: "(null|object|function)"
}, v_ = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: W() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: W() ? "right" : "left"
}, T_ = {
  animation: !0,
  template: '<div class="opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal" role="tooltip"><div data-te-tooltip-inner-ref class="tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded"></div></div>',
  trigger: "hover focus",
  title: "",
  delay: 0,
  html: !1,
  selector: !1,
  placement: "top",
  offset: [0, 0],
  container: !1,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  boundary: "clippingParents",
  customClass: "",
  sanitize: !0,
  sanitizeFn: null,
  allowList: __,
  popperConfig: { hide: !0 }
}, E_ = {
  HIDE: `hide${kt}`,
  HIDDEN: `hidden${kt}`,
  SHOW: `show${kt}`,
  SHOWN: `shown${kt}`,
  INSERTED: `inserted${kt}`,
  CLICK: `click${kt}`,
  FOCUSIN: `focusin${kt}`,
  FOCUSOUT: `focusout${kt}`,
  MOUSEENTER: `mouseenter${kt}`,
  MOUSELEAVE: `mouseleave${kt}`
}, C_ = "fade", A_ = "modal", Kn = "show", _i = "show", zn = "out", ya = ".tooltip-inner", wa = `.${A_}`, ka = "hide.te.modal", fi = "hover", Un = "focus", y_ = "click", w_ = "manual";
class ri extends ft {
  constructor(t, e) {
    if (typeof qc > "u")
      throw new TypeError(
        "Bootstrap's tooltips require Popper (https://popper.js.org)"
      );
    super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();
  }
  // Getters
  static get Default() {
    return T_;
  }
  static get NAME() {
    return Aa;
  }
  static get Event() {
    return E_;
  }
  static get DefaultType() {
    return b_;
  }
  // Public
  enable() {
    this._isEnabled = !0;
  }
  disable() {
    this._isEnabled = !1;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle(t) {
    if (this._isEnabled)
      if (t) {
        const e = this._initializeOnDelegatedTarget(t);
        e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);
      } else {
        if (this.getTipElement().classList.contains(Kn)) {
          this._leave(null, this);
          return;
        }
        this._enter(null, this);
      }
  }
  dispose() {
    clearTimeout(this._timeout), c.off(
      this._element.closest(wa),
      ka,
      this._hideModalHandler
    ), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();
  }
  show() {
    if (this._element.style.display === "none")
      throw new Error("Please use show on visible elements");
    if (!(this.isWithContent() && this._isEnabled))
      return;
    const t = c.trigger(
      this._element,
      this.constructor.Event.SHOW
    ), e = fc(this._element), i = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);
    if (t.defaultPrevented || !i)
      return;
    this.constructor.NAME === "tooltip" && this.tip && this.getTitle() !== this.tip.querySelector(ya).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);
    const n = this.getTipElement(), o = et(this.constructor.NAME);
    n.setAttribute("id", o), this._element.setAttribute("aria-describedby", o), this._config.animation && setTimeout(() => {
      this.tip.classList.add("opacity-100"), this.tip.classList.remove("opacity-0");
    }, 100);
    const r = typeof this._config.placement == "function" ? this._config.placement.call(this, n, this._element) : this._config.placement, a = this._getAttachment(r);
    this._addAttachmentClass(a);
    const { container: l } = this._config;
    if (A.setData(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), c.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = se(
      this._element,
      n,
      this._getPopperConfig(a)
    ), n.getAttribute("id").includes("tooltip"))
      switch (r) {
        case "bottom":
          n.classList.add("py-[0.4rem]");
          break;
        case "left":
          n.classList.add("px-[0.4rem]");
          break;
        case "right":
          n.classList.add("px-[0.4rem]");
          break;
        default:
          n.classList.add("py-[0.4rem]");
          break;
      }
    const u = this._resolvePossibleFunction(this._config.customClass);
    u && n.classList.add(...u.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((g) => {
      c.on(g, "mouseover", hn);
    });
    const _ = () => {
      const g = this._hoverState;
      this._hoverState = null, c.trigger(this._element, this.constructor.Event.SHOWN), g === zn && this._leave(null, this);
    }, f = this.tip.classList.contains("transition-opacity");
    this._queueCallback(_, this.tip, f);
  }
  hide() {
    if (!this._popper)
      return;
    const t = this.getTipElement(), e = () => {
      this._isWithActiveTrigger() || (this._hoverState !== _i && t.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), c.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());
    };
    if (c.trigger(
      this._element,
      this.constructor.Event.HIDE
    ).defaultPrevented)
      return;
    t.classList.add("opacity-0"), t.classList.remove("opacity-100"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((o) => c.off(o, "mouseover", hn)), this._activeTrigger[y_] = !1, this._activeTrigger[Un] = !1, this._activeTrigger[fi] = !1;
    const n = this.tip.classList.contains("opacity-0");
    this._queueCallback(e, this.tip, n), this._hoverState = "";
  }
  update() {
    this._popper !== null && this._popper.update();
  }
  // Protected
  isWithContent() {
    return !!this.getTitle();
  }
  getTipElement() {
    if (this.tip)
      return this.tip;
    const t = document.createElement("div");
    t.innerHTML = this._config.template;
    const e = t.children[0];
    return this.setContent(e), e.classList.remove(C_, Kn), this.tip = e, this.tip;
  }
  setContent(t) {
    this._sanitizeAndSetContent(t, this.getTitle(), ya);
  }
  _sanitizeAndSetContent(t, e, i) {
    const n = d.findOne(i, t);
    if (!e && n) {
      n.remove();
      return;
    }
    this.setElementContent(n, e);
  }
  setElementContent(t, e) {
    if (t !== null) {
      if (Xe(e)) {
        e = ee(e), this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent;
        return;
      }
      this._config.html ? (this._config.sanitize && (e = pn(
        e,
        this._config.allowList,
        this._config.sanitizeFn
      )), t.innerHTML = e) : t.textContent = e;
    }
  }
  getTitle() {
    const t = this._element.getAttribute("data-te-original-title") || this._config.title;
    return this._resolvePossibleFunction(t);
  }
  updateAttachment(t) {
    return t === "right" ? "end" : t === "left" ? "start" : t;
  }
  // Private
  _initializeOnDelegatedTarget(t, e) {
    return e || this.constructor.getOrCreateInstance(
      t.delegateTarget,
      this._getDelegateConfig()
    );
  }
  _getOffset() {
    const { offset: t } = this._config;
    return typeof t == "string" ? t.split(",").map((e) => Number.parseInt(e, 10)) : typeof t == "function" ? (e) => t(e, this._element) : t;
  }
  _resolvePossibleFunction(t) {
    return typeof t == "function" ? t.call(this._element) : t;
  }
  _getPopperConfig(t) {
    const e = {
      placement: t,
      modifiers: [
        {
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        },
        {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        },
        {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        },
        {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        },
        {
          name: "onChange",
          enabled: !0,
          phase: "afterWrite",
          fn: (i) => this._handlePopperPlacementChange(i)
        }
      ],
      onFirstUpdate: (i) => {
        i.options.placement !== i.placement && this._handlePopperPlacementChange(i);
      }
    };
    return {
      ...e,
      ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(e) : this._config.popperConfig
    };
  }
  _addAttachmentClass(t) {
    this.getTipElement().classList.add(
      `${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`
    );
  }
  _getAttachment(t) {
    return v_[t.toUpperCase()];
  }
  _setListeners() {
    this._config.trigger.split(" ").forEach((e) => {
      if (e === "click")
        c.on(
          this._element,
          this.constructor.Event.CLICK,
          this._config.selector,
          (i) => this.toggle(i)
        );
      else if (e !== w_) {
        const i = e === fi ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = e === fi ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
        c.on(
          this._element,
          i,
          this._config.selector,
          (o) => this._enter(o)
        ), c.on(
          this._element,
          n,
          this._config.selector,
          (o) => this._leave(o)
        );
      }
    }), this._hideModalHandler = () => {
      this._element && this.hide();
    }, c.on(
      this._element.closest(wa),
      ka,
      this._hideModalHandler
    ), this._config.selector ? this._config = {
      ...this._config,
      trigger: "manual",
      selector: ""
    } : this._fixTitle();
  }
  _fixTitle() {
    const t = this._element.getAttribute("title"), e = typeof this._element.getAttribute(
      "data-te-original-title"
    );
    (t || e !== "string") && (this._element.setAttribute("data-te-original-title", t || ""), t && !this._element.getAttribute("aria-label") && !this._element.textContent && this._element.setAttribute("aria-label", t), this._element.setAttribute("title", ""));
  }
  _enter(t, e) {
    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusin" ? Un : fi] = !0), e.getTipElement().classList.contains(Kn) || e._hoverState === _i) {
      e._hoverState = _i;
      return;
    }
    if (clearTimeout(e._timeout), e._hoverState = _i, !e._config.delay || !e._config.delay.show) {
      e.show();
      return;
    }
    e._timeout = setTimeout(() => {
      e._hoverState === _i && e.show();
    }, e._config.delay.show);
  }
  _leave(t, e) {
    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusout" ? Un : fi] = e._element.contains(t.relatedTarget)), !e._isWithActiveTrigger()) {
      if (clearTimeout(e._timeout), e._hoverState = zn, !e._config.delay || !e._config.delay.hide) {
        e.hide();
        return;
      }
      e._timeout = setTimeout(() => {
        e._hoverState === zn && e.hide();
      }, e._config.delay.hide);
    }
  }
  _isWithActiveTrigger() {
    for (const t in this._activeTrigger)
      if (this._activeTrigger[t])
        return !0;
    return !1;
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return Object.keys(e).forEach((i) => {
      g_.has(i) && delete e[i];
    }), t = {
      ...this.constructor.Default,
      ...e,
      ...typeof t == "object" && t ? t : {}
    }, t.container = t.container === !1 ? document.body : ee(t.container), typeof t.delay == "number" && (t.delay = {
      show: t.delay,
      hide: t.delay
    }), typeof t.title == "number" && (t.title = t.title.toString()), typeof t.content == "number" && (t.content = t.content.toString()), I(Aa, t, this.constructor.DefaultType), t.sanitize && (t.template = pn(
      t.template,
      t.allowList,
      t.sanitizeFn
    )), t;
  }
  _getDelegateConfig() {
    const t = {};
    for (const e in this._config)
      this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);
    return t;
  }
  _cleanTipClass() {
    const t = this.getTipElement(), e = new RegExp(
      `(^|\\s)${this._getBasicClassPrefix()}\\S+`,
      "g"
    ), i = t.getAttribute("class").match(e);
    i !== null && i.length > 0 && i.map((n) => n.trim()).forEach((n) => t.classList.remove(n));
  }
  _getBasicClassPrefix() {
    return m_;
  }
  _handlePopperPlacementChange(t) {
    const { state: e } = t;
    e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));
  }
  _disposePopper() {
    this._popper && (this._popper.destroy(), this._popper = null);
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = ri.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const k_ = "popover", x_ = "te.popover", xt = `.${x_}`, O_ = "te-popover", S_ = {
  ...ri.Default,
  placement: "right",
  offset: [0, 8],
  trigger: "click",
  content: "",
  template: '<div class="opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_0px_3px_0_rgba(0,0,0,0.07),0_2px_2px_0_rgba(0,0,0,0.04)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white data-[popper-reference-hidden]:hidden" role="tooltip"><h3 class="popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500"></h3><div class="popover-body p-4 text-[#212529] dark:text-white"></div></div>'
}, I_ = {
  ...ri.DefaultType,
  content: "(string|element|function)"
}, D_ = {
  HIDE: `hide${xt}`,
  HIDDEN: `hidden${xt}`,
  SHOW: `show${xt}`,
  SHOWN: `shown${xt}`,
  INSERTED: `inserted${xt}`,
  CLICK: `click${xt}`,
  FOCUSIN: `focusin${xt}`,
  FOCUSOUT: `focusout${xt}`,
  MOUSEENTER: `mouseenter${xt}`,
  MOUSELEAVE: `mouseleave${xt}`
}, $_ = ".popover-header", L_ = ".popover-body";
class nh extends ri {
  // Getters
  static get Default() {
    return S_;
  }
  static get NAME() {
    return k_;
  }
  static get Event() {
    return D_;
  }
  static get DefaultType() {
    return I_;
  }
  // Overrides
  isWithContent() {
    return this.getTitle() || this._getContent();
  }
  setContent(t) {
    this._sanitizeAndSetContent(t, this.getTitle(), $_), this._sanitizeAndSetContent(t, this._getContent(), L_);
  }
  // Private
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  _getBasicClassPrefix() {
    return O_;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = nh.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const Xn = "scrollspy", N_ = "te.scrollspy", yr = `.${N_}`, xa = {
  offset: 10,
  method: "auto",
  target: ""
}, M_ = {
  offset: "number",
  method: "string",
  target: "(string|element)"
}, R_ = {
  active: "!text-primary dark:!text-primary-400 font-semibold border-l-[0.125rem] border-solid border-primary dark:border-primary-400"
}, P_ = {
  active: "string"
}, B_ = `activate${yr}`, H_ = `scroll${yr}`, Gn = "data-te-nav-link-active", oh = "[data-te-dropdown-item-ref]", V_ = "[data-te-nav-list-ref]", Uo = "[data-te-nav-link-ref]", W_ = "[data-te-nav-item-ref]", rh = "[data-te-list-group-item-ref]", qn = `${Uo}, ${rh}, ${oh}`, F_ = "[data-te-dropdown-ref]", Y_ = "[data-te-dropdown-toggle-ref]", j_ = "maxOffset", Oa = "position";
class ah extends ft {
  constructor(t, e, i) {
    super(t), this._scrollElement = this._element.tagName === "BODY" ? window : this._element, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, c.on(this._scrollElement, H_, () => this._process()), this.refresh(), this._process();
  }
  // Getters
  static get Default() {
    return xa;
  }
  static get NAME() {
    return Xn;
  }
  // Public
  refresh() {
    const t = this._scrollElement === this._scrollElement.window ? j_ : Oa, e = this._config.method === "auto" ? t : this._config.method, i = e === Oa ? this._getScrollTop() : 0;
    this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), d.find(
      qn,
      this._config.target
    ).map((o) => {
      const r = lr(o), a = r ? d.findOne(r) : null;
      if (a) {
        const l = a.getBoundingClientRect();
        if (l.width || l.height)
          return [
            h[e](a).top + i,
            r
          ];
      }
      return null;
    }).filter((o) => o).sort((o, r) => o[0] - r[0]).forEach((o) => {
      this._offsets.push(o[0]), this._targets.push(o[1]);
    });
  }
  dispose() {
    c.off(this._scrollElement, yr), super.dispose();
  }
  // Private
  _getConfig(t) {
    return t = {
      ...xa,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, t.target = ee(t.target) || document.documentElement, I(Xn, t, M_), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...R_,
      ...e,
      ...t
    }, I(Xn, t, P_), t;
  }
  _getScrollTop() {
    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
  }
  _getScrollHeight() {
    return this._scrollElement.scrollHeight || Math.max(
      document.body.scrollHeight,
      document.documentElement.scrollHeight
    );
  }
  _getOffsetHeight() {
    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
  }
  _process() {
    const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), i = this._config.offset + e - this._getOffsetHeight();
    if (this._scrollHeight !== e && this.refresh(), t >= i) {
      const n = this._targets[this._targets.length - 1];
      this._activeTarget !== n && this._activate(n);
      return;
    }
    if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) {
      this._activeTarget = null, this._clear();
      return;
    }
    for (let n = this._offsets.length; n--; )
      this._activeTarget !== this._targets[n] && t >= this._offsets[n] && (typeof this._offsets[n + 1] > "u" || t < this._offsets[n + 1]) && this._activate(this._targets[n]);
  }
  _activate(t) {
    this._activeTarget = t, this._clear();
    const e = qn.split(",").map(
      (n) => `${n}[data-te-target="${t}"],${n}[href="${t}"]`
    ), i = d.findOne(e.join(","), this._config.target);
    i.classList.add(...this._classes.active.split(" ")), i.setAttribute(Gn, ""), i.getAttribute(oh) ? d.findOne(
      Y_,
      i.closest(F_)
    ).classList.add(...this._classes.active.split(" ")) : d.parents(i, V_).forEach(
      (n) => {
        d.prev(
          n,
          `${Uo}, ${rh}`
        ).forEach((o) => {
          o.classList.add(...this._classes.active.split(" ")), o.setAttribute(Gn, "");
        }), d.prev(n, W_).forEach(
          (o) => {
            d.children(o, Uo).forEach(
              (r) => r.classList.add(...this._classes.active.split(" "))
            );
          }
        );
      }
    ), c.trigger(this._scrollElement, B_, {
      relatedTarget: t
    });
  }
  _clear() {
    d.find(qn, this._config.target).filter(
      (t) => t.classList.contains(...this._classes.active.split(" "))
    ).forEach((t) => {
      t.classList.remove(...this._classes.active.split(" ")), t.removeAttribute(Gn);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = ah.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const Sa = "tab", K_ = "te.tab", Tn = `.${K_}`, z_ = `hide${Tn}`, U_ = `hidden${Tn}`, X_ = `show${Tn}`, G_ = `shown${Tn}`, q_ = "data-te-dropdown-menu-ref", He = "data-te-tab-active", Ks = "data-te-nav-active", Z_ = "[data-te-dropdown-ref]", Q_ = "[data-te-nav-ref]", Ia = `[${He}]`, J_ = `[${Ks}]`, Da = ":scope > li > .active", tf = "[data-te-dropdown-toggle-ref]", ef = ":scope > [data-te-dropdown-menu-ref] [data-te-dropdown-show]", sf = {
  show: "opacity-100",
  hide: "opacity-0"
}, nf = {
  show: "string",
  hide: "string"
};
class lh extends ft {
  constructor(t, e) {
    super(t), this._classes = this._getClasses(e);
  }
  // Getters
  static get NAME() {
    return Sa;
  }
  // Public
  show() {
    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.getAttribute(Ks) === "")
      return;
    let t;
    const e = te(this._element), i = this._element.closest(Q_), n = d.findOne(
      J_,
      i
    );
    if (i) {
      const l = i.nodeName === "UL" || i.nodeName === "OL" ? Da : Ia;
      t = d.find(l, i), t = t[t.length - 1];
    }
    const o = t ? c.trigger(t, z_, {
      relatedTarget: this._element
    }) : null;
    if (c.trigger(this._element, X_, {
      relatedTarget: t
    }).defaultPrevented || o !== null && o.defaultPrevented)
      return;
    this._activate(
      this._element,
      i,
      null,
      n,
      this._element
    );
    const a = () => {
      c.trigger(t, U_, {
        relatedTarget: this._element
      }), c.trigger(this._element, G_, {
        relatedTarget: t
      });
    };
    e ? this._activate(
      e,
      e.parentNode,
      a,
      n,
      this._element
    ) : a();
  }
  // Private
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...sf,
      ...e,
      ...t
    }, I(Sa, t, nf), t;
  }
  _activate(t, e, i, n, o) {
    const a = (e && (e.nodeName === "UL" || e.nodeName === "OL") ? d.find(Da, e) : d.children(e, Ia))[0], l = i && a && a.hasAttribute(He), p = () => this._transitionComplete(
      t,
      a,
      i,
      n,
      o
    );
    a && l ? (h.removeClass(a, this._classes.show), h.addClass(a, this._classes.hide), this._queueCallback(p, t, !0)) : p();
  }
  _transitionComplete(t, e, i, n, o) {
    if (e && n) {
      e.removeAttribute(He), n.removeAttribute(Ks);
      const a = d.findOne(
        ef,
        e.parentNode
      );
      a && a.removeAttribute(He), e.getAttribute("role") === "tab" && e.setAttribute("aria-selected", !1);
    }
    t.setAttribute(He, ""), o.setAttribute(Ks, ""), t.getAttribute("role") === "tab" && t.setAttribute("aria-selected", !0), si(t), t.classList.contains(this._classes.hide) && (h.removeClass(t, this._classes.hide), h.addClass(t, this._classes.show));
    let r = t.parentNode;
    if (r && r.nodeName === "LI" && (r = r.parentNode), r && r.hasAttribute(q_)) {
      const a = t.closest(Z_);
      a && d.find(tf, a).forEach(
        (l) => l.setAttribute(He, "")
      ), t.setAttribute("aria-expanded", !0);
    }
    i && i();
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = lh.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
}
const Zn = "toast", of = "te.toast", ne = `.${of}`, rf = `mouseover${ne}`, af = `mouseout${ne}`, lf = `focusin${ne}`, cf = `focusout${ne}`, hf = `hide${ne}`, df = `hidden${ne}`, uf = `show${ne}`, pf = `shown${ne}`, $a = "data-te-toast-hide", Qn = "data-te-toast-show", as = "data-te-toast-showing", _f = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
}, La = {
  animation: !0,
  autohide: !0,
  delay: 5e3
}, ff = {
  fadeIn: "animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none",
  fadeOut: "animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none"
}, mf = {
  fadeIn: "string",
  fadeOut: "string"
};
class Xo extends ft {
  constructor(t, e, i) {
    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners(), this._didInit = !1, this._init();
  }
  // Getters
  static get DefaultType() {
    return _f;
  }
  static get Default() {
    return La;
  }
  static get NAME() {
    return Zn;
  }
  // Public
  show() {
    if (c.trigger(this._element, uf).defaultPrevented)
      return;
    this._clearTimeout(), this._config.animation && (h.removeClass(this._element, this._classes.fadeOut), h.addClass(this._element, this._classes.fadeIn));
    const e = () => {
      this._element.removeAttribute(as), c.trigger(this._element, pf), this._maybeScheduleHide();
    };
    this._element.removeAttribute($a), si(this._element), this._element.setAttribute(Qn, ""), this._element.setAttribute(as, ""), this._queueCallback(e, this._element, this._config.animation);
  }
  hide() {
    if (!this._element || this._element.dataset.teToastShow === void 0 || c.trigger(this._element, hf).defaultPrevented)
      return;
    const e = () => {
      let i = 0;
      this._config.animation && (i = 300, h.removeClass(this._element, this._classes.fadeIn), h.addClass(this._element, this._classes.fadeOut)), setTimeout(() => {
        this._element.setAttribute($a, ""), this._element.removeAttribute(as), this._element.removeAttribute(Qn), c.trigger(this._element, df);
      }, i);
    };
    this._element.setAttribute(as, ""), this._queueCallback(e, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout(), this._element.dataset.teToastShow !== void 0 && this._element.removeAttribute(Qn), super.dispose();
  }
  // Private
  _init() {
    this._didInit || (vn(Xo), this._didInit = !0);
  }
  _getConfig(t) {
    return t = {
      ...La,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, I(Zn, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...ff,
      ...e,
      ...t
    }, I(Zn, t, mf), t;
  }
  _maybeScheduleHide() {
    this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay)));
  }
  _onInteraction(t, e) {
    switch (t.type) {
      case "mouseover":
      case "mouseout":
        this._hasMouseInteraction = e;
        break;
      case "focusin":
      case "focusout":
        this._hasKeyboardInteraction = e;
        break;
    }
    if (e) {
      this._clearTimeout();
      return;
    }
    const i = t.relatedTarget;
    this._element === i || this._element.contains(i) || this._maybeScheduleHide();
  }
  _setListeners() {
    c.on(
      this._element,
      rf,
      (t) => this._onInteraction(t, !0)
    ), c.on(
      this._element,
      af,
      (t) => this._onInteraction(t, !1)
    ), c.on(
      this._element,
      lf,
      (t) => this._onInteraction(t, !0)
    ), c.on(
      this._element,
      cf,
      (t) => this._onInteraction(t, !1)
    );
  }
  _clearTimeout() {
    clearTimeout(this._timeout), this._timeout = null;
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      const e = Xo.getOrCreateInstance(this, t);
      if (typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
(() => {
  var s = { 454: (i, n, o) => {
    o.d(n, { Z: () => l });
    var r = o(645), a = o.n(r)()(function(p) {
      return p[1];
    });
    a.push([i.id, "INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}", ""]);
    const l = a;
  }, 645: (i) => {
    i.exports = function(n) {
      var o = [];
      return o.toString = function() {
        return this.map(function(r) {
          var a = n(r);
          return r[2] ? "@media ".concat(r[2], " {").concat(a, "}") : a;
        }).join("");
      }, o.i = function(r, a, l) {
        typeof r == "string" && (r = [[null, r, ""]]);
        var p = {};
        if (l)
          for (var u = 0; u < this.length; u++) {
            var _ = this[u][0];
            _ != null && (p[_] = !0);
          }
        for (var f = 0; f < r.length; f++) {
          var g = [].concat(r[f]);
          l && p[g[0]] || (a && (g[2] ? g[2] = "".concat(a, " and ").concat(g[2]) : g[2] = a), o.push(g));
        }
      }, o;
    };
  }, 810: () => {
    (function() {
      if (typeof window < "u")
        try {
          var i = new window.CustomEvent("test", { cancelable: !0 });
          if (i.preventDefault(), i.defaultPrevented !== !0)
            throw new Error("Could not prevent default");
        } catch {
          var n = function(r, a) {
            var l, p;
            return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent("CustomEvent")).initCustomEvent(r, a.bubbles, a.cancelable, a.detail), p = l.preventDefault, l.preventDefault = function() {
              p.call(this);
              try {
                Object.defineProperty(this, "defaultPrevented", { get: function() {
                  return !0;
                } });
              } catch {
                this.defaultPrevented = !0;
              }
            }, l;
          };
          n.prototype = window.Event.prototype, window.CustomEvent = n;
        }
    })();
  }, 379: (i, n, o) => {
    var r, a = function() {
      var C = {};
      return function(E) {
        if (C[E] === void 0) {
          var w = document.querySelector(E);
          if (window.HTMLIFrameElement && w instanceof window.HTMLIFrameElement)
            try {
              w = w.contentDocument.head;
            } catch {
              w = null;
            }
          C[E] = w;
        }
        return C[E];
      };
    }(), l = [];
    function p(C) {
      for (var E = -1, w = 0; w < l.length; w++)
        if (l[w].identifier === C) {
          E = w;
          break;
        }
      return E;
    }
    function u(C, E) {
      for (var w = {}, k = [], D = 0; D < C.length; D++) {
        var O = C[D], x = E.base ? O[0] + E.base : O[0], L = w[x] || 0, S = "".concat(x, " ").concat(L);
        w[x] = L + 1;
        var N = p(S), P = { css: O[1], media: O[2], sourceMap: O[3] };
        N !== -1 ? (l[N].references++, l[N].updater(P)) : l.push({ identifier: S, updater: y(P, E), references: 1 }), k.push(S);
      }
      return k;
    }
    function _(C) {
      var E = document.createElement("style"), w = C.attributes || {};
      if (w.nonce === void 0) {
        var k = o.nc;
        k && (w.nonce = k);
      }
      if (Object.keys(w).forEach(function(O) {
        E.setAttribute(O, w[O]);
      }), typeof C.insert == "function")
        C.insert(E);
      else {
        var D = a(C.insert || "head");
        if (!D)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
        D.appendChild(E);
      }
      return E;
    }
    var f, g = (f = [], function(C, E) {
      return f[C] = E, f.filter(Boolean).join(`
`);
    });
    function m(C, E, w, k) {
      var D = w ? "" : k.media ? "@media ".concat(k.media, " {").concat(k.css, "}") : k.css;
      if (C.styleSheet)
        C.styleSheet.cssText = g(E, D);
      else {
        var O = document.createTextNode(D), x = C.childNodes;
        x[E] && C.removeChild(x[E]), x.length ? C.insertBefore(O, x[E]) : C.appendChild(O);
      }
    }
    function b(C, E, w) {
      var k = w.css, D = w.media, O = w.sourceMap;
      if (D ? C.setAttribute("media", D) : C.removeAttribute("media"), O && typeof btoa < "u" && (k += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(O)))), " */")), C.styleSheet)
        C.styleSheet.cssText = k;
      else {
        for (; C.firstChild; )
          C.removeChild(C.firstChild);
        C.appendChild(document.createTextNode(k));
      }
    }
    var v = null, T = 0;
    function y(C, E) {
      var w, k, D;
      if (E.singleton) {
        var O = T++;
        w = v || (v = _(E)), k = m.bind(null, w, O, !1), D = m.bind(null, w, O, !0);
      } else
        w = _(E), k = b.bind(null, w, E), D = function() {
          (function(x) {
            if (x.parentNode === null)
              return !1;
            x.parentNode.removeChild(x);
          })(w);
        };
      return k(C), function(x) {
        if (x) {
          if (x.css === C.css && x.media === C.media && x.sourceMap === C.sourceMap)
            return;
          k(C = x);
        } else
          D();
      };
    }
    i.exports = function(C, E) {
      (E = E || {}).singleton || typeof E.singleton == "boolean" || (E.singleton = (r === void 0 && (r = !!(window && document && document.all && !window.atob)), r));
      var w = u(C = C || [], E);
      return function(k) {
        if (k = k || [], Object.prototype.toString.call(k) === "[object Array]") {
          for (var D = 0; D < w.length; D++) {
            var O = p(w[D]);
            l[O].references--;
          }
          for (var x = u(k, E), L = 0; L < w.length; L++) {
            var S = p(w[L]);
            l[S].references === 0 && (l[S].updater(), l.splice(S, 1));
          }
          w = x;
        }
      };
    };
  } }, t = {};
  function e(i) {
    var n = t[i];
    if (n !== void 0)
      return n.exports;
    var o = t[i] = { id: i, exports: {} };
    return s[i](o, o.exports, e), o.exports;
  }
  e.n = (i) => {
    var n = i && i.__esModule ? () => i.default : () => i;
    return e.d(n, { a: n }), n;
  }, e.d = (i, n) => {
    for (var o in n)
      e.o(n, o) && !e.o(i, o) && Object.defineProperty(i, o, { enumerable: !0, get: n[o] });
  }, e.o = (i, n) => Object.prototype.hasOwnProperty.call(i, n), (() => {
    var i = e(379), n = e.n(i), o = e(454);
    function r(l) {
      if (!l.hasAttribute("autocompleted")) {
        l.setAttribute("autocompleted", "");
        var p = new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !0, detail: null });
        l.dispatchEvent(p) || (l.value = "");
      }
    }
    function a(l) {
      l.hasAttribute("autocompleted") && (l.removeAttribute("autocompleted"), l.dispatchEvent(new window.CustomEvent("onautocomplete", { bubbles: !0, cancelable: !1, detail: null })));
    }
    n()(o.Z, { insert: "head", singleton: !1 }), o.Z.locals, e(810), document.addEventListener("animationstart", function(l) {
      l.animationName === "onautofillstart" ? r(l.target) : a(l.target);
    }, !0), document.addEventListener("input", function(l) {
      l.inputType !== "insertReplacementText" && "data" in l ? a(l.target) : r(l.target);
    }, !0);
  })();
})();
const Jn = "input", ls = "te.input", ch = "data-te-input-wrapper-init", hh = "data-te-input-notch-ref", dh = "data-te-input-notch-leading-ref", uh = "data-te-input-notch-middle-ref", gf = "data-te-input-notch-trailing-ref", bf = "data-te-input-helper-ref", vf = "data-te-input-placeholder-active", Yt = "data-te-input-state-active", Na = "data-te-input-focused", Ma = "data-te-input-form-counter", cs = `[${ch}] input`, hs = `[${ch}] textarea`, Ie = `[${hh}]`, Ra = `[${dh}]`, Pa = `[${uh}]`, Tf = `[${bf}]`, Ef = {
  inputFormWhite: !1
}, Cf = {
  inputFormWhite: "(boolean)"
}, ph = {
  notch: "group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none",
  notchLeading: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0",
  notchLeadingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchLeadingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchMiddle: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent",
  notchMiddleNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchMiddleWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  notchTrailing: "pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0",
  notchTrailingNormal: "border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary",
  notchTrailingWhite: "border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white",
  counter: "text-right leading-[1.6]"
}, Af = {
  notch: "string",
  notchLeading: "string",
  notchLeadingNormal: "string",
  notchLeadingWhite: "string",
  notchMiddle: "string",
  notchMiddleNormal: "string",
  notchMiddleWhite: "string",
  notchTrailing: "string",
  notchTrailingNormal: "string",
  notchTrailingWhite: "string",
  counter: "string"
};
class V {
  constructor(t, e, i) {
    this._config = this._getConfig(e, t), this._element = t, this._classes = this._getClasses(i), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (A.setData(t, ls, this), this.init());
  }
  // Getters
  static get NAME() {
    return Jn;
  }
  get input() {
    return d.findOne("input", this._element) || d.findOne("textarea", this._element);
  }
  // Public
  init() {
    this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._getEvents(), this._initiated = !0);
  }
  update() {
    this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();
  }
  forceActive() {
    this.input.setAttribute(Yt, ""), d.findOne(Ie, this.input.parentNode).setAttribute(
      Yt,
      ""
    );
  }
  forceInactive() {
    this.input.removeAttribute(Yt), d.findOne(
      Ie,
      this.input.parentNode
    ).removeAttribute(Yt);
  }
  dispose() {
    this._removeBorder(), A.removeData(this._element, ls), this._element = null;
  }
  // Private
  _getConfig(t, e) {
    return t = {
      ...Ef,
      ...h.getDataAttributes(e),
      ...typeof t == "object" ? t : {}
    }, I(Jn, t, Cf), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...ph,
      ...e,
      ...t
    }, I(Jn, t, Af), t;
  }
  _getLabelData() {
    this._label = d.findOne("label", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());
  }
  _getHelper() {
    this._helper = d.findOne(Tf, this._element);
  }
  _getCounter() {
    this._counter = h.getDataAttribute(
      this.input,
      "inputShowcounter"
    ), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());
  }
  _getEvents() {
    c.on(
      this._element,
      "focus",
      "input",
      V.activate(new V())
    ), c.on(
      this._element,
      "input",
      "input",
      V.activate(new V())
    ), c.on(
      this._element,
      "blur",
      "input",
      V.deactivate(new V())
    ), c.on(
      this._element,
      "focus",
      "textarea",
      V.activate(new V())
    ), c.on(
      this._element,
      "input",
      "textarea",
      V.activate(new V())
    ), c.on(
      this._element,
      "blur",
      "textarea",
      V.deactivate(new V())
    ), c.on(window, "shown.te.modal", (t) => {
      d.find(cs, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.update();
        }
      ), d.find(hs, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.update();
        }
      );
    }), c.on(window, "shown.te.dropdown", (t) => {
      const e = t.target.parentNode.querySelector(
        "[data-te-dropdown-menu-ref]"
      );
      e && (d.find(cs, e).forEach(
        (i) => {
          const n = V.getInstance(i.parentNode);
          n && n.update();
        }
      ), d.find(hs, e).forEach(
        (i) => {
          const n = V.getInstance(i.parentNode);
          n && n.update();
        }
      ));
    }), c.on(window, "shown.te.tab", (t) => {
      let e;
      t.target.href ? e = t.target.href.split("#")[1] : e = h.getDataAttribute(t.target, "target").split(
        "#"
      )[1];
      const i = d.findOne(`#${e}`);
      d.find(cs, i).forEach((n) => {
        const o = V.getInstance(n.parentNode);
        o && o.update();
      }), d.find(hs, i).forEach(
        (n) => {
          const o = V.getInstance(n.parentNode);
          o && o.update();
        }
      );
    }), c.on(window, "reset", (t) => {
      d.find(cs, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.forceInactive();
        }
      ), d.find(hs, t.target).forEach(
        (e) => {
          const i = V.getInstance(e.parentNode);
          i && i.forceInactive();
        }
      );
    }), c.on(window, "onautocomplete", (t) => {
      const e = V.getInstance(t.target.parentNode);
      !e || !t.cancelable || e.forceActive();
    });
  }
  _showCounter() {
    if (d.find(
      `[${Ma}]`,
      this._element
    ).length > 0)
      return;
    this._counterElement = document.createElement("div"), h.addClass(this._counterElement, this._classes.counter), this._counterElement.setAttribute(Ma, "");
    const e = this.input.value.length;
    this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();
  }
  _bindCounter() {
    c.on(this.input, "input", () => {
      const t = this.input.value.length;
      this._counterElement.innerHTML = `${t} / ${this._maxLength}`;
    });
  }
  _toggleDefaultDatePlaceholder(t = this.input) {
    if (!(t.getAttribute("type") === "date"))
      return;
    !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;
  }
  _showPlaceholder() {
    this.input.setAttribute(vf, "");
  }
  _getNotchData() {
    this._notchMiddle = d.findOne(
      Pa,
      this._element
    ), this._notchLeading = d.findOne(
      Ra,
      this._element
    );
  }
  _getLabelWidth() {
    this._labelWidth = this._label.clientWidth * 0.8 + 8;
  }
  _getLabelPositionInInputGroup() {
    if (this._labelMarginLeft = 0, !this._element.hasAttribute("data-te-input-group-ref"))
      return;
    const t = this.input, e = d.prev(
      t,
      "[data-te-input-group-text-ref]"
    )[0];
    e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;
  }
  _applyDivs() {
    const t = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal, e = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal, i = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal, n = d.find(Ie, this._element), o = $("div");
    h.addClass(o, this._classes.notch), o.setAttribute(hh, ""), this._notchLeading = $("div"), h.addClass(
      this._notchLeading,
      `${this._classes.notchLeading} ${t}`
    ), this._notchLeading.setAttribute(dh, ""), this._notchMiddle = $("div"), h.addClass(
      this._notchMiddle,
      `${this._classes.notchMiddle} ${e}`
    ), this._notchMiddle.setAttribute(uh, ""), this._notchTrailing = $("div"), h.addClass(
      this._notchTrailing,
      `${this._classes.notchTrailing} ${i}`
    ), this._notchTrailing.setAttribute(gf, ""), !(n.length >= 1) && (o.append(this._notchLeading), o.append(this._notchMiddle), o.append(this._notchTrailing), this._element.append(o));
  }
  _applyNotch() {
    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);
  }
  _removeBorder() {
    const t = d.findOne(Ie, this._element);
    t && t.remove();
  }
  _activate(t) {
    gc(() => {
      this._getElements(t);
      const e = t ? t.target : this.input, i = d.findOne(
        Ie,
        this._element
      );
      t && t.type === "focus" && i && i.setAttribute(Na, ""), e.value !== "" && (e.setAttribute(Yt, ""), i && i.setAttribute(Yt, "")), this._toggleDefaultDatePlaceholder(e);
    });
  }
  _getElements(t) {
    if (t && (this._element = t.target.parentNode, this._label = d.findOne("label", this._element)), t && this._label) {
      const e = this._labelWidth;
      this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = d.findOne(
        Pa,
        t.target.parentNode
      ), this._notchLeading = d.findOne(
        Ra,
        t.target.parentNode
      ), this._applyNotch());
    }
  }
  _deactivate(t) {
    const e = t ? t.target : this.input, i = d.findOne(
      Ie,
      e.parentNode
    );
    i.removeAttribute(Na), e.value === "" && (e.removeAttribute(Yt), i.removeAttribute(Yt)), this._toggleDefaultDatePlaceholder(e);
  }
  static activate(t) {
    return function(e) {
      t._activate(e);
    };
  }
  static deactivate(t) {
    return function(e) {
      t._deactivate(e);
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, ls);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new V(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, ls);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Ba = "animation", to = "te.animation", yf = {
  animation: "string",
  animationStart: "string",
  animationShowOnLoad: "boolean",
  onStart: "(null|function)",
  onEnd: "(null|function)",
  onHide: "(null|function)",
  onShow: "(null|function)",
  animationOnScroll: "(string)",
  animationWindowHeight: "number",
  animationOffset: "(number|string)",
  animationDelay: "(number|string)",
  animationReverse: "boolean",
  animationInterval: "(number|string)",
  animationRepeat: "(number|boolean)",
  animationReset: "boolean"
}, wf = {
  animation: "fade",
  animationStart: "onClick",
  animationShowOnLoad: !0,
  onStart: null,
  onEnd: null,
  onHide: null,
  onShow: null,
  animationOnScroll: "once",
  animationWindowHeight: 0,
  animationOffset: 0,
  animationDelay: 0,
  animationReverse: !1,
  animationInterval: 0,
  animationRepeat: !1,
  animationReset: !1
};
class wr {
  constructor(t, e) {
    this._element = t, this._animateElement = this._getAnimateElement(), this._isFirstScroll = !0, this._repeatAnimateOnScroll = !0, this._options = this._getConfig(e), this._element && (A.setData(t, to, this), this._init());
  }
  // Getters
  static get NAME() {
    return Ba;
  }
  // Public
  init() {
    this._init();
  }
  startAnimation() {
    this._startAnimation();
  }
  stopAnimation() {
    this._clearAnimationClass();
  }
  changeAnimationType(t) {
    this._options.animation = t;
  }
  dispose() {
    c.off(this._element, "mousedown"), c.off(this._animateElement, "animationend"), c.off(window, "scroll"), c.off(this._element, "mouseover"), A.removeData(this._element, to), this._element = null, this._animateElement = null, this._isFirstScroll = null, this._repeatAnimateOnScroll = null, this._options = null;
  }
  // Private
  _init() {
    switch (this._options.animationStart) {
      case "onHover":
        this._bindHoverEvents();
        break;
      case "onLoad":
        this._startAnimation();
        break;
      case "onScroll":
        this._bindScrollEvents();
        break;
      case "onClick":
        this._bindClickEvents();
        break;
    }
    this._bindTriggerOnEndCallback(), this._options.animationReset && this._bindResetAnimationAfterFinish();
  }
  _getAnimateElement() {
    const t = h.getDataAttribute(
      this._element,
      "animation-target"
    );
    return t ? d.find(t)[0] : this._element;
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._animateElement);
    return t = {
      ...wf,
      ...e,
      ...t
    }, I(Ba, t, yf), t;
  }
  _animateOnScroll() {
    const t = h.offset(this._animateElement).top, e = this._animateElement.offsetHeight, i = window.innerHeight, n = t + this._options.animationOffset <= i && t + this._options.animationOffset + e >= 0, o = this._animateElement.style.visibility === "visible";
    switch (!0) {
      case (n && this._isFirstScroll):
        this._isFirstScroll = !1, this._startAnimation();
        break;
      case (!n && this._isFirstScroll):
        this._isFirstScroll = !1, this._hideAnimateElement();
        break;
      case (n && !o && this._repeatAnimateOnScroll):
        this._options.animationOnScroll !== "repeat" && (this._repeatAnimateOnScroll = !1), this._callback(this._options.onShow), this._showAnimateElement(), this._startAnimation();
        break;
      case (!n && o && this._repeatAnimateOnScroll):
        this._hideAnimateElement(), this._clearAnimationClass(), this._callback(this._options.onHide);
        break;
    }
  }
  _addAnimatedClass() {
    h.addClass(
      this._animateElement,
      `animate-${this._options.animation}`
    );
  }
  _clearAnimationClass() {
    this._animateElement.classList.remove(`animate-${this._options.animation}`);
  }
  _startAnimation() {
    this._callback(this._options.onStart), this._addAnimatedClass(), this._options.animationRepeat && !this._options.animationInterval && this._setAnimationRepeat(), this._options.animationReverse && this._setAnimationReverse(), this._options.animationDelay && this._setAnimationDelay(), this._options.animationDuration && this._setAnimationDuration(), this._options.animationInterval && this._setAnimationInterval();
  }
  _setAnimationReverse() {
    h.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : "2",
      animationDirection: "alternate"
    });
  }
  _setAnimationDuration() {
    h.style(this._animateElement, {
      animationDuration: `${this._options.animationDuration}ms`
    });
  }
  _setAnimationDelay() {
    h.style(this._animateElement, {
      animationDelay: `${this._options.animationDelay}ms`
    });
  }
  _setAnimationRepeat() {
    h.style(this._animateElement, {
      animationIterationCount: this._options.animationRepeat === !0 ? "infinite" : this._options.animationRepeat
    });
  }
  _setAnimationInterval() {
    c.on(this._animateElement, "animationend", () => {
      this._clearAnimationClass(), setTimeout(() => {
        this._addAnimatedClass();
      }, this._options.animationInterval);
    });
  }
  _hideAnimateElement() {
    h.style(this._animateElement, { visibility: "hidden" });
  }
  _showAnimateElement() {
    h.style(this._animateElement, { visibility: "visible" });
  }
  _bindResetAnimationAfterFinish() {
    c.on(this._animateElement, "animationend", () => {
      this._clearAnimationClass();
    });
  }
  _bindTriggerOnEndCallback() {
    c.on(this._animateElement, "animationend", () => {
      this._callback(this._options.onEnd);
    });
  }
  _bindScrollEvents() {
    this._options.animationShowOnLoad || this._animateOnScroll(), c.on(window, "scroll", () => {
      this._animateOnScroll();
    });
  }
  _bindClickEvents() {
    c.on(this._element, "mousedown", () => {
      this._startAnimation();
    });
  }
  _bindHoverEvents() {
    c.one(this._element, "mouseover", () => {
      this._startAnimation();
    }), c.one(this._animateElement, "animationend", () => {
      setTimeout(() => {
        this._bindHoverEvents();
      }, 100);
    });
  }
  _callback(t) {
    t instanceof Function && t();
  }
  // Static
  static autoInit(t) {
    t._init();
  }
  static jQueryInterface(t) {
    new wr(this[0], t).init();
  }
  static getInstance(t) {
    return A.getData(t, to);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const kf = {
  property: "color",
  defaultValue: null,
  inherit: !0
}, De = (s, t) => {
  const { property: e, defaultValue: i, inherit: n } = { ...kf, ...t }, o = document.createElement("div");
  o.classList.add(s), document.body.appendChild(o);
  const a = window.getComputedStyle(o)[e] || i, p = window.getComputedStyle(o.parentElement)[e];
  return document.body.removeChild(o), !n && p && a === p ? i : a || i;
}, eo = "ripple", ds = "te.ripple", xf = "rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%", Of = ["[data-te-ripple-init]"], us = [0, 0, 0], Sf = [
  {
    name: "primary",
    gradientColor: De("text-primary", { defaultValue: "#3B71CA", inherit: !1 })
  },
  {
    name: "secondary",
    gradientColor: De("text-secondary", { defaultValue: "#9FA6B2", inherit: !1 })
  },
  {
    name: "success",
    gradientColor: De("text-success", { defaultValue: "#14A44D", inherit: !1 })
  },
  {
    name: "danger",
    gradientColor: De("text-danger", { defaultValue: "#DC4C64", inherit: !1 })
  },
  {
    name: "warning",
    gradientColor: De("text-warning", { defaultValue: "#E4A11B", inherit: !1 })
  },
  {
    name: "info",
    gradientColor: De("text-info", { defaultValue: "#54B4D3", inherit: !1 })
  },
  {
    name: "light",
    gradientColor: "#fbfbfb"
  },
  {
    name: "dark",
    gradientColor: "#262626"
  }
], Ha = 0.5, If = {
  rippleCentered: !1,
  rippleColor: "",
  rippleColorDark: "",
  rippleDuration: "500ms",
  rippleRadius: 0,
  rippleUnbound: !1
}, Df = {
  rippleCentered: "boolean",
  rippleColor: "string",
  rippleColorDark: "string",
  rippleDuration: "string",
  rippleRadius: "number",
  rippleUnbound: "boolean"
}, $f = {
  ripple: "relative overflow-hidden inline-block align-bottom",
  rippleWave: "rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]",
  unbound: "overflow-visible"
}, Lf = {
  ripple: "string",
  rippleWave: "string",
  unbound: "string"
};
class ei {
  constructor(t, e, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._element && (A.setData(t, ds, this), h.addClass(this._element, this._classes.ripple)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._initialClasses = null, this.init();
  }
  // Getters
  static get NAME() {
    return eo;
  }
  // Public
  init() {
    this._addClickEvent(this._element);
  }
  dispose() {
    A.removeData(this._element, ds), c.off(this._element, "click", this._clickHandler), this._element = null, this._options = null;
  }
  // Private
  _autoInit(t) {
    Of.forEach((e) => {
      d.closest(t.target, e) && (this._element = d.closest(t.target, e));
    }), this._element.style.minWidth || (h.style(this._element, {
      "min-width": getComputedStyle(this._element).width
    }), this._isMinWidthSet = !0), this._options = this._getConfig(), this._classes = this._getClasses(), this._initialClasses = [...this._element.classList], h.addClass(this._element, this._classes.ripple), this._createRipple(t);
  }
  _addClickEvent(t) {
    c.on(t, "mousedown", this._clickHandler);
  }
  _createRipple(t) {
    this._element.className.indexOf(this._classes.ripple) < 0 && h.addClass(this._element, this._classes.ripple);
    const { layerX: e, layerY: i } = t, n = t.offsetX || e, o = t.offsetY || i, r = this._element.offsetHeight, a = this._element.offsetWidth, l = this._durationToMsNumber(this._options.rippleDuration), p = {
      offsetX: this._options.rippleCentered ? r / 2 : n,
      offsetY: this._options.rippleCentered ? a / 2 : o,
      height: r,
      width: a
    }, u = this._getDiameter(p), _ = this._options.rippleRadius || u / 2, f = {
      delay: l * Ha,
      duration: l - l * Ha
    }, g = {
      left: this._options.rippleCentered ? `${a / 2 - _}px` : `${n - _}px`,
      top: this._options.rippleCentered ? `${r / 2 - _}px` : `${o - _}px`,
      height: `${this._options.rippleRadius * 2 || u}px`,
      width: `${this._options.rippleRadius * 2 || u}px`,
      transitionDelay: `0s, ${f.delay}ms`,
      transitionDuration: `${l}ms, ${f.duration}ms`
    }, m = $("div");
    this._createHTMLRipple({
      wrapper: this._element,
      ripple: m,
      styles: g
    }), this._removeHTMLRipple({ ripple: m, duration: l });
  }
  _createHTMLRipple({ wrapper: t, ripple: e, styles: i }) {
    Object.keys(i).forEach(
      (n) => e.style[n] = i[n]
    ), h.addClass(e, this._classes.rippleWave), e.setAttribute("data-te-ripple-ref", ""), this._addColor(e, t), this._toggleUnbound(t), this._appendRipple(e, t);
  }
  _removeHTMLRipple({ ripple: t, duration: e }) {
    this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), t && setTimeout(() => {
      t.classList.add("!opacity-0");
    }, 10), this._rippleTimer = setTimeout(() => {
      if (t && (t.remove(), this._element)) {
        d.find("[data-te-ripple-ref]", this._element).forEach(
          (n) => {
            n.remove();
          }
        ), this._isMinWidthSet && (h.style(this._element, { "min-width": "" }), this._isMinWidthSet = !1);
        const i = this._initialClasses ? this._addedNewRippleClasses(
          this._classes.ripple,
          this._initialClasses
        ) : this._classes.ripple.split(" ");
        h.removeClass(this._element, i);
      }
    }, e);
  }
  _addedNewRippleClasses(t, e) {
    return t.split(" ").filter(
      (i) => e.findIndex((n) => i === n) === -1
    );
  }
  _durationToMsNumber(t) {
    return Number(t.replace("ms", "").replace("s", "000"));
  }
  _getConfig(t = {}) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...If,
      ...e,
      ...t
    }, I(eo, t, Df), t;
  }
  _getClasses(t = {}) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...$f,
      ...e,
      ...t
    }, I(eo, t, Lf), t;
  }
  _getDiameter({ offsetX: t, offsetY: e, height: i, width: n }) {
    const o = e <= i / 2, r = t <= n / 2, a = (f, g) => Math.sqrt(f ** 2 + g ** 2), l = e === i / 2 && t === n / 2, p = {
      first: o === !0 && r === !1,
      second: o === !0 && r === !0,
      third: o === !1 && r === !0,
      fourth: o === !1 && r === !1
    }, u = {
      topLeft: a(t, e),
      topRight: a(n - t, e),
      bottomLeft: a(t, i - e),
      bottomRight: a(n - t, i - e)
    };
    let _ = 0;
    return l || p.fourth ? _ = u.topLeft : p.third ? _ = u.topRight : p.second ? _ = u.bottomRight : p.first && (_ = u.bottomLeft), _ * 2;
  }
  _appendRipple(t, e) {
    e.appendChild(t), setTimeout(() => {
      h.addClass(t, "opacity-0 scale-100");
    }, 50);
  }
  _toggleUnbound(t) {
    this._options.rippleUnbound === !0 ? h.addClass(t, this._classes.unbound) : h.removeClass(t, this._classes.unbound);
  }
  _addColor(t) {
    let e = this._options.rippleColor || "rgb(0,0,0)";
    (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) && (e = this._options.rippleColorDark || this._options.rippleColor);
    const i = Sf.find(
      (r) => r.name === e.toLowerCase()
    ), n = i ? this._colorToRGB(i.gradientColor).join(",") : this._colorToRGB(e).join(","), o = xf.split("{{color}}").join(`${n}`);
    t.style.backgroundImage = `radial-gradient(circle, ${o})`;
  }
  _colorToRGB(t) {
    function e(o) {
      return o.length < 7 && (o = `#${o[1]}${o[1]}${o[2]}${o[2]}${o[3]}${o[3]}`), [
        parseInt(o.substr(1, 2), 16),
        parseInt(o.substr(3, 2), 16),
        parseInt(o.substr(5, 2), 16)
      ];
    }
    function i(o) {
      const r = document.body.appendChild(
        document.createElement("fictum")
      ), a = "rgb(1, 2, 3)";
      return r.style.color = a, r.style.color !== a || (r.style.color = o, r.style.color === a || r.style.color === "") ? us : (o = getComputedStyle(r).color, document.body.removeChild(r), o);
    }
    function n(o) {
      return o = o.match(/[.\d]+/g).map((r) => +Number(r)), o.length = 3, o;
    }
    return t.toLowerCase() === "transparent" ? us : t[0] === "#" ? e(t) : (t.indexOf("rgb") === -1 && (t = i(t)), t.indexOf("rgb") === 0 ? n(t) : us);
  }
  // Static
  static autoInitial(t) {
    return function(e) {
      t._autoInit(e);
    };
  }
  static jQueryInterface(t) {
    return this.each(function() {
      return A.getData(this, ds) ? null : new ei(this, t);
    });
  }
  static getInstance(t) {
    return A.getData(t, ds);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
function tt(s) {
  return s.getDate();
}
function zs(s) {
  return s.getDay();
}
function Y(s) {
  return s.getMonth();
}
function B(s) {
  return s.getFullYear();
}
function Nf(s, t, e) {
  const i = e.startDay, n = i > 0 ? 7 - i : 0, r = new Date(s, t).getDay() + n;
  return r >= 7 ? r - 7 : r;
}
function Go(s) {
  return Mf(s).getDate();
}
function Mf(s) {
  return Ct(s.getFullYear(), s.getMonth() + 1, 0);
}
function je() {
  return /* @__PURE__ */ new Date();
}
function at(s, t) {
  return lt(s, t * 12);
}
function lt(s, t) {
  const e = Ct(
    s.getFullYear(),
    s.getMonth() + t,
    s.getDate()
  ), i = tt(s), n = tt(e);
  return i !== n && e.setDate(0), e;
}
function $e(s, t) {
  return Ct(s.getFullYear(), s.getMonth(), s.getDate() + t);
}
function Ct(s, t, e) {
  const i = new Date(s, t, e);
  return s >= 0 && s < 100 && i.setFullYear(i.getFullYear() - 1900), i;
}
function Va(s) {
  const t = s.split("-"), e = t[0], i = t[1], n = t[2];
  return Ct(e, i, n);
}
function Rf(s) {
  return !Number.isNaN(s.getTime());
}
function Fe(s, t) {
  return B(s) - B(t) || Y(s) - Y(t) || tt(s) - tt(t);
}
function me(s, t) {
  return s.setHours(0, 0, 0, 0), t.setHours(0, 0, 0, 0), s.getTime() === t.getTime();
}
function Us(s, t) {
  const i = B(s) - Bf();
  return Pf(i, t);
}
function Pf(s, t) {
  return (s % t + t) % t;
}
function Bf(s, t, e) {
  let i = 0;
  return e ? i = B(e) - s + 1 : t && (i = B(t)), i;
}
function _n(s, t, e, i, n, o) {
  const r = /* @__PURE__ */ new Date();
  r.setHours(0, 0, 0, 0);
  const a = t && Fe(s, t) <= -1, l = e && Fe(s, e) >= 1, p = n && Fe(s, r) <= -1, u = o && Fe(s, r) >= 1, _ = i && i(s) === !1;
  return a || l || _ || p || u;
}
function _h(s, t, e, i, n, o) {
  const r = /* @__PURE__ */ new Date(), a = i && B(i), l = i && Y(i), p = e && B(e), u = e && Y(e), _ = B(r), f = Y(r), g = l && a && (t > a || t === a && s > l), m = u && p && (t < p || t === p && s < u), b = n && (t < _ || t === _ && s < f), v = o && (t > _ || t === _ && s > f);
  return g || m || b || v;
}
function qo(s, t, e, i, n) {
  const o = t && B(t), r = e && B(e), a = B(/* @__PURE__ */ new Date()), l = r && s > r, p = o && s < o, u = i && s < a, _ = n && s > a;
  return l || p || u || _;
}
function Hf(s, t, e, i, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (s && o && Fe(o, l) < 0 || s) && (o = l), o && Pi(
    t,
    o,
    e,
    i,
    n,
    o,
    r,
    a
  );
}
function Vf(s, t, e, i, n, o, r, a) {
  const l = /* @__PURE__ */ new Date();
  return l.setHours(0, 0, 0, 0), (s && n && Fe(n, l) < 0 || s) && (n = l), n && Pi(
    t,
    n,
    e,
    i,
    n,
    o,
    r,
    a
  );
}
function Pi(s, t, e, i, n, o, r, a) {
  return e === "days" ? B(s) === B(t) && Y(s) === Y(t) : e === "months" ? B(s) === B(t) : e === "years" ? B(t) >= a && B(t) <= r : !1;
}
const Wf = "data-te-datepicker-modal-container-ref", Ff = "data-te-datepicker-dropdown-container-ref", Yf = "data-te-dropdown-backdrop-ref", jf = "data-te-datepicker-date-text-ref", Wa = "data-te-datepicker-view-ref", Kf = "data-te-datepicker-previous-button-ref", zf = "data-te-datepicker-next-button-ref", Uf = "data-te-datepicker-ok-button-ref", Xf = "data-te-datepicker-cancel-button-ref", Gf = "data-te-datepicker-clear-button-ref", qf = "data-te-datepicker-view-change-button-ref";
function Zf(s, t, e, i, n, o, r, a, l, p) {
  const u = Y(s), _ = B(s), f = tt(s), g = zs(s), m = $("div"), b = `
        ${Fa(
    s,
    u,
    _,
    t,
    e,
    i,
    n,
    o,
    r,
    a,
    p
  )}
    `, v = `
      ${Jf(f, g, u, n, p)}
      ${Fa(
    s,
    u,
    _,
    t,
    e,
    i,
    n,
    o,
    r,
    a,
    p
  )}
    `;
  return n.inline ? (h.addClass(m, p.datepickerDropdownContainer), m.setAttribute(Ff, l), m.innerHTML = b) : (h.addClass(m, p.modalContainer), m.setAttribute(Wf, l), m.innerHTML = v), m;
}
function Qf(s) {
  const t = $("div");
  return h.addClass(t, s), t.setAttribute(Yf, ""), t;
}
function Jf(s, t, e, i, n) {
  return `
      <div class="${n.datepickerHeader}" data-te-datepicker-header>
        <div class="${n.datepickerTitle}">
          <span class="${n.datepickerTitleText}">${i.title}</span>
        </div>
        <div class="${n.datepickerDate}">
          <span class="${n.datepickerDateText}" ${jf} >${i.weekdaysShort[t]}, ${i.monthsShort[e]} ${s}</span>
        </div>
      </div>
    `;
}
function Fa(s, t, e, i, n, o, r, a, l, p, u) {
  let _;
  return r.inline ? _ = `
    <div class="${u.datepickerMain}">
      ${ja(t, e, r, u)}
      <div class="${u.datepickerView}" ${Wa} tabindex="0">
        ${Ya(
    s,
    e,
    i,
    n,
    o,
    r,
    a,
    l,
    p,
    u
  )}
      </div>
    </div>
  ` : _ = `
    <div class="${u.datepickerMain}">
      ${ja(t, e, r, u)}
      <div class="${u.datepickerView}" ${Wa} tabindex="0">
        ${Ya(
    s,
    e,
    i,
    n,
    o,
    r,
    a,
    l,
    p,
    u
  )}
      </div>
      ${tm(r, u)}
    </div>
  `, _;
}
function Ya(s, t, e, i, n, o, r, a, l, p) {
  let u;
  return o.view === "days" ? u = Xs(s, e, o, p) : o.view === "months" ? u = Gs(
    t,
    i,
    n,
    o,
    r,
    p
  ) : u = qs(
    s,
    i,
    o,
    a,
    l,
    p
  ), u;
}
function ja(s, t, e, i) {
  return `
    <div class="${i.datepickerDateControls}">
      <button class="${i.datepickerViewChangeButton}" aria-label="${e.switchToMultiYearViewLabel}" ${qf}>
        ${e.monthsFull[s]} ${t} ${Lt(
    e,
    i
  )}
      </button>
      <div class="${i.datepickerArrowControls}">
        <button class="${i.datepickerPreviousButton}" aria-label="${e.prevMonthLabel}" ${Kf}>${e.changeMonthIconTemplate}</button>
        <button class="${i.datepickerNextButton}" aria-label="${e.nextMonthLabel}" ${zf}>${e.changeMonthIconTemplate}</button>
      </div>
    </div>
    `;
}
function Lt(s, t) {
  return `
  <span class="${t.datepickerViewChangeIcon}">
  ${s.viewChangeIconTemplate}
  </span>
  `;
}
function tm(s, t) {
  const e = `<button class="${t.datepickerFooterBtn}" aria-label="${s.okBtnLabel}" ${Uf}>${s.okBtnText}</button>`, i = `<button class="${t.datepickerFooterBtn}" aria-label="${s.cancelBtnLabel}" ${Xf}>${s.cancelBtnText}</button>`, n = `<button class="${t.datepickerFooterBtn} ${t.datepickerClearBtn}" aria-label="${s.clearBtnLabel}" ${Gf}>${s.clearBtnText}</button>`;
  return `
        <div class="${t.datepickerFooter}">
          
        ${s.removeClearBtn ? "" : n}
        ${s.removeCancelBtn ? "" : i}
        ${s.removeOkBtn ? "" : e}
        </div>
      `;
}
function Xs(s, t, e, i) {
  const n = em(s, t, e), r = `
      <tr>
        ${e.weekdaysNarrow.map((l, p) => `<th class="${i.datepickerDayHeading}" scope="col" aria-label="${e.weekdaysFull[p]}">${l}</th>`).join("")}
      </tr>
    `, a = n.map((l) => `
        <tr>
          ${l.map((p) => `
              <td
              class="${i.datepickerCell} ${i.datepickerCellSmall}"
              data-te-date="${B(p.date)}-${Y(
    p.date
  )}-${tt(p.date)}"
              aria-label="${p.date}"
              aria-selected="${p.isSelected}"
              ${p.isSelected ? "data-te-datepicker-cell-selected" : ""}
              ${!p.currentMonth || p.disabled ? "data-te-datepicker-cell-disabled" : ""}
              ${p.isToday ? "data-te-datepicker-cell-current" : ""}
              >
                <div
                  class="${i.datepickerCellContent} ${i.datepickerCellContentSmall}"
                  style="${p.currentMonth ? "display: block" : "display: none"}"
                  >
                  ${p.dayNumber}
                  </div>
              </td>
            `).join("")}
        </tr>
      `).join("");
  return `
      <table class="${i.datepickerTable}">
        <thead>
          ${r}
        </thead>
        <tbody>
         ${a}
        </tbody>
      </table>
    `;
}
function em(s, t, e) {
  const i = [], n = Y(s), o = Y(lt(s, -1)), r = Y(lt(s, 1)), a = B(s), l = Nf(a, n, e), p = Go(s), u = Go(lt(s, -1)), _ = 7;
  let f = 1, g = !1;
  for (let m = 1; m < _; m++) {
    const b = [];
    if (m === 1) {
      const v = u - l + 1;
      for (let y = v; y <= u; y++) {
        const C = Ct(a, o, y);
        b.push({
          date: C,
          currentMonth: g,
          isSelected: t && me(C, t),
          isToday: me(C, je()),
          dayNumber: tt(C)
        });
      }
      g = !0;
      const T = _ - b.length;
      for (let y = 0; y < T; y++) {
        const C = Ct(a, n, f);
        b.push({
          date: C,
          currentMonth: g,
          isSelected: t && me(C, t),
          isToday: me(C, je()),
          dayNumber: tt(C),
          disabled: _n(
            C,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), f++;
      }
    } else
      for (let v = 1; v < 8; v++) {
        f > p && (f = 1, g = !1);
        const T = Ct(
          a,
          g ? n : r,
          f
        );
        b.push({
          date: T,
          currentMonth: g,
          isSelected: t && me(T, t),
          isToday: me(T, je()),
          dayNumber: tt(T),
          disabled: _n(
            T,
            e.min,
            e.max,
            e.filter,
            e.disablePast,
            e.disableFuture
          )
        }), f++;
      }
    i.push(b);
  }
  return i;
}
function Gs(s, t, e, i, n, o) {
  const r = im(i, n), a = Y(je()), l = B(je()), p = `
      ${r.map((u) => `
          <tr>
            ${u.map((_) => {
    const f = i.monthsShort.indexOf(_);
    return `
                <td class="${o.datepickerCell} ${o.datepickerCellLarge}"
                ${_h(
      f,
      s,
      i.min,
      i.max,
      i.disablePast,
      i.disableFuture
    ) ? "data-te-datepicker-cell-disabled" : ""}
                
                data-te-month="${f}" data-te-year="${s}" aria-label="${_}, ${s}"
                ${f === e && s === t ? "data-te-datepicker-cell-selected" : ""}
                ${f === a && s === l ? "data-te-datepicker-cell-current" : ""}" data-te-month="${f}" data-te-year="${s}" aria-label="${_}, ${s}">
                  <div class="${o.datepickerCellContent} ${o.datepickerCellContentLarge}">${_}</div>
                </td>
              `;
  }).join("")}
          </tr>
        `).join("")}
    `;
  return `
      <table class="${o.datepickerTable}">
        <tbody>
         ${p}
        </tbody>
      </table>
    `;
}
function im(s, t) {
  const e = [];
  let i = [];
  for (let n = 0; n < s.monthsShort.length; n++)
    if (i.push(s.monthsShort[n]), i.length === t) {
      const o = i;
      e.push(o), i = [];
    }
  return e;
}
function qs(s, t, e, i, n, o) {
  const r = sm(s, i, n), a = B(je()), l = `
    ${r.map((p) => `
        <tr>
          ${p.map((u) => `
              <td class="${o.datepickerCell} ${o.datepickerCellLarge}"  aria-label="${u}" data-te-year="${u}"
              ${qo(
    u,
    e.min,
    e.max,
    e.disablePast,
    e.disableFuture
  ) ? "data-te-datepicker-cell-disabled" : ""}
              ${u === t ? "data-te-datepicker-cell-selected" : ""}
              ${u === a ? "data-te-datepicker-cell-current" : ""}
              >
                <div class="${o.datepickerCellContent} ${o.datepickerCellContentLarge}">${u}</div>
              </td>
            `).join("")}
        </tr>
      `).join("")}
  `;
  return `
      <table class="${o.datepickerTable}">
        <tbody>
        ${l}
        </tbody>
      </table>
    `;
}
function sm(s, t, e) {
  const i = [], n = B(s), o = Us(s, t), r = n - o;
  let a = [];
  for (let l = 0; l < t; l++)
    if (a.push(r + l), a.length === e) {
      const p = a;
      i.push(p), a = [];
    }
  return i;
}
function nm(s, t) {
  return `
    <button id="${s}" type="button" class="${t}" data-te-datepicker-toggle-button-ref data-te-datepicker-toggle-ref>
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
      <path fill-rule="evenodd" d="M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z" clip-rule="evenodd" />
      </svg>  
    </button>
  `;
}
const Ke = 37, U = 38, ze = 39, z = 40, Te = 36, Ee = 35, io = 33, so = 34, it = 13, Zs = 32, we = 27, ke = 9, om = 8, rm = 46, Tt = 24, ps = 4, _s = 4, no = "datepicker", Qs = "te.datepicker", En = `.${Qs}`, am = ".data-api", lm = `close${En}`, cm = `open${En}`, hm = `dateChange${En}`, fs = `click${En}${am}`, fh = "data-te-datepicker-modal-container-ref", mh = "data-te-datepicker-dropdown-container-ref", ms = "[data-te-datepicker-toggle-ref]", dm = `[${fh}]`, um = `[${mh}]`, pm = "[data-te-datepicker-view-change-button-ref]", _m = "[data-te-datepicker-previous-button-ref]", fm = "[data-te-datepicker-next-button-ref]", mm = "[data-te-datepicker-ok-button-ref]", gm = "[data-te-datepicker-cancel-button-ref]", bm = "[data-te-datepicker-clear-button-ref]", vm = "[data-te-datepicker-view-ref]", Tm = "[data-te-datepicker-toggle-button-ref]", Em = "[data-te-datepicker-date-text-ref]", Cm = "[data-te-dropdown-backdrop-ref]", Am = "animate-[fade-in_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", ym = "animate-[fade-out_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", wm = "animate-[fade-in_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", km = "animate-[fade-out_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none", xm = "flex flex-col fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[328px] h-[512px] bg-white rounded-[0.6rem] shadow-lg z-[1066] xs:max-md:landscape:w-[475px] xs:max-md:landscape:h-[360px] xs:max-md:landscape:flex-row dark:bg-zinc-700", Om = "w-full h-full fixed top-0 right-0 left-0 bottom-0 bg-black/40 z-[1065]", Sm = "relative h-full", Im = "xs:max-md:landscape:h-full h-[120px] px-6 bg-primary flex flex-col rounded-t-lg dark:bg-zinc-800", Dm = "h-8 flex flex-col justify-end", $m = "text-[10px] font-normal uppercase tracking-[1.7px] text-white", Lm = "xs:max-md:landscape:mt-24 h-[72px] flex flex-col justify-end", Nm = "text-[34px] font-normal text-white", Mm = "outline-none px-3", Rm = "px-3 pt-2.5 pb-0 flex justify-between text-black/[64]", Pm = "flex items-center outline-none p-2.5 text-neutral-500 font-medium text-[0.9rem] rounded-xl shadow-none bg-transparent m-0 border-none hover:bg-neutral-200 focus:bg-neutral-200  dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10", Bm = "mt-2.5", Hm = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent mr-6 hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:mx-auto", Vm = "p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:rotate-180 [&>svg]:mx-auto", Wm = "h-14 flex absolute w-full bottom-0 justify-end items-center px-3", Fm = "outline-none bg-white text-primary border-none cursor-pointer py-0 px-2.5 uppercase text-[0.8rem] leading-10 font-medium h-10 tracking-[.1rem] rounded-[10px] mb-2.5 hover:bg-neutral-200 focus:bg-neutral-200 dark:bg-transparent dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10", Ym = "mr-auto", jm = "w-10 h-10 text-center text-[12px] font-normal dark:text-white", Km = "text-center data-[te-datepicker-cell-disabled]:text-neutral-300 data-[te-datepicker-cell-disabled]:cursor-default data-[te-datepicker-cell-disabled]:pointer-events-none data-[te-datepicker-cell-disabled]:hover:cursor-default hover:cursor-pointer group", zm = "w-10 h-10 xs:max-md:landscape:w-8 xs:max-md:landscape:h-8", Um = "w-[76px] h-[42px]", Xm = "mx-auto group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-neutral-300 group-[[data-te-datepicker-cell-selected]]:bg-primary group-[[data-te-datepicker-cell-selected]]:text-white group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-neutral-100 group-[[data-te-datepicker-cell-focused]]:data-[te-datepicker-cell-selected]:bg-primary group-[[data-te-datepicker-cell-current]]:border-solid group-[[data-te-datepicker-cell-current]]:border-black group-[[data-te-datepicker-cell-current]]:border dark:group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-white/10 dark:group-[[data-te-datepicker-cell-current]]:border-white dark:text-white dark:group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-white/10 dark:group-[[data-te-datepicker-cell-disabled]]:text-neutral-500", Gm = "w-9 h-9 leading-9 rounded-[50%] text-[13px]", qm = "w-[72px] h-10 leading-10 py-[1px] px-0.5 rounded-[999px]", Zm = "mx-auto w-[304px]", Qm = "flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200", Jm = "inline-block pointer-events-none ml-[3px] [&>svg]:w-4 [&>svg]:h-4 [&>svg]:fill-neutral-500 dark:[&>svg]:fill-white", tg = "w-[328px] h-[380px] bg-white rounded-lg shadow-[0px_2px_15px_-3px_rgba(0,0,0,.07),_0px_10px_20px_-2px_rgba(0,0,0,.04)] z-[1066] dark:bg-zinc-700", eg = {
  title: "Select date",
  container: "body",
  disablePast: !1,
  disableFuture: !1,
  monthsFull: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  monthsShort: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  weekdaysFull: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  weekdaysNarrow: ["S", "M", "T", "W", "T", "F", "S"],
  okBtnText: "Ok",
  clearBtnText: "Clear",
  cancelBtnText: "Cancel",
  okBtnLabel: "Confirm selection",
  clearBtnLabel: "Clear selection",
  cancelBtnLabel: "Cancel selection",
  nextMonthLabel: "Next month",
  prevMonthLabel: "Previous month",
  nextYearLabel: "Next year",
  prevYearLabel: "Previous year",
  changeMonthIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
  </svg>
  `,
  nextMultiYearLabel: "Next 24 years",
  prevMultiYearLabel: "Previous 24 years",
  switchToMultiYearViewLabel: "Choose year and month",
  switchToMonthViewLabel: "Choose date",
  switchToDayViewLabel: "Choose date",
  startDate: null,
  startDay: 0,
  format: "dd/mm/yyyy",
  view: "days",
  viewChangeIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="0" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
  </svg>
  `,
  min: null,
  max: null,
  filter: null,
  inline: !1,
  toggleButton: !0,
  disableToggleButton: !1,
  disableInput: !1,
  animations: !0,
  confirmDateOnSelect: !1,
  removeOkBtn: !1,
  removeCancelBtn: !1,
  removeClearBtn: !1
}, ig = {
  title: "string",
  container: "string",
  disablePast: "boolean",
  disableFuture: "boolean",
  monthsFull: "array",
  monthsShort: "array",
  weekdaysFull: "array",
  weekdaysShort: "array",
  weekdaysNarrow: "array",
  okBtnText: "string",
  clearBtnText: "string",
  cancelBtnText: "string",
  okBtnLabel: "string",
  clearBtnLabel: "string",
  cancelBtnLabel: "string",
  nextMonthLabel: "string",
  prevMonthLabel: "string",
  nextYearLabel: "string",
  prevYearLabel: "string",
  nextMultiYearLabel: "string",
  prevMultiYearLabel: "string",
  changeMonthIconTemplate: "string",
  switchToMultiYearViewLabel: "string",
  switchToMonthViewLabel: "string",
  switchToDayViewLabel: "string",
  startDate: "(null|string|date)",
  startDay: "number",
  format: "string",
  view: "string",
  viewChangeIconTemplate: "string",
  min: "(null|string|date)",
  max: "(null|string|date)",
  filter: "(null|function)",
  inline: "boolean",
  toggleButton: "boolean",
  disableToggleButton: "boolean",
  disableInput: "boolean",
  animations: "boolean",
  confirmDateOnSelect: "boolean",
  removeOkBtn: "boolean",
  removeCancelBtn: "boolean",
  removeClearBtn: "boolean"
}, sg = {
  fadeIn: Am,
  fadeOut: ym,
  fadeInShort: wm,
  fadeOutShort: km,
  modalContainer: xm,
  datepickerBackdrop: Om,
  datepickerMain: Sm,
  datepickerHeader: Im,
  datepickerTitle: Dm,
  datepickerTitleText: $m,
  datepickerDate: Lm,
  datepickerDateText: Nm,
  datepickerView: Mm,
  datepickerDateControls: Rm,
  datepickerViewChangeButton: Pm,
  datepickerViewChangeIcon: Jm,
  datepickerArrowControls: Bm,
  datepickerPreviousButton: Hm,
  datepickerNextButton: Vm,
  datepickerFooter: Wm,
  datepickerFooterBtn: Fm,
  datepickerClearBtn: Ym,
  datepickerDayHeading: jm,
  datepickerCell: Km,
  datepickerCellSmall: zm,
  datepickerCellLarge: Um,
  datepickerCellContent: Xm,
  datepickerCellContentSmall: Gm,
  datepickerCellContentLarge: qm,
  datepickerTable: Zm,
  datepickerToggleButton: Qm,
  datepickerDropdownContainer: tg
}, ng = {
  fadeIn: "string",
  fadeOut: "string",
  fadeInShort: "string",
  fadeOutShort: "string",
  modalContainer: "string",
  datepickerBackdrop: "string",
  datepickerMain: "string",
  datepickerHeader: "string",
  datepickerTitle: "string",
  datepickerTitleText: "string",
  datepickerDate: "string",
  datepickerDateText: "string",
  datepickerView: "string",
  datepickerDateControls: "string",
  datepickerViewChangeButton: "string",
  datepickerArrowControls: "string",
  datepickerPreviousButton: "string",
  datepickerNextButton: "string",
  datepickerFooter: "string",
  datepickerFooterBtn: "string",
  datepickerClearBtn: "string",
  datepickerDayHeading: "string",
  datepickerCell: "string",
  datepickerCellSmall: "string",
  datepickerCellLarge: "string",
  datepickerCellContent: "string",
  datepickerCellContentSmall: "string",
  datepickerCellContentLarge: "string",
  datepickerTable: "string",
  datepickerToggleButton: "string",
  datepickerDropdownContainer: "string"
};
class og {
  constructor(t, e, i) {
    this._element = t, this._input = d.findOne("input", this._element), this._options = this._getConfig(e), this._classes = this._getClasses(i), this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = this._options.view, this._popper = null, this._focusTrap = null, this._isOpen = !1, this._toggleButtonId = et("datepicker-toggle-"), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this._scrollBar = new ti(), this._element && A.setData(t, Qs, this), this._init(), this.toggleButton && this._options.disableToggle && (this.toggleButton.disabled = "true"), this._options.disableInput && (this._input.disabled = "true");
  }
  // Getters
  static get NAME() {
    return no;
  }
  get container() {
    return d.findOne(
      `[${fh}='${this._toggleButtonId}']`
    ) || d.findOne(
      `[${mh}='${this._toggleButtonId}']`
    );
  }
  get options() {
    return this._options;
  }
  get activeCell() {
    let t;
    return this._view === "days" && (t = this._getActiveDayCell()), this._view === "months" && (t = this._getActiveMonthCell()), this._view === "years" && (t = this._getActiveYearCell()), t;
  }
  get activeDay() {
    return tt(this._activeDate);
  }
  get activeMonth() {
    return Y(this._activeDate);
  }
  get activeYear() {
    return B(this._activeDate);
  }
  get firstYearInView() {
    return this.activeYear - Us(this._activeDate, Tt);
  }
  get lastYearInView() {
    return this.firstYearInView + Tt - 1;
  }
  get viewChangeButton() {
    return d.findOne(pm, this.container);
  }
  get previousButton() {
    return d.findOne(_m, this.container);
  }
  get nextButton() {
    return d.findOne(fm, this.container);
  }
  get okButton() {
    return d.findOne(mm, this.container);
  }
  get cancelButton() {
    return d.findOne(gm, this.container);
  }
  get clearButton() {
    return d.findOne(bm, this.container);
  }
  get datesContainer() {
    return d.findOne(vm, this.container);
  }
  get toggleButton() {
    return d.findOne(Tm, this._element);
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    if (t = {
      ...eg,
      ...e,
      ...t
    }, I(no, t, ig), t.max && typeof t.max == "string" && (t.max = new Date(t.max)), t.min && typeof t.min == "string" && (t.min = new Date(t.min)), t.startDay && t.startDay !== 0) {
      const i = this._getNewDaysOrderArray(t);
      t.weekdaysNarrow = i;
    }
    return t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...sg,
      ...e,
      ...t
    }, I(no, t, ng), t;
  }
  _getContainer() {
    return d.findOne(this._options.container);
  }
  _getNewDaysOrderArray(t) {
    const e = t.startDay, i = t.weekdaysNarrow;
    return i.slice(e).concat(i.slice(0, e));
  }
  _init() {
    !this.toggleButton && this._options.toggleButton && (this._appendToggleButton(), (this._input.readOnly || this._input.disabled) && (this.toggleButton.style.pointerEvents = "none")), this._listenToUserInput(), this._listenToToggleClick(), this._listenToToggleKeydown();
  }
  _appendToggleButton() {
    const t = nm(
      this._toggleButtonId,
      this._classes.datepickerToggleButton
    );
    this._element.insertAdjacentHTML("beforeend", t);
  }
  open() {
    if (this._input.readOnly || this._input.disabled)
      return;
    const t = c.trigger(this._element, cm);
    if (this._isOpen || t.defaultPrevented)
      return;
    this._setInitialDate();
    const e = Qf(this._classes.datepickerBackdrop), i = Zf(
      this._activeDate,
      this._selectedDate,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      _s,
      Tt,
      ps,
      this._toggleButtonId,
      this._classes
    );
    this._options.inline ? this._openDropdown(i) : (this._openModal(e, i), this._scrollBar.hide()), this._animations && (h.addClass(this.container, this._classes.fadeIn), h.addClass(e, this._classes.fadeInShort)), this._setFocusTrap(this.container), this._listenToDateSelection(), this._addControlsListeners(), this._updateControlsDisabledState(), this._listenToEscapeClick(), this._listenToKeyboardNavigation(), this._listenToDatesContainerFocus(), this._listenToDatesContainerBlur(), this._asyncFocusDatesContainer(), this._updateViewControlsAndAttributes(this._view), this._isOpen = !0, setTimeout(() => {
      this._listenToOutsideClick();
    }, 0);
  }
  _openDropdown(t) {
    this._popper = se(this._input, t, {
      placement: "bottom-start"
    }), this._getContainer().appendChild(t);
  }
  _openModal(t, e) {
    const i = this._getContainer();
    i.appendChild(t), i.appendChild(e);
  }
  _setFocusTrap(t) {
    this._focusTrap = new zi(t, {
      event: "keydown",
      condition: (e) => e.key === "Tab"
    }), this._focusTrap.trap();
  }
  _listenToUserInput() {
    c.on(this._input, "input", (t) => {
      this._handleUserInput(t.target.value);
    });
  }
  _listenToToggleClick() {
    c.on(
      this._element,
      fs,
      ms,
      (t) => {
        t.preventDefault(), this.open();
      }
    );
  }
  _listenToToggleKeydown() {
    c.on(
      this._element,
      "keydown",
      ms,
      (t) => {
        t.keyCode === it && !this._isOpen && this.open();
      }
    );
  }
  _listenToDateSelection() {
    c.on(this.datesContainer, "click", (t) => {
      this._handleDateSelection(t);
    });
  }
  _handleDateSelection(t) {
    const e = t.target.nodeName === "DIV" ? t.target.parentNode.dataset : t.target.dataset, i = t.target.nodeName === "DIV" ? t.target.parentNode : t.target;
    if (e.teDate && this._pickDay(e.teDate, i), e.teMonth && e.teYear) {
      const n = parseInt(e.teMonth, 10), o = parseInt(e.teYear, 10);
      this._pickMonth(n, o);
    }
    if (e.teYear && !e.teMonth) {
      const n = parseInt(e.teYear, 10);
      this._pickYear(n);
    }
    this._options.inline || this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _updateHeaderDate(t, e, i) {
    const n = d.findOne(
      Em,
      this.container
    ), o = Y(t), r = tt(t), a = zs(t);
    n.innerHTML = `${i[a]}, ${e[o]} ${r}`;
  }
  _addControlsListeners() {
    c.on(this.nextButton, "click", () => {
      this._view === "days" ? this.nextMonth() : this._view === "years" ? this.nextYears() : this.nextYear(), this._updateControlsDisabledState();
    }), c.on(this.previousButton, "click", () => {
      this._view === "days" ? this.previousMonth() : this._view === "years" ? this.previousYears() : this.previousYear(), this._updateControlsDisabledState();
    }), c.on(this.viewChangeButton, "click", () => {
      this._view === "days" ? this._changeView("years") : (this._view === "years" || this._view === "months") && this._changeView("days");
    }), this._options.inline || this._listenToFooterButtonsClick();
  }
  _listenToFooterButtonsClick() {
    c.on(this.okButton, "click", () => this.handleOk()), c.on(this.cancelButton, "click", () => this.handleCancel()), c.on(this.clearButton, "click", () => this.handleClear());
  }
  _listenToOutsideClick() {
    c.on(document, fs, (t) => {
      const e = t.target === this.container, i = this.container && this.container.contains(t.target);
      !e && !i && this.close();
    });
  }
  _listenToEscapeClick() {
    c.on(document, "keydown", (t) => {
      t.keyCode === we && this._isOpen && this.close();
    });
  }
  _listenToKeyboardNavigation() {
    c.on(this.datesContainer, "keydown", (t) => {
      this._handleKeydown(t);
    });
  }
  _listenToDatesContainerFocus() {
    c.on(this.datesContainer, "focus", () => {
      this._focusActiveCell(this.activeCell);
    });
  }
  _listenToDatesContainerBlur() {
    c.on(this.datesContainer, "blur", () => {
      this._removeCurrentFocusStyles();
    });
  }
  _handleKeydown(t) {
    this._view === "days" && this._handleDaysViewKeydown(t), this._view === "months" && this._handleMonthsViewKeydown(t), this._view === "years" && this._handleYearsViewKeydown(t);
  }
  _handleDaysViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell;
    switch (t.keyCode) {
      case Ke:
        this._activeDate = $e(this._activeDate, W() ? 1 : -1);
        break;
      case ze:
        this._activeDate = $e(this._activeDate, W() ? -1 : 1);
        break;
      case U:
        this._activeDate = $e(this._activeDate, -7);
        break;
      case z:
        this._activeDate = $e(this._activeDate, 7);
        break;
      case Te:
        this._activeDate = $e(
          this._activeDate,
          1 - tt(this._activeDate)
        );
        break;
      case Ee:
        this._activeDate = $e(
          this._activeDate,
          Go(this._activeDate) - tt(this._activeDate)
        );
        break;
      case io:
        this._activeDate = lt(this._activeDate, -1);
        break;
      case so:
        this._activeDate = lt(this._activeDate, 1);
        break;
      case it:
      case Zs:
        this._selectDate(this._activeDate), this._handleDateSelection(t), t.preventDefault();
        return;
      default:
        return;
    }
    Pi(
      e,
      this._activeDate,
      this._view,
      Tt,
      this._options.min,
      this._options.max
    ) || this._changeView("days"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _asyncFocusDatesContainer() {
    setTimeout(() => {
      this.datesContainer.focus();
    }, 0);
  }
  _focusActiveCell(t) {
    t && t.setAttribute("data-te-datepicker-cell-focused", "");
  }
  _removeHighlightFromCell(t) {
    t && t.removeAttribute("data-te-datepicker-cell-focused");
  }
  _getActiveDayCell() {
    const t = d.find("td", this.datesContainer);
    return Array.from(t).find((i) => {
      const n = Va(i.dataset.teDate);
      return me(n, this._activeDate);
    });
  }
  _handleMonthsViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell;
    switch (t.keyCode) {
      case Ke:
        this._activeDate = lt(this._activeDate, W() ? 1 : -1);
        break;
      case ze:
        this._activeDate = lt(this._activeDate, W() ? -1 : 1);
        break;
      case U:
        this._activeDate = lt(this._activeDate, -4);
        break;
      case z:
        this._activeDate = lt(this._activeDate, 4);
        break;
      case Te:
        this._activeDate = lt(this._activeDate, -this.activeMonth);
        break;
      case Ee:
        this._activeDate = lt(this._activeDate, 11 - this.activeMonth);
        break;
      case io:
        this._activeDate = at(this._activeDate, -1);
        break;
      case so:
        this._activeDate = at(this._activeDate, 1);
        break;
      case it:
      case Zs:
        this._selectMonth(this.activeMonth);
        return;
      default:
        return;
    }
    Pi(
      e,
      this._activeDate,
      this._view,
      Tt,
      this._options.min,
      this._options.max
    ) || this._changeView("months"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveMonthCell() {
    const t = d.find("td", this.datesContainer);
    return Array.from(t).find((i) => {
      const n = parseInt(i.dataset.teYear, 10), o = parseInt(i.dataset.teMonth, 10);
      return n === this.activeYear && o === this.activeMonth;
    });
  }
  _handleYearsViewKeydown(t) {
    const e = this._activeDate, i = this.activeCell, n = 4, o = 24;
    switch (t.keyCode) {
      case Ke:
        this._activeDate = at(this._activeDate, W() ? 1 : -1);
        break;
      case ze:
        this._activeDate = at(this._activeDate, W() ? -1 : 1);
        break;
      case U:
        this._activeDate = at(this._activeDate, -n);
        break;
      case z:
        this._activeDate = at(this._activeDate, n);
        break;
      case Te:
        this._activeDate = at(
          this._activeDate,
          -Us(this._activeDate, o)
        );
        break;
      case Ee:
        this._activeDate = at(
          this._activeDate,
          o - Us(this._activeDate, o) - 1
        );
        break;
      case io:
        this._activeDate = at(this._activeDate, -o);
        break;
      case so:
        this._activeDate = at(this._activeDate, o);
        break;
      case it:
      case Zs:
        this._selectYear(this.activeYear);
        return;
      default:
        return;
    }
    Pi(
      e,
      this._activeDate,
      this._view,
      Tt,
      this._options.min,
      this._options.max
    ) || this._changeView("years"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();
  }
  _getActiveYearCell() {
    const t = d.find("td", this.datesContainer);
    return Array.from(t).find((i) => parseInt(i.dataset.teYear, 10) === this.activeYear);
  }
  _setInitialDate() {
    this._input.value ? this._handleUserInput(this._input.value) : this._options.startDate ? this._activeDate = new Date(this._options.startDate) : this._activeDate = /* @__PURE__ */ new Date();
  }
  close() {
    const t = c.trigger(this._element, lm);
    !this._isOpen || t.defaultPrevented || (this._removeDatepickerListeners(), this._animations && h.addClass(this.container, this._classes.fadeOut), this._options.inline ? this._closeDropdown() : this._closeModal(), this._isOpen = !1, this._view = this._options.view, this.toggleButton ? this.toggleButton.focus() : this._input.focus());
  }
  _closeDropdown() {
    const t = d.findOne(um), e = this._getContainer();
    window.matchMedia("(prefers-reduced-motion: reduce)").matches && (t && e.removeChild(t), this._popper && this._popper.destroy()), t.addEventListener("animationend", () => {
      t && e.removeChild(t), this._popper && this._popper.destroy();
    }), this._removeFocusTrap();
  }
  _closeModal() {
    const t = d.findOne(Cm), e = d.findOne(dm);
    !e || !t || (this._animations ? (h.addClass(t, this._classes.fadeOutShort), t.addEventListener("animationend", () => {
      this._removePicker(t, e), this._scrollBar.reset();
    })) : (this._removePicker(t, e), this._scrollBar.reset()));
  }
  _removePicker(t, e) {
    const i = this._getContainer();
    i.removeChild(t), i.removeChild(e);
  }
  _removeFocusTrap() {
    this._focusTrap && (this._focusTrap.disable(), this._focusTrap = null);
  }
  _removeDatepickerListeners() {
    c.off(this.nextButton, "click"), c.off(this.previousButton, "click"), c.off(this.viewChangeButton, "click"), c.off(this.okButton, "click"), c.off(this.cancelButton, "click"), c.off(this.clearButton, "click"), c.off(this.datesContainer, "click"), c.off(this.datesContainer, "keydown"), c.off(this.datesContainer, "focus"), c.off(this.datesContainer, "blur"), c.off(document, fs);
  }
  dispose() {
    this._isOpen && this.close(), this._removeInputAndToggleListeners();
    const t = d.findOne(
      `#${this._toggleButtonId}`
    );
    t && this._element.removeChild(t), A.removeData(this._element, Qs), this._element = null, this._input = null, this._options = null, this._activeDate = null, this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = null, this._popper = null, this._focusTrap = null;
  }
  _removeInputAndToggleListeners() {
    c.off(this._input, "input"), c.off(
      this._element,
      fs,
      ms
    ), c.off(this._element, "keydown", ms);
  }
  handleOk() {
    this._confirmSelection(this._headerDate), this.close();
  }
  _selectDate(t, e = this.activeCell) {
    const { min: i, max: n, filter: o, disablePast: r, disableFuture: a } = this._options;
    _n(t, i, n, o, r, a) || (this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._selectedDate = t, this._selectedYear = B(t), this._selectedMonth = Y(t), this._headerDate = t, (this._options.inline || this.options.confirmDateOnSelect) && (this._confirmSelection(t), this.close()));
  }
  _selectYear(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerYear = t, this._asyncChangeView("months");
  }
  _selectMonth(t, e = this.activeCell) {
    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerMonth = t, this._asyncChangeView("days");
  }
  _removeSelectedStyles(t) {
    t && t.removeAttribute("data-te-datepicker-cell-selected");
  }
  _addSelectedStyles(t) {
    t && t.setAttribute("data-te-datepicker-cell-selected", "");
  }
  _confirmSelection(t) {
    if (t) {
      const e = this.formatDate(t);
      this._input.value = e, c.trigger(this._element, hm, { date: t }), c.trigger(this._input, "input");
    }
  }
  handleCancel() {
    this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this.close();
  }
  handleClear() {
    this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null, this._removeCurrentSelectionStyles(), this._input.value = "", this._setInitialDate(), this._changeView("days"), this._updateHeaderDate(
      this._activeDate,
      this._options.monthsShort,
      this._options.weekdaysShort
    );
  }
  _removeCurrentSelectionStyles() {
    const t = d.findOne(
      "[data-te-datepicker-cell-selected]",
      this.container
    );
    t && t.removeAttribute("data-te-datepicker-cell-selected");
  }
  _removeCurrentFocusStyles() {
    const t = d.findOne(
      "[data-te-datepicker-cell-focused]",
      this.container
    );
    t && t.removeAttribute("data-te-datepicker-cell-focused");
  }
  formatDate(t) {
    const e = tt(t), i = this._addLeadingZero(tt(t)), n = this._options.weekdaysShort[zs(t)], o = this._options.weekdaysFull[zs(t)], r = Y(t) + 1, a = this._addLeadingZero(Y(t) + 1), l = this._options.monthsShort[Y(t)], p = this._options.monthsFull[Y(t)], u = B(t).toString().length === 2 ? B(t) : B(t).toString().slice(2, 4), _ = B(t), f = this._options.format.split(
      /(d{1,4}|m{1,4}|y{4}|yy|!.)/g
    );
    let g = "";
    return f.forEach((m) => {
      switch (m) {
        case "dddd":
          m = m.replace(m, o);
          break;
        case "ddd":
          m = m.replace(m, n);
          break;
        case "dd":
          m = m.replace(m, i);
          break;
        case "d":
          m = m.replace(m, e);
          break;
        case "mmmm":
          m = m.replace(m, p);
          break;
        case "mmm":
          m = m.replace(m, l);
          break;
        case "mm":
          m = m.replace(m, a);
          break;
        case "m":
          m = m.replace(m, r);
          break;
        case "yyyy":
          m = m.replace(m, _);
          break;
        case "yy":
          m = m.replace(m, u);
          break;
      }
      g += m;
    }), g;
  }
  _addLeadingZero(t) {
    return parseInt(t, 10) < 10 ? `0${t}` : t;
  }
  _pickDay(t, e) {
    const i = Va(t), { min: n, max: o, filter: r, disablePast: a, disableFuture: l } = this._options;
    _n(i, n, o, r, a, l) || (this._activeDate = i, this._selectDate(i, e));
  }
  _pickYear(t) {
    const { min: e, max: i, disablePast: n, disableFuture: o } = this._options;
    if (qo(t, e, i, n, o))
      return;
    const r = Ct(t, this.activeMonth, this.activeDay);
    this._activeDate = r, this._selectedDate = r, this._selectYear(t);
  }
  _pickMonth(t, e) {
    const { min: i, max: n, disablePast: o, disableFuture: r } = this._options;
    if (_h(t, e, i, n, o, r) || qo(e, i, n, o, r))
      return;
    const a = Ct(e, t, this.activeDay);
    this._activeDate = a, this._selectMonth(t);
  }
  nextMonth() {
    const t = lt(this._activeDate, 1), e = Xs(
      t,
      this._headerDate,
      this._options,
      this._classes
    );
    this._activeDate = t, this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  previousMonth() {
    const t = lt(this._activeDate, -1);
    this._activeDate = t;
    const e = Xs(
      t,
      this._headerDate,
      this._options,
      this._classes
    );
    this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  nextYear() {
    const t = at(this._activeDate, 1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    );
    const e = Gs(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      _s,
      this._classes
    );
    this.datesContainer.innerHTML = e;
  }
  previousYear() {
    const t = at(this._activeDate, -1);
    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    );
    const e = Gs(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      _s,
      this._classes
    );
    this.datesContainer.innerHTML = e;
  }
  nextYears() {
    const t = at(this._activeDate, 24);
    this._activeDate = t;
    const e = qs(
      t,
      this._selectedYear,
      this._options,
      Tt,
      ps,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  previousYears() {
    const t = at(this._activeDate, -24);
    this._activeDate = t;
    const e = qs(
      t,
      this._selectedYear,
      this._options,
      Tt,
      ps,
      this._classes
    );
    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.datesContainer.innerHTML = e;
  }
  _asyncChangeView(t) {
    setTimeout(() => {
      this._changeView(t);
    }, 0);
  }
  _changeView(t) {
    this._view = t, this.datesContainer.blur(), t === "days" && (this.datesContainer.innerHTML = Xs(
      this._activeDate,
      this._headerDate,
      this._options,
      this._classes
    )), t === "months" && (this.datesContainer.innerHTML = Gs(
      this.activeYear,
      this._selectedYear,
      this._selectedMonth,
      this._options,
      _s,
      this._classes
    )), t === "years" && (this.datesContainer.innerHTML = qs(
      this._activeDate,
      this._selectedYear,
      this._options,
      Tt,
      ps,
      this._classes
    )), this.datesContainer.focus(), this._updateViewControlsAndAttributes(t), this._updateControlsDisabledState();
  }
  _updateViewControlsAndAttributes(t) {
    t === "days" && (this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToMultiYearViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevMonthLabel
    ), this.nextButton.setAttribute("aria-label", this._options.nextMonthLabel)), t === "months" && (this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToDayViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevYearLabel
    ), this.nextButton.setAttribute("aria-label", this._options.nextYearLabel)), t === "years" && (this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += Lt(
      this._options,
      this._classes
    ), this.viewChangeButton.setAttribute(
      "aria-label",
      this._options.switchToMonthViewLabel
    ), this.previousButton.setAttribute(
      "aria-label",
      this._options.prevMultiYearLabel
    ), this.nextButton.setAttribute(
      "aria-label",
      this._options.nextMultiYearLabel
    ));
  }
  _updateControlsDisabledState() {
    Hf(
      this._options.disableFuture,
      this._activeDate,
      this._view,
      Tt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.nextButton.disabled = !0 : this.nextButton.disabled = !1, Vf(
      this._options.disablePast,
      this._activeDate,
      this._view,
      Tt,
      this._options.min,
      this._options.max,
      this.lastYearInView,
      this.firstYearInView
    ) ? this.previousButton.disabled = !0 : this.previousButton.disabled = !1;
  }
  _handleUserInput(t) {
    const e = this._getDelimeters(this._options.format), i = this._parseDate(t, this._options.format, e);
    Rf(i) ? (this._activeDate = i, this._selectedDate = i, this._selectedYear = B(i), this._selectedMonth = Y(i), this._headerDate = i) : (this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null);
  }
  _getDelimeters(t) {
    return t.match(/[^(dmy)]{1,}/g);
  }
  _parseDate(t, e, i) {
    let n;
    i[0] !== i[1] ? n = i[0] + i[1] : n = i[0];
    const o = new RegExp(`[${n}]`), r = t.split(o), a = e.split(o), l = e.indexOf("mmm") !== -1, p = [];
    for (let b = 0; b < a.length; b++)
      a[b].indexOf("yy") !== -1 && (p[0] = { value: r[b], format: a[b] }), a[b].indexOf("m") !== -1 && (p[1] = { value: r[b], format: a[b] }), a[b].indexOf("d") !== -1 && a[b].length <= 2 && (p[2] = { value: r[b], format: a[b] });
    let u;
    e.indexOf("mmmm") !== -1 ? u = this._options.monthsFull : u = this._options.monthsShort;
    const _ = Number(p[0].value), f = l ? this.getMonthNumberByMonthName(p[1].value, u) : Number(p[1].value) - 1, g = Number(p[2].value);
    return Ct(_, f, g);
  }
  getMonthNumberByMonthName(t, e) {
    return e.findIndex((i) => i === t);
  }
  static getInstance(t) {
    return A.getData(t, Qs);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const rg = ({
  format24: s,
  okLabel: t,
  cancelLabel: e,
  headID: i,
  footerID: n,
  bodyID: o,
  pickerID: r,
  clearLabel: a,
  inline: l,
  showClearBtn: p,
  amLabel: u,
  pmLabel: _
}, f) => {
  const g = `<div id='${r}' class='${f.timepickerWrapper}' data-te-timepicker-wrapper>
      <div class="${f.timepickerContainer}">
        <div class="${f.timepickerElements}" data-te-timepicker-elements-wrapper>
        <div id='${i}' class='${f.timepickerHead}' style='padding-right:${s ? 50 : 10}px'>
        <div class='${f.timepickerHeadContent}'>
            <div class="${f.timepickerCurrentWrapper}">
              <span class="${f.timepickerCurrentButtonWrapper}">
                <button type='button' class='${f.timepickerCurrentButton}' tabindex="0" data-te-timepicker-active data-te-timepicker-current data-te-timepicker-hour data-te-ripple-init>21</button>
              </span>
              <button type='button' class='${f.timepickerDot}' disabled>:</button>
            <span class="${f.timepickerCurrentButtonWrapper}">
              <button type='button' class='${f.timepickerCurrentButton}' tabindex="0" data-te-timepicker-current data-te-timepicker-minute data-te-ripple-init>21</button>
            </span>
            </div>
            ${s ? "" : `<div class="${f.timepickerModeWrapper}">
                  <button type='button' class="${f.timepickerModeAm}" tabindex="0" data-te-timepicker-am data-te-timepicker-hour-mode data-te-ripple-init>${u}</button>
                  <button class="${f.timepickerModePm}" tabindex="0" data-te-timepicker-pm data-te-timepicker-hour-mode data-te-ripple-init>${_}</button>
                </div>`}
        </div>
      </div>
      ${l ? "" : `<div id='${o}' class='${f.timepickerClockWrapper}' data-te-timepicker-clock-wrapper>
            <div class='${f.timepickerClock}' data-te-timepicker-clock>
              <span class='${f.timepickerMiddleDot}' data-te-timepicker-middle-dot></span>
              <div class='${f.timepickerHandPointer}' data-te-timepicker-hand-pointer>
                <div class='${f.timepickerPointerCircle}' data-te-timepicker-circle></div>
              </div>
              ${s ? '<div class="' + f.timepickerClockInner + '" data-te-timepicker-clock-inner></div>' : ""}
            </div>
          </div>`}
    </div>
    <div id='${n}' class='${f.timepickerFooterWrapper}'>
      <div class="${f.timepickerFooter}">
        ${p ? `<button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-clear tabindex="0" data-te-ripple-init>${a}</button>` : ""}
        <button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-cancel tabindex="0" data-te-ripple-init>${e}</button>
        <button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>
      </div>
    </div>
  </div>
</div>`, m = `<div id='${r}' class='${f.timepickerInlineWrapper}' data-te-timepicker-wrapper>
        <div class="${f.timepickerInlineContainer}">
          <div class="${f.timepickerInlineElements}" data-te-timepicker-elements-wrapper>
          <div id='${i}' class='${f.timepickerInlineHead}'
          style='padding-right:10px'>
          <div class='${f.timepickerInlineHeadContent}'>
              <div class="${f.timepickerCurrentWrapper}">
                <span class="${f.timepickerInlineHourWrapper}" data-te-timepicker-inline-hour-icons>
                  <span class="${f.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-hour>
                    <span class="${f.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                      </svg>   
                    </span>
                  </span>
                  <button type='button' class='${f.timepickerInlineCurrentButton}' data-te-timepicker-hour data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                  <span class="${f.timepickerInlineIconDown}" data-te-timepicker-icon-inline-hour data-te-timepicker-icon-down>
                    <span class="${f.timepickerInlineIconSvg}">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                      </svg>  
                    </span>
                  </span>
                </span>
                <button type='button' class='${f.timepickerInlineDot}' data-te-timepicker-current-inline disabled>:</button>
              <span class="${f.timepickerCurrentMinuteWrapper}">
                <span class="${f.timepickerInlineIconUp}" data-te-timepicker-icon-up data-te-timepicker-icon-inline-minute>
                  <span class="${f.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
                    </svg>
                  </span>
                </span>
                <button type='button' class='${f.timepickerInlineCurrentButton}' data-te-timepicker-minute data-te-timepicker-current data-te-timepicker-current-inline tabindex="0" data-te-ripple-init>21</button>
                <span class="${f.timepickerInlineIconDown}" data-te-timepicker-icon-inline-minute data-te-timepicker-icon-down>
                  <span class="${f.timepickerInlineIconSvg}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                    </svg> 
                  </span>
                </span>
              </span>
              </div>
              ${s ? "" : `<div class="${f.timepickerInlineModeWrapper}">
                      <button type='button' class="${f.timepickerInlineModeAm}" data-te-timepicker-am data-te-timepicker-hour-mode tabindex="0" data-te-ripple-init>${u}</button>
                      <button class="${f.timepickerInlineModePm}" data-te-timepicker-hour-mode data-te-timepicker-pm tabindex="0" data-te-ripple-init>${_}</button>
                      <button type='button' class='${f.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>
                    </div>`}
              ${s ? `<button class='${f.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex="0" data-te-ripple-init>${t}</button>` : ""}
          </div>
        </div>
      </div>
    </div>
</div>`;
  return l ? m : g;
}, ag = (s, t, e) => {
  const { iconSVG: i } = s;
  return `
  <button id="${t}" tabindex="0" type="button" class="${e.timepickerToggleButton}" data-te-toggle="timepicker" data-te-timepicker-toggle-button data-te-timepicker-icon>
    ${i}
  </button>
`;
}, Cn = "data-te-timepicker-disabled", gs = "data-te-timepicker-active", Ce = (s) => {
  if (s === "")
    return;
  let t, e, i, n;
  return gh(s) ? (t = s.getHours(), n = t, e = s.getMinutes(), t %= 12, n === 0 && t === 0 && (i = "AM"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? "PM" : "AM"), e = e < 10 ? `0${e}` : e) : ([t, e, i] = R(s, !1), n = t, t %= 12, n === 0 && t === 0 && (i = "AM"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? "PM" : "AM")), {
    hours: t,
    minutes: e,
    amOrPm: i
  };
}, gh = (s) => s && Object.prototype.toString.call(s) === "[object Date]" && !Number.isNaN(s), Ka = (s) => {
  if (s === "")
    return;
  let t, e;
  return gh(s) ? (t = s.getHours(), e = s.getMinutes()) : [t, e] = R(s, !1), e = Number(e) < 10 ? `0${Number(e)}` : e, {
    hours: t,
    minutes: e
  };
}, lg = (s, t, e) => c.on(document, s, t, ({ target: i }) => {
  if (i.hasAttribute(gs))
    return;
  document.querySelectorAll(t).forEach((o) => {
    o.hasAttribute(gs) && (h.removeClass(o, e.opacity), o.removeAttribute(gs));
  }), h.addClass(i, e.opacity), i.setAttribute(gs, "");
}), za = ({ clientX: s, clientY: t, touches: e }, i, n = !1) => {
  const { left: o, top: r } = i.getBoundingClientRect();
  let a = {};
  return !n || !e ? a = {
    x: s - o,
    y: t - r
  } : n && Object.keys(e).length > 0 && (a = {
    x: e[0].clientX - o,
    y: e[0].clientY - r
  }), a;
}, bs = () => navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
  navigator.userAgent
), R = (s, t = !0) => t ? s.value.replace(/:/gi, " ").split(" ") : s.replace(/:/gi, " ").split(" "), bh = (s, t) => {
  const [e, i, n] = R(s, !1), [o, r, a] = R(t, !1);
  return n === "PM" && a === "AM" || n === a && e > o || i > r;
}, vh = () => {
  const s = /* @__PURE__ */ new Date(), t = s.getHours(), e = s.getMinutes();
  return `${t}:${e < 10 ? `0${e}` : e}`;
}, Gt = (s, t, e) => {
  if (!t)
    return s;
  let i = vh();
  return e && (i = `${Ce(i).hours}:${Ce(i).minutes} ${Ce(i).amOrPm}`), (s !== "" && bh(i, s) || s === "") && (s = i), s;
}, qt = (s, t, e) => {
  if (!t)
    return s;
  let i = vh();
  return e && (i = `${Ce(i).hours}:${Ce(i).minutes} ${Ce(i).amOrPm}`), (s !== "" && !bh(i, s) || s === "") && (s = i), s;
}, cg = ({ format12: s, maxTime: t, minTime: e, disablePast: i, disableFuture: n }, o, r) => {
  const a = R(o)[1];
  e = Gt(e, i, s), t = qt(t, n, s);
  const [l, p, u] = R(t, !1), [_, f, g] = R(e, !1);
  if (u !== void 0 || g !== void 0)
    return [r, a];
  if (!(l !== "" && _ === "" && Number(r) > Number(l)) && !(l === "" && _ !== "" && p === void 0 && f !== "" && Number(r) < Number(_)))
    return [r, a];
}, Ua = (s, t, e, i) => {
  s.forEach((n) => {
    t = t === "12" && i ? "0" : t, (n.textContent === "00" || Number(n.textContent === "12" && i ? "0" : n.textContent) > t) && (h.addClass(n, e.tipsDisabled), n.setAttribute(Cn, ""));
  });
}, Xa = (s, t, e, i) => {
  s.forEach((n) => {
    t = t === "12" && i ? "0" : t, n.textContent !== "00" && Number(n.textContent === "12" && i ? "0" : n.textContent) < Number(t) && (h.addClass(n, e.tipsDisabled), n.setAttribute(Cn, ""));
  });
}, Th = (s, t, e, i) => {
  if (t === "12" || t === "24")
    return;
  const n = e ? 12 : 24;
  return i === "max" ? (Number(s) === n ? 0 : Number(s)) > Number(t) : (Number(s) === n ? 0 : Number(s)) < Number(t);
}, hg = (s, t, e, i, n, o) => {
  s.forEach((r) => {
    (Th(i, e, o, "max") || Number(r.textContent) > t && Number(i) === Number(e)) && (h.addClass(r, n.tipsDisabled), r.setAttribute(Cn, ""));
  });
}, dg = (s, t, e, i, n, o) => {
  s.forEach((r) => {
    (Th(i, e, o, "min") || Number(r.textContent) < t && Number(i) === Number(e)) && (h.addClass(r, n.tipsDisabled), r.setAttribute(Cn, ""));
  });
}, ug = (s) => s.startsWith("0") ? Number(s.slice(1)) : Number(s), Bi = "timepicker", M = `data-te-${Bi}`, Ga = "[data-te-toggle]", Js = `te.${Bi}`, Pt = `.${Js}`, Bt = ".data-api", qa = `click${Pt}${Bt}`, vs = `keydown${Pt}${Bt}`, Za = `mousedown${Pt}${Bt}`, Qa = `mouseup${Pt}${Bt}`, Ja = `mousemove${Pt}${Bt}`, tl = `mouseleave${Pt}${Bt}`, el = `mouseover${Pt}${Bt}`, il = `touchmove${Pt}${Bt}`, sl = `touchend${Pt}${Bt}`, nl = `touchstart${Pt}${Bt}`, pg = `[${M}-am]`, _g = `[${M}-pm]`, fg = `[${M}-format24]`, Ts = `[${M}-current]`, Es = `[${M}-hour-mode]`, mg = `[${M}-toggle-button]`, oo = `${M}-cancel`, ol = `${M}-clear`, ro = `${M}-submit`, gg = `${M}-icon`, ao = `${M}-icon-up`, lo = `${M}-icon-down`, bg = `${M}-icon-inline-hour`, vg = `${M}-icon-inline-minute`, rl = `${M}-inline-hour-icons`, Tg = `${M}-current-inline`, Eg = "readonly", Cg = `${M}-invalid-feedback`, co = `${M}-is-invalid`, jt = `${M}-disabled`, H = `${M}-active`, Ag = `${M}-input`, ue = `${M}-clock`, mi = `${M}-clock-inner`, ho = `${M}-wrapper`, al = `${M}-clock-wrapper`, Cs = `${M}-hour`, uo = `${M}-minute`, As = `${M}-tips-element`, X = `${M}-tips-hours`, q = `${M}-tips-minutes`, ht = `${M}-tips-inner`, ys = `${M}-tips-inner-element`, ll = `${M}-middle-dot`, po = `${M}-hand-pointer`, _o = `${M}-circle`, cl = `${M}-modal`, yg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>`, wg = {
  appendValidationInfo: !0,
  bodyID: "",
  cancelLabel: "Cancel",
  clearLabel: "Clear",
  closeModalOnBackdropClick: !0,
  closeModalOnMinutesClick: !1,
  container: "body",
  defaultTime: "",
  disabled: !1,
  disablePast: !1,
  disableFuture: !1,
  enableValidation: !0,
  focusInputAfterApprove: !1,
  footerID: "",
  format12: !0,
  format24: !1,
  headID: "",
  increment: !1,
  inline: !1,
  invalidLabel: "Invalid Time Format",
  maxTime: "",
  minTime: "",
  modalID: "",
  okLabel: "Ok",
  overflowHidden: !0,
  pickerID: "",
  readOnly: !1,
  showClearBtn: !0,
  switchHoursToMinutesOnClick: !0,
  iconSVG: yg,
  withIcon: !0,
  pmLabel: "PM",
  amLabel: "AM",
  animations: !0
}, kg = {
  appendValidationInfo: "boolean",
  bodyID: "string",
  cancelLabel: "string",
  clearLabel: "string",
  closeModalOnBackdropClick: "boolean",
  closeModalOnMinutesClick: "boolean",
  container: "string",
  disabled: "boolean",
  disablePast: "boolean",
  disableFuture: "boolean",
  enableValidation: "boolean",
  footerID: "string",
  format12: "boolean",
  format24: "boolean",
  headID: "string",
  increment: "boolean",
  inline: "boolean",
  invalidLabel: "string",
  modalID: "string",
  okLabel: "string",
  overflowHidden: "boolean",
  pickerID: "string",
  readOnly: "boolean",
  showClearBtn: "boolean",
  switchHoursToMinutesOnClick: "boolean",
  defaultTime: "(string|date|number)",
  iconSVG: "string",
  withIcon: "boolean",
  pmLabel: "string",
  amLabel: "string",
  animations: "boolean"
}, xg = {
  tips: "absolute rounded-[100%] w-[32px] h-[32px] text-center cursor-pointer text-[1.1rem] rounded-[100%] bg-transparent flex justify-center items-center font-light focus:outline-none selection:bg-transparent",
  tipsActive: "text-white bg-[#3b71ca] font-normal",
  tipsDisabled: "text-[#b3afaf] pointer-events-none bg-transparent",
  transform: "transition-[transform,height] ease-in-out duration-[400ms]",
  modal: "z-[1065]",
  clockAnimation: "animate-[show-up-clock_350ms_linear]",
  opacity: "!opacity-100",
  timepickerWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col fixed",
  timepickerContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)] min-[320px]:max-[825px]:landscape:rounded-lg",
  timepickerElements: "flex flex-col min-w-[310px] min-h-[325px] bg-white rounded-t-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape:min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg pr-[24px] pl-[50px] py-[10px] min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center",
  timepickerHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly",
  timepickerCurrentWrapper: "[direction:ltr] rtl:[direction:rtl]",
  timepickerCurrentButtonWrapper: "relative h-full",
  timepickerCurrentButton: "text-[3.75rem] font-light leading-[1.2] tracking-[-0.00833em] text-white opacity-[.54] border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none ",
  timepickerDot: "font-light leading-[1.2] tracking-[-0.00833em] text-[3.75rem] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal",
  timepickerModeWrapper: "flex flex-col justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerModeAm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerModePm: "p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none",
  timepickerClockWrapper: "min-w-[310px] max-w-[325px] min-h-[305px] overflow-x-hidden h-full flex justify-center flex-col items-center dark:bg-zinc-500",
  timepickerClock: "relative rounded-[100%] w-[260px] h-[260px] cursor-default my-0 mx-auto bg-[#00000012] dark:bg-zinc-600/50",
  timepickerMiddleDot: "top-1/2 left-1/2 w-[6px] h-[6px] -translate-y-1/2 -translate-x-1/2 rounded-[50%] bg-[#3b71ca] absolute",
  timepickerHandPointer: "bg-[#3b71ca] bottom-1/2 h-2/5 left-[calc(50%-1px)] rtl:!left-auto origin-[center_bottom_0] rtl:!origin-[50%_50%_0] w-[2px] absolute",
  timepickerPointerCircle: "-top-[21px] -left-[15px] w-[4px] border-[14px] border-solid border-[#3b71ca] h-[4px] box-content rounded-[100%] absolute",
  timepickerClockInner: "absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 w-[160px] h-[160px] rounded-[100%]",
  timepickerFooterWrapper: "rounded-b-lg flex justify-between items-center w-full h-[56px] px-[12px] bg-white dark:bg-zinc-500",
  timepickerFooter: "w-full flex justify-between",
  timepickerFooterButton: "text-[0.8rem] min-w-[64px] box-border font-medium leading-[40px] rounded-[10px] tracking-[0.1rem] uppercase text-[#3b71ca] dark:text-white border-none bg-transparent transition-[background-color,box-shadow,border] duration-[250ms] ease-[cubic-bezier(0.4,0,0.2,1)] delay-[0ms] outline-none py-0 px-[10px] h-[40px] mb-[10px] hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none",
  timepickerInlineWrapper: "touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col rounded-lg",
  timepickerInlineContainer: "flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)]",
  timepickerInlineElements: "flex flex-col min-h-[auto] min-w-[310px] bg-white rounded-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:rounded-bl-lg min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape::min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around",
  timepickerInlineHead: "bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center p-0 rounded-b-lg",
  timepickerInlineHeadContent: "min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly items-center",
  timepickerInlineHourWrapper: "relative h-full !opacity-100",
  timepickerCurrentMinuteWrapper: "relative h-full",
  timepickerInlineIconUp: "absolute text-white -top-[35px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineIconSvg: "h-4 w-4",
  timepickerInlineCurrentButton: "font-light leading-[1.2] tracking-[-0.00833em] text-white border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal !opacity-100 cursor-pointer focus:bg-[#00000026] hover:outline-none focus:outline-none text-[2.5rem] hover:bg-[unset]",
  timepickerInlineIconDown: "absolute text-white -bottom-[47px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center",
  timepickerInlineDot: "font-light leading-[1.2] tracking-[-0.00833em] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal text-[2.5rem]",
  timepickerInlineModeWrapper: "flex justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row",
  timepickerInlineModeAm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer mr-2 ml-6",
  timepickerInlineModePm: "hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer",
  timepickerInlineSubmitButton: "hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none text-[0.8rem] box-border font-medium leading-[40px] tracking-[.1rem] uppercase border-none bg-transparent [transition:background-color_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,box-shadow_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,border_250ms_cubic-bezier(0.4,0,0.2,1)_0ms] outline-none rounded-[100%] h-[48px] min-w-[48px] inline-block ml-[30px] text-white py-1 px-2 mb-0",
  timepickerToggleButton: "h-4 w-4 ml-auto absolute outline-none border-none bg-transparent right-1.5 top-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)] cursor-pointer hover:text-[#3b71ca] focus:text-[#3b71ca] dark:hover:text-[#3b71ca] dark:focus:text-[#3b71ca] dark:text-white"
}, Og = {
  tips: "string",
  tipsActive: "string",
  tipsDisabled: "string",
  transform: "string",
  modal: "string",
  clockAnimation: "string",
  opacity: "string",
  timepickerWrapper: "string",
  timepickerContainer: "string",
  timepickerElements: "string",
  timepickerHead: "string",
  timepickerHeadContent: "string",
  timepickerCurrentWrapper: "string",
  timepickerCurrentButtonWrapper: "string",
  timepickerCurrentButton: "string",
  timepickerDot: "string",
  timepickerModeWrapper: "string",
  timepickerModeAm: "string",
  timepickerModePm: "string",
  timepickerClockWrapper: "string",
  timepickerClock: "string",
  timepickerMiddleDot: "string",
  timepickerHandPointer: "string",
  timepickerPointerCircle: "string",
  timepickerClockInner: "string",
  timepickerFooterWrapper: "string",
  timepickerFooterButton: "string",
  timepickerInlineWrapper: "string",
  timepickerInlineContainer: "string",
  timepickerInlineElements: "string",
  timepickerInlineHead: "string",
  timepickerInlineHeadContent: "string",
  timepickerInlineHourWrapper: "string",
  timepickerCurrentMinuteWrapper: "string",
  timepickerInlineIconUp: "string",
  timepickerInlineIconSvg: "string",
  timepickerInlineCurrentButton: "string",
  timepickerInlineIconDown: "string",
  timepickerInlineDot: "string",
  timepickerInlineModeWrapper: "string",
  timepickerInlineModeAm: "string",
  timepickerInlineModePm: "string",
  timepickerInlineSubmitButton: "string",
  timepickerToggleButton: "string"
};
class Sg {
  constructor(t, e = {}, i) {
    wt(this, "_toggleAmPm", (t) => {
      t === "PM" ? (this._isPmEnabled = !0, this._isAmEnabled = !1) : t === "AM" && (this._isPmEnabled = !1, this._isAmEnabled = !0);
    });
    wt(this, "_toggleBackgroundColorCircle", (t) => {
      if (this._modal.querySelector(`${t}[${H}]`) !== null) {
        h.addStyle(this._circle, {
          backgroundColor: "#1976d2"
        });
        return;
      }
      h.addStyle(this._circle, {
        backgroundColor: "transparent"
      });
    });
    wt(this, "_toggleClassActive", (t, { textContent: e }, i) => {
      const n = [...t].find(
        (o) => Number(o) === Number(e)
      );
      return i.forEach((o) => {
        if (!o.hasAttribute(jt)) {
          if (o.textContent === n) {
            h.addClass(o, this._classes.tipsActive), o.setAttribute(H, "");
            return;
          }
          h.removeClass(o, this._classes.tipsActive), o.removeAttribute(H);
        }
      });
    });
    wt(this, "_makeMinutesDegrees", (t, e) => {
      const { increment: i } = this._options;
      return t < 0 ? (e = Math.round(360 + t / 6) % 60, t = 360 + Math.round(t / 6) * 6) : (e = Math.round(t / 6) % 60, t = Math.round(t / 6) * 6), i && (t = Math.round(t / 30) * 30, e = Math.round(t / 6) * 6 / 6, e === 60 && (e = "00")), t >= 360 && (t = 0), {
        degrees: t,
        minute: e,
        addDegrees: i ? 30 : 6
      };
    });
    wt(this, "_makeHourDegrees", (t, e, i) => {
      if (t)
        return this._hasTargetInnerClass(t) ? e < 0 ? (i = Math.round(360 + e / 30) % 24, e = 360 + e) : (i = Math.round(e / 30) + 12, i === 12 && (i = "00")) : e < 0 ? (i = Math.round(360 + e / 30) % 12, e = 360 + e) : (i = Math.round(e / 30) % 12, (i === 0 || i > 12) && (i = 12)), e >= 360 && (e = 0), {
          degrees: e,
          hour: i,
          addDegrees: 30
        };
    });
    wt(this, "_makeInnerHoursDegrees", (t, e) => (t < 0 ? (e = Math.round(360 + t / 30) % 24, t = 360 + t) : (e = Math.round(t / 30) + 12, e === 12 && (e = "00")), {
      degrees: t,
      hour: e,
      addDegrees: 30
    }));
    wt(this, "_getAppendClock", (t = [], e = `[${ue}]`, i) => {
      let { minTime: n, maxTime: o } = this._options;
      const { inline: r, format12: a, disablePast: l, disableFuture: p } = this._options;
      n = Gt(n, l, a), o = qt(o, p, a);
      const [u, _, f] = R(
        o,
        !1
      ), [g, m, b] = R(
        n,
        !1
      );
      !r && a && this._isInvalidTimeFormat && !this._AM.hasAttribute(H) && (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, ""));
      const v = d.findOne(e), T = 360 / t.length;
      function y(k) {
        return k * (Math.PI / 180);
      }
      if (v === null)
        return;
      const C = (v.offsetWidth - 32) / 2, E = (v.offsetHeight - 32) / 2, w = C - 4;
      setTimeout(() => {
        let k;
        a && (k = d.findOne(
          `${Es}[${H}]`
        ).textContent), this._handleDisablingTipsMinTime(
          k,
          b,
          m,
          g
        ), this._handleDisablingTipsMaxTime(
          k,
          f,
          _,
          u
        );
      }, 0), [...t].forEach((k, D) => {
        const O = y(D * T), x = $("span"), L = $("span");
        L.innerHTML = k, h.addClass(x, this._classes.tips), x.setAttribute(i, "");
        const S = x.offsetWidth, N = x.offsetHeight;
        return h.addStyle(x, {
          left: `${C + Math.sin(O) * w - S}px`,
          bottom: `${E + Math.cos(O) * w - N}px`
        }), t.includes("05") && x.setAttribute(q, ""), t.includes("13") ? L.setAttribute(ys, "") : L.setAttribute(As, ""), x.appendChild(L), v.appendChild(x);
      });
    });
    this._element = t, this._element && A.setData(t, Js, this), this._document = document, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._currentTime = null, this._toggleButtonId = et("timepicker-toggle-"), this.hoursArray = [
      "12",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "10",
      "11"
    ], this.innerHours = [
      "00",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "20",
      "21",
      "22",
      "23"
    ], this.minutesArray = [
      "00",
      "05",
      "10",
      "15",
      "20",
      "25",
      "30",
      "35",
      "40",
      "45",
      "50",
      "55"
    ], this.input = d.findOne("input", this._element), this.dataWithIcon = t.dataset.withIcon, this.dataToggle = t.dataset.toggle, this.customIcon = d.findOne(
      mg,
      this._element
    ), this._checkToggleButton(), this.inputFormatShow = d.findOne(
      fg,
      this._element
    ), this.inputFormat = this.inputFormatShow === null ? "" : Object.values(this.inputFormatShow.dataset)[0], this.elementToggle = d.findOne(
      Ga,
      this._element
    ), this.toggleElement = Object.values(
      t.querySelector(Ga).dataset
    )[0], this._hour = null, this._minutes = null, this._AM = null, this._PM = null, this._wrapper = null, this._modal = null, this._hand = null, this._circle = null, this._focusTrap = null, this._popper = null, this._interval = null, this._timeoutInterval = null, this._inputValue = this._options.defaultTime !== "" ? this._options.defaultTime : this.input.value, this._options.format24 && (this._options.format12 = !1, this._currentTime = Ka(this._inputValue)), this._options.format12 && (this._options.format24 = !1, this._currentTime = Ce(this._inputValue)), this._options.readOnly && this.input.setAttribute(Eg, !0), this.inputFormat === "true" && this.inputFormat !== "" && (this._options.format12 = !1, this._options.format24 = !0, this._currentTime = Ka(this._inputValue)), this._animations = !window.matchMedia("(prefers-reduced-motion: reduce)").matches && this._options.animations, this.init(), this._isHours = !0, this._isMinutes = !1, this._isInvalidTimeFormat = !1, this._isMouseMove = !1, this._isInner = !1, this._isAmEnabled = !1, this._isPmEnabled = !1, this._options.format12 && !this._options.defaultTime && (this._isPmEnabled = !0), this._objWithDataOnChange = { degrees: null }, this._scrollBar = new ti();
  }
  // Getters
  static get NAME() {
    return Bi;
  }
  // Public
  init() {
    const { format12: t, format24: e, enableValidation: i } = this._options;
    let n, o, r;
    if (this.input.setAttribute(Ag, ""), this._currentTime !== void 0) {
      const { hours: a, minutes: l, amOrPm: p } = this._currentTime;
      n = Number(a) < 10 ? 0 : "", o = `${n}${Number(a)}:${l}`, r = p, t ? this.input.value = `${o} ${r}` : e && (this.input.value = `${o}`);
    } else
      n = "", o = "", r = "", this.input.value = "";
    this.input.value.length > 0 && this.input.value !== "" && (this.input.setAttribute(H, ""), c.trigger(this.input, "input")), !(this._options === null && this._element === null) && (i && this._getValidate("keydown change blur focus"), this._handleOpen(), this._listenToToggleKeydown());
  }
  dispose() {
    this._removeModal(), this._element !== null && A.removeData(this._element, Js), setTimeout(() => {
      this._element = null, this._options = null, this.input = null, this._focusTrap = null;
    }, 350), c.off(
      this._element,
      "click",
      `[data-te-toggle='${this.toggleElement}']`
    ), c.off(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`
    );
  }
  update(t = {}) {
    this._options = this._getConfig({ ...this._options, ...t });
  }
  // private
  _checkToggleButton() {
    this.customIcon === null && (this.dataWithIcon !== void 0 && (this._options.withIcon = null, this.dataWithIcon === "true" && this._appendToggleButton(this._options)), this._options.withIcon && this._appendToggleButton(this._options));
  }
  _appendToggleButton() {
    const t = ag(
      this._options,
      this._toggleButtonId,
      this._classes
    );
    this.input.insertAdjacentHTML("afterend", t);
  }
  _getDomElements() {
    this._hour = d.findOne(`[${Cs}]`), this._minutes = d.findOne(`[${uo}]`), this._AM = d.findOne(pg), this._PM = d.findOne(_g), this._wrapper = d.findOne(`[${ho}]`), this._modal = d.findOne(`[${cl}]`), this._hand = d.findOne(`[${po}]`), this._circle = d.findOne(`[${_o}]`), this._clock = d.findOne(`[${ue}]`), this._clockInner = d.findOne(
      `[${mi}]`
    );
  }
  _handlerMaxMinHoursOptions(t, e, i, n, o, r) {
    if (!e && !i)
      return !0;
    const { format24: a, format12: l, disablePast: p, disableFuture: u } = this._options, { _isAmEnabled: _, _isPmEnabled: f } = this, g = r.keyCode, m = r.target.hasAttribute(mi) || r.target.hasAttribute(ht) || r.target.hasAttribute(ys);
    i = Gt(i, p, l), e = qt(e, u, l), typeof e != "number" && (e = R(e, !1)[0]);
    const b = e !== "" ? e * 30 : "", v = i !== "" ? i * 30 : "";
    t < 0 && (t = 360 + t), t = t === 360 ? 0 : t;
    const T = () => {
      const D = document.querySelectorAll(
        `[${As}]`
      ), O = document.querySelectorAll(
        `[${ys}]`
      ), x = ug(this._hour.innerText);
      let L, S, N;
      return g === U ? S = 1 : g === z && (S = -1), x === 12 && g === U ? N = 1 : x === 0 && g === U ? N = 13 : x === 0 && g === z ? N = 23 : x === 13 && g === z ? N = 0 : x === 1 && g === z ? N = 12 : N = x + S, D.forEach((P) => {
        Number(P.textContent) === N && (L = P);
      }), O.forEach((P) => {
        Number(P.textContent) === N && (L = P);
      }), !L.parentElement.hasAttribute(jt);
    }, y = () => {
      const D = i !== "" && i > 12 ? (i - 12) * 30 : "", O = e !== "" && e > 12 ? (e - 12) * 30 : "";
      if (!(D && t < D || O && t > O || e && e < 12))
        return !0;
    };
    if (a && r.type !== "keydown" && m)
      return y();
    if (r.type === "keydown")
      return T();
    const C = !o || o === "PM" && f || i !== "" && o === "AM" && _, E = !n || n === "PM" && f || e !== "" && n === "AM" && _, w = () => {
      const D = v === 360 && l ? 0 : v;
      if (i) {
        if (o === "PM" && _ || C && t < D)
          return;
      } else
        return !0;
      return !0;
    }, k = () => {
      const D = b === 360 && l ? 0 : b;
      if (e) {
        if (n === "AM" && f || E && t > D)
          return;
      } else
        return !0;
      return !0;
    };
    return w() && k();
  }
  _handleKeyboard() {
    c.on(this._document, vs, "", (t) => {
      let e, i, n;
      const {
        increment: o,
        maxTime: r,
        minTime: a,
        format12: l,
        disablePast: p,
        disableFuture: u
      } = this._options;
      let _ = R(a, !1)[0], f = R(r, !1)[0];
      const g = R(a, !1)[2], m = R(r, !1)[2];
      _ = Gt(_, p, l), f = qt(f, u, l), typeof f != "number" && (f = R(f, !1)[0]);
      const b = d.findOne(`[${q}]`) === null, v = d.findOne(`[${ht}]`) !== null, T = Number(this._hand.style.transform.replace(/[^\d-]/g, "")), y = d.find(
        `[${q}]`,
        this._modal
      ), C = d.find(
        `[${X}]`,
        this._modal
      ), E = d.find(
        `[${ht}]`,
        this._modal
      );
      let w = this._makeHourDegrees(t.target, T, e).hour;
      const { degrees: k, addDegrees: D } = this._makeHourDegrees(
        t.target,
        T,
        e
      );
      let { minute: O, degrees: x } = this._makeMinutesDegrees(T, i);
      const L = this._makeMinutesDegrees(
        T,
        i
      ).addDegrees;
      let { hour: S } = this._makeInnerHoursDegrees(
        T,
        n
      );
      if (t.keyCode === we) {
        const N = d.findOne(
          `[${oo}]`,
          this._modal
        );
        c.trigger(N, "click");
      } else if (b) {
        if (v && (t.keyCode === ze && (this._isInner = !1, h.addStyle(this._hand, {
          height: "calc(40% + 1px)"
        }), this._hour.textContent = this._setHourOrMinute(
          w > 12 ? 1 : w
        ), this._toggleClassActive(this.hoursArray, this._hour, C), this._toggleClassActive(this.innerHours, this._hour, E)), t.keyCode === Ke && (this._isInner = !0, h.addStyle(this._hand, {
          height: "21.5%"
        }), this._hour.textContent = this._setHourOrMinute(
          S >= 24 || S === "00" ? 0 : S
        ), this._toggleClassActive(this.innerHours, this._hour, E), this._toggleClassActive(
          this.hoursArray,
          this._hour - 1,
          C
        ))), t.keyCode === U) {
          if (!this._handlerMaxMinHoursOptions(
            k + 30,
            f,
            _,
            m,
            g,
            t
          ))
            return;
          h.addStyle(this._hand, {
            transform: `rotateZ(${k + D}deg)`
          }), this._isInner ? (S += 1, S === 24 ? S = 0 : (S === 25 || S === "001") && (S = 13), this._hour.textContent = this._setHourOrMinute(S), this._toggleClassActive(this.innerHours, this._hour, E)) : (w += 1, this._hour.textContent = this._setHourOrMinute(
            w > 12 ? 1 : w
          ), this._toggleClassActive(this.hoursArray, this._hour, C));
        }
        if (t.keyCode === z) {
          if (!this._handlerMaxMinHoursOptions(
            k - 30,
            f,
            _,
            m,
            g,
            t
          ))
            return;
          h.addStyle(this._hand, {
            transform: `rotateZ(${k - D}deg)`
          }), this._isInner ? (S -= 1, S === 12 ? S = 0 : S === -1 && (S = 23), this._hour.textContent = this._setHourOrMinute(S), this._toggleClassActive(this.innerHours, this._hour, E)) : (w -= 1, this._hour.textContent = this._setHourOrMinute(
            w === 0 ? 12 : w
          ), this._toggleClassActive(this.hoursArray, this._hour, C));
        }
      } else
        t.keyCode === U && (x += L, h.addStyle(this._hand, {
          transform: `rotateZ(${x}deg)`
        }), O += 1, o && (O += 4, O === "0014" && (O = 5)), this._minutes.textContent = this._setHourOrMinute(
          O > 59 ? 0 : O
        ), this._toggleClassActive(
          this.minutesArray,
          this._minutes,
          y
        ), this._toggleBackgroundColorCircle(
          `[${q}]`
        )), t.keyCode === z && (x -= L, h.addStyle(this._hand, {
          transform: `rotateZ(${x}deg)`
        }), o ? O -= 5 : O -= 1, O === -1 ? O = 59 : O === -5 && (O = 55), this._minutes.textContent = this._setHourOrMinute(O), this._toggleClassActive(
          this.minutesArray,
          this._minutes,
          y
        ), this._toggleBackgroundColorCircle(
          `[${q}]`
        ));
    });
  }
  _setActiveClassToTipsOnOpen(t, ...e) {
    if (!this._isInvalidTimeFormat)
      if (this._options.format24) {
        const i = d.find(
          `[${X}]`,
          this._modal
        ), n = d.find(
          `[${ht}]`,
          this._modal
        );
        this._addActiveClassToTip(i, t), this._addActiveClassToTip(n, t);
      } else {
        [...e].filter((n) => (n.toLowerCase() === "pm" ? (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, "")) : n.toLowerCase() === "am" ? (h.addClass(this._AM, this._classes.opacity), this._AM.setAttribute(H, "")) : (h.removeClass(this._AM, this._classes.opacity), h.removeClass(this._PM, this._classes.opacity), this._AM.removeAttribute(H), this._PM.removeAttribute(H)), n));
        const i = d.find(
          `[${X}]`,
          this._modal
        );
        this._addActiveClassToTip(i, t);
      }
  }
  _setTipsAndTimesDependOnInputValue(t, e) {
    const { inline: i, format12: n } = this._options;
    if (this._isInvalidTimeFormat)
      this._hour.textContent = "12", this._minutes.textContent = "00", i || h.addStyle(this._hand, {
        transform: "rotateZ(0deg)"
      }), n && (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, ""));
    else {
      const o = t > 12 ? t * 30 - 360 : t * 30;
      this._hour.textContent = t, this._minutes.textContent = e, i || (h.addStyle(this._hand, {
        transform: `rotateZ(${o}deg)`
      }), h.addStyle(this._circle, {
        backgroundColor: "#1976d2"
      }), (Number(t) > 12 || t === "00") && h.addStyle(this._hand, {
        height: "21.5%"
      }));
    }
  }
  _listenToToggleKeydown() {
    c.on(
      this._element,
      "keydown",
      `[data-te-toggle='${this.toggleElement}']`,
      (t) => {
        t.keyCode === it && (t.preventDefault(), c.trigger(this.elementToggle, "click"));
      }
    );
  }
  _handleOpen() {
    const t = this._getContainer();
    K.on(
      this._element,
      "click",
      `[data-te-toggle='${this.toggleElement}']`,
      (e) => {
        if (this._options === null)
          return;
        const i = h.getDataAttribute(this.input, "toggle") !== null ? 200 : 0;
        setTimeout(() => {
          h.addStyle(this.elementToggle, {
            pointerEvents: "none"
          }), this.elementToggle.blur();
          let n;
          R(this.input)[0] === "" ? n = ["12", "00", "PM"] : n = R(this.input);
          const { modalID: o, inline: r, format12: a } = this._options, [l, p, u] = n, _ = $("div");
          if ((Number(l) > 12 || l === "00") && (this._isInner = !0), this.input.blur(), e.target.blur(), _.innerHTML = rg(this._options, this._classes), h.addClass(_, this._classes.modal), _.setAttribute(cl, ""), _.setAttribute("role", "dialog"), _.setAttribute("tabIndex", "-1"), _.setAttribute("id", o), r ? (this._popper = se(this.input, _, {
            placement: "bottom-start"
          }), t.appendChild(_)) : (t.appendChild(_), this._scrollBar.hide()), this._getDomElements(), this._animations ? this._toggleBackdropAnimation() : h.addClass(this._wrapper, this._classes.opacity), this._setActiveClassToTipsOnOpen(l, p, u), this._appendTimes(), this._setActiveClassToTipsOnOpen(l, p, u), this._setTipsAndTimesDependOnInputValue(l, p), this.input.value === "") {
            const f = d.find(
              `[${X}]`,
              this._modal
            );
            a && (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, "")), this._hour.textContent = "12", this._minutes.textContent = "00", this._addActiveClassToTip(
              f,
              Number(this._hour.textContent)
            );
          }
          if (this._handleSwitchTimeMode(), this._handleOkButton(), this._handleClose(), r)
            this._handleHoverInlineBtn(), this._handleDocumentClickInline(), this._handleInlineClicks();
          else {
            this._handleSwitchHourMinute(), this._handleClockClick(), this._handleKeyboard();
            const f = document.querySelector(
              `${Ts}[${H}]`
            );
            h.addClass(f, this._classes.opacity), h.addStyle(this._hour, {
              pointerEvents: "none"
            }), h.addStyle(this._minutes, {
              pointerEvents: ""
            });
          }
          this._focusTrap = new zi(this._wrapper, {
            event: "keydown",
            condition: ({ key: f }) => f === "Tab"
          }), this._focusTrap.trap();
        }, i);
      }
    );
  }
  _handleInlineClicks() {
    let t, e;
    const i = (g) => {
      let m = g;
      return m > 59 ? m = 0 : m < 0 && (m = 59), m;
    }, n = (g) => {
      let m = g;
      return this._options.format24 ? (m > 24 ? m = 1 : m < 0 && (m = 23), m > 23 && (m = 0)) : (m > 12 ? m = 1 : m < 1 && (m = 12), m > 12 && (m = 1)), m;
    }, o = (g) => {
      const m = n(g);
      this._hour.textContent = this._setHourOrMinute(m);
    }, r = (g) => {
      const m = i(g);
      this._minutes.textContent = this._setHourOrMinute(m);
    }, a = () => {
      t = n(t) + 1, o(t);
    }, l = () => {
      e = i(e) + 1, r(e);
    }, p = () => {
      t = n(t) - 1, o(t);
    }, u = () => {
      e = i(e) - 1, r(e);
    }, _ = () => {
      clearInterval(this._interval), clearTimeout(this._timeoutInterval);
    }, f = (g) => {
      _(), this._timeoutInterval = setTimeout(() => {
        this._interval = setInterval(g, 100);
      }, 500);
    };
    K.on(
      this._modal,
      "click mousedown mouseup touchstart touchend contextmenu",
      `[${ao}], [${lo}]`,
      (g) => {
        t = Number(this._hour.textContent), e = Number(this._minutes.textContent);
        const { target: m, type: b } = g, v = b === "mousedown" || b === "touchstart";
        m.closest(`[${ao}]`) ? m.closest(`[${ao}]`).parentNode.hasAttribute(rl) ? v ? f(a) : b === "mouseup" || b === "touchend" || b === "contextmenu" ? _() : a() : v ? f(l) : b === "mouseup" || b === "touchend" || b === "contextmenu" ? _() : l() : m.closest(`[${lo}]`) && (m.closest(`[${lo}]`).parentNode.hasAttribute(rl) ? v ? f(p) : b === "mouseup" || b === "touchend" ? _() : p() : v ? f(u) : b === "mouseup" || b === "touchend" ? _() : u());
      }
    ), c.on(window, vs, (g) => {
      const m = g.code, b = document.activeElement.hasAttribute(Cs), v = document.activeElement.hasAttribute(
        uo
      ), T = document.activeElement === document.body;
      switch (t = Number(this._hour.textContent), e = Number(this._minutes.textContent), m) {
        case "ArrowUp":
          g.preventDefault(), T || b ? (this._hour.focus(), a()) : v && l();
          break;
        case "ArrowDown":
          g.preventDefault(), T || b ? (this._hour.focus(), p()) : v && u();
          break;
      }
    });
  }
  _handleClose() {
    c.on(
      this._modal,
      "click",
      `[${ho}], [${oo}], [${ol}]`,
      ({ target: t }) => {
        const { closeModalOnBackdropClick: e } = this._options, i = () => {
          var n;
          h.addStyle(this.elementToggle, {
            pointerEvents: "auto"
          }), this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), (n = this._focusTrap) == null || n.disable(), this._focusTrap = null, this.elementToggle ? this.elementToggle.focus() : this.input && this.input.focus();
        };
        if (t.hasAttribute(ol)) {
          this._toggleAmPm("PM"), this.input.value = "", this.input.removeAttribute(H);
          let n;
          R(this.input)[0] === "" ? n = ["12", "00", "PM"] : n = R(this.input);
          const [o, r, a] = n;
          this._setTipsAndTimesDependOnInputValue("12", "00"), this._setActiveClassToTipsOnOpen(o, r, a), this._hour.click();
        } else
          (t.hasAttribute(oo) || t.hasAttribute(ro) || t.hasAttribute(ho) && e) && i();
      }
    );
  }
  showValueInput() {
    return this.input.value;
  }
  _handleOkButton() {
    K.on(
      this._modal,
      "click",
      `[${ro}]`,
      () => {
        let { maxTime: t, minTime: e } = this._options;
        const {
          format12: i,
          format24: n,
          readOnly: o,
          focusInputAfterApprove: r,
          disablePast: a,
          disableFuture: l
        } = this._options, p = this._document.querySelector(
          `${Es}[${H}]`
        ), u = `${this._hour.textContent}:${this._minutes.textContent}`, _ = Number(this._hour.textContent), f = _ === 12 && i ? 0 : _, g = Number(this._minutes.textContent);
        e = Gt(e, a, i), t = qt(t, l, i);
        let [m, b, v] = R(
          t,
          !1
        ), [T, y, C] = R(
          e,
          !1
        );
        T = T === "12" && i ? "00" : T, m = m === "12" && i ? "00" : m;
        const E = f < Number(T), w = f > Number(m);
        let k = !0;
        p && (k = v === p.textContent);
        let D = !0;
        p && (D = C === p.textContent);
        const O = g > b && f === Number(m), x = g < y && f === Number(T);
        if (this.input.setAttribute(H, ""), h.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), t !== "") {
          if (k && (w || O))
            return;
          if (v === "AM" && p.textContent === "PM")
            return;
        }
        e !== "" && (D && (E || x) || C === "PM" && p.textContent === "AM") || cg(
          this._options,
          this.input,
          this._hour.textContent
        ) !== void 0 && (this._isInvalidTimeFormat && this.input.removeAttribute(co), !o && r && this.input.focus(), h.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), n ? this.input.value = u : p === null ? this.input.value = `${u} PM` : this.input.value = `${u} ${p.textContent}`, this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), c.trigger(this.input, "input.te.timepicker"), c.trigger(this.input, "input"));
      }
    );
  }
  _handleHoverInlineBtn() {
    K.on(
      this._modal,
      "mouseover mouseleave",
      `[${Tg}]`,
      ({ type: t, target: e }) => {
        const i = d.find(
          `[${bg}]`,
          this._modal
        ), n = d.find(
          `[${vg}]`,
          this._modal
        ), o = (l, p) => l.forEach((u) => {
          if (p) {
            h.addClass(u, this._classes.opacity), u.setAttribute(H, "");
            return;
          }
          h.removeClass(u, this._classes.opacity), u.removeAttribute(H);
        }), a = e.hasAttribute(Cs) ? i : n;
        o(a, t === "mouseover");
      }
    );
  }
  _handleDocumentClickInline() {
    c.on(document, qa, ({ target: t }) => {
      if (this._modal && !this._modal.contains(t) && !t.hasAttribute(gg)) {
        if (clearInterval(this._interval), h.addStyle(this.elementToggle, {
          pointerEvents: "auto"
        }), this._removeModal(), !this._animations)
          return;
        this._toggleBackdropAnimation(!0);
      }
    });
  }
  _handleSwitchHourMinute() {
    lg(
      "click",
      Ts,
      this._classes
    ), c.on(
      this._modal,
      "click",
      Ts,
      () => {
        const { format24: t } = this._options, e = d.find(
          Ts,
          this._modal
        ), i = d.find(
          `[${q}]`,
          this._modal
        ), n = d.find(
          `[${X}]`,
          this._modal
        ), o = d.find(
          `[${ht}]`,
          this._modal
        ), r = Number(this._hour.textContent), a = Number(this._minutes.textContent), l = (p, u) => {
          n.forEach((f) => f.remove()), i.forEach((f) => f.remove()), h.addClass(this._hand, this._classes.transform), setTimeout(() => {
            h.removeClass(this._hand, this._classes.transform);
          }, 401), this._getAppendClock(p, `[${ue}]`, u);
          const _ = () => {
            const f = d.find(
              `[${X}]`,
              this._modal
            ), g = d.find(
              `[${q}]`,
              this._modal
            );
            this._addActiveClassToTip(f, r), this._addActiveClassToTip(g, a);
          };
          if (!t)
            setTimeout(() => {
              _();
            }, 401);
          else {
            const f = d.find(
              `[${ht}]`,
              this._modal
            );
            setTimeout(() => {
              this._addActiveClassToTip(f, r), _();
            }, 401);
          }
        };
        e.forEach((p) => {
          p.hasAttribute(H) && (p.hasAttribute(uo) ? (h.addClass(this._hand, this._classes.transform), h.addStyle(this._hand, {
            transform: `rotateZ(${this._minutes.textContent * 6}deg)`,
            height: "calc(40% + 1px)"
          }), t && o.length > 0 && o.forEach((u) => u.remove()), l(
            this.minutesArray,
            q
          ), this._hour.style.pointerEvents = "", this._minutes.style.pointerEvents = "none") : p.hasAttribute(Cs) && (h.addStyle(this._hand, {
            transform: `rotateZ(${this._hour.textContent * 30}deg)`
          }), Number(this._hour.textContent) > 12 ? (h.addStyle(this._hand, {
            transform: `rotateZ(${this._hour.textContent * 30 - 360}deg)`,
            height: "21.5%"
          }), Number(this._hour.textContent) > 12 && h.addStyle(this._hand, {
            height: "21.5%"
          })) : h.addStyle(this._hand, {
            height: "calc(40% + 1px)"
          }), t && this._getAppendClock(
            this.innerHours,
            `[${mi}]`,
            ht
          ), o.length > 0 && o.forEach((u) => u.remove()), l(
            this.hoursArray,
            X
          ), h.addStyle(this._hour, {
            pointerEvents: "none"
          }), h.addStyle(this._minutes, {
            pointerEvents: ""
          })));
        });
      }
    );
  }
  _handleDisablingTipsMaxTime(t, e, i, n) {
    if (!this._options.maxTime && !this._options.disableFuture)
      return;
    const o = d.find(
      `[${X}]`
    ), r = d.find(
      `[${ht}]`
    ), a = d.find(
      `[${q}]`
    );
    if (!e || e === t) {
      Ua(
        r,
        n,
        this._classes,
        this._options.format12
      ), Ua(
        o,
        n,
        this._classes,
        this._options.format12
      ), hg(
        a,
        i,
        n,
        this._hour.textContent,
        this._classes,
        this._options.format12
      );
      return;
    }
    e === "AM" && t === "PM" && (o.forEach((l) => {
      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(jt, "");
    }), a.forEach((l) => {
      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(jt, "");
    }));
  }
  _handleDisablingTipsMinTime(t, e, i, n) {
    if (!this._options.minTime && !this._options.disablePast)
      return;
    const o = d.find(
      `[${X}]`
    ), r = d.find(
      `[${ht}]`
    ), a = d.find(
      `[${q}]`
    );
    !e || e === t ? (Xa(
      o,
      n,
      this._classes,
      this._options.format12
    ), Xa(
      r,
      n,
      this._classes,
      this._options.format12
    ), dg(
      a,
      i,
      n,
      this._hour.textContent,
      this._classes,
      this._options.format12
    )) : e === "PM" && t === "AM" && (o.forEach((l) => {
      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(jt, "");
    }), a.forEach((l) => {
      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(jt, "");
    }));
  }
  _handleSwitchTimeMode() {
    c.on(
      document,
      "click",
      Es,
      ({ target: t }) => {
        let { maxTime: e, minTime: i } = this._options;
        const { disablePast: n, disableFuture: o, format12: r } = this._options;
        i = Gt(i, n, r), e = qt(e, o, r);
        const [a, l, p] = R(
          e,
          !1
        ), [u, _, f] = R(
          i,
          !1
        ), g = d.find(
          `[${X}]`
        ), m = d.find(
          `[${q}]`
        );
        (() => {
          g.forEach((v) => {
            h.removeClass(v, this._classes.tipsDisabled), v.removeAttribute(jt);
          }), m.forEach((v) => {
            h.removeClass(v, this._classes.tipsDisabled), v.removeAttribute(jt);
          });
        })(), this._handleDisablingTipsMinTime(
          t.textContent,
          f,
          _,
          u
        ), this._handleDisablingTipsMaxTime(
          t.textContent,
          p,
          l,
          a
        ), this._toggleAmPm(t.textContent), t.hasAttribute(H) || (d.find(
          Es
        ).forEach((T) => {
          T.hasAttribute(H) && (h.removeClass(T, this._classes.opacity), T.removeAttribute(H));
        }), h.addClass(t, this._classes.opacity), t.setAttribute(H, ""));
      }
    );
  }
  _handleClockClick() {
    let { maxTime: t, minTime: e } = this._options;
    const { disablePast: i, disableFuture: n, format12: o } = this._options;
    e = Gt(e, i, o), t = qt(t, n, o);
    const r = R(t, !1)[2], a = R(e, !1)[2], l = R(t, !1)[0], p = R(e, !1)[0], u = d.findOne(
      `[${al}]`
    );
    K.on(
      document,
      `${Za} ${Qa} ${Ja} ${tl} ${el} ${nl} ${il} ${sl}`,
      "",
      (_) => {
        bs() || _.preventDefault();
        const { type: f, target: g } = _, { closeModalOnMinutesClick: m, switchHoursToMinutesOnClick: b } = this._options, v = d.findOne(
          `[${q}]`,
          this._modal
        ) !== null, T = d.findOne(
          `[${X}]`,
          this._modal
        ) !== null, y = d.findOne(
          `[${ht}]`,
          this._modal
        ) !== null, C = d.find(
          `[${q}]`,
          this._modal
        ), E = za(_, u), w = u.offsetWidth / 2;
        let k = Math.atan2(E.y - w, E.x - w);
        if (bs()) {
          const L = za(_, u, !0);
          k = Math.atan2(L.y - w, L.x - w);
        }
        let D = null, O = null, x = null;
        if (f === "mousedown" || f === "mousemove" || f === "touchmove" || f === "touchstart")
          (f === "mousedown" || f === "touchstart" || f === "touchmove") && (this._hasTargetInnerClass(g) || g.hasAttribute(al) || g.hasAttribute(ue) || g.hasAttribute(q) || g.hasAttribute(X) || g.hasAttribute(_o) || g.hasAttribute(po) || g.hasAttribute(ll) || g.hasAttribute(As)) && (this._isMouseMove = !0, bs() && _.touches && (D = _.touches[0].clientX, O = _.touches[0].clientY, x = document.elementFromPoint(D, O)));
        else if (f === "mouseup" || f === "touchend") {
          if (this._isMouseMove = !1, this._hasTargetInnerClass(g) || g.hasAttribute(ue) || g.hasAttribute(X) || g.hasAttribute(_o) || g.hasAttribute(po) || g.hasAttribute(ll) || g.hasAttribute(As)) {
            if ((T || y) && b) {
              const L = Number(this._hour.textContent) > l || Number(this._hour.textContent) < p;
              if (this._options.format24 && l !== "" && p !== "" && L)
                return;
              if (this._options.format24 && p !== "" && Number(this._hour.textContent) < p)
                return;
            }
            c.trigger(this._minutes, "click");
          }
          if (v && m) {
            const L = d.findOne(
              `[${ro}]`,
              this._modal
            );
            c.trigger(L, "click");
          }
        }
        if (v) {
          let L;
          const S = Math.trunc(k * 180 / Math.PI) + 90, { degrees: N, minute: P } = this._makeMinutesDegrees(S, L);
          if (this._handlerMaxMinMinutesOptions(N, P) === void 0)
            return;
          const { degrees: ot, minute: rt } = this._handlerMaxMinMinutesOptions(N, P);
          if (this._isMouseMove) {
            if (h.addStyle(this._hand, {
              transform: `rotateZ(${ot}deg)`
            }), rt === void 0)
              return;
            const G = () => rt >= 10 || rt === "00" ? rt : `0${rt}`;
            this._minutes.textContent = G(), this._toggleClassActive(
              this.minutesArray,
              this._minutes,
              C
            ), this._toggleBackgroundColorCircle(
              `[${q}]`
            ), this._objWithDataOnChange.degreesMinutes = ot, this._objWithDataOnChange.minutes = rt;
          }
        }
        if (T || y) {
          let L, S = Math.trunc(k * 180 / Math.PI) + 90;
          if (S = Math.round(S / 30) * 30, h.addStyle(this._circle, {
            backgroundColor: "#1976d2"
          }), this._makeHourDegrees(g, S, L) === void 0)
            return;
          const N = () => {
            if (bs() && S && x) {
              const { degrees: P, hour: ot } = this._makeHourDegrees(x, S, L);
              return this._handleMoveHand(
                x,
                ot,
                P
              );
            } else {
              const { degrees: P, hour: ot } = this._makeHourDegrees(g, S, L);
              return this._handleMoveHand(g, ot, P);
            }
          };
          this._objWithDataOnChange.degreesHours = S, this._handlerMaxMinHoursOptions(
            S,
            l,
            p,
            r,
            a,
            _
          ) && N();
        }
        _.stopPropagation();
      }
    );
  }
  _hasTargetInnerClass(t) {
    return t.hasAttribute(mi) || t.hasAttribute(ht) || t.hasAttribute(ys);
  }
  _handleMoveHand(t, e, i) {
    const n = d.find(
      `[${X}]`,
      this._modal
    ), o = d.find(
      `[${ht}]`,
      this._modal
    );
    this._isMouseMove && (this._hasTargetInnerClass(t) ? h.addStyle(this._hand, {
      height: "21.5%"
    }) : h.addStyle(this._hand, {
      height: "calc(40% + 1px)"
    }), h.addStyle(this._hand, {
      transform: `rotateZ(${i}deg)`
    }), this._hour.textContent = e >= 10 || e === "00" ? e : `0${e}`, this._toggleClassActive(this.hoursArray, this._hour, n), this._toggleClassActive(this.innerHours, this._hour, o), this._objWithDataOnChange.hour = e >= 10 || e === "00" ? e : `0${e}`);
  }
  _handlerMaxMinMinutesOptions(t, e) {
    let { maxTime: i, minTime: n } = this._options;
    const { format12: o, increment: r, disablePast: a, disableFuture: l } = this._options;
    n = Gt(n, a, o), i = qt(i, l, o);
    const p = R(i, !1)[1], u = R(n, !1)[1], _ = R(i, !1)[0], f = R(n, !1)[0], g = f === "12" && o ? "0" : f, m = _ === "12" && o ? "0" : _, b = R(i, !1)[2], v = R(n, !1)[2], T = p !== "" ? p * 6 : "", y = u !== "" ? u * 6 : "", C = Number(this._hour.textContent), E = C === 12 && o ? 0 : C;
    if (!b && !v) {
      if (i !== "" && n !== "") {
        if (Number(m) === E && t > T || Number(g) === E && t < y)
          return t;
      } else if (n !== "" && E <= Number(g)) {
        if (t <= y - 6)
          return t;
      } else if (i !== "" && E >= Number(m) && t >= T + 6)
        return t;
    } else {
      if (n !== "") {
        if (v === "PM" && this._isAmEnabled)
          return;
        if (v === "PM" && this._isPmEnabled) {
          if (E < Number(g))
            return;
          if (E <= Number(g) && t <= y - 6)
            return t;
        } else if (v === "AM" && this._isAmEnabled) {
          if (E < Number(g))
            return;
          if (E <= Number(g) && t <= y - 6)
            return t;
        }
      }
      if (i !== "") {
        if (b === "AM" && this._isPmEnabled)
          return;
        if (b === "PM" && this._isPmEnabled) {
          if (E >= Number(m) && t >= T + 6)
            return t;
        } else if (b === "AM" && this._isAmEnabled && E >= Number(m) && t >= T + 6)
          return t;
      }
    }
    return r && (t = Math.round(t / 30) * 30), t < 0 ? t = 360 + t : t >= 360 && (t = 0), {
      degrees: t,
      minute: e
    };
  }
  _removeModal() {
    this._animations ? setTimeout(() => {
      this._removeModalElements(), this._scrollBar.reset();
    }, 300) : (this._removeModalElements(), this._scrollBar.reset()), K.off(
      this._document,
      `${qa} ${vs} ${Za} ${Qa} ${Ja} ${tl} ${el} ${nl} ${il} ${sl}`
    ), c.off(window, vs);
  }
  _removeModalElements() {
    this._modal && this._modal.remove();
  }
  _toggleBackdropAnimation(t = !1) {
    t ? this._wrapper.classList.add("animate-[fade-out_350ms_ease-in-out]") : (this._wrapper.classList.add("animate-[fade-in_350ms_ease-in-out]"), this._options.inline || h.addClass(this._clock, this._classes.clockAnimation)), setTimeout(() => {
      this._wrapper.classList.remove(
        "animate-[fade-out_350ms_ease-in-out]",
        "animate-[fade-in_350ms_ease-in-out]"
      );
    }, 351);
  }
  _addActiveClassToTip(t, e) {
    t.forEach((i) => {
      Number(i.textContent) === Number(e) && (h.addClass(i, this._classes.tipsActive), i.setAttribute(H, ""));
    });
  }
  _setHourOrMinute(t) {
    return t < 10 ? `0${t}` : t;
  }
  _appendTimes() {
    const { format24: t } = this._options;
    if (t) {
      this._getAppendClock(
        this.hoursArray,
        `[${ue}]`,
        X
      ), this._getAppendClock(
        this.innerHours,
        `[${mi}]`,
        ht
      );
      return;
    }
    this._getAppendClock(
      this.hoursArray,
      `[${ue}]`,
      X
    );
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...wg,
      ...e,
      ...t
    }, I(Bi, t, kg), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...xg,
      ...e,
      ...t
    }, I(Bi, t, Og), t;
  }
  _getContainer() {
    return d.findOne(this._options.container);
  }
  _getValidate(t) {
    const { format24: e, format12: i, appendValidationInfo: n } = this._options;
    K.on(this.input, t, ({ target: o }) => {
      if (this._options === null || this.input.value === "")
        return;
      const r = /^(0?[1-9]|1[012])(:[0-5]\d) [APap][mM]$/, a = /^([01]\d|2[0-3])(:[0-5]\d)$/, l = r.test(o.value);
      if (a.test(o.value) !== !0 && e || l !== !0 && i) {
        n && this.input.setAttribute(co, ""), h.addStyle(o, { marginBottom: 0 }), this._isInvalidTimeFormat = !0;
        return;
      }
      this.input.removeAttribute(co), this._isInvalidTimeFormat = !1;
      const u = d.findOne(
        `[${Cg}]`
      );
      u !== null && u.remove();
    });
  }
  // Static
  static getInstance(t) {
    return A.getData(t, Js);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Ig = {
  threshold: 10,
  direction: "all"
};
let Dg = class {
  constructor(t, e) {
    this._element = t, this._startPosition = null, this._options = {
      ...Ig,
      ...e
    };
  }
  handleTouchStart(t) {
    this._startPosition = this._getCoordinates(t);
  }
  handleTouchMove(t) {
    if (!this._startPosition)
      return;
    const e = this._getCoordinates(t), i = {
      x: e.x - this._startPosition.x,
      y: e.y - this._startPosition.y
    }, n = this._getDirection(i);
    if (this._options.direction === "all") {
      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)
        return;
      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;
      c.trigger(this._element, `swipe${r}`), c.trigger(this._element, "swipe", { direction: r }), this._startPosition = null;
      return;
    }
    const o = this._options.direction === "left" || this._options === "right" ? "x" : "y";
    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (c.trigger(this._element, `swipe${n[o].direction}`), this._startPosition = null);
  }
  handleTouchEnd() {
    this._startPosition = null;
  }
  _getCoordinates(t) {
    const [e] = t.touches;
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  _getDirection(t) {
    return {
      x: {
        direction: t.x < 0 ? "left" : "right",
        value: Math.abs(t.x)
      },
      y: {
        direction: t.y < 0 ? "up" : "down",
        value: Math.abs(t.y)
      }
    };
  }
}, $g = class {
  constructor(t, e = "swipe", i = {}) {
    this._element = t, this._event = e, this.swipe = new Dg(t, i), this._touchStartHandler = this._handleTouchStart.bind(this), this._touchMoveHandler = this._handleTouchMove.bind(this), this._touchEndHandler = this._handleTouchEnd.bind(this);
  }
  dispose() {
    this._element.removeEventListener("touchstart", this._touchStartHandler), this._element.removeEventListener("touchmove", this._touchMoveHandler), window.removeEventListener("touchend", this._touchEndHandler);
  }
  init() {
    this._element.addEventListener(
      "touchstart",
      (t) => this._handleTouchStart(t)
    ), this._element.addEventListener(
      "touchmove",
      (t) => this._handleTouchMove(t)
    ), window.addEventListener("touchend", (t) => this._handleTouchEnd(t));
  }
  _handleTouchStart(t) {
    this[this._event].handleTouchStart(t);
  }
  _handleTouchMove(t) {
    this[this._event].handleTouchMove(t);
  }
  _handleTouchEnd(t) {
    this[this._event].handleTouchEnd(t);
  }
};
const hl = "sidenav", ws = "te.sidenav", Lg = "data-te-sidenav-rotate-icon-ref", fo = "[data-te-sidenav-toggle-ref]", Ng = "[data-te-collapse-init]", Mg = '[data-te-sidenav-slim="true"]', Rg = '[data-te-sidenav-slim="false"]', Pg = "[data-te-sidenav-menu-ref]", Le = "[data-te-sidenav-collapse-ref]", gi = "[data-te-sidenav-link-ref]", Bg = W() ? 100 : -100, Hg = W() ? -100 : 100, Vg = {
  sidenavAccordion: "(boolean)",
  sidenavBackdrop: "(boolean)",
  sidenavBackdropClass: "(null|string)",
  sidenavCloseOnEsc: "(boolean)",
  sidenavColor: "(string)",
  sidenavContent: "(null|string)",
  sidenavExpandable: "(boolean)",
  sidenavExpandOnHover: "(boolean)",
  sidenavFocusTrap: "(boolean)",
  sidenavHidden: "(boolean)",
  sidenavMode: "(string)",
  sidenavModeBreakpointOver: "(null|string|number)",
  sidenavModeBreakpointSide: "(null|string|number)",
  sidenavModeBreakpointPush: "(null|string|number)",
  sidenavBreakpointSm: "(number)",
  sidenavBreakpointMd: "(number)",
  sidenavBreakpointLg: "(number)",
  sidenavBreakpointXl: "(number)",
  sidenavBreakpoint2xl: "(number)",
  sidenavScrollContainer: "(null|string)",
  sidenavSlim: "(boolean)",
  sidenavSlimCollapsed: "(boolean)",
  sidenavSlimWidth: "(number)",
  sidenavPosition: "(string)",
  sidenavRight: "(boolean)",
  sidenavTransitionDuration: "(number)",
  sidenavWidth: "(number)"
}, Wg = {
  sidenavAccordion: !1,
  sidenavBackdrop: !0,
  sidenavBackdropClass: null,
  sidenavCloseOnEsc: !0,
  sidenavColor: "primary",
  sidenavContent: null,
  sidenavExpandable: !0,
  sidenavExpandOnHover: !1,
  sidenavFocusTrap: !0,
  sidenavHidden: !0,
  sidenavMode: "over",
  sidenavModeBreakpointOver: null,
  sidenavModeBreakpointSide: null,
  sidenavModeBreakpointPush: null,
  sidenavBreakpointSm: 640,
  sidenavBreakpointMd: 768,
  sidenavBreakpointLg: 1024,
  sidenavBreakpointXl: 1280,
  sidenavBreakpoint2xl: 1536,
  sidenavScrollContainer: null,
  sidenavSlim: !1,
  sidenavSlimCollapsed: !1,
  sidenavSlimWidth: 77,
  sidenavPosition: "fixed",
  sidenavRight: !1,
  sidenavTransitionDuration: 300,
  sidenavWidth: 240
};
class Ci {
  constructor(t, e = {}) {
    wt(this, "_addBackdropOnInit", () => {
      this._options.sidenavHidden || (this._backdrop.show(), c.off(this._element, "transitionend", this._addBackdropOnInit));
    });
    this._element = t, this._options = e, this._ID = et(""), this._content = null, this._initialContentStyle = null, this._slimCollapsed = !1, this._activeNode = null, this._tempSlim = !1, this._backdrop = this._initializeBackDrop(), this._focusTrap = null, this._perfectScrollbar = null, this._touch = null, this._setModeFromBreakpoints(), this.escHandler = (i) => {
      i.keyCode === we && this.toggler && Mt(this.toggler) && (this._update(!1), c.off(window, "keydown", this.escHandler));
    }, this.hashHandler = () => {
      this._setActiveElements();
    }, t && (A.setData(t, ws, this), this._setup()), this.options.sidenavBackdrop && !this.options.sidenavHidden && this.options.sidenavMode === "over" && c.on(this._element, "transitionend", this._addBackdropOnInit), this._didInit = !1, this._init();
  }
  // Getters
  static get NAME() {
    return hl;
  }
  get container() {
    if (this.options.sidenavPosition === "fixed")
      return d.findOne("body");
    const t = (e) => !e.parentNode || e.parentNode === document ? e : e.parentNode.style.position === "relative" || e.parentNode.classList.contains("relative") ? e.parentNode : t(e.parentNode);
    return t(this._element);
  }
  get isVisible() {
    let t = 0, e = window.innerWidth;
    if (this.options.sidenavPosition !== "fixed") {
      const n = this.container.getBoundingClientRect();
      t = n.x, e = n.x + n.width;
    }
    const { x: i } = this._element.getBoundingClientRect();
    if (this.options.sidenavRight && !W() || !this.options.sidenavRight && W()) {
      let n = 0;
      if (this.container.scrollHeight > this.container.clientHeight && (n = this.container.offsetWidth - this.container.clientWidth), this.container.tagName === "BODY") {
        const o = document.documentElement.clientWidth;
        n = Math.abs(window.innerWidth - o);
      }
      return Math.abs(i + n - e) > 10;
    }
    return Math.abs(i - t) < 10;
  }
  get links() {
    return d.find(gi, this._element);
  }
  get navigation() {
    return d.find(Pg, this._element);
  }
  get options() {
    const t = {
      ...Wg,
      ...h.getDataAttributes(this._element),
      ...this._options
    };
    return I(hl, t, Vg), t;
  }
  get sidenavStyle() {
    return {
      width: `${this.width}px`,
      height: this.options.sidenavPosition === "fixed" ? "100vh" : "100%",
      position: this.options.sidenavPosition,
      transition: `all ${this.transitionDuration} linear`
    };
  }
  get toggler() {
    return d.find(fo).find(
      (e) => {
        const i = h.getDataAttribute(e, "target");
        return d.findOne(i) === this._element;
      }
    );
  }
  get transitionDuration() {
    return `${this.options.sidenavTransitionDuration / 1e3}s`;
  }
  get translation() {
    return this.options.sidenavRight ? Hg : Bg;
  }
  get width() {
    return this._slimCollapsed ? this.options.sidenavSlimWidth : this.options.sidenavWidth;
  }
  get isBackdropVisible() {
    return !!this._backdrop._element;
  }
  // Public
  changeMode(t) {
    this._setMode(t);
  }
  dispose() {
    c.off(window, "keydown", this.escHandler), this.options.sidenavBackdrop && this._backdrop.dispose(), c.off(window, "hashchange", this.hashHandler), this._touch.dispose(), A.removeData(this._element, ws), this._element = null;
  }
  hide() {
    this._emitEvents(!1), this._update(!1), this._options.sidenavBackdrop && this.isBackdropVisible && this._backdrop.hide();
  }
  show() {
    this._emitEvents(!0), this._update(!0), this._options.sidenavBackdrop && this._options.sidenavMode === "over" && this._backdrop.show();
  }
  toggle() {
    this._emitEvents(!this.isVisible), this._update(!this.isVisible);
  }
  toggleSlim() {
    this._setSlim(!this._slimCollapsed);
  }
  update(t) {
    this._options = t, this._setup();
  }
  getBreakpoint(t) {
    return this._transformBreakpointValuesToObject()[t];
  }
  // Private
  _init() {
    this._didInit || (c.on(
      document,
      "click",
      fo,
      Ci.toggleSidenav()
    ), this._didInit = !0);
  }
  _transformBreakpointValuesToObject() {
    return {
      sm: this.options.sidenavBreakpointSm,
      md: this.options.sidenavBreakpointMd,
      lg: this.options.sidenavBreakpointLg,
      xl: this.options.sidenavBreakpointXl,
      "2xl": this.options.sidenavBreakpoint2xl
    };
  }
  _setModeFromBreakpoints() {
    const t = window.innerWidth, e = this._transformBreakpointValuesToObject();
    if (t === void 0 || !e)
      return;
    const i = typeof this.options.sidenavModeBreakpointOver == "number" ? t - this.options.sidenavModeBreakpointOver : t - e[this.options.sidenavModeBreakpointOver], n = typeof this.options.sidenavModeBreakpointSide == "number" ? t - this.options.sidenavModeBreakpointSide : t - e[this.options.sidenavModeBreakpointSide], o = typeof this.options.sidenavModeBreakpointPush == "number" ? t - this.options.sidenavModeBreakpointPush : t - e[this.options.sidenavModeBreakpointPush], r = (l, p) => l - p < 0 ? -1 : p - l < 0 ? 1 : 0, a = [i, n, o].filter((l) => l != null && l >= 0).sort(r)[0];
    i > 0 && i === a ? (this._options.sidenavMode = "over", this._options.sidenavHidden = !0) : n > 0 && n === a ? this._options.sidenavMode = "side" : o > 0 && o === a && (this._options.sidenavMode = "push");
  }
  _collapseItems() {
    this.navigation.forEach((t) => {
      d.find(Le, t).forEach((i) => {
        Qt.getInstance(i).hide();
      });
    });
  }
  _getOffsetValue(t, { index: e, property: i, offsets: n }) {
    const o = this._getPxValue(
      this._initialContentStyle[e][n[i].property]
    ), r = t ? n[i].value : 0;
    return o + r;
  }
  _getProperty(...t) {
    return t.map((e, i) => i === 0 ? e : e[0].toUpperCase().concat(e.slice(1))).join("");
  }
  _getPxValue(t) {
    return t ? parseFloat(t) : 0;
  }
  _handleSwipe(t, e) {
    e && this._slimCollapsed && this.options.sidenavSlim && this.options.sidenavExpandable ? this.toggleSlim() : e || (this._slimCollapsed || !this.options.sidenavSlim || !this.options.sidenavExpandable ? this.toggler && Mt(this.toggler) && this.toggle() : this.toggleSlim());
  }
  _isActive(t, e) {
    return e ? e === t : t.attributes.href ? new URL(t, window.location.href).href === window.location.href : !1;
  }
  _isAllToBeCollapsed() {
    return d.find(
      Ng,
      this._element
    ).filter(
      (i) => i.getAttribute("aria-expanded") === "true"
    ).length === 0;
  }
  _isAllCollapsed() {
    return d.find(Le, this._element).filter(
      (t) => Mt(t)
    ).length === 0;
  }
  _initializeBackDrop() {
    if (!this.options.sidenavBackdrop)
      return;
    const t = this.options.sidenavBackdropClass ? this.options.sidenavBackdropClass.split(" ") : this.options.sidenavPosition ? [
      "opacity-50",
      "transition-all",
      "duration-300",
      "ease-in-out",
      this.options.sidenavPosition,
      "top-0",
      "left-0",
      "z-50",
      "bg-black/10",
      "dark:bg-black-60",
      "w-full",
      "h-full",
      this._element.id
    ] : null;
    return new Cr({
      isVisible: this.options.sidenavBackdrop,
      isAnimated: !0,
      rootElement: this._element.parentNode,
      backdropClasses: t,
      clickCallback: () => this.hide()
    });
  }
  _updateBackdrop(t) {
    if (this.options.sidenavMode === "over") {
      t ? this._backdrop.show() : this.isBackdropVisible && this._backdrop.hide();
      return;
    }
    this.isBackdropVisible && this._backdrop.hide();
  }
  _setup() {
    this._setupTouch(), this.options.sidenavFocusTrap && this._setupFocusTrap(), this._setupCollapse(), this.options.sidenavSlim && this._setupSlim(), this._setupInitialStyling(), this._setupScrolling(), this.options.sidenavContent && this._setupContent(), this._setupActiveState(), this._setupRippleEffect(), this.options.sidenavHidden || this._updateOffsets(!0, !0), this.options.sidenavMode === "over" && this._setTabindex(!0);
  }
  _setupActiveState() {
    this._setActiveElements(), this.links.forEach((t) => {
      c.on(t, "click", () => this._setActiveElements(t)), c.on(t, "keydown", (e) => {
        e.keyCode === it && this._setActiveElements(t);
      });
    }), c.on(window, "hashchange", this.hashHandler);
  }
  _setupCollapse() {
    this.navigation.forEach((t, e) => {
      d.find(Le, t).forEach(
        (n, o) => this._setupCollapseList({ list: n, index: o, menu: t, menuIndex: e })
      );
    });
  }
  _generateCollpaseID(t, e) {
    return `sidenav-collapse-${this._ID}-${e}-${t}`;
  }
  _setupCollapseList({ list: t, index: e, menu: i, menuIndex: n }) {
    const o = this._generateCollpaseID(e, n);
    t.setAttribute("id", o), t.setAttribute("data-te-collapse-item", "");
    const [r] = d.prev(t, gi);
    h.setDataAttribute(r, "collapse-init", ""), r.setAttribute("href", `#${o}`), r.setAttribute("role", "button");
    const a = Qt.getInstance(t) || new Qt(t, {
      toggle: !1,
      parent: this.options.sidenavAccordion ? i : t
    });
    (t.dataset.teSidenavStateShow === "" || t.dataset.teCollapseShow === "") && this._rotateArrow(r, !1), c.on(r, "click", (l) => {
      this._toggleCategory(l, a, t), this._tempSlim && this._isAllToBeCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    }), c.on(
      t,
      "show.te.collapse",
      () => this._rotateArrow(r, !1)
    ), c.on(
      t,
      "hide.te.collapse",
      () => this._rotateArrow(r, !0)
    ), c.on(t, "shown.te.collapse", () => {
      this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    }), c.on(t, "hidden.te.collapse", () => {
      this._tempSlim && this._isAllCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === "over" && this._focusTrap && this._focusTrap.update();
    });
  }
  _setupContent() {
    this._content = d.find(this.options.sidenavContent), this._content.forEach((t) => {
      const e = [
        "!p",
        "!m",
        "!px",
        "!pl",
        "!pr",
        "!mx",
        "!ml",
        "!mr",
        "!-p",
        "!-m",
        "!-px",
        "!-pl",
        "!-pr",
        "!-mx",
        "!-ml",
        "!-mr"
      ];
      [...t.classList].filter(
        (n) => e.findIndex((o) => n.includes(o)) >= 0
      ).forEach((n) => t.classList.remove(n));
    }), this._initialContentStyle = this._content.map((t) => {
      const { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r } = window.getComputedStyle(t);
      return { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r };
    });
  }
  _setupFocusTrap() {
    this._focusTrap = new zi(
      this._element,
      {
        event: "keydown",
        condition: (t) => t.keyCode === ke,
        onlyVisible: !0
      },
      this.toggler
    );
  }
  _setupInitialStyling() {
    this._setColor(), h.style(this._element, this.sidenavStyle);
  }
  _setupScrolling() {
    let t = this._element;
    if (this.options.sidenavScrollContainer) {
      t = d.findOne(
        this.options.sidenavScrollContainer,
        this._element
      );
      const i = fd(t.parentNode.children).filter(
        (n) => n !== t
      ).reduce((n, o) => n + o.clientHeight, 0);
      h.style(t, {
        maxHeight: `calc(100% - ${i}px)`,
        position: "relative"
      });
    }
    this._perfectScrollbar = new Bh(t, {
      suppressScrollX: !0,
      handlers: ["click-rail", "drag-thumb", "wheel", "touch"]
    });
  }
  _setupSlim() {
    this._slimCollapsed = this.options.sidenavSlimCollapsed, this._toggleSlimDisplay(this._slimCollapsed), this.options.sidenavExpandOnHover && (this._element.addEventListener("mouseenter", () => {
      this._slimCollapsed && this._setSlim(!1);
    }), this._element.addEventListener("mouseleave", () => {
      this._slimCollapsed || this._setSlim(!0);
    }));
  }
  _setupRippleEffect() {
    this.links.forEach((t) => {
      let e = ei.getInstance(t), i = this.options.sidenavColor;
      if (e && e._options.sidenavColor !== this.options.sidenavColor)
        e.dispose();
      else if (e)
        return;
      (localStorage.theme === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) && (i = "white"), e = new ei(t, { rippleColor: i });
    });
  }
  _setupTouch() {
    this._touch = new $g(this._element, "swipe", { threshold: 20 }), this._touch.init(), c.on(
      this._element,
      "swipeleft",
      (t) => this._handleSwipe(t, this.options.sidenavRight)
    ), c.on(
      this._element,
      "swiperight",
      (t) => this._handleSwipe(t, !this.options.sidenavRight)
    );
  }
  _setActive(t, e) {
    t.setAttribute("data-te-sidebar-state-active", ""), this._activeNode && t.removeAttribute("data-te-sidebar-state-active"), this._activeNode = t;
    const [i] = d.parents(
      this._activeNode,
      Le
    );
    if (!i) {
      this._setActiveCategory();
      return;
    }
    const [n] = d.prev(i, gi);
    this._setActiveCategory(n), !e && !this._slimCollapsed && Qt.getInstance(i).show();
  }
  _setActiveCategory(t) {
    this.navigation.forEach((e) => {
      d.find(Le, e).forEach((n) => {
        const [o] = d.prev(n, gi);
        o !== t ? o.removeAttribute("data-te-sidenav-state-active") : o.setAttribute("data-te-sidenav-state-active", "");
      });
    });
  }
  _setActiveElements(t) {
    this.navigation.forEach((e) => {
      d.find(gi, e).filter((n) => d.next(n, Le).length === 0).forEach((n) => {
        this._isActive(n, t) && n !== this._activeNode && this._setActive(n, t);
      });
    }), t && this._updateFocus(this.isVisible);
  }
  _setColor() {
    const t = [
      "primary",
      "secondary",
      "success",
      "info",
      "warning",
      "danger",
      "light",
      "dark"
    ], { sidenavColor: e } = this.options, i = t.includes(e) ? e : "primary";
    t.forEach((n) => {
      this._element.classList.remove(`sidenav-${n}`);
    }), h.addClass(this._element, `sidenav-${i}`);
  }
  _setContentOffsets(t, e, i) {
    this._content.forEach((n, o) => {
      const r = this._getOffsetValue(t, {
        index: o,
        property: "padding",
        offsets: e
      }), a = this._getOffsetValue(t, {
        index: o,
        property: "margin",
        offsets: e
      }), l = {};
      if (i || (l.transition = `all ${this.transitionDuration} linear`), l[e.padding.property] = `${r}px`, l[e.margin.property] = `${a}px`, h.style(n, l), !!t) {
        if (i) {
          h.style(n, {
            transition: this._initialContentStyle[o].transition
          });
          return;
        }
        c.on(n, "transitionend", () => {
          h.style(n, {
            transition: this._initialContentStyle[o].transition
          });
        });
      }
    });
  }
  _setMode(t) {
    this.options.sidenavMode !== t && (this._options.sidenavMode = t, this._update(this.isVisible));
  }
  _setSlim(t) {
    const e = t ? ["collapse", "collapsed"] : ["expand", "expanded"];
    this._triggerEvents(...e), t && this._collapseItems(), this._slimCollapsed = t, this._toggleSlimDisplay(t), h.style(this._element, { width: `${this.width}px` }), this._updateOffsets(this.isVisible);
  }
  _setTabindex(t) {
    this.links.forEach((e) => {
      e.tabIndex = t ? 0 : -1;
    });
  }
  _emitEvents(t) {
    const e = t ? ["show", "shown"] : ["hide", "hidden"];
    this._triggerEvents(...e);
  }
  _rotateArrow(t, e) {
    const [i] = d.children(t, `[${Lg}]`);
    i && (e ? h.removeClass(i, "rotate-180") : h.addClass(i, "rotate-180"));
  }
  _toggleCategory(t, e) {
    t.preventDefault(), e.toggle(), this._slimCollapsed && this.options.sidenavExpandable && (this._tempSlim = !0, this._setSlim(!1));
  }
  _toggleSlimDisplay(t) {
    const e = d.find(
      Mg,
      this._element
    ), i = d.find(
      Rg,
      this._element
    ), n = () => {
      e.forEach((o) => {
        h.style(o, {
          display: this._slimCollapsed ? "unset" : "none"
        });
      }), i.forEach((o) => {
        h.style(o, {
          display: this._slimCollapsed ? "none" : "unset"
        });
      });
    };
    t ? setTimeout(
      () => n(),
      this.options.sidenavTransitionDuration
    ) : n();
  }
  async _triggerEvents(t, e) {
    c.trigger(this._element, `${t}.te.sidenav`), e && await setTimeout(() => {
      c.trigger(this._element, `${e}.te.sidenav`);
    }, this.options.sidenavTransitionDuration + 5);
  }
  _isiPhone() {
    return /iPhone|iPod/i.test(navigator.userAgent);
  }
  _update(t) {
    t && this._isiPhone() && h.addClass(this._element, "ps--scrolling-y"), this.toggler && this._updateTogglerAria(t), this._updateDisplay(t), this.options.sidenavBackdrop && this._updateBackdrop(t), this._updateOffsets(t), t && this.options.sidenavCloseOnEsc && this.options.sidenavMode !== "side" && c.on(window, "keydown", this.escHandler), this.options.sidenavFocusTrap && this._updateFocus(t);
  }
  _updateDisplay(t) {
    const e = t ? 0 : this.translation;
    h.style(this._element, {
      transform: `translateX(${e}%)`
    });
  }
  _updateFocus(t) {
    if (this._setTabindex(t), this.options.sidenavMode === "over" && this.options.sidenavFocusTrap) {
      if (t) {
        this._focusTrap.trap();
        return;
      }
      this._focusTrap.disable();
    }
    this._focusTrap.disable();
  }
  _updateOffsets(t, e = !1) {
    const [i, n] = this.options.sidenavRight ? ["right", "left"] : ["left", "right"], o = {
      property: this._getProperty("padding", i),
      value: this.options.sidenavMode === "over" ? 0 : this.width
    }, r = {
      property: this._getProperty("margin", n),
      value: this.options.sidenavMode === "push" ? -1 * this.width : 0
    };
    c.trigger(this._element, "update.te.sidenav", {
      margin: r,
      padding: o
    }), this._content && (this._content.className = "", this._setContentOffsets(t, { padding: o, margin: r }, e));
  }
  _updateTogglerAria(t) {
    this.toggler.setAttribute("aria-expanded", t);
  }
  // Static
  static toggleSidenav() {
    return function(t) {
      const e = d.closest(t.target, fo), i = h.getDataAttributes(e).target;
      d.find(i).forEach((n) => {
        (Ci.getInstance(n) || new Ci(n)).toggle();
      });
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, ws);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new Ci(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, ws);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Zo = "stepper", tn = "te.stepper", ai = `.${tn}`, Ui = `data-te-${Zo}`, Ai = "horizontal", Ot = "vertical", Fg = `onChangeStep${ai}`, Yg = `onChangedStep${ai}`, jg = {
  stepperType: "string",
  stepperLinear: "boolean",
  stepperNoEditable: "boolean",
  stepperActive: "string",
  stepperCompleted: "string",
  stepperInvalid: "string",
  stepperDisabled: "string",
  stepperVerticalBreakpoint: "number",
  stepperMobileBreakpoint: "number",
  stepperMobileBarBreakpoint: "number",
  stepperAnimationDuration: "number",
  slideInLeftAnimation: "string",
  slideOutLeftAnimation: "string",
  slideInRightAnimation: "string",
  slideOutRightAnimation: "string"
}, Kg = {
  stepperType: Ai,
  stepperLinear: !1,
  stepperNoEditable: !1,
  stepperActive: "",
  stepperCompleted: "",
  stepperInvalid: "",
  stepperDisabled: "",
  stepperVerticalBreakpoint: 0,
  stepperMobileBreakpoint: 0,
  stepperMobileBarBreakpoint: 4,
  stepperAnimationDuration: 800,
  slideInLeftAnimation: "animate-[slide-in-left_0.8s_both]",
  slideOutLeftAnimation: "animate-[slide-out-left_0.8s_both]",
  slideInRightAnimation: "animate-[slide-in-right_0.8s_both]",
  slideOutRightAnimation: "animate-[slide-out-right_0.8s_both]"
}, dl = `mousedown${ai}`, ul = `keydown${ai}`, zg = `keyup${ai}`, pl = `resize${ai}`, Kt = `[${Ui}-step-ref]`, Z = `[${Ui}-head-ref]`, _l = `[${Ui}-head-text-ref]`, ks = `[${Ui}-head-icon-ref]`, Q = `[${Ui}-content-ref]`;
class UA {
  constructor(t, e) {
    this._element = t, this._options = this._getConfig(e), this._elementHeight = 0, this._steps = d.find(`${Kt}`, this._element), this._currentView = "", this._activeStepIndex = 0, this._verticalStepperStyles = [], this._timeout = 0, this._element && (A.setData(t, tn, this), this._init());
  }
  // Getters
  static get NAME() {
    return Zo;
  }
  get activeStep() {
    return this._steps[this._activeStepIndex];
  }
  get activeStepIndex() {
    return this._activeStepIndex;
  }
  // Public
  dispose() {
    this._steps.forEach((t) => {
      c.off(t, dl), c.off(t, ul);
    }), c.off(window, pl), A.removeData(this._element, tn), this._element = null;
  }
  changeStep(t) {
    this._toggleStep(t);
  }
  nextStep() {
    this._toggleStep(this._activeStepIndex + 1);
  }
  previousStep() {
    this._toggleStep(this._activeStepIndex - 1);
  }
  // Private
  _init() {
    const t = d.find(`${Kt}`, this._element)[this._activeStepIndex].setAttribute("data-te", "active-step"), e = d.find(
      `${_l}`,
      this._element
    ), i = d.find(
      `${ks}`,
      this._element
    );
    switch (t ? (this._activeStepIndex = this._steps.indexOf(t), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperActive
    ), e[this._activeStepIndex].classList.add("font-medium"), i[this._activeStepIndex].classList.add("!bg-primary-100"), i[this._activeStepIndex].classList.add("!text-primary-700")) : (e[this._activeStepIndex].classList.add("font-medium"), i[this._activeStepIndex].classList.add("!bg-primary-100"), i[this._activeStepIndex].classList.add("!text-primary-700"), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperActive
    )), this._bindMouseDown(), this._bindKeysNavigation(), this._options.stepperType) {
      case Ot:
        this._toggleVertical();
        break;
      default:
        this._toggleHorizontal();
        break;
    }
    (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView(), this._bindResize();
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...Kg,
      ...e,
      ...t
    }, I(Zo, t, jg), t;
  }
  _bindMouseDown() {
    this._steps.forEach((t) => {
      const e = d.findOne(`${Z}`, t);
      c.on(e, dl, (i) => {
        const n = d.parents(i.target, `${Kt}`)[0], o = this._steps.indexOf(n);
        i.preventDefault(), this._toggleStep(o);
      });
    });
  }
  _bindResize() {
    c.on(window, pl, () => {
      this._currentView === Ot && this._setSingleStepHeight(this.activeStep), this._currentView === Ai && this._setHeight(this.activeStep), (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView();
    });
  }
  _toggleStepperView() {
    const t = this._options.stepperVerticalBreakpoint < window.innerWidth, e = this._options.stepperVerticalBreakpoint > window.innerWidth, i = this._options.stepperMobileBreakpoint > window.innerWidth;
    t && this._currentView !== Ai && this._toggleHorizontal(), e && !i && this._currentView !== Ot && (this._steps.forEach((n) => {
      const o = d.findOne(`${Q}`, n);
      this._resetStepperHeight(), this._showElement(o);
    }), this._toggleVertical());
  }
  _toggleStep(t) {
    if (this._activeStepIndex === t)
      return;
    this._options.stepperNoEditable && this._toggleDisabled();
    const e = this._activeStepIndex, i = c.trigger(
      this.activeStep,
      Fg,
      {
        currentStep: this._activeStepIndex,
        nextStep: t
      }
    );
    t > this._activeStepIndex && i.defaultPrevented || (this._showElement(
      d.findOne(`${Q}`, this._steps[t])
    ), this._toggleActive(t), t > this._activeStepIndex && this._toggleCompleted(this._activeStepIndex), this._currentView === Ai ? this._animateHorizontalStep(t) : (this._animateVerticalStep(t), this._setSingleStepHeight(this._steps[t])), this._toggleStepTabIndex(
      d.findOne(`${Z}`, this.activeStep),
      d.findOne(`${Z}`, this._steps[t])
    ), this._activeStepIndex = t, this._steps[this._activeStepIndex].setAttribute("data-te", "active-step"), this._steps.forEach((n, o) => {
      n[this._activeStepIndex] !== o && n.removeAttribute("data-te");
    }), c.trigger(this.activeStep, Yg, {
      currentStep: this._activeStepIndex,
      prevStep: e
    }));
  }
  _resetStepperHeight() {
    this._element.style.height = "";
  }
  _setStepsHeight() {
    this._steps.forEach((t) => {
      const e = d.findOne(`${Q}`, t), i = window.getComputedStyle(e);
      this._verticalStepperStyles.push({
        paddingTop: parseFloat(i.paddingTop),
        paddingBottom: parseFloat(i.paddingBottom)
      });
      const n = e.scrollHeight;
      e.style.height = `${n}px`;
    });
  }
  _setSingleStepHeight(t) {
    const e = d.findOne(`${Q}`, t), i = this.activeStep === t, n = this._steps.indexOf(t);
    let o;
    i ? (e.style.height = "", o = e.scrollHeight) : o = e.scrollHeight + this._verticalStepperStyles[n].paddingTop + this._verticalStepperStyles[n].paddingBottom, e.style.height = `${o}px`;
  }
  _toggleVertical() {
    this._currentView = Ot, this._setStepsHeight(), this._hideInactiveSteps();
  }
  _toggleHorizontal() {
    this._currentView = Ai, this._setHeight(this.activeStep), this._hideInactiveSteps();
  }
  _toggleStepperClass() {
    d.findOne(
      "[data-te-stepper-type]",
      this._element
    ) !== null && this._steps.forEach((e) => {
      d.findOne(`${Q}`, e).classList.remove("!my-0"), d.findOne(`${Q}`, e).classList.remove("!py-0"), d.findOne(`${Q}`, e).classList.remove("!h-0");
    });
  }
  _toggleStepClass(t, e, i) {
    i && this._steps[t].classList[e](i);
  }
  _bindKeysNavigation() {
    this._toggleStepTabIndex(
      !1,
      d.findOne(`${Z}`, this.activeStep)
    ), this._steps.forEach((t) => {
      const e = d.findOne(`${Z}`, t);
      c.on(e, ul, (i) => {
        const n = d.parents(
          i.currentTarget,
          `${Kt}`
        )[0], o = d.next(n, `${Kt}`)[0], r = d.prev(n, `${Kt}`)[0], a = d.findOne(
          `${Z}`,
          n
        ), l = d.findOne(
          `${Z}`,
          this.activeStep
        );
        let p = null, u = null;
        if (o && (p = d.findOne(`${Z}`, o)), r && (u = d.findOne(`${Z}`, r)), i.keyCode === Ke && this._currentView !== Ot && (u ? (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus()) : p && (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus())), i.keyCode === ze && this._currentView !== Ot && (p ? (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus()) : u && (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus())), i.keyCode === z && this._currentView === Ot && (i.preventDefault(), p && (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus())), i.keyCode === U && this._currentView === Ot && (i.preventDefault(), u && (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus())), i.keyCode === Te) {
          const _ = d.findOne(
            `${Z}`,
            this._steps[0]
          );
          this._toggleStepTabIndex(a, _), this._toggleOutlineStyles(a, _), _.focus();
        }
        if (i.keyCode === Ee) {
          const _ = this._steps[this._steps.length - 1], f = d.findOne(`${Z}`, _);
          this._toggleStepTabIndex(a, f), this._toggleOutlineStyles(a, f), f.focus();
        }
        (i.keyCode === it || i.keyCode === Zs) && (i.preventDefault(), this.changeStep(this._steps.indexOf(n))), i.keyCode === ke && (this._toggleStepTabIndex(a, l), this._toggleOutlineStyles(a, !1), l.focus());
      }), c.on(e, zg, (i) => {
        const n = d.parents(
          i.currentTarget,
          `${Kt}`
        )[0], o = d.findOne(
          `${Z}`,
          n
        ), r = d.findOne(
          `${Z}`,
          this.activeStep
        );
        i.keyCode === ke && (this._toggleStepTabIndex(o, r), this._toggleOutlineStyles(!1, r), r.focus());
      });
    });
  }
  _toggleStepTabIndex(t, e) {
    t && t.setAttribute("tabIndex", -1), e && e.setAttribute("tabIndex", 0);
  }
  _toggleOutlineStyles(t, e) {
    t && (t.style.outline = ""), e && (e.style.outline = "revert");
  }
  _toggleDisabled() {
    const t = d.find(`${Z}`, this._element), e = d.find(
      `${ks}`,
      this._element
    );
    t[this._activeStepIndex].classList.add("color-[#858585]"), t[this._activeStepIndex].classList.add("cursor-default"), e[this._activeStepIndex].classList.add("!bg-[#858585]"), this._toggleStepClass(
      this._activeStepIndex,
      "add",
      this._options.stepperDisabled
    );
  }
  _toggleActive(t) {
    const e = d.find(
      `${_l}`,
      this._element
    ), i = d.find(
      `${ks}`,
      this._element
    );
    e[t].classList.add("font-medium"), i[t].classList.add("!bg-primary-100"), i[t].classList.add("!text-primary-700"), i[t].classList.remove("!bg-success-100"), i[t].classList.remove("!text-success-700"), e[this._activeStepIndex].classList.remove("font-medium"), i[this._activeStepIndex].classList.remove("!bg-primary-100"), i[this._activeStepIndex].classList.remove(
      "!text-primary-700"
    ), this._toggleStepClass(t, "add", this._options.stepperActive), this._toggleStepClass(
      this._activeStepIndex,
      "remove",
      this._options.stepperActive
    );
  }
  _toggleCompleted(t) {
    const e = d.find(
      `${ks}`,
      this._element
    );
    this._options.stepperNoEditable ? this._steps[t].classList.add("pointer-events-none") : (e[t].classList.add("!bg-success-100"), e[t].classList.add("!text-success-700")), e[t].classList.remove("!bg-danger-100"), e[t].classList.remove("!text-danger-700"), this._toggleStepClass(t, "add", this._options.stepperCompleted), this._toggleStepClass(t, "remove", this._options.stepperInvalid);
  }
  _hideInactiveSteps() {
    this._steps.forEach((t) => {
      if (!t.getAttribute("data-te")) {
        const e = d.findOne(`${Q}`, t);
        e.classList.remove("translate-x-[150%]"), this._hideElement(e);
      }
    });
  }
  _setHeight(t) {
    const e = d.findOne(`${Q}`, t), i = getComputedStyle(e), n = d.findOne(`${Z}`, t), o = getComputedStyle(n), r = e.offsetHeight + parseFloat(i.marginTop) + parseFloat(i.marginBottom), a = n.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom);
    this._element.style.height = `${a + r}px`;
  }
  _hideElement(t) {
    !d.parents(
      t,
      `${Kt}`
    )[0].getAttribute("data-te") && this._currentView !== Ot ? t.style.display = "none" : (t.classList.add("!my-0"), t.classList.add("!py-0"), t.classList.add("!h-0"));
  }
  _showElement(t) {
    this._currentView === Ot ? (t.classList.remove("!my-0"), t.classList.remove("!py-0"), t.classList.remove("!h-0")) : t.style.display = "block";
  }
  _animateHorizontalStep(t) {
    clearTimeout(this._timeout), this._clearStepsAnimation();
    const e = t > this._activeStepIndex, i = d.findOne(
      `${Q}`,
      this._steps[t]
    ), n = d.findOne(
      `${Q}`,
      this.activeStep
    );
    let o, r;
    this._steps.forEach((a, l) => {
      const p = d.findOne(`${Q}`, a);
      l !== t && l !== this._activeStepIndex && this._hideElement(p);
    }), e ? (r = this._options.slideOutLeftAnimation, o = this._options.slideInRightAnimation) : (r = this._options.slideOutRightAnimation, o = this._options.slideInLeftAnimation), n.classList.add(r), i.classList.add(o), this._setHeight(this._steps[t]), this._timeout = setTimeout(() => {
      this._hideElement(n), this._clearStepsAnimation();
    }, this._options.stepperAnimationDuration);
  }
  _clearStepsAnimation() {
    this._steps.forEach((t) => {
      d.findOne(`${Q}`, t).classList.remove(
        this._options.slideInLeftAnimation,
        this._options.slideOutLeftAnimation,
        this._options.slideInRightAnimation,
        this._options.slideOutRightAnimation
      );
    });
  }
  _animateVerticalStep(t) {
    const e = d.findOne(
      `${Q}`,
      this._steps[t]
    ), i = d.findOne(
      `${Q}`,
      this.activeStep
    );
    this._hideElement(i), this._showElement(e);
  }
  static getInstance(t) {
    return A.getData(t, tn);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const fl = "data-te-input-state-active", xs = "data-te-input-selected", ml = "data-te-input-multiple-active", gl = "[data-te-form-check-input]";
class bl {
  constructor(t, e, i, n, o, r, a, l, p, u, _) {
    this.id = t, this.nativeOption = e, this.multiple = i, this.value = n, this.label = o, this.selected = r, this.disabled = a, this.hidden = l, this.secondaryText = p, this.groupId = u, this.icon = _, this.node = null, this.active = !1;
  }
  select() {
    this.multiple ? this._selectMultiple() : this._selectSingle();
  }
  _selectSingle() {
    this.selected || (this.node.setAttribute(xs, ""), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0));
  }
  _selectMultiple() {
    if (!this.selected) {
      const t = d.findOne(
        gl,
        this.node
      );
      t.checked = !0, this.node.setAttribute(xs, ""), this.node.setAttribute("aria-selected", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0);
    }
  }
  deselect() {
    this.multiple ? this._deselectMultiple() : this._deselectSingle();
  }
  _deselectSingle() {
    this.selected && (this.node.removeAttribute(xs), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1));
  }
  _deselectMultiple() {
    if (this.selected) {
      const t = d.findOne(
        gl,
        this.node
      );
      t.checked = !1, this.node.removeAttribute(xs), this.node.setAttribute("aria-selected", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1);
    }
  }
  setNode(t) {
    this.node = t;
  }
  setActiveStyles() {
    if (!this.active) {
      if (this.multiple) {
        this.node.setAttribute(ml, "");
        return;
      }
      this.active = !0, this.node.setAttribute(fl, "");
    }
  }
  removeActiveStyles() {
    this.active && (this.active = !1, this.node.removeAttribute(fl)), this.multiple && this.node.removeAttribute(ml);
  }
}
class Ug {
  constructor(t = !1) {
    this._multiple = t, this._selections = [];
  }
  select(t) {
    this._multiple ? this._selections.push(t) : this._selections = [t];
  }
  deselect(t) {
    if (this._multiple) {
      const e = this._selections.findIndex(
        (i) => t === i
      );
      this._selections.splice(e, 1);
    } else
      this._selections = [];
  }
  clear() {
    this._selections = [];
  }
  get selection() {
    return this._selections[0];
  }
  get selections() {
    return this._selections;
  }
  get label() {
    return this._selections[0] && this.selection.label;
  }
  get labels() {
    return this._selections.map((t) => t.label).join(", ");
  }
  get value() {
    return this.selections[0] && this.selection.value;
  }
  get values() {
    return this._selections.map((t) => t.value);
  }
}
function Qo(s) {
  return s.filter((t) => !t.disabled).every((t) => t.selected);
}
const Xg = "data-te-select-form-outline-ref", Gg = "data-te-select-wrapper-ref", qg = "data-te-select-input-ref", Zg = "data-te-select-clear-btn-ref", Qg = "data-te-select-dropdown-container-ref", Jg = "data-te-select-dropdown-ref", tb = "data-te-select-options-wrapper-ref", eb = "data-te-select-options-list-ref", ib = "data-te-select-input-filter-ref", Eh = "data-te-select-option-ref", sb = "data-te-select-option-all-ref", nb = "data-te-select-option-text-ref", ob = "data-te-form-check-input", rb = "data-te-select-option-group-ref", ab = "data-te-select-option-group-label-ref", Ch = "data-te-select-selected", lb = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
</svg>
`, cb = (s) => {
  s.code === "Tab" || s.code === "Esc" || s.preventDefault();
};
function Os(s, t, e, i, n) {
  t.selectSize === "default" && h.addClass(s, e), t.selectSize === "sm" && h.addClass(s, i), t.selectSize === "lg" && h.addClass(s, n);
}
function hb(s, t, e, i, n) {
  const o = document.createElement("div");
  o.setAttribute("id", s), o.setAttribute(Gg, "");
  const r = $("div");
  r.setAttribute(Xg, ""), h.addClass(r, i.formOutline);
  const a = $("input"), l = t.selectFilter ? "combobox" : "listbox", p = t.multiple ? "true" : "false", u = t.disabled ? "true" : "false";
  a.setAttribute(qg, ""), h.addClass(a, i.selectInput), Os(
    a,
    t,
    i.selectInputSizeDefault,
    i.selectInputSizeSm,
    i.selectInputSizeLg
  ), t.selectFormWhite && h.addClass(a, i.selectInputWhite), a.setAttribute("type", "text"), a.setAttribute("role", l), a.setAttribute("aria-multiselectable", p), a.setAttribute("aria-disabled", u), a.setAttribute("aria-haspopup", "true"), a.setAttribute("aria-expanded", !1), t.tabIndex && a.setAttribute("tabIndex", t.tabIndex), t.disabled && a.setAttribute("disabled", ""), t.selectPlaceholder !== "" && a.setAttribute("placeholder", t.selectPlaceholder), t.selectValidation ? (h.addStyle(a, {
    "pointer-events": "none",
    "caret-color": "transparent"
  }), h.addStyle(r, { cursor: "pointer" })) : a.setAttribute("readonly", "true"), t.selectValidation && (a.setAttribute("required", "true"), a.setAttribute("aria-required", "true"), a.addEventListener("keydown", cb));
  const _ = $("div");
  h.addClass(_, i.selectValidationValid);
  const f = document.createTextNode(
    `${t.selectValidFeedback}`
  );
  _.appendChild(f);
  const g = $("div");
  h.addClass(g, i.selectValidationInvalid);
  const m = document.createTextNode(
    `${t.selectInvalidFeedback}`
  );
  g.appendChild(m);
  const b = $("span");
  b.setAttribute(Zg, ""), h.addClass(b, i.selectClearBtn), Os(
    b,
    t,
    i.selectClearBtnDefault,
    i.selectClearBtnSm,
    i.selectClearBtnLg
  ), t.selectFormWhite && h.addClass(b, i.selectClearBtnWhite);
  const v = document.createTextNode("✕");
  b.appendChild(v), b.setAttribute("tabindex", "0");
  const T = $("span");
  return h.addClass(T, i.selectArrow), Os(
    T,
    t,
    i.selectArrowDefault,
    i.selectArrowSm,
    i.selectArrowLg
  ), t.selectFormWhite && h.addClass(T, i.selectArrowWhite), T.innerHTML = n || lb, r.appendChild(a), e && (h.addClass(e, i.selectLabel), Os(
    e,
    t,
    i.selectLabelSizeDefault,
    i.selectLabelSizeSm,
    i.selectLabelSizeLg
  ), t.selectFormWhite && h.addClass(e, i.selectLabelWhite), r.appendChild(e)), t.selectValidation && (r.appendChild(_), r.appendChild(g)), t.selectClearButton && r.appendChild(b), r.appendChild(T), o.appendChild(r), o;
}
function vl(s, t, e, i, n, o, r, a) {
  const l = document.createElement("div");
  l.setAttribute(Qg, ""), h.addClass(l, a.selectDropdownContainer), l.setAttribute("id", `${s}`), l.style.width = `${e}px`;
  const p = document.createElement("div");
  p.setAttribute("tabindex", 0), p.setAttribute(Jg, ""), h.addClass(p, a.dropdown);
  const u = $("div");
  u.setAttribute(tb, ""), h.addClass(u, a.optionsWrapper), h.addClass(u, a.optionsWrapperScrollbar), u.style.maxHeight = `${i}px`;
  const _ = Ah(
    o,
    n,
    t,
    a
  );
  return u.appendChild(_), t.selectFilter && p.appendChild(
    db(t.selectSearchPlaceholder, a)
  ), p.appendChild(u), r && p.appendChild(r), l.appendChild(p), l;
}
function Ah(s, t, e, i) {
  const n = $("div");
  n.setAttribute(eb, ""), h.addClass(n, i.optionsList);
  let o;
  return e.multiple ? o = pb(
    s,
    t,
    e,
    i
  ) : o = ub(s, e, i), o.forEach((r) => {
    n.appendChild(r);
  }), n;
}
function db(s, t) {
  const e = $("div");
  h.addClass(e, t.inputGroup);
  const i = $("input");
  return i.setAttribute(ib, ""), h.addClass(i, t.selectFilterInput), i.placeholder = s, i.setAttribute("role", "searchbox"), i.setAttribute("type", "text"), e.appendChild(i), e;
}
function ub(s, t, e) {
  return yh(s, t, e);
}
function pb(s, t, e, i) {
  let n = null;
  e.selectAll && (n = _b(
    t,
    s,
    e,
    i
  ));
  const o = yh(s, e, i);
  return n ? [n, ...o] : o;
}
function yh(s, t, e) {
  const i = [];
  return s.forEach((n) => {
    if (Object.prototype.hasOwnProperty.call(
      n,
      "options"
    )) {
      const r = bb(n, t, e);
      i.push(r);
    } else
      i.push(wh(n, t, e));
  }), i;
}
function _b(s, t, e, i) {
  const n = Qo(t), o = $("div");
  o.setAttribute(Eh, "");
  const r = i.selectAllOption || i.selectOption;
  return h.addClass(o, r), o.setAttribute(sb, ""), h.addStyle(o, {
    height: `${e.selectOptionHeight}px`
  }), o.setAttribute("role", "option"), o.setAttribute("aria-selected", n), n && o.setAttribute(Ch, ""), o.appendChild(kh(s, e, i)), s.setNode(o), o;
}
function wh(s, t, e) {
  if (s.node)
    return s.node;
  const i = $("div");
  return i.setAttribute(Eh, ""), h.addClass(i, e.selectOption), h.addStyle(i, {
    height: `${t.selectOptionHeight}px`
  }), h.setDataAttribute(i, "id", s.id), i.setAttribute("role", "option"), i.setAttribute("aria-selected", s.selected), i.setAttribute("aria-disabled", s.disabled), s.selected && i.setAttribute(Ch, ""), s.disabled && i.setAttribute("data-te-select-option-disabled", !0), s.hidden && h.addClass(i, "hidden"), i.appendChild(kh(s, t, e)), s.icon && i.appendChild(gb(s, e)), s.setNode(i), i;
}
function kh(s, t, e) {
  const i = $("span");
  i.setAttribute(nb, ""), h.addClass(i, e.selectOptionText);
  const n = document.createTextNode(s.label);
  return t.multiple && i.appendChild(mb(s, e)), i.appendChild(n), (s.secondaryText || typeof s.secondaryText == "number") && i.appendChild(
    fb(s.secondaryText, e)
  ), i;
}
function fb(s, t) {
  const e = $("span");
  h.addClass(e, t.selectOptionSecondaryText);
  const i = document.createTextNode(s);
  return e.appendChild(i), e;
}
function mb(s, t) {
  const e = $("input");
  e.setAttribute("type", "checkbox"), h.addClass(e, t.formCheckInput), e.setAttribute(ob, "");
  const i = $("label");
  return s.selected && e.setAttribute("checked", !0), s.disabled && e.setAttribute("disabled", !0), e.appendChild(i), e;
}
function gb(s, t) {
  const e = $("span"), i = $("img");
  return h.addClass(i, t.selectOptionIcon), i.src = s.icon, e.appendChild(i), e;
}
function bb(s, t, e) {
  const i = $("div");
  i.setAttribute(rb, ""), h.addClass(i, e.selectOptionGroup), i.setAttribute("role", "group"), i.setAttribute("id", s.id), s.hidden && h.addClass(i, "hidden");
  const n = $("label");
  return n.setAttribute(ab, ""), h.addClass(n, e.selectOptionGroupLabel), h.addStyle(n, { height: `${t.selectOptionHeight}px` }), n.setAttribute("for", s.id), n.textContent = s.label, i.appendChild(n), s.options.forEach((o) => {
    i.appendChild(wh(o, t, e));
  }), i;
}
function vb(s, t) {
  const e = $("div");
  return e.textContent = s, h.addClass(e, t.selectLabel), h.addClass(e, t.selectFakeValue), e;
}
const mo = "select", yi = "te.select", Xi = `.${yi}`, Tb = `close${Xi}`, Eb = `open${Xi}`, Tl = `optionSelect${Xi}`, El = `optionDeselect${Xi}`, Cb = `valueChange${Xi}`, Ab = "change", Cl = "data-te-select-init", xh = "data-te-select-no-results-ref", Al = "data-te-select-open", J = "data-te-input-state-active", zt = "data-te-input-focused", go = "data-te-input-disabled", yb = "data-te-select-option-group-label-ref", wb = "data-te-select-option-all-ref", bi = "data-te-select-selected", kb = "[data-te-select-label-ref]", yl = "[data-te-select-input-ref]", xb = "[data-te-select-input-filter-ref]", Ob = "[data-te-select-dropdown-ref]", Sb = "[data-te-select-options-wrapper-ref]", wl = "[data-te-select-options-list-ref]", Ib = "[data-te-select-option-ref]", Db = "[data-te-select-clear-btn-ref]", $b = "[data-te-select-custom-content-ref]", Lb = `[${xh}]`, kl = "[data-te-select-form-outline-ref]", Nb = "[data-te-select-toggle]", bo = "[data-te-input-notch-ref]", Mb = {
  selectAutoSelect: !1,
  selectContainer: "body",
  selectClearButton: !1,
  disabled: !1,
  selectDisplayedLabels: 5,
  selectFormWhite: !1,
  multiple: !1,
  selectOptionsSelectedLabel: "options selected",
  selectOptionHeight: 38,
  selectAll: !0,
  selectAllLabel: "Select all",
  selectSearchPlaceholder: "Search...",
  selectSize: "default",
  selectVisibleOptions: 5,
  selectFilter: !1,
  selectFilterDebounce: 300,
  selectNoResultText: "No results",
  selectValidation: !1,
  selectValidFeedback: "Valid",
  selectInvalidFeedback: "Invalid",
  selectPlaceholder: ""
}, Rb = {
  selectAutoSelect: "boolean",
  selectContainer: "string",
  selectClearButton: "boolean",
  disabled: "boolean",
  selectDisplayedLabels: "number",
  selectFormWhite: "boolean",
  multiple: "boolean",
  selectOptionsSelectedLabel: "string",
  selectOptionHeight: "number",
  selectAll: "boolean",
  selectAllLabel: "string",
  selectSearchPlaceholder: "string",
  selectSize: "string",
  selectVisibleOptions: "number",
  selectFilter: "boolean",
  selectFilterDebounce: "number",
  selectNoResultText: "string",
  selectValidation: "boolean",
  selectValidFeedback: "string",
  selectInvalidFeedback: "string",
  selectPlaceholder: "string"
}, Pb = {
  dropdown: "relative outline-none min-w-[100px] m-0 scale-y-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700",
  formCheckInput: "relative float-left mt-[0.15rem] mr-[8px] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 dark:border-neutral-600 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary dark:checked:border-primary checked:bg-primary dark:checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:ml-[0.25rem] checked:after:-mt-px checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:ml-[0.25rem] checked:focus:after:-mt-px checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-t-0 checked:focus:after:border-l-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent",
  formOutline: "relative",
  initialized: "hidden",
  inputGroup: "flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200",
  noResult: "flex items-center px-4",
  optionsList: "list-none m-0 p-0",
  optionsWrapper: "overflow-y-auto",
  optionsWrapperScrollbar: "[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded",
  selectArrow: "absolute right-3 text-[0.8rem] cursor-pointer peer-focus:text-primary peer-data-[te-input-focused]:text-primary group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)] w-5 h-5",
  selectArrowWhite: "text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white",
  selectArrowDefault: "top-2",
  selectArrowLg: "top-[13px]",
  selectArrowSm: "top-1",
  selectClearBtn: "absolute top-2 right-9 text-black cursor-pointer focus:text-primary outline-none dark:text-gray-200",
  selectClearBtnWhite: "!text-gray-50",
  selectClearBtnDefault: "top-2 text-base",
  selectClearBtnLg: "top-[11px] text-base",
  selectClearBtnSm: "top-1 text-[0.8rem]",
  selectDropdownContainer: "z-[1070]",
  selectFakeValue: "transform-none hidden data-[te-input-state-active]:block",
  selectFilterInput: "relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-primary focus:text-gray-700 focus:shadow-te-primary focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200",
  selectInput: "peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600",
  selectInputWhite: "!text-gray-50",
  selectInputSizeDefault: "py-[0.32rem] px-3 leading-[1.6]",
  selectInputSizeLg: "py-[0.32rem] px-3 leading-[2.15]",
  selectInputSizeSm: "py-[0.33rem] px-3 text-xs leading-[1.5]",
  selectLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8] dark:peer-focus:text-primary",
  selectLabelWhite: "!text-gray-50",
  selectLabelSizeDefault: "pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]",
  selectLabelSizeLg: "pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]",
  selectLabelSizeSm: "pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]",
  selectOption: "flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30",
  selectAllOption: "",
  selectOptionGroup: "group/opt",
  selectOptionGroupLabel: "flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300",
  selectOptionIcon: "w-7 h-7 rounded-full",
  selectOptionSecondaryText: "block text-[0.8rem] text-gray-500 dark:text-gray-300",
  selectOptionText: "group",
  selectValidationValid: "hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block",
  selectValidationInvalid: "hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block"
}, Bb = {
  dropdown: "string",
  formCheckInput: "string",
  formOutline: "string",
  initialized: "string",
  inputGroup: "string",
  noResult: "string",
  optionsList: "string",
  optionsWrapper: "string",
  optionsWrapperScrollbar: "string",
  selectArrow: "string",
  selectArrowDefault: "string",
  selectArrowLg: "string",
  selectArrowSm: "string",
  selectClearBtn: "string",
  selectClearBtnDefault: "string",
  selectClearBtnLg: "string",
  selectClearBtnSm: "string",
  selectDropdownContainer: "string",
  selectFakeValue: "string",
  selectFilterInput: "string",
  selectInput: "string",
  selectInputSizeDefault: "string",
  selectInputSizeLg: "string",
  selectInputSizeSm: "string",
  selectLabel: "string",
  selectLabelSizeDefault: "string",
  selectLabelSizeLg: "string",
  selectLabelSizeSm: "string",
  selectOption: "string",
  selectAllOption: "string",
  selectOptionGroup: "string",
  selectOptionGroupLabel: "string",
  selectOptionIcon: "string",
  selectOptionSecondaryText: "string",
  selectOptionText: "string"
};
class kr {
  constructor(t, e, i) {
    this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._config.selectPlaceholder && !this._config.multiple && this._addPlaceholderOption(), this._optionsToRender = this._getOptionsToRender(t), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new Ug(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = et("select-wrapper-"), this._dropdownContainerId = et("select-dropdown-container-"), this._selectAllId = et("select-all-"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.selectOptionHeight * this._config.selectVisibleOptions, this._popper = null, this._input = null, this._label = d.next(this._element, kb)[0], this._notch = null, this._fakeValue = null, this._isFakeValueActive = !1, this._customContent = d.next(
      t,
      $b
    )[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = !1, this._addMutationObserver(), this._element && A.setData(t, yi, this);
  }
  static get NAME() {
    return mo;
  }
  get filterInput() {
    return d.findOne(
      xb,
      this._dropdownContainer
    );
  }
  get dropdown() {
    return d.findOne(Ob, this._dropdownContainer);
  }
  get optionsList() {
    return d.findOne(
      wl,
      this._dropdownContainer
    );
  }
  get optionsWrapper() {
    return d.findOne(
      Sb,
      this._dropdownContainer
    );
  }
  get clearButton() {
    return d.findOne(Db, this._wrapper);
  }
  get options() {
    return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;
  }
  get value() {
    return this.multiple ? this._selectionModel.values : this._selectionModel.value;
  }
  get multiple() {
    return this._config.multiple;
  }
  get hasSelectAll() {
    return this.multiple && this._config.selectAll;
  }
  get hasSelection() {
    return this._selectionModel.selection || this._selectionModel.selections.length > 0;
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...Mb,
      ...e,
      ...t
    }, this._element.hasAttribute("multiple") && (t.multiple = !0), this._element.hasAttribute("disabled") && (t.disabled = !0), this._element.tabIndex && (t.tabIndex = this._element.getAttribute("tabIndex")), I(mo, t, Rb), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...Pb,
      ...e,
      ...t
    }, I(mo, t, Bb), t;
  }
  _addPlaceholderOption() {
    const t = new Option("", "", !0, !0);
    t.hidden = !0, t.selected = !0, this._element.prepend(t);
  }
  _getOptionsToRender(t) {
    const e = [];
    return t.childNodes.forEach((n) => {
      if (n.nodeName === "OPTGROUP") {
        const o = {
          id: et("group-"),
          label: n.label,
          disabled: n.hasAttribute("disabled"),
          hidden: n.hasAttribute("hidden"),
          options: []
        };
        n.childNodes.forEach((a) => {
          a.nodeName === "OPTION" && o.options.push(
            this._createOptionObject(a, o)
          );
        }), e.push(o);
      } else
        n.nodeName === "OPTION" && e.push(this._createOptionObject(n));
    }), e;
  }
  _getPlainOptions(t) {
    if (!d.findOne("optgroup", this._element))
      return t;
    const i = [];
    return t.forEach((n) => {
      Object.prototype.hasOwnProperty.call(
        n,
        "options"
      ) ? n.options.forEach((r) => {
        i.push(r);
      }) : i.push(n);
    }), i;
  }
  _createOptionObject(t, e = {}) {
    const i = et("option-"), n = e.id ? e.id : null, o = e.disabled ? e.disabled : !1, r = t.selected || t.hasAttribute(bi), a = t.hasAttribute("disabled") || o, l = t.hasAttribute("hidden") || e && e.hidden, p = this.multiple, u = t.value, _ = t.label, f = h.getDataAttribute(
      t,
      "selectSecondaryText"
    ), g = h.getDataAttribute(t, "select-icon");
    return new bl(
      i,
      t,
      p,
      u,
      _,
      r,
      a,
      l,
      f,
      n,
      g
    );
  }
  _getNavigationOptions() {
    const t = this.options.filter((e) => !e.hidden);
    return this.hasSelectAll ? [this._selectAllOption, ...t] : t;
  }
  _init() {
    this._renderMaterialWrapper(), this._wrapper = d.findOne(`#${this._wrapperId}`), this._input = d.findOne(yl, this._wrapper), this._config.disabled && this._input.setAttribute(go, "");
    const t = this._config.selectContainer;
    t === "body" ? this._container = document.body : this._container = d.findOne(t), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = vl(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent,
      this._classes
    ), this._setFirstActiveOption(), this._listenToFocusChange();
  }
  _renderMaterialWrapper() {
    const t = hb(
      this._wrapperId,
      this._config,
      this._label,
      this._classes,
      this._config.customArrow
    );
    this._element.parentNode.insertBefore(t, this._element), h.addClass(this._element, this._classes.initialized), t.appendChild(this._element);
  }
  _initOutlineInput() {
    const t = d.findOne(
      kl,
      this._wrapper
    );
    new V(
      t,
      {
        inputFormWhite: this._config.selectFormWhite
      },
      this._classes
    ).init(), this._notch = d.findOne(bo, this._wrapper);
  }
  _bindComponentEvents() {
    this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown();
  }
  _setDefaultSelections() {
    this.options.forEach((t) => {
      t.selected && this._selectionModel.select(t);
    });
  }
  _listenToComponentKeydown() {
    c.on(this._wrapper, "keydown", this._handleKeydown.bind(this));
  }
  _handleKeydown(t) {
    this._isOpen && !this._config.selectFilter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);
  }
  _handleOpenKeydown(t) {
    const e = t.keyCode, i = e === we || e === U && t.altKey || e === ke;
    if (e === ke && this._config.selectAutoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), i) {
      this.close(), this._input.focus();
      return;
    }
    switch (e) {
      case z:
        this._setNextOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case U:
        this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case Te:
        this._setFirstOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case Ee:
        this._setLastOptionActive(), this._scrollToOption(this._activeOption);
        break;
      case it:
        t.preventDefault(), this._activeOption && (this.hasSelectAll && this._activeOptionIndex === 0 ? this._handleSelectAll() : this._handleSelection(this._activeOption));
        return;
      default:
        return;
    }
    t.preventDefault();
  }
  _handleClosedKeydown(t) {
    const e = t.keyCode;
    if (e === it && t.preventDefault(), (e === it || e === z && t.altKey || e === z && this.multiple) && this.open(), this.multiple)
      switch (e) {
        case z:
          this.open();
          break;
        case U:
          this.open();
          break;
        default:
          return;
      }
    else
      switch (e) {
        case z:
          this._setNextOptionActive(), this._handleSelection(this._activeOption);
          break;
        case U:
          this._setPreviousOptionActive(), this._handleSelection(this._activeOption);
          break;
        case Te:
          this._setFirstOptionActive(), this._handleSelection(this._activeOption);
          break;
        case Ee:
          this._setLastOptionActive(), this._handleSelection(this._activeOption);
          break;
        default:
          return;
      }
    t.preventDefault();
  }
  _scrollToOption(t) {
    if (!t)
      return;
    let e;
    const i = this.options.filter((u) => !u.hidden);
    this.hasSelectAll ? e = i.indexOf(t) + 1 : e = i.indexOf(t);
    const n = this._getNumberOfGroupsBeforeOption(e), o = e + n, r = this.optionsWrapper, a = r.offsetHeight, l = this._config.selectOptionHeight, p = r.scrollTop;
    if (e > -1) {
      const u = o * l, _ = u + l > p + a;
      u < p ? r.scrollTop = u : _ ? r.scrollTop = u - a + l : r.scrollTop = p;
    }
  }
  _getNumberOfGroupsBeforeOption(t) {
    const e = this.options.filter((r) => !r.hidden), i = this._optionsToRender.filter((r) => !r.hidden), n = this.hasSelectAll ? t - 1 : t;
    let o = 0;
    for (let r = 0; r <= n; r++)
      e[r].groupId && i[o] && i[o].id && e[r].groupId === i[o].id && o++;
    return o;
  }
  _setNextOptionActive() {
    let t = this._activeOptionIndex + 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t += 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setPreviousOptionActive() {
    let t = this._activeOptionIndex - 1;
    const e = this._getNavigationOptions();
    if (e[t]) {
      for (; e[t].disabled; )
        if (t -= 1, !e[t])
          return;
      this._updateActiveOption(e[t], t);
    }
  }
  _setFirstOptionActive() {
    const e = this._getNavigationOptions();
    this._updateActiveOption(e[0], 0);
  }
  _setLastOptionActive() {
    const t = this._getNavigationOptions(), e = t.length - 1;
    this._updateActiveOption(t[e], e);
  }
  _updateActiveOption(t, e) {
    const i = this._activeOption;
    i && i.removeActiveStyles(), t.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t;
  }
  _listenToWrapperClick() {
    c.on(this._wrapper, "click", () => {
      this.toggle();
    });
  }
  _listenToClearBtnClick() {
    c.on(this.clearButton, "click", (t) => {
      t.preventDefault(), t.stopPropagation(), this._handleClear();
    });
  }
  _listenToClearBtnKeydown() {
    c.on(this.clearButton, "keydown", (t) => {
      t.keyCode === it && (this._handleClear(), t.preventDefault(), t.stopPropagation());
    });
  }
  _handleClear() {
    if (this.multiple)
      this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();
    else {
      const t = this._selectionModel.selection;
      this._selectionModel.clear(), t.deselect();
    }
    this._fakeValue.textContent = "", this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent();
  }
  _listenToOptionsClick() {
    c.on(this.optionsWrapper, "click", (t) => {
      if (t.target.hasAttribute(
        yb
      ))
        return;
      const i = t.target.nodeName === "DIV" ? t.target : d.closest(t.target, Ib);
      if (i.hasAttribute(wb)) {
        this._handleSelectAll();
        return;
      }
      const o = i.dataset.teId, r = this.options.find((a) => a.id === o);
      r && !r.disabled && this._handleSelection(r);
    });
  }
  _handleSelectAll() {
    this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _selectAllOptions(t) {
    t.forEach((e) => {
      !e.selected && !e.disabled && (this._selectionModel.select(e), e.select());
    });
  }
  _deselectAllOptions(t) {
    t.forEach((e) => {
      e.selected && !e.disabled && (this._selectionModel.deselect(e), e.deselect());
    });
  }
  _handleSelection(t) {
    this.multiple ? (this._handleMultiSelection(t), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleAutoSelection(t) {
    this._singleOptionSelect(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();
  }
  _handleSingleSelection(t) {
    this._singleOptionSelect(t), this.close(), this._input.focus();
  }
  _singleOptionSelect(t) {
    const e = this._selectionModel.selections[0];
    e && e !== t && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute(bi, !1), c.trigger(this._element, El, {
      value: e.value
    })), (!e || e && t !== e) && (this._selectionModel.select(t), t.select(), t.node.setAttribute(bi, !0), c.trigger(this._element, Tl, {
      value: t.value
    }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent());
  }
  _handleMultiSelection(t) {
    t.selected ? (this._selectionModel.deselect(t), t.deselect(), t.node.setAttribute(bi, !1), c.trigger(this._element, El, {
      value: t.value
    })) : (this._selectionModel.select(t), t.select(), t.node.setAttribute(bi, !0), c.trigger(this._element, Tl, {
      value: t.value
    })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();
  }
  _emitValueChangeEvent(t) {
    c.trigger(this._element, Cb, { value: t });
  }
  _emitNativeChangeEvent() {
    c.trigger(this._element, Ab);
  }
  _updateInputValue() {
    const t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;
    let e;
    this.multiple && this._config.selectDisplayedLabels !== -1 && this._selectionModel.selections.length > this._config.selectDisplayedLabels ? e = `${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}` : e = t, !this.multiple && !this._isSelectionValid(this._selectionModel.selection) ? this._input.value = "" : this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = " " : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = "" : this._input.value = this._optionsToRender[0].label;
  }
  _isSelectionValid(t) {
    return !(t && (t.disabled || t.value === ""));
  }
  _isLabelEmpty(t) {
    return !!(t && t.label === "");
  }
  _appendFakeValue() {
    if (!this._selectionModel.selection || this._selectionModel._multiple)
      return;
    const t = this._selectionModel.selection.label;
    this._fakeValue = vb(t, this._classes), d.findOne(
      kl,
      this._wrapper
    ).appendChild(this._fakeValue);
  }
  _updateLabelPosition() {
    const t = this._element.hasAttribute(Cl), e = this._input.value !== "";
    this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? (this._label.setAttribute(J, ""), this._notch.setAttribute(J, "")) : (this._label.removeAttribute(J), this._notch.removeAttribute(J, "")));
  }
  _updateLabelPositionWhileClosing() {
    this._label && (this._input.value !== "" || this._isFakeValueActive ? (this._label.setAttribute(J, ""), this._notch.setAttribute(J, "")) : (this._label.removeAttribute(J), this._notch.removeAttribute(J)));
  }
  _updateFakeLabelPosition() {
    this._fakeValue && (this._input.value === "" && this._fakeValue.innerHTML !== "" && !this._config.selectPlaceholder ? (this._isFakeValueActive = !0, this._fakeValue.setAttribute(J, "")) : (this._isFakeValueActive = !1, this._fakeValue.removeAttribute(J)));
  }
  _updateClearButtonVisibility() {
    if (!this.clearButton)
      return;
    this._selectionModel.selection || this._selectionModel.selections.length > 0 ? h.addStyle(this.clearButton, { display: "block" }) : h.addStyle(this.clearButton, { display: "none" });
  }
  _updateSelectAllState() {
    const t = this._selectAllOption.selected, e = Qo(this.options);
    !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select();
  }
  toggle() {
    this._isOpen ? this.close() : this.open();
  }
  open() {
    const t = this._config.disabled, e = c.trigger(this._element, Eb);
    this._isOpen || t || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.selectFilter && (setTimeout(() => {
      this.filterInput.focus();
    }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = !0, this._updateLabelPosition(), this._setInputActiveStyles());
  }
  _openDropdown() {
    this._popper = se(this._input, this._dropdownContainer, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 1]
          }
        }
      ]
    }), this._container.appendChild(this._dropdownContainer), setTimeout(() => {
      this.dropdown.setAttribute(Al, "");
    }, 0);
  }
  _updateDropdownWidth() {
    const t = this._input.offsetWidth;
    h.addStyle(this._dropdownContainer, { width: `${t}px` });
  }
  _setFirstActiveOption() {
    const t = this._getNavigationOptions(), e = this._activeOption;
    e && e.removeActiveStyles();
    const i = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;
    i ? (this._activeOption = i, i.setActiveStyles(), this._activeOptionIndex = t.findIndex(
      (n) => n === i
    )) : (this._activeOption = null, this._activeOptionIndex = -1);
  }
  _setInputActiveStyles() {
    this._input.setAttribute(zt, ""), d.findOne(bo, this._wrapper).setAttribute(
      zt,
      ""
    );
  }
  _listenToWindowResize() {
    c.on(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleWindowResize() {
    this._dropdownContainer && this._updateDropdownWidth();
  }
  _listenToSelectSearch() {
    this.filterInput.addEventListener("input", (t) => {
      const e = t.target.value, i = this._config.selectFilterDebounce;
      this._debounceFilter(e, i);
    });
  }
  _debounceFilter(t, e) {
    this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
      this._filterOptions(t);
    }, e);
  }
  _filterOptions(t) {
    const e = [];
    this._optionsToRender.forEach((o) => {
      const r = Object.prototype.hasOwnProperty.call(
        o,
        "options"
      ), a = !r && o.label.toLowerCase().includes(t.toLowerCase()), l = {};
      r && (l.label = o.label, l.options = this._filter(t, o.options), l.options.length > 0 && e.push(l)), a && e.push(o);
    });
    const i = this._config.selectNoResultText !== "", n = e.length !== 0;
    if (n)
      this._updateOptionsListTemplate(e), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(e), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption();
    else if (!n && i) {
      const o = this._getNoResultTemplate();
      this.optionsWrapper.innerHTML = o;
    }
  }
  _updateOptionsListTemplate(t) {
    const e = d.findOne(wl, this._dropdownContainer) || d.findOne(Lb, this._dropdownContainer), i = Ah(
      t,
      this._selectAllOption,
      this._config,
      this._classes
    );
    this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(i);
  }
  _getNoResultTemplate() {
    return `<div class="${this._classes.noResult}" ${xh} style="height: ${this._config.selectOptionHeight}px">${this._config.selectNoResultText}</div>`;
  }
  _filter(t, e) {
    const i = t.toLowerCase();
    return e.filter(
      (n) => n.label.toLowerCase().includes(i)
    );
  }
  _listenToDropdownKeydown() {
    c.on(
      this.dropdown,
      "keydown",
      this._handleOpenKeydown.bind(this)
    );
  }
  _listenToOutsideClick() {
    this._outsideClick = this._handleOutSideClick.bind(this), c.on(document, "click", this._outsideClick);
  }
  _listenToFocusChange(t = !0) {
    if (t === !1) {
      c.off(
        this._input,
        "focus",
        () => this._notch.setAttribute(zt, "")
      ), c.off(
        this._input,
        "blur",
        () => this._notch.removeAttribute(zt)
      );
      return;
    }
    c.on(
      this._input,
      "focus",
      () => this._notch.setAttribute(zt, "")
    ), c.on(
      this._input,
      "blur",
      () => this._notch.removeAttribute(zt)
    );
  }
  _handleOutSideClick(t) {
    const e = this._wrapper && this._wrapper.contains(t.target), i = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
    let o;
    this._toggleButton || (this._elementToggle = d.find(Nb)), this._elementToggle && this._elementToggle.forEach((r) => {
      const a = h.getDataAttribute(
        r,
        "select-toggle"
      );
      (a === this._element.id || this._element.classList.contains(a)) && (this._toggleButton = r, o = this._toggleButton.contains(t.target));
    }), !e && !i && !n && !o && this.close();
  }
  close() {
    const t = c.trigger(this._element, Tb), e = cn(
      this._dropdownContainer.children[0]
    );
    !this._isOpen || t.defaultPrevented || (this._config.selectFilter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), this.dropdown.removeAttribute(Al), setTimeout(() => {
      this._input.removeAttribute(zt), this._input.blur(), d.findOne(bo, this._wrapper).removeAttribute(
        zt
      ), this._label && !this.hasSelection && (this._label.removeAttribute(J), this._notch.setAttribute(J, ""), this._input.removeAttribute(J), this._notch.removeAttribute(J)), this._updateLabelPositionWhileClosing();
    }, 0), setTimeout(() => {
      this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = !1, c.off(this.dropdown, "transitionend");
    }, e));
  }
  _resetFilterState() {
    this.filterInput.value = "", this._filteredOptionsList = null;
  }
  _removeDropdownEvents() {
    c.off(document, "click", this._outsideClick), this._config.selectFilter && c.off(this.dropdown, "keydown"), c.off(this.optionsWrapper, "click");
  }
  _addMutationObserver() {
    this._mutationObserver = new MutationObserver(() => {
      this._wrapper && (this._updateSelections(), this._updateDisabledState());
    }), this._observeMutationObserver();
  }
  _updateSelections() {
    this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();
    const t = this._config.filter && this.filterInput && this.filterInput.value;
    this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = vl(
      this._dropdownContainerId,
      this._config,
      this._input.offsetWidth,
      this._dropdownHeight,
      this._selectAllOption,
      this._optionsToRender,
      this._customContent,
      this._classes
    );
  }
  _updateDisabledState() {
    const t = d.findOne(yl, this._wrapper);
    this._element.hasAttribute("disabled") ? (this._config.disabled = !0, t.setAttribute("disabled", ""), t.setAttribute(go, "")) : (this._config.disabled = !1, t.removeAttribute("disabled"), t.removeAttribute(go));
  }
  _observeMutationObserver() {
    this._mutationObserver && this._mutationObserver.observe(this._element, {
      attributes: !0,
      childList: !0,
      characterData: !0,
      subtree: !0
    });
  }
  _disconnectMutationObserver() {
    this.mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null);
  }
  _createSelectAllOption() {
    const t = this._selectAllId, e = null, i = !0, n = "select-all", o = this._config.selectAllLabel, r = Qo(this.options), a = !1, l = !1, p = null, u = null, _ = null;
    return new bl(
      t,
      e,
      i,
      n,
      o,
      r,
      a,
      l,
      p,
      u,
      _
    );
  }
  dispose() {
    this._removeComponentEvents(), this._destroyMaterialSelect(), this._listenToFocusChange(!1), A.removeData(this._element, yi);
  }
  _removeComponentEvents() {
    c.off(this.input, "click"), c.off(this.wrapper, this._handleKeydown.bind(this)), c.off(this.clearButton, "click"), c.off(this.clearButton, "keydown"), c.off(window, "resize", this._handleWindowResize.bind(this));
  }
  _destroyMaterialSelect() {
    this._isOpen && this.close(), this._destroyMaterialTemplate();
  }
  _destroyMaterialTemplate() {
    const t = this._wrapper.parentNode, e = d.find("label", this._wrapper);
    t.appendChild(this._element), e.forEach((i) => {
      t.appendChild(i);
    }), e.forEach((i) => {
      i.removeAttribute(J);
    }), h.removeClass(this._element, this._classes.initialized), this._element.removeAttribute(Cl), t.removeChild(this._wrapper);
  }
  setValue(t) {
    this.options.filter((i) => i.selected).forEach((i) => i.nativeOption.selected = !1), Array.isArray(t) ? t.forEach((i) => {
      this._selectByValue(i);
    }) : this._selectByValue(t), this._updateSelections(), this._emitValueChangeEvent(this.value);
  }
  _selectByValue(t) {
    const e = this.options.find(
      (i) => i.value === t
    );
    return e ? (e.nativeOption.selected = !0, !0) : !1;
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, yi);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new kr(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, yi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Hb = ({ inputID: s, labelText: t }, e) => `<div data-te-chips-input-wrapper data-te-input-wrapper-init class="${e.chipsInputWrapper}">
      <input
          type="text"
          class="${e.chipsInput}"
          id="${s}"
          placeholder="Example label" />
        <label
          for="${s}"
          class="${e.chipsLabel}"
          >${t}
        </label>
      </div>
    </div>`, Vb = ({ text: s, iconSVG: t }, e) => `<div data-te-chip-init data-te-ripple-init class="${e.chipElement}">
    <span data-te-chip-text>${s}</span> 
      <span data-te-chip-close class="${e.chipCloseIcon}">
        ${t}
      </span>
  </div>`, en = "chip", Wb = `te.${en}`, Oh = "data-te-chip-close", vo = `[${Oh}]`, Fb = "delete.te.chips", Yb = "select.te.chip", jb = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3 h-3"> <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>', Kb = {
  text: "string",
  closeIcon: "boolean",
  img: "object",
  iconSVG: "string"
}, zb = {
  text: "",
  closeIcon: !1,
  img: { path: "", alt: "" },
  iconSVG: jb
}, Ub = {
  icon: "float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:text-[#8b8b8b] transition-all duration-200 ease-in-out",
  chipElement: "flex justify-between items-center h-[32px] leading-loose py-[5px] px-[12px] mr-4 my-[5px] text-[13px] font-normal text-[#4f4f4f] cursor-pointer bg-[#eceff1] dark:text-white dark:bg-neutral-600 rounded-[16px] transition-[opacity] duration-300 ease-linear [word-wrap: break-word] shadow-none normal-case hover:!shadow-none active:bg-[#cacfd1] inline-block font-medium leading-normal text-[#4f4f4f] text-center no-underline align-middle cursor-pointer select-none border-[.125rem] border-solid border-transparent py-1.5 px-3 text-xs rounded",
  chipCloseIcon: "w-4 float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:fill-[#8b8b8b] dark:fill-gray-400 dark:hover:fill-gray-100 transition-all duration-200 ease-in-out"
}, Xb = {
  icon: "string",
  chipElement: "string",
  chipCloseIcon: "string"
};
class vi {
  constructor(t, e = {}, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i);
  }
  // Getters
  static get NAME() {
    return en;
  }
  // Public
  init() {
    this._appendCloseIcon(), this._handleDelete(), this._handleTextChip(), this._handleClickOnChip();
  }
  dispose() {
    this._element = null, this._options = null, c.off(this._element, "click");
  }
  appendChip() {
    const { text: t, closeIcon: e, iconSVG: i } = this._options;
    return Vb({ text: t, closeIcon: e, iconSVG: i }, this._classes);
  }
  // Private
  _appendCloseIcon(t = this._element) {
    if (!(d.find(vo, this._element).length > 0) && this._options.closeIcon) {
      const e = $("span");
      e.classList = this._classes.icon, e.setAttribute(Oh), e.innerHTML = this._options.iconSVG, t.insertAdjacentElement("beforeend", e);
    }
  }
  _handleClickOnChip() {
    c.on(this._element, "click", (t) => {
      const { textContent: e } = t.target, i = {};
      i.tag = e.trim(), c.trigger(Yb, { event: t, obj: i });
    });
  }
  _handleDelete() {
    d.find(
      vo,
      this._element
    ).length !== 0 && c.on(this._element, "click", vo, () => {
      c.trigger(this._element, Fb), this._element.remove();
    });
  }
  _handleTextChip() {
    this._element.innerText === "" && (this._element.innerText = this._options.text);
  }
  _getConfig(t) {
    const e = {
      ...zb,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(en, e, Kb), e;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...Ub,
      ...e,
      ...t
    }, I(en, t, Xb), t;
  }
  static getInstance(t) {
    return A.getData(t, Wb);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Hi = "chips", Gi = `data-te-${Hi}`, xl = `te.${Hi}`, Gb = `${Gi}-input-init`, bt = `${Gi}-active`, Ol = `${Gi}-initial`, Sh = `${Gi}-placeholder`, qb = `${Gi}-input-wrapper`, Jo = "data-te-chip-init", Ih = "data-te-chip-close", Dh = "data-te-chip-text", Zb = `[${bt}]`, tr = `[${Jo}]`, Qb = `${tr}${Zb}`, To = `[${Ih}]`, Jb = `[${qb}]`, tv = `[${Dh}]`, ev = `[${Sh}]`, iv = "data-te-input-notch-leading-ref", sv = "data-te-input-notch-middle-ref", nv = `[${iv}]`, ov = `[${sv}]`, Ne = "data-te-input-state-active", Eo = "[data-te-input-notch-ref]", rv = "add.te.chips", av = "arrowDown.te.chips", lv = "arrowLeft.te.chips", cv = "arrowRight.te.chips", hv = "arrowUp.te.chips", Sl = "delete.te.chips", Il = "select.te.chips", dv = {
  inputID: "string",
  parentSelector: "string",
  initialValues: "array",
  editable: "boolean",
  labelText: "string",
  inputClasses: "object",
  inputOptions: "object"
}, uv = {
  inputID: et("chips-input-"),
  parentSelector: "",
  initialValues: [{ tag: "init1" }, { tag: "init2" }],
  editable: !1,
  labelText: "Example label",
  inputClasses: {},
  inputOptions: {}
}, pv = {
  opacity: "opacity-0",
  inputWrapperPadding: "p-[5px]",
  transition: "transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  contentEditable: "outline-none !border-[3px] !border-solid !border-[#b2b3b4]",
  chipsInputWrapper: "relative flex items-center flex-wrap transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]",
  chipsInput: "peer block min-h-[auto] w-[150px] rounded border-0 bg-transparent py-[0.32rem] px-3 leading-[1.6] outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0",
  chipsLabel: "pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate pt-[0.37rem] leading-[1.6] text-gray-500 transition-all duration-200 ease-out peer-focus:-translate-y-[0.9rem] peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:-translate-y-[0.9rem] peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200"
}, _v = {
  opacity: "string",
  inputWrapperPadding: "string",
  transition: "string",
  contentEditable: "string",
  chipsInputWrapper: "string",
  chipsInput: "string",
  chipsLabel: "string"
};
class XA extends vi {
  constructor(e, i = {}, n) {
    super(e, i);
    wt(this, "_handleBlurInput", ({ target: e }) => {
      e.value.length > 0 && this._handleCreateChip(e, e.value), this.allChips.length > 0 ? (e.setAttribute(bt, ""), this.input.setAttribute(Ne, ""), d.findOne(
        Eo,
        this.input.parentNode
      ).setAttribute(Ne, ""), this.chipsInputWrapper.classList.add(
        ...this._classes.inputWrapperPadding.split(" ")
      )) : (e.removeAttribute(bt), this.input.removeAttribute(Ne), d.findOne(
        Eo,
        this.input.parentNode
      ).removeAttribute(Ne), this.chipsInputWrapper.classList.remove(
        ...this._classes.inputWrapperPadding.split(" ")
      )), this.allChips.forEach((i) => i.removeAttribute(bt));
    });
    this._element = e, this._inputInstance = null, this._element && A.setData(e, xl, this), this._options = this._getConfig(i), this._classes = this._getClasses(n), this.numberClicks = 0, this.init();
  }
  // Getters
  static get NAME() {
    return Hi;
  }
  get activeChip() {
    return d.findOne(Qb, this._element);
  }
  get input() {
    return d.findOne("input", this._element);
  }
  get allChips() {
    return d.find(tr, this._element);
  }
  get chipsInputWrapper() {
    return d.findOne(Jb, this._element);
  }
  // Public
  init() {
    this._setChipsClass(), this._appendInputToElement(Sh), this._handleInitialValue(), this._handleInputText(), this._handleKeyboard(), this._handleChipsOnSelect(), this._handleEditable(), this._handleChipsFocus(), this._handleClicksOnChips(), this._inputInstance._getLabelWidth(), this._inputInstance._applyNotch();
  }
  dispose() {
    this._element = null, this._options = null;
  }
  // Private
  _getNotchData() {
    this._notchMiddle = d.findOne(
      ov,
      this._element
    ), this._notchLeading = d.findOne(
      nv,
      this._element
    );
  }
  _setChipsClass() {
    this._element.setAttribute(Gb, "");
  }
  _handleDeleteEvents(e) {
    const [i] = this.allChips.slice(-1);
    if (this.activeChip === null)
      i.remove(), this._handleEvents(e, Sl);
    else {
      const n = this.allChips.findIndex((a) => a === this.activeChip), o = this._handleActiveChipAfterRemove(n), r = [];
      if (this.activeChip === null)
        return;
      this.activeChip.remove(), this._handleEvents(e, Sl), this.numberClicks = n, o.setAttribute(bt, ""), this.allChips.forEach((a) => {
        a.hasAttribute(bt) && (r.push(a), r.length > 1 && this.allChips.forEach((l) => l.remove()));
      });
    }
  }
  _handleUpEvents(e) {
    this.numberClicks += 1, this.numberClicks === this.allChips.length + 1 && (this.numberClicks = 0), this._handleRightKeyboardArrow(this.numberClicks), this._handleEvents(e, cv), this._handleEvents(e, hv);
  }
  _handleDownEvents(e) {
    this.numberClicks -= 1, this.numberClicks <= 0 && (this.numberClicks = this.allChips.length), this._handleLeftKeyboardArrow(this.numberClicks), this._handleEvents(e, lv), this._handleEvents(e, av);
  }
  _keyboardEvents(e) {
    const { target: i, keyCode: n, ctrlKey: o } = e;
    i.value.length > 0 || this.allChips.length === 0 || (n === om || n === rm ? this._handleDeleteEvents(e) : n === ze || n === U ? this._handleUpEvents(e) : n === Ke || n === z ? this._handleDownEvents(e) : n === 65 && o && this._handleAddActiveClass());
  }
  _handleKeyboard() {
    c.on(
      this.input,
      "keydown",
      (e) => this._keyboardEvents(e)
    );
  }
  _handleEditable() {
    const { editable: e } = this._options;
    e && this.allChips.forEach((i) => {
      c.on(i, "dblclick", (n) => {
        const o = d.findOne(To, i);
        i.classList.add(...this._classes.contentEditable.split(" ")), i.contentEditable = !0, i.focus(), setTimeout(() => {
          h.addStyle(o, { display: "none" });
        }, 200), o.classList.add(...this._classes.opacity.split(" ")), n.target.textContent, c.trigger(i, Il, {
          event: n,
          allChips: this.allChips
        });
      }), c.on(document, "click", ({ target: n }) => {
        const o = d.findOne(To, i), r = d.findOne(tv, i), a = n === i, l = i && i.contains(n);
        !a && !l && (i.contentEditable = !1, i.classList.remove(...this._classes.contentEditable.split(" ")), r.textContent !== "" && setTimeout(() => {
          h.addStyle(o, { display: "block" }), o.classList.remove(...this._classes.opacity.split(" "));
        }, 160)), r.textContent === "" && (setTimeout(() => {
          i.classList.add(...this._classes.opacity.split(" "));
        }, 200), setTimeout(() => {
          i.remove();
        }, 300));
      });
    });
  }
  _handleRemoveActiveClass() {
    this.allChips.forEach((e) => e.removeAttribute(bt));
  }
  _handleAddActiveClass() {
    this.allChips.forEach((e) => e.setAttribute(bt, ""));
  }
  _handleRightKeyboardArrow(e) {
    this._handleRemoveActiveClass(), e === 0 && (e = 1), this._handleAddActiveClassWithKebyboard(e);
  }
  _handleLeftKeyboardArrow(e) {
    this._handleRemoveActiveClass(), this._handleAddActiveClassWithKebyboard(e);
  }
  _handleActiveChipAfterRemove(e) {
    const i = e === 0 ? 1 : e - 1;
    return this.allChips[i];
  }
  _handleClicksOnChips() {
    c.on(this._element, "click", () => {
      this.allChips.length === 0 && (this.chipsInputWrapper.classList.remove(
        ...this._classes.inputWrapperPadding.split(" ")
      ), this.input.removeAttribute(bt));
    });
  }
  _handleTextContent() {
    const e = [];
    return this.allChips.forEach((i) => e.push({ tag: i.textContent.trim() })), e;
  }
  _handleEvents(e, i) {
    const n = this._handleTextContent(), o = this.allChips.filter(
      (r) => r.hasAttribute(bt) && r
    );
    c.trigger(this._element, i, {
      event: e,
      allChips: this.allChips,
      arrOfObjects: n,
      active: o,
      activeObj: {
        tag: o.length <= 0 ? "" : o[0].textContent.trim()
      }
    });
  }
  _handleChipsFocus() {
    c.on(this._element, "click", ({ target: { attributes: e } }) => {
      const i = [...e].map((n) => n.name);
      i.includes(Jo) || i.includes(Ih) || i.includes(Dh) || this.input.focus();
    });
  }
  _handleInitialValue() {
    if (this._appendInputToElement(Ol), this._element.hasAttribute(Ol)) {
      const { initialValues: e } = this._options;
      e.forEach(
        ({ tag: i }) => this._handleCreateChip(this.input, i)
      ), d.findOne(
        Eo,
        this.input.parentNode
      ).setAttribute(Ne, ""), this.input.setAttribute(bt, ""), this.input.setAttribute(Ne, "");
    }
    this.allChips.length > 0 && (this.chipsInputWrapper.classList.add(
      ...this._classes.inputWrapperPadding.split(" ")
    ), this.chipsInputWrapper.classList.add(
      ...this._classes.transition.split(" ")
    ));
  }
  _handleKeysInputToElement(e) {
    const { keyCode: i, target: n } = e;
    if (n.hasAttribute(Jo)) {
      const o = d.findOne(To, n);
      i === it && (n.contentEditable = !1, n.classList.remove(...this._classes.contentEditable.split(" ")), n.textContent !== "" ? setTimeout(() => {
        h.addStyle(o, { display: "block" }), o.classList.remove(...this._classes.opacity.split(" "));
      }, 160) : n.textContent === "" && (setTimeout(() => {
        n.classList.add(...this._classes.opacity.split(" "));
      }, 200), setTimeout(() => {
        n.remove();
      }, 300)));
      return;
    }
    if (i === it) {
      if (n.value === "")
        return;
      this._handleCreateChip(n, n.value), this._handleRemoveActiveClass(), this.numberClicks = this.allChips.length + 1, this._handleEvents(e, rv);
    }
    this.allChips.length > 0 ? (this.chipsInputWrapper.classList.add(
      ...this._classes.inputWrapperPadding.split(" ")
    ), this.chipsInputWrapper.classList.add(
      ...this._classes.transition.split(" ")
    )) : this.chipsInputWrapper.classList.remove(
      ...this._classes.inputWrapperPadding.split(" ")
    );
  }
  _handleInputText() {
    const e = d.findOne(
      ev,
      this._element
    );
    c.on(
      this._element,
      "keyup",
      e,
      (i) => this._handleKeysInputToElement(i)
    ), c.on(this.input, "blur", (i) => this._handleBlurInput(i));
  }
  _appendInputToElement(e) {
    if (!this._element.hasAttribute(e))
      return;
    const i = Hb(this._options, this._classes);
    this._element.insertAdjacentHTML("beforeend", i);
    const n = d.findOne(
      "[data-te-chips-input-wrapper]",
      this._element
    );
    this._inputInstance = new V(
      n,
      this._options.inputOptions,
      this._options.inputClasses
    );
  }
  _handleCreateChip(e, i) {
    const n = $("div"), o = vi.getInstance(n), r = new vi(o, { text: i }, this._classes);
    this._options.parentSelector !== "" ? document.querySelector(this._options.parentSelector).insertAdjacentHTML("beforeend", r.appendChip()) : e.insertAdjacentHTML("beforebegin", r.appendChip()), e.value = "", d.find(tr).forEach((a) => {
      let l = vi.getInstance(a);
      return l || (l = new vi(a, {}, this._classes)), l.init();
    }), this._handleEditable();
  }
  _handleChipsOnSelect() {
    this.allChips.forEach((e) => {
      c.on(this._element, "click", (i) => {
        c.trigger(e, Il, {
          event: i,
          allChips: this.allChips
        });
      });
    });
  }
  _handleAddActiveClassWithKebyboard(e) {
    let i;
    this.allChips[e - 1] === void 0 ? i = this.allChips[e - 2] : i = this.allChips[e - 1], i.setAttribute(bt);
  }
  _getConfig(e) {
    const i = {
      ...uv,
      ...h.getDataAttributes(this._element),
      ...e
    };
    return I(Hi, i, dv), i;
  }
  _getClasses(e) {
    const i = h.getDataClassAttributes(this._element);
    return e = {
      ...pv,
      ...i,
      ...e
    }, I(Hi, e, _v), e;
  }
  static getInstance(e) {
    return A.getData(e, xl);
  }
  static getOrCreateInstance(e, i = {}) {
    return this.getInstance(e) || new this(e, typeof i == "object" ? i : null);
  }
}
const Ut = {
  plugins: {
    legend: {
      labels: {
        color: "rgb(102,102,102)"
      }
    }
  }
}, wi = {
  line: {
    options: {
      ...Ut,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.0)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bar: {
    options: {
      ...Ut,
      backgroundColor: "rgb(59, 112, 202)",
      borderWidth: 0,
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !0,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  pie: {
    options: {
      ...Ut,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  doughnut: {
    options: {
      ...Ut,
      elements: {
        arc: { backgroundColor: "rgb(59, 112, 202)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  polarArea: {
    options: {
      ...Ut,
      elements: {
        arc: { backgroundColor: "rgba(59, 112, 202, 0.5)" }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  radar: {
    options: {
      ...Ut,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgb(59, 112, 202)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      }
    }
  },
  scatter: {
    options: {
      ...Ut,
      elements: {
        line: {
          backgroundColor: "rgba(59, 112, 202, 0.5)",
          borderColor: "rgb(59, 112, 202)",
          borderWidth: 2,
          tension: 0
        },
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      tooltips: {
        intersect: !1,
        mode: "index"
      },
      datasets: {
        borderColor: "red"
      },
      scales: {
        x: {
          stacked: !0,
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          stacked: !1,
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  },
  bubble: {
    options: {
      ...Ut,
      elements: {
        point: {
          borderColor: "rgb(59, 112, 202)",
          backgroundColor: "rgba(59, 112, 202, 0.5)"
        }
      },
      responsive: !0,
      legend: {
        display: !0
      },
      scales: {
        x: {
          grid: {
            display: !1
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        },
        y: {
          grid: {
            borderDash: [2],
            drawBorder: !1,
            zeroLineColor: "rgba(0,0,0,0)",
            zeroLineBorderDash: [2],
            zeroLineBorderDashOffset: [2]
          },
          ticks: {
            fontColor: "rgba(0,0,0, 0.5)"
          }
        }
      }
    }
  }
};
var fv = function(t) {
  return mv(t) && !gv(t);
};
function mv(s) {
  return !!s && typeof s == "object";
}
function gv(s) {
  var t = Object.prototype.toString.call(s);
  return t === "[object RegExp]" || t === "[object Date]" || Tv(s);
}
var bv = typeof Symbol == "function" && Symbol.for, vv = bv ? Symbol.for("react.element") : 60103;
function Tv(s) {
  return s.$$typeof === vv;
}
function Ev(s) {
  return Array.isArray(s) ? [] : {};
}
function Yi(s, t) {
  return t.clone !== !1 && t.isMergeableObject(s) ? ii(Ev(s), s, t) : s;
}
function Cv(s, t, e) {
  return s.concat(t).map(function(i) {
    return Yi(i, e);
  });
}
function Av(s, t) {
  if (!t.customMerge)
    return ii;
  var e = t.customMerge(s);
  return typeof e == "function" ? e : ii;
}
function yv(s) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(s).filter(function(t) {
    return Object.propertyIsEnumerable.call(s, t);
  }) : [];
}
function Dl(s) {
  return Object.keys(s).concat(yv(s));
}
function $h(s, t) {
  try {
    return t in s;
  } catch {
    return !1;
  }
}
function wv(s, t) {
  return $h(s, t) && !(Object.hasOwnProperty.call(s, t) && Object.propertyIsEnumerable.call(s, t));
}
function kv(s, t, e) {
  var i = {};
  return e.isMergeableObject(s) && Dl(s).forEach(function(n) {
    i[n] = Yi(s[n], e);
  }), Dl(t).forEach(function(n) {
    wv(s, n) || ($h(s, n) && e.isMergeableObject(t[n]) ? i[n] = Av(n, e)(s[n], t[n], e) : i[n] = Yi(t[n], e));
  }), i;
}
function ii(s, t, e) {
  e = e || {}, e.arrayMerge = e.arrayMerge || Cv, e.isMergeableObject = e.isMergeableObject || fv, e.cloneUnlessOtherwiseSpecified = Yi;
  var i = Array.isArray(t), n = Array.isArray(s), o = i === n;
  return o ? i ? e.arrayMerge(s, t, e) : kv(s, t, e) : Yi(t, e);
}
ii.all = function(t, e) {
  if (!Array.isArray(t))
    throw new Error("first argument should be an array");
  return t.reduce(function(i, n) {
    return ii(i, n, e);
  }, {});
};
var xv = ii, er = xv;
const $l = "chart", Ss = "te.chart", Ov = "chart", Co = (s, t, e) => {
  const i = (n, o, r) => {
    const a = n.slice();
    return o.forEach((l, p) => {
      typeof a[p] > "u" ? a[p] = r.cloneUnlessOtherwiseSpecified(
        l,
        r
      ) : r.isMergeableObject(l) ? a[p] = er(n[p], l, r) : n.indexOf(l) === -1 && a.push(l);
    }), a;
  };
  return er(e[t], s, {
    arrayMerge: i
  });
}, Sv = {
  darkTicksColor: "#fff",
  darkLabelColor: "#fff",
  darkGridLinesColor: "#555",
  darkmodeOff: "undefined",
  darkMode: null,
  darkBgColor: "#262626",
  darkBgColorLight: "#fff",
  options: null
}, Iv = {
  darkTicksColor: "string",
  darkLabelColor: "string",
  darkGridLinesColor: "string",
  darkmodeOff: "(string|null)",
  darkMode: "(string|null)",
  darkBgColor: "string",
  darkBgColorLight: "string",
  options: "(object|null)"
};
class Lh {
  constructor(t, e, i = {}, n = {}) {
    this._waitForCharts(t, e, i, n);
  }
  async _getChartjs() {
    const {
      Chart: t,
      ArcElement: e,
      LineElement: i,
      BarElement: n,
      PointElement: o,
      BarController: r,
      BubbleController: a,
      DoughnutController: l,
      LineController: p,
      PieController: u,
      PolarAreaController: _,
      RadarController: f,
      ScatterController: g,
      CategoryScale: m,
      LinearScale: b,
      LogarithmicScale: v,
      RadialLinearScale: T,
      TimeScale: y,
      TimeSeriesScale: C,
      Decimation: E,
      Filler: w,
      Legend: k,
      Title: D,
      Tooltip: O,
      SubTitle: x
    } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_tw-elements_dist_js_chart_es_js").then(__webpack_require__.bind(__webpack_require__, /*! ./chart.es.js */ "./node_modules/tw-elements/dist/js/chart.es.js")).then((L) => L.f);
    return t.register(
      e,
      i,
      n,
      o,
      r,
      a,
      l,
      p,
      u,
      _,
      f,
      g,
      m,
      b,
      v,
      T,
      y,
      C,
      E,
      w,
      k,
      D,
      O,
      x
    ), t;
  }
  async _getChartDataLabels() {
    return await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_tw-elements_dist_js_chart_es_js"), __webpack_require__.e("vendors-node_modules_tw-elements_dist_js_chartjs-plugin-datalabels_es_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./chartjs-plugin-datalabels.es.js */ "./node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js"));
  }
  async _waitForCharts(t, e, i = {}, n = {}) {
    if (this._Chartjs = await this._getChartjs(), this._ChartDataLabels = await this._getChartDataLabels(), this._element = t, this._data = e, this._options = i, this._type = e.type, this._canvas = null, this._chart = null, this._darkOptions = this._getDarkConfig(n), this._darkModeClassContainer = document.querySelector("html"), this._prevConfig = null, this._observer = null, this._element && (A.setData(t, Ss, this), h.addClass(this._element, Ov), this._chartConstructor()), this._darkOptions.darkmodeOff !== null) {
      const o = this._darkOptions.darkMode === "dark" ? "dark" : this._darkOptions.darkMode === "light" ? "light" : this.systemColorMode;
      this._handleMode(o), this._observer = new MutationObserver(this._observerCallback.bind(this)), this._observer.observe(this._darkModeClassContainer, {
        attributes: !0
      });
    }
  }
  // Getters
  static get NAME() {
    return $l;
  }
  get systemColorMode() {
    return localStorage.theme || (this._darkModeClassContainer.classList.contains("dark") ? "dark" : "light");
  }
  // Public
  dispose() {
    this._observer.disconnect(), A.removeData(this._element, Ss), this._element = null;
  }
  update(t, e) {
    t && (this._data = { ...this._data, ...t }, this._chart.data = this._data);
    const i = Object.prototype.hasOwnProperty.call(
      e,
      "options"
    ) ? e : { options: { ...e } };
    this._options = er(this._options, i), this._chart.options = Co(
      this._options,
      this._type,
      wi
    ).options, this._chart.update();
  }
  setTheme(t) {
    t !== "dark" && t !== "light" || !this._data || this._handleMode(t);
  }
  // Private
  _getDarkConfig(t) {
    let e = {};
    const i = h.getDataAttributes(this._element);
    Object.keys(i).forEach(
      (p) => p.startsWith("dark") && (e[p] = i[p])
    ), e = {
      ...Sv,
      ...e
    };
    const n = {
      y: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      },
      x: {
        ticks: {
          color: e.darkTicksColor
        },
        grid: {
          color: e.darkGridLinesColor
        }
      }
    }, o = {
      r: {
        ticks: {
          color: e.darkTicksColor,
          backdropColor: e.darkBgColor
        },
        grid: {
          color: e.darkGridLinesColor
        },
        pointLabels: {
          color: e.darkTicksColor
        }
      }
    }, l = {
      scales: ["pie", "doughnut", "polarArea", "radar"].includes(this._type) ? ["polarArea", "radar"].includes(this._type) ? o : {} : n,
      plugins: {
        legend: {
          labels: {
            color: e.darkLabelColor
          }
        }
      }
    };
    return t = {
      ...e,
      options: {
        ...l
      },
      ...t
    }, I($l, t, Iv), t;
  }
  _chartConstructor() {
    if (this._data) {
      this._createCanvas();
      const t = Co(this._options, this._type, wi), e = [];
      t.dataLabelsPlugin && e.push(this._ChartDataLabels.default), this._prevConfig = t, this._chart = new this._Chartjs(this._canvas, {
        ...this._data,
        ...t,
        plugins: e
      });
    }
  }
  _createCanvas() {
    this._canvas || (this._element.nodeName === "CANVAS" ? this._canvas = this._element : (this._canvas = $("canvas"), this._element.appendChild(this._canvas)));
  }
  _handleMode(t) {
    t === "dark" ? (this._changeDatasetBorderColor(), this.update(null, this._darkOptions.options)) : (this._changeDatasetBorderColor(!1), this._prevConfig && this.update(null, this._prevConfig));
  }
  _observerCallback(t) {
    for (const e of t)
      e.type === "attributes" && this._handleMode(this.systemColorMode);
  }
  _changeDatasetBorderColor(t = !0) {
    [...this._data.data.datasets].forEach(
      (e) => ["pie", "doughnut", "polarArea"].includes(this._type) && (e.borderColor = t ? this._darkOptions.darkBgColor : this._darkOptions.darkBgColorLight)
    );
  }
  static jQueryInterface(t, e, i) {
    return this.each(function() {
      let n = A.getData(this, Ss);
      if (!(!n && /dispose/.test(t))) {
        if (!n) {
          const o = e ? Co(e, i, wi) : wi[i];
          n = new Lh(this, {
            ...t,
            ...o
          });
        }
        if (typeof t == "string") {
          if (typeof n[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          n[t](e, i);
        }
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, Ss);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function Nt(s) {
  return getComputedStyle(s);
}
function ct(s, t) {
  for (var e in t) {
    var i = t[e];
    typeof i == "number" && (i = i + "px"), s.style[e] = i;
  }
  return s;
}
function Is(s) {
  var t = document.createElement("div");
  return t.className = s, t;
}
var Ll = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function Jt(s, t) {
  if (!Ll)
    throw new Error("No element matching method supported");
  return Ll.call(s, t);
}
function Ye(s) {
  s.remove ? s.remove() : s.parentNode && s.parentNode.removeChild(s);
}
function Nl(s, t) {
  return Array.prototype.filter.call(
    s.children,
    function(e) {
      return Jt(e, t);
    }
  );
}
var j = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(s) {
      return "ps__thumb-" + s;
    },
    rail: function(s) {
      return "ps__rail-" + s;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(s) {
      return "ps--active-" + s;
    },
    scrolling: function(s) {
      return "ps--scrolling-" + s;
    }
  }
}, Nh = { x: null, y: null };
function Mh(s, t) {
  var e = s.element.classList, i = j.state.scrolling(t);
  e.contains(i) ? clearTimeout(Nh[t]) : e.add(i);
}
function Rh(s, t) {
  Nh[t] = setTimeout(
    function() {
      return s.isAlive && s.element.classList.remove(j.state.scrolling(t));
    },
    s.settings.scrollingThreshold
  );
}
function Dv(s, t) {
  Mh(s, t), Rh(s, t);
}
var qi = function(t) {
  this.element = t, this.handlers = {};
}, Ph = { isEmpty: { configurable: !0 } };
qi.prototype.bind = function(t, e) {
  typeof this.handlers[t] > "u" && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1);
};
qi.prototype.unbind = function(t, e) {
  var i = this;
  this.handlers[t] = this.handlers[t].filter(function(n) {
    return e && n !== e ? !0 : (i.element.removeEventListener(t, n, !1), !1);
  });
};
qi.prototype.unbindAll = function() {
  for (var t in this.handlers)
    this.unbind(t);
};
Ph.isEmpty.get = function() {
  var s = this;
  return Object.keys(this.handlers).every(
    function(t) {
      return s.handlers[t].length === 0;
    }
  );
};
Object.defineProperties(qi.prototype, Ph);
var li = function() {
  this.eventElements = [];
};
li.prototype.eventElement = function(t) {
  var e = this.eventElements.filter(function(i) {
    return i.element === t;
  })[0];
  return e || (e = new qi(t), this.eventElements.push(e)), e;
};
li.prototype.bind = function(t, e, i) {
  this.eventElement(t).bind(e, i);
};
li.prototype.unbind = function(t, e, i) {
  var n = this.eventElement(t);
  n.unbind(e, i), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1);
};
li.prototype.unbindAll = function() {
  this.eventElements.forEach(function(t) {
    return t.unbindAll();
  }), this.eventElements = [];
};
li.prototype.once = function(t, e, i) {
  var n = this.eventElement(t), o = function(r) {
    n.unbind(e, o), i(r);
  };
  n.bind(e, o);
};
function Ds(s) {
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(s);
  var t = document.createEvent("CustomEvent");
  return t.initCustomEvent(s, !1, !1, void 0), t;
}
function fn(s, t, e, i, n) {
  i === void 0 && (i = !0), n === void 0 && (n = !1);
  var o;
  if (t === "top")
    o = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  else if (t === "left")
    o = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  else
    throw new Error("A proper axis should be provided");
  $v(s, e, o, i, n);
}
function $v(s, t, e, i, n) {
  var o = e[0], r = e[1], a = e[2], l = e[3], p = e[4], u = e[5];
  i === void 0 && (i = !0), n === void 0 && (n = !1);
  var _ = s.element;
  s.reach[l] = null, _[a] < 1 && (s.reach[l] = "start"), _[a] > s[o] - s[r] - 1 && (s.reach[l] = "end"), t && (_.dispatchEvent(Ds("ps-scroll-" + l)), t < 0 ? _.dispatchEvent(Ds("ps-scroll-" + p)) : t > 0 && _.dispatchEvent(Ds("ps-scroll-" + u)), i && Dv(s, l)), s.reach[l] && (t || n) && _.dispatchEvent(Ds("ps-" + l + "-reach-" + s.reach[l]));
}
function F(s) {
  return parseInt(s, 10) || 0;
}
function Lv(s) {
  return Jt(s, "input,[contenteditable]") || Jt(s, "select,[contenteditable]") || Jt(s, "textarea,[contenteditable]") || Jt(s, "button,[contenteditable]");
}
function Nv(s) {
  var t = Nt(s);
  return F(t.width) + F(t.paddingLeft) + F(t.paddingRight) + F(t.borderLeftWidth) + F(t.borderRightWidth);
}
var Ve = {
  isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
};
function Ht(s) {
  var t = s.element, e = Math.floor(t.scrollTop), i = t.getBoundingClientRect();
  s.containerWidth = Math.round(i.width), s.containerHeight = Math.round(i.height), s.contentWidth = t.scrollWidth, s.contentHeight = t.scrollHeight, t.contains(s.scrollbarXRail) || (Nl(t, j.element.rail("x")).forEach(
    function(n) {
      return Ye(n);
    }
  ), t.appendChild(s.scrollbarXRail)), t.contains(s.scrollbarYRail) || (Nl(t, j.element.rail("y")).forEach(
    function(n) {
      return Ye(n);
    }
  ), t.appendChild(s.scrollbarYRail)), !s.settings.suppressScrollX && s.containerWidth + s.settings.scrollXMarginOffset < s.contentWidth ? (s.scrollbarXActive = !0, s.railXWidth = s.containerWidth - s.railXMarginWidth, s.railXRatio = s.containerWidth / s.railXWidth, s.scrollbarXWidth = Ml(
    s,
    F(s.railXWidth * s.containerWidth / s.contentWidth)
  ), s.scrollbarXLeft = F(
    (s.negativeScrollAdjustment + t.scrollLeft) * (s.railXWidth - s.scrollbarXWidth) / (s.contentWidth - s.containerWidth)
  )) : s.scrollbarXActive = !1, !s.settings.suppressScrollY && s.containerHeight + s.settings.scrollYMarginOffset < s.contentHeight ? (s.scrollbarYActive = !0, s.railYHeight = s.containerHeight - s.railYMarginHeight, s.railYRatio = s.containerHeight / s.railYHeight, s.scrollbarYHeight = Ml(
    s,
    F(s.railYHeight * s.containerHeight / s.contentHeight)
  ), s.scrollbarYTop = F(
    e * (s.railYHeight - s.scrollbarYHeight) / (s.contentHeight - s.containerHeight)
  )) : s.scrollbarYActive = !1, s.scrollbarXLeft >= s.railXWidth - s.scrollbarXWidth && (s.scrollbarXLeft = s.railXWidth - s.scrollbarXWidth), s.scrollbarYTop >= s.railYHeight - s.scrollbarYHeight && (s.scrollbarYTop = s.railYHeight - s.scrollbarYHeight), Mv(t, s), s.scrollbarXActive ? t.classList.add(j.state.active("x")) : (t.classList.remove(j.state.active("x")), s.scrollbarXWidth = 0, s.scrollbarXLeft = 0, t.scrollLeft = s.isRtl === !0 ? s.contentWidth : 0), s.scrollbarYActive ? t.classList.add(j.state.active("y")) : (t.classList.remove(j.state.active("y")), s.scrollbarYHeight = 0, s.scrollbarYTop = 0, t.scrollTop = 0);
}
function Ml(s, t) {
  return s.settings.minScrollbarLength && (t = Math.max(t, s.settings.minScrollbarLength)), s.settings.maxScrollbarLength && (t = Math.min(t, s.settings.maxScrollbarLength)), t;
}
function Mv(s, t) {
  var e = { width: t.railXWidth }, i = Math.floor(s.scrollTop);
  t.isRtl ? e.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth - t.contentWidth : e.left = s.scrollLeft, t.isScrollbarXUsingBottom ? e.bottom = t.scrollbarXBottom - i : e.top = t.scrollbarXTop + i, ct(t.scrollbarXRail, e);
  var n = { top: i, height: t.railYHeight };
  t.isScrollbarYUsingRight ? t.isRtl ? n.right = t.contentWidth - (t.negativeScrollAdjustment + s.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : n.right = t.scrollbarYRight - s.scrollLeft : t.isRtl ? n.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : n.left = t.scrollbarYLeft + s.scrollLeft, ct(t.scrollbarYRail, n), ct(t.scrollbarX, {
    left: t.scrollbarXLeft,
    width: t.scrollbarXWidth - t.railBorderXWidth
  }), ct(t.scrollbarY, {
    top: t.scrollbarYTop,
    height: t.scrollbarYHeight - t.railBorderYWidth
  });
}
function Rv(s) {
  s.element, s.event.bind(s.scrollbarY, "mousedown", function(t) {
    return t.stopPropagation();
  }), s.event.bind(s.scrollbarYRail, "mousedown", function(t) {
    var e = t.pageY - window.pageYOffset - s.scrollbarYRail.getBoundingClientRect().top, i = e > s.scrollbarYTop ? 1 : -1;
    s.element.scrollTop += i * s.containerHeight, Ht(s), t.stopPropagation();
  }), s.event.bind(s.scrollbarX, "mousedown", function(t) {
    return t.stopPropagation();
  }), s.event.bind(s.scrollbarXRail, "mousedown", function(t) {
    var e = t.pageX - window.pageXOffset - s.scrollbarXRail.getBoundingClientRect().left, i = e > s.scrollbarXLeft ? 1 : -1;
    s.element.scrollLeft += i * s.containerWidth, Ht(s), t.stopPropagation();
  });
}
function Pv(s) {
  Rl(s, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]), Rl(s, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function Rl(s, t) {
  var e = t[0], i = t[1], n = t[2], o = t[3], r = t[4], a = t[5], l = t[6], p = t[7], u = t[8], _ = s.element, f = null, g = null, m = null;
  function b(y) {
    y.touches && y.touches[0] && (y[n] = y.touches[0].pageY), _[l] = f + m * (y[n] - g), Mh(s, p), Ht(s), y.stopPropagation(), y.type.startsWith("touch") && y.changedTouches.length > 1 && y.preventDefault();
  }
  function v() {
    Rh(s, p), s[u].classList.remove(j.state.clicking), s.event.unbind(s.ownerDocument, "mousemove", b);
  }
  function T(y, C) {
    f = _[l], C && y.touches && (y[n] = y.touches[0].pageY), g = y[n], m = (s[i] - s[e]) / (s[o] - s[a]), C ? s.event.bind(s.ownerDocument, "touchmove", b) : (s.event.bind(s.ownerDocument, "mousemove", b), s.event.once(s.ownerDocument, "mouseup", v), y.preventDefault()), s[u].classList.add(j.state.clicking), y.stopPropagation();
  }
  s.event.bind(s[r], "mousedown", function(y) {
    T(y);
  }), s.event.bind(s[r], "touchstart", function(y) {
    T(y, !0);
  });
}
function Bv(s) {
  var t = s.element, e = function() {
    return Jt(t, ":hover");
  }, i = function() {
    return Jt(s.scrollbarX, ":focus") || Jt(s.scrollbarY, ":focus");
  };
  function n(o, r) {
    var a = Math.floor(t.scrollTop);
    if (o === 0) {
      if (!s.scrollbarYActive)
        return !1;
      if (a === 0 && r > 0 || a >= s.contentHeight - s.containerHeight && r < 0)
        return !s.settings.wheelPropagation;
    }
    var l = t.scrollLeft;
    if (r === 0) {
      if (!s.scrollbarXActive)
        return !1;
      if (l === 0 && o < 0 || l >= s.contentWidth - s.containerWidth && o > 0)
        return !s.settings.wheelPropagation;
    }
    return !0;
  }
  s.event.bind(s.ownerDocument, "keydown", function(o) {
    if (!(o.isDefaultPrevented && o.isDefaultPrevented() || o.defaultPrevented) && !(!e() && !i())) {
      var r = document.activeElement ? document.activeElement : s.ownerDocument.activeElement;
      if (r) {
        if (r.tagName === "IFRAME")
          r = r.contentDocument.activeElement;
        else
          for (; r.shadowRoot; )
            r = r.shadowRoot.activeElement;
        if (Lv(r))
          return;
      }
      var a = 0, l = 0;
      switch (o.which) {
        case 37:
          o.metaKey ? a = -s.contentWidth : o.altKey ? a = -s.containerWidth : a = -30;
          break;
        case 38:
          o.metaKey ? l = s.contentHeight : o.altKey ? l = s.containerHeight : l = 30;
          break;
        case 39:
          o.metaKey ? a = s.contentWidth : o.altKey ? a = s.containerWidth : a = 30;
          break;
        case 40:
          o.metaKey ? l = -s.contentHeight : o.altKey ? l = -s.containerHeight : l = -30;
          break;
        case 32:
          o.shiftKey ? l = s.containerHeight : l = -s.containerHeight;
          break;
        case 33:
          l = s.containerHeight;
          break;
        case 34:
          l = -s.containerHeight;
          break;
        case 36:
          l = s.contentHeight;
          break;
        case 35:
          l = -s.contentHeight;
          break;
        default:
          return;
      }
      s.settings.suppressScrollX && a !== 0 || s.settings.suppressScrollY && l !== 0 || (t.scrollTop -= l, t.scrollLeft += a, Ht(s), n(a, l) && o.preventDefault());
    }
  });
}
function Hv(s) {
  var t = s.element;
  function e(r, a) {
    var l = Math.floor(t.scrollTop), p = t.scrollTop === 0, u = l + t.offsetHeight === t.scrollHeight, _ = t.scrollLeft === 0, f = t.scrollLeft + t.offsetWidth === t.scrollWidth, g;
    return Math.abs(a) > Math.abs(r) ? g = p || u : g = _ || f, g ? !s.settings.wheelPropagation : !0;
  }
  function i(r) {
    var a = r.deltaX, l = -1 * r.deltaY;
    return (typeof a > "u" || typeof l > "u") && (a = -1 * r.wheelDeltaX / 6, l = r.wheelDeltaY / 6), r.deltaMode && r.deltaMode === 1 && (a *= 10, l *= 10), a !== a && l !== l && (a = 0, l = r.wheelDelta), r.shiftKey ? [-l, -a] : [a, l];
  }
  function n(r, a, l) {
    if (!Ve.isWebKit && t.querySelector("select:focus"))
      return !0;
    if (!t.contains(r))
      return !1;
    for (var p = r; p && p !== t; ) {
      if (p.classList.contains(j.element.consuming))
        return !0;
      var u = Nt(p);
      if (l && u.overflowY.match(/(scroll|auto)/)) {
        var _ = p.scrollHeight - p.clientHeight;
        if (_ > 0 && (p.scrollTop > 0 && l < 0 || p.scrollTop < _ && l > 0))
          return !0;
      }
      if (a && u.overflowX.match(/(scroll|auto)/)) {
        var f = p.scrollWidth - p.clientWidth;
        if (f > 0 && (p.scrollLeft > 0 && a < 0 || p.scrollLeft < f && a > 0))
          return !0;
      }
      p = p.parentNode;
    }
    return !1;
  }
  function o(r) {
    var a = i(r), l = a[0], p = a[1];
    if (!n(r.target, l, p)) {
      var u = !1;
      s.settings.useBothWheelAxes ? s.scrollbarYActive && !s.scrollbarXActive ? (p ? t.scrollTop -= p * s.settings.wheelSpeed : t.scrollTop += l * s.settings.wheelSpeed, u = !0) : s.scrollbarXActive && !s.scrollbarYActive && (l ? t.scrollLeft += l * s.settings.wheelSpeed : t.scrollLeft -= p * s.settings.wheelSpeed, u = !0) : (t.scrollTop -= p * s.settings.wheelSpeed, t.scrollLeft += l * s.settings.wheelSpeed), Ht(s), u = u || e(l, p), u && !r.ctrlKey && (r.stopPropagation(), r.preventDefault());
    }
  }
  typeof window.onwheel < "u" ? s.event.bind(t, "wheel", o) : typeof window.onmousewheel < "u" && s.event.bind(t, "mousewheel", o);
}
function Vv(s) {
  if (!Ve.supportsTouch && !Ve.supportsIePointer)
    return;
  var t = s.element;
  function e(m, b) {
    var v = Math.floor(t.scrollTop), T = t.scrollLeft, y = Math.abs(m), C = Math.abs(b);
    if (C > y) {
      if (b < 0 && v === s.contentHeight - s.containerHeight || b > 0 && v === 0)
        return window.scrollY === 0 && b > 0 && Ve.isChrome;
    } else if (y > C && (m < 0 && T === s.contentWidth - s.containerWidth || m > 0 && T === 0))
      return !0;
    return !0;
  }
  function i(m, b) {
    t.scrollTop -= b, t.scrollLeft -= m, Ht(s);
  }
  var n = {}, o = 0, r = {}, a = null;
  function l(m) {
    return m.targetTouches ? m.targetTouches[0] : m;
  }
  function p(m) {
    return m.pointerType && m.pointerType === "pen" && m.buttons === 0 ? !1 : !!(m.targetTouches && m.targetTouches.length === 1 || m.pointerType && m.pointerType !== "mouse" && m.pointerType !== m.MSPOINTER_TYPE_MOUSE);
  }
  function u(m) {
    if (p(m)) {
      var b = l(m);
      n.pageX = b.pageX, n.pageY = b.pageY, o = (/* @__PURE__ */ new Date()).getTime(), a !== null && clearInterval(a);
    }
  }
  function _(m, b, v) {
    if (!t.contains(m))
      return !1;
    for (var T = m; T && T !== t; ) {
      if (T.classList.contains(j.element.consuming))
        return !0;
      var y = Nt(T);
      if (v && y.overflowY.match(/(scroll|auto)/)) {
        var C = T.scrollHeight - T.clientHeight;
        if (C > 0 && (T.scrollTop > 0 && v < 0 || T.scrollTop < C && v > 0))
          return !0;
      }
      if (b && y.overflowX.match(/(scroll|auto)/)) {
        var E = T.scrollWidth - T.clientWidth;
        if (E > 0 && (T.scrollLeft > 0 && b < 0 || T.scrollLeft < E && b > 0))
          return !0;
      }
      T = T.parentNode;
    }
    return !1;
  }
  function f(m) {
    if (p(m)) {
      var b = l(m), v = { pageX: b.pageX, pageY: b.pageY }, T = v.pageX - n.pageX, y = v.pageY - n.pageY;
      if (_(m.target, T, y))
        return;
      i(T, y), n = v;
      var C = (/* @__PURE__ */ new Date()).getTime(), E = C - o;
      E > 0 && (r.x = T / E, r.y = y / E, o = C), e(T, y) && m.preventDefault();
    }
  }
  function g() {
    s.settings.swipeEasing && (clearInterval(a), a = setInterval(function() {
      if (s.isInitialized) {
        clearInterval(a);
        return;
      }
      if (!r.x && !r.y) {
        clearInterval(a);
        return;
      }
      if (Math.abs(r.x) < 0.01 && Math.abs(r.y) < 0.01) {
        clearInterval(a);
        return;
      }
      if (!s.element) {
        clearInterval(a);
        return;
      }
      i(r.x * 30, r.y * 30), r.x *= 0.8, r.y *= 0.8;
    }, 10));
  }
  Ve.supportsTouch ? (s.event.bind(t, "touchstart", u), s.event.bind(t, "touchmove", f), s.event.bind(t, "touchend", g)) : Ve.supportsIePointer && (window.PointerEvent ? (s.event.bind(t, "pointerdown", u), s.event.bind(t, "pointermove", f), s.event.bind(t, "pointerup", g)) : window.MSPointerEvent && (s.event.bind(t, "MSPointerDown", u), s.event.bind(t, "MSPointerMove", f), s.event.bind(t, "MSPointerUp", g)));
}
var Wv = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: !1,
    suppressScrollY: !1,
    swipeEasing: !0,
    useBothWheelAxes: !1,
    wheelPropagation: !0,
    wheelSpeed: 1
  };
}, Fv = {
  "click-rail": Rv,
  "drag-thumb": Pv,
  keyboard: Bv,
  wheel: Hv,
  touch: Vv
}, Zi = function(t, e) {
  var i = this;
  if (e === void 0 && (e = {}), typeof t == "string" && (t = document.querySelector(t)), !t || !t.nodeName)
    throw new Error("no element is specified to initialize PerfectScrollbar");
  this.element = t, t.classList.add(j.main), this.settings = Wv();
  for (var n in e)
    this.settings[n] = e[n];
  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
  var o = function() {
    return t.classList.add(j.state.focus);
  }, r = function() {
    return t.classList.remove(j.state.focus);
  };
  this.isRtl = Nt(t).direction === "rtl", this.isRtl === !0 && t.classList.add(j.rtl), this.isNegativeScroll = function() {
    var p = t.scrollLeft, u = null;
    return t.scrollLeft = -1, u = t.scrollLeft < 0, t.scrollLeft = p, u;
  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new li(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = Is(j.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = Is(j.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", o), this.event.bind(this.scrollbarX, "blur", r), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
  var a = Nt(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(a.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = F(a.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = F(a.borderLeftWidth) + F(a.borderRightWidth), ct(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = F(a.marginLeft) + F(a.marginRight), ct(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = Is(j.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = Is(j.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", o), this.event.bind(this.scrollbarY, "blur", r), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
  var l = Nt(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(l.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = F(l.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? Nv(this.scrollbarY) : null, this.railBorderYWidth = F(l.borderTopWidth) + F(l.borderBottomWidth), ct(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = F(l.marginTop) + F(l.marginBottom), ct(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
    x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  }, this.isAlive = !0, this.settings.handlers.forEach(function(p) {
    return Fv[p](i);
  }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", function(p) {
    return i.onScroll(p);
  }), Ht(this);
};
Zi.prototype.update = function() {
  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, ct(this.scrollbarXRail, { display: "block" }), ct(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = F(Nt(this.scrollbarXRail).marginLeft) + F(Nt(this.scrollbarXRail).marginRight), this.railYMarginHeight = F(Nt(this.scrollbarYRail).marginTop) + F(Nt(this.scrollbarYRail).marginBottom), ct(this.scrollbarXRail, { display: "none" }), ct(this.scrollbarYRail, { display: "none" }), Ht(this), fn(this, "top", 0, !1, !0), fn(this, "left", 0, !1, !0), ct(this.scrollbarXRail, { display: "" }), ct(this.scrollbarYRail, { display: "" }));
};
Zi.prototype.onScroll = function(t) {
  this.isAlive && (Ht(this), fn(this, "top", this.element.scrollTop - this.lastScrollTop), fn(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  ), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
};
Zi.prototype.destroy = function() {
  this.isAlive && (this.event.unbindAll(), Ye(this.scrollbarX), Ye(this.scrollbarY), Ye(this.scrollbarXRail), Ye(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
};
Zi.prototype.removePsClasses = function() {
  this.element.className = this.element.className.split(" ").filter(function(t) {
    return !t.match(/^ps([-_].+|)$/);
  }).join(" ");
};
const Ao = "perfectScrollbar", Yv = "perfect-scrollbar", $s = "te.perfectScrollbar", St = "te", It = "ps", yo = [
  { te: `scrollX.${St}.${It}`, ps: "ps-scroll-x" },
  { te: `scrollY.${St}.${It}`, ps: "ps-scroll-y" },
  { te: `scrollUp.${St}.${It}`, ps: "ps-scroll-up" },
  { te: `scrollDown.${St}.${It}`, ps: "ps-scroll-down" },
  { te: `scrollLeft.${St}.${It}`, ps: "ps-scroll-left" },
  { te: `scrollRight.${St}.${It}`, ps: "ps-scroll-right" },
  { te: `scrollXEnd.${St}.${It}`, ps: "ps-x-reach-end" },
  { te: `scrollYEnd.${St}.${It}`, ps: "ps-y-reach-end" },
  { te: `scrollXStart.${St}.${It}`, ps: "ps-x-reach-start" },
  { te: `scrollYStart.${St}.${It}`, ps: "ps-y-reach-start" }
], jv = {
  handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
  wheelSpeed: 1,
  wheelPropagation: !0,
  swipeEasing: !0,
  minScrollbarLength: null,
  maxScrollbarLength: null,
  scrollingThreshold: 1e3,
  useBothWheelAxes: !1,
  suppressScrollX: !1,
  suppressScrollY: !1,
  scrollXMarginOffset: 0,
  scrollYMarginOffset: 0,
  positionRight: !0
}, Kv = {
  handlers: "(string|array)",
  wheelSpeed: "number",
  wheelPropagation: "boolean",
  swipeEasing: "boolean",
  minScrollbarLength: "(number|null)",
  maxScrollbarLength: "(number|null)",
  scrollingThreshold: "number",
  useBothWheelAxes: "boolean",
  suppressScrollX: "boolean",
  suppressScrollY: "boolean",
  scrollXMarginOffset: "number",
  scrollYMarginOffset: "number",
  positionRight: "boolean"
}, zv = {
  ps: "group/ps overflow-hidden [overflow-anchor:none] touch-none",
  railX: "group/x absolute bottom-0 h-[0.9375rem] hidden opacity-0 transition-[background-color,_opacity] duration-200 ease-linear motion-reduce:transition-none z-[1035] group-[&.ps--active-x]/ps:block group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-x]/ps:opacity-60 hover:!opacity-90 focus:!opacity-90 [&.ps--clicking]:!opacity-90 outline-none",
  railXColors: "group-[&.ps--active-x]/ps:bg-transparent hover:!bg-[#eee] focus:!bg-[#eee] [&.ps--clicking]:!bg-[#eee] dark:hover:!bg-[#555] dark:focus:!bg-[#555] dark:[&.ps--clicking]:!bg-[#555]",
  railXThumb: "absolute bottom-0.5 rounded-md h-1.5 group-focus/ps:opacity-100 group-active/ps:opacity-100 [transition:background-color_.2s_linear,_height_.2s_ease-in-out] group-hover/x:h-[11px] group-focus/x:h-[0.6875rem] group-[&.ps--clicking]/x:bg-[#999] group-[&.ps--clicking]/x:h-[11px] outline-none",
  railXThumbColors: "bg-[#aaa] group-hover/x:bg-[#999] group-focus/x:bg-[#999]",
  railY: "group/y absolute right-0 w-[0.9375rem] hidden opacity-0 transition-[background-color,_opacity] duration-200 ease-linear motion-reduce:transition-none z-[1035] group-[&.ps--active-y]/ps:block group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-y]/ps:opacity-60 hover:!opacity-90 focus:!opacity-90 [&.ps--clicking]:!opacity-90 outline-none",
  railYColors: "group-[&.ps--active-y]/ps:bg-transparent hover:!bg-[#eee] focus:!bg-[#eee] [&.ps--clicking]:!bg-[#eee] dark:hover:!bg-[#555] dark:focus:!bg-[#555] dark:[&.ps--clicking]:!bg-[#555]",
  railYThumb: "absolute right-0.5 rounded-md w-1.5 group-focus/ps:opacity-100 group-active/ps:opacity-100 [transition:background-color_.2s_linear,_width_.2s_ease-in-out,_opacity] group-hover/y:w-[11px] group-focus/y:w-[0.6875rem] group-[&.ps--clicking]/y:w-[11px] outline-none",
  railYThumbColors: "bg-[#aaa] group-hover/y:bg-[#999] group-focus/y:bg-[#999] group-[&.ps--clicking]/y:bg-[#999]"
}, Uv = {
  ps: "string",
  railX: "string",
  railXColors: "string",
  railXThumb: "string",
  railXThumbColors: "string",
  railY: "string",
  railYColors: "string",
  railYThumb: "string",
  railYThumbColors: "string"
};
class xr {
  constructor(t, e = {}, i = {}) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this.perfectScrollbar = null, this._observer = null, this._psClasses = [
      {
        ps: "ps__rail-x",
        te: this._classes.railX,
        teColor: this._classes.railXColors
      },
      {
        ps: "ps__rail-y",
        te: this._classes.railY,
        teColor: this._classes.railYColors
      },
      {
        ps: "ps__thumb-x",
        te: this._classes.railXThumb,
        teColor: this._classes.railXThumbColors
      },
      {
        ps: "ps__thumb-y",
        te: this._classes.railYThumb,
        teColor: this._classes.railYThumbColors
      }
    ], this._element && (A.setData(t, $s, this), h.addClass(this._element, Yv)), this.init();
  }
  // Getters
  static get NAME() {
    return Ao;
  }
  get railX() {
    return d.findOne(".ps__rail-x", this._element);
  }
  get railY() {
    return d.findOne(".ps__rail-y", this._element);
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return e.handlers !== void 0 && (e.handlers = e.handlers.split(" ")), t = {
      ...jv,
      ...e,
      ...t
    }, I(Ao, t, Kv), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...zv,
      ...e,
      ...t
    }, I(Ao, t, Uv), t;
  }
  // Public
  dispose() {
    this._options.positionRight && this._observer.disconnect(), A.removeData(this._element, $s), this._element = null, this._dataAttrOptions = null, this._options = null, this.perfectScrollbar.destroy(), this.removeEvent(yo), this.perfectScrollbar = null;
  }
  init() {
    if (this.perfectScrollbar = new Zi(this._element, this._options), this._addPerfectScrollbarStyles(), this._updateScrollPosition(), this.perfectScrollbar.update(), this._initEvents(yo), this._options.positionRight) {
      this._observer = new ResizeObserver(() => {
        setTimeout(() => {
          this._updateScrollPosition();
        }, 100);
      });
      const t = {
        attributes: !0,
        attributeFilter: ["class", "className"]
      };
      this._observer.observe(this._element, t);
    }
  }
  _updateScrollPosition() {
    const t = getComputedStyle(this._element).getPropertyValue("height"), e = getComputedStyle(this._element).getPropertyValue("width");
    this.railX && (this.railX.style.transform = `translateY(calc(-100% + ${this._canTransform(t) ? t : "0px"}))`), this.railY && (this.railY.style.transform = `translateX(calc(-100% + ${this._canTransform(e) ? e : "0px"}))`);
  }
  _canTransform(t) {
    return t && t.includes("px");
  }
  update() {
    return this.perfectScrollbar.update();
  }
  _initEvents(t = []) {
    t.forEach(
      ({ ps: e, te: i }) => c.on(
        this._element,
        e,
        (n) => c.trigger(this._element, i, { e: n })
      )
    );
  }
  _addPerfectScrollbarStyles() {
    this._psClasses.forEach((t) => {
      const e = d.findOne(`.${t.ps}`, this._element);
      h.addClass(e, t.te), h.addClass(e, t.teColor);
    }), h.addClass(this._element, this._classes.ps), h.removeClass(this._element, "ps");
  }
  removeEvent(t) {
    let e = [];
    typeof t == "string" && (e = yo.filter(({ te: i }) => i === t)), e.forEach(({ ps: i, te: n }) => {
      c.off(this._element, i), c.off(this._element, n);
    });
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, $s);
      const i = typeof t == "object" && t;
      if (!(!e && /dispose|hide/.test(t)) && (e || (e = new xr(this, i)), typeof t == "string")) {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t]();
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, $s);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Bh = xr, Xv = "data-te-datatable-select-ref", Gv = "data-te-datatable-pagination-nav-ref", qv = "data-te-datatable-pagination-right-ref", Zv = "data-te-datatable-pagination-left-ref", Qv = "data-te-datatable-pagination-start-ref", Jv = "data-te-datatable-pagination-end-ref", tT = ({
  text: s,
  entries: t,
  entriesOptions: e,
  fullPagination: i,
  rowsText: n,
  allText: o,
  paginationStartIconTemplate: r,
  paginationLeftIconTemplate: a,
  paginationRightIconTemplate: l,
  paginationEndIconTemplate: p,
  classes: u
}, _, f) => {
  const g = e.map((m) => m === "All" ? `<option value="${m}" ${m === t ? "selected" : ""}>${o}</option>` : `<option value="${m}" ${m === t ? "selected" : ""}>${m}</option>`).join(`
`);
  return `
<div class="${u.pagination} ${f ? `${u.paginationBordered}` : ""} ${u.borderColor} ${u.color}">
  <div class="${u.selectItemsWrapper}">  
    <p class="${u.paginationRowsText} ${_ ? `${u.loadingPaginationRowsText}` : ""}">${n}</p>
    <div class="${u.selectWrapper} ${_ ? `${u.loadingPaginationSelectWrapper}` : ""}">
      <select name="entries"
        ${_ ? "disabled" : ""} class="select" ${Xv}>
        ${g}
      </select>
    </div>
  </div>
  <div class="${u.paginationNav} ${_ ? `${u.loadingPaginationNav}` : ""}" ${Gv}>
  ${s}
  </div>
  <div class="${u.paginationButtonsWrapper}">
    ${i ? `<button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationStartButton}" ${Qv}>
           ${r}
          </button>` : ""}
    <button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationLeftButton}" ${Zv}>
      ${a}
  </button>
    <button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationRightButton}" ${qv}>
      ${l}
  </button>
    ${i ? `<button data-te-ripple-init data-te-ripple-color="dark" class="${u.paginationEndButton}" ${Jv}>
           ${p}
          </button>` : ""}
  </div>
</div>
`;
}, eT = "data-te-datatable-sort-icon-ref", iT = "data-te-datatable-header-checkbox-ref", sT = (s, t, e, i, n, o, r, a) => {
  const l = e ? `
  <th scope="col">
    <div class="${a.checkboxHeaderWrapper}">
      <input
        class="${a.checkboxHeader}"
        type="checkbox"
        value=""
        ${iT}
        />
    </div>
  </th>
  ` : '<th scope="col"></th>', p = s.map((u, _) => {
    const f = u.fixed ? s.filter((g, m) => g.fixed === u.fixed && m < _).reduce((g, m) => g + m.width, 0) : null;
    return `<th class="${a.column} ${i ? `${a.tableBordered}` : ""} ${a.borderColor} ${n ? `${a.sm}` : ""} ${u.fixed ? `${a.fixedHeader} ${a.color}` : ""} ${o ? `${a.loadingColumn}` : ""}" style="${u.fixed ? `${u.fixed === "right" ? "right" : "left"}: ${f}px;` : ""}" scope="col">${u.sort ? `<div class="${a.sortIconWrapper}"><span class="${a.sortIcon} ${o ? "invisible" : ""}" data-te-sort="${u.field}" ${eT}>${r}</span>` : ""} <span class="${u.sort ? "" : "pl-[18px]"}">${u.label}</span></div></th>`;
  });
  return [t ? l : "", ...p].join(`
`);
}, nT = "data-te-datatable-row-ref", oT = "data-te-datatable-row-checkbox-ref", rT = "data-te-datatable-cell-ref", aT = ({
  rows: s,
  columns: t,
  noFoundMessage: e,
  edit: i,
  selectable: n,
  loading: o,
  bordered: r,
  borderless: a,
  striped: l,
  hover: p,
  sm: u,
  classes: _
}) => {
  const f = s.map((g) => {
    const m = `
      <td data-te-field="checkbox" class="${r ? `${_.tableBordered} ${_.borderColor}` : ""}">
        <div class="${_.checkboxRowWrapper}">
          <input
            class="${_.checkboxRow}"
            type="checkbox"
            value=""
            data-te-row-index="${g.rowIndex}"  ${oT}/>
        </div>
      </td>`, b = t.map((v, T) => {
      const y = {};
      if (v.width && (y["min-width"] = `${v.width - 1}px`, y["max-width"] = `${v.width}px`, y.width = `${v.width}px`), v.fixed) {
        const E = t.filter((w, k) => w.fixed === v.fixed && k < T).reduce((w, k) => w + k.width, 0);
        y[v.fixed === "right" ? "right" : "left"] = `${E}px`;
      }
      return `<td style="${Object.keys(y).map((E) => `${E}: ${y[E]}`).join("; ")}" class="${_.rowItem} ${_.borderColor} ${i ? `${_.edit}` : ""} ${r ? `${_.tableBordered}` : ""} ${u ? `${_.sm}` : ""} ${v.fixed ? `${_.fixedHeader} ${_.color}` : ""}" ${rT} data-te-field="${v.field}" ${i && 'contenteditable="true"'}>${g[v.field]}</td>`;
    }).join("");
    return `<tr scope="row" class="${_.row} ${_.borderColor} ${_.rowAnimation} ${l ? `${_.striped}` : ""} ${a ? `${_.borderless}` : ""} ${p ? `${_.hoverRow}` : ""}" data-te-index="${g.rowIndex}" ${nT}>${n ? m : ""}${b}</tr>`;
  });
  return s.length > 0 || o ? f.join(`
`) : `<tr class="${_.noFoundMessageWrapper} ${_.borderColor}"><td class="${_.noFoundMessage}">${e}</td></tr>`;
}, lT = "data-te-datatable-inner-ref", cT = "data-te-datatable-header-ref", Pl = ({
  columns: s,
  rows: t,
  noFoundMessage: e,
  edit: i,
  multi: n,
  selectable: o,
  loading: r,
  loadingMessage: a,
  pagination: l,
  bordered: p,
  borderless: u,
  striped: _,
  hover: f,
  fixedHeader: g,
  sm: m,
  sortIconTemplate: b,
  classes: v
}) => {
  const T = aT({
    rows: t,
    columns: s,
    noFoundMessage: e,
    edit: i,
    loading: r,
    selectable: o,
    bordered: p,
    borderless: u,
    striped: _,
    hover: f,
    sm: m,
    classes: v
  }), y = sT(
    s,
    o,
    n,
    p,
    m,
    r,
    b,
    v
  );
  return { table: `
<div class="${v.color}" ${lT}>
  <table class="${v.table}">
    <thead class="${v.tableHeader} ${p ? `${v.tableBordered}` : ""} ${u ? `${v.borderless}` : ""} ${v.borderColor}" ${cT}>
      <tr>
        ${y}
      </tr>
    </thead>
    <tbody class="${g ? `${v.fixedHeaderBody}` : ""}">
      ${r ? "" : T}
    </tbody>
  </table>
</div>
${r ? `
  <div class="${v.loadingItemsWrapper}">
    <div class="${v.loadingProgressBarWrapper}">
      <div class="${v.loadingProgressBar}"></div>
    </div>
  </div>
<p class="${v.loadingMessage}">${a}</p>
` : ""}
${l.enable ? tT(l, r, p) : ""}
  `, rows: T, column: y };
}, hT = ({ rows: s, field: t, order: e }) => s.sort((n, o) => {
  let r = n[t], a = o[t];
  return typeof r == "string" && (r = r.toLowerCase()), typeof a == "string" && (a = a.toLowerCase()), r < a ? e === "desc" ? 1 : -1 : r > a ? e === "desc" ? -1 : 1 : 0;
}), dT = (s, t, e) => {
  if (!t)
    return s;
  const i = (n) => {
    const o = document.createElement("div");
    return o.innerHTML = n, n = o.textContent || o.innerText || "", n.toString().toLowerCase().match(t.toLowerCase());
  };
  return s.filter((n) => {
    if (e && typeof e == "string")
      return i(n[e]);
    let o = Object.values(n);
    return e && Array.isArray(e) && (o = Object.keys(n).filter((r) => e.includes(r)).map((r) => n[r])), o.filter((r) => i(r)).length > 0;
  });
}, Bl = ({ rows: s, entries: t, activePage: e }) => {
  const i = e * t;
  return s.slice(i, i + Number(t));
}, Vi = "datatable", gt = `data-te-${Vi}`, ki = `te.${Vi}`, An = `.${ki}`, uT = `[${gt}-inner-ref]`, wo = `[${gt}-cell-ref]`, pT = `[${gt}-header-ref]`, _T = `[${gt}-header-checkbox-ref]`, fT = `[${gt}-pagination-right-ref]`, mT = `[${gt}-pagination-left-ref]`, gT = `[${gt}-pagination-start-ref]`, bT = `[${gt}-pagination-end-ref]`, vT = `[${gt}-pagination-nav-ref]`, TT = `[${gt}-select-ref]`, ko = `[${gt}-sort-icon-ref]`, Ti = `[${gt}-row-ref]`, xo = `[${gt}-row-checkbox-ref]`, ET = `selectRows${An}`, Hl = `render${An}`, CT = `rowClick${An}`, AT = `update${An}`, yT = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 10.5L12 3m0 0l7.5 7.5M12 3v18" />
</svg>`, wT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M18.75 19.5l-7.5-7.5 7.5-7.5m-6 15L5.25 12l7.5-7.5" />
</svg>`, kT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
</svg>`, xT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
</svg>`, OT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M11.25 4.5l7.5 7.5-7.5 7.5m-6-15l7.5 7.5-7.5 7.5"/>
</svg>`, ST = "border-neutral-200 dark:border-neutral-500", IT = "border-none", DT = "relative float-left -ml-[1.5rem] mr-[6px] mt-[0.15rem] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:-mt-px checked:after:ml-[0.25rem] checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-l-0 checked:after:border-t-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:-mt-px checked:focus:after:ml-[0.25rem] checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-l-0 checked:focus:after:border-t-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent dark:border-neutral-600 dark:checked:border-primary dark:checked:bg-primary dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:border-neutral-400", $T = "mb-[0.125rem] min-h-[1.5rem] pl-[1.5rem] ml-3 flex items-center", LT = "relative float-left -ml-[1.5rem] mr-[6px] mt-[0.15rem] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:-mt-px checked:after:ml-[0.25rem] checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-l-0 checked:after:border-t-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:-mt-px checked:focus:after:ml-[0.25rem] checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-l-0 checked:focus:after:border-t-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent dark:border-neutral-600 dark:checked:border-primary dark:checked:bg-primary dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:border-neutral-400", NT = "mb-[0.125rem] min-h-[1.5rem] pl-[1.5rem] ml-3 flex items-center", MT = "bg-white dark:bg-neutral-800", RT = "py-4 pl-1 text-clip overflow-hidden text-[#212529] dark:text-white", PT = "focus:outline-none", BT = "sticky top-0 z-30", HT = "sticky z-10 bg-inherit", VT = "hover:bg-neutral-100 dark:hover:bg-neutral-700", WT = "pointer-events-none cursor-none text-neutral-400 dark:text-neutral-300", FT = "h-[2px] relative w-full overflow-hidden", YT = "text-center text-neutral-500 font-ligh text-sm my-4 dark:text-neutral-400", jT = "text-neutral-500 dark:text-neutral-300", KT = "text-neutral-500 dark:text-neutral-300", zT = "pointer-events-none cursor-none", UT = "h-full w-[45%] bg-primary-400 dark:bg-primary-600", XT = "h-full animate-[progress_3s_ease-in-out_infinite]", GT = "pl-2 py-3 font-light text-sm dark:text-neutral-300", qT = "border-b", ZT = "flex md:flex-row justify-end items-center py-2 space-x-4 text-sm flex-col leading-[1.6]", QT = "border border-t-0", JT = "order-1 my-3 md:order-none md:my-0 md:pr-1", tE = "inline-block rounded p-2.5 text-xs font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", eE = "inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", iE = "font-normal order-2 mb-3 md:order-none md:mb-0", sE = "inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", nE = "font-light", oE = "inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600", rE = "border-b", aE = "transition ease-in-out duration-300 motion-reduce:transition-none", lE = "whitespace-nowrap text-clip overflow-auto px-[1.4rem] py-4", cE = "relative", hE = "!bg-neutral-100 dark:!bg-neutral-600", dE = "flex items-center space-x-4 order-3 md:order-none", uE = "w-[70px]", pE = "!py-2", _E = "w-[15px] h-[10px] origin-bottom font-black mr-1 opacity-0 text-neutral-500 group-hover:opacity-100 transition hover:ease-in-out transform ease-linear duration-300 motion-reduce:transition-none dark:text-neutral-400", fE = "flex flex-row group", mE = "[&:nth-child(odd)]:bg-neutral-50 [&:nth-child(odd)]:dark:bg-neutral-700", gE = "border", bE = "border-b font-normal px-[1.4rem]", vE = "text-left text-sm font-light w-full leading-[1.6]", TE = {
  bordered: "boolean",
  borderless: "boolean",
  clickableRows: "boolean",
  defaultValue: "string",
  edit: "boolean",
  entries: "(number|string)",
  entriesOptions: "array",
  fullPagination: "boolean",
  hover: "boolean",
  loading: "boolean",
  loadingMessage: "string",
  maxWidth: "(null|number|string)",
  maxHeight: "(null|number|string)",
  multi: "boolean",
  noFoundMessage: "string",
  pagination: "boolean",
  selectable: "boolean",
  sm: "boolean",
  sortField: "(null|string)",
  sortOrder: "string",
  fixedHeader: "boolean",
  striped: "boolean",
  rowsText: "string",
  ofText: "string",
  allText: "string",
  forceSort: "boolean",
  sortIconTemplate: "string",
  paginationStartIconTemplate: "string",
  paginationEndIconTemplate: "string",
  paginationLeftIconTemplate: "string",
  paginationRightIconTemplate: "string"
}, EE = {
  bordered: !1,
  borderless: !1,
  clickableRows: !1,
  defaultValue: "-",
  edit: !1,
  entries: 10,
  entriesOptions: [10, 25, 50, 200],
  fixedHeader: !1,
  fullPagination: !1,
  hover: !1,
  loading: !1,
  loadingMessage: "Loading results...",
  maxWidth: null,
  maxHeight: null,
  multi: !1,
  noFoundMessage: "No matching results found",
  pagination: !0,
  selectable: !1,
  sm: !1,
  sortField: null,
  sortOrder: "asc",
  striped: !1,
  rowsText: "Rows per page:",
  ofText: "of",
  allText: "All",
  forceSort: !1,
  sortIconTemplate: yT,
  paginationStartIconTemplate: wT,
  paginationEndIconTemplate: OT,
  paginationLeftIconTemplate: kT,
  paginationRightIconTemplate: xT
}, CE = {
  label: "string",
  field: "string",
  fixed: "(boolean|string)",
  format: "(function|null)",
  width: "(number|null)",
  sort: "boolean",
  columnIndex: "number"
}, AE = {
  label: "",
  field: "",
  fixed: !1,
  format: null,
  width: null,
  sort: !0,
  columnIndex: 0
}, yE = {
  table: vE,
  tableHeader: bE,
  column: RT,
  pagination: ZT,
  selectWrapper: uE,
  scroll: cE,
  tableBordered: gE,
  paginationBordered: QT,
  borderless: IT,
  checkboxRowWrapper: NT,
  checkboxRow: LT,
  checkboxHeaderWrapper: $T,
  checkboxHeader: DT,
  row: rE,
  rowItem: lE,
  striped: mE,
  sortIconWrapper: fE,
  sortIcon: _E,
  paginationRowsText: nE,
  paginationNav: iE,
  paginationButtonsWrapper: JT,
  hoverRow: VT,
  borderColor: ST,
  color: MT,
  fixedHeader: BT,
  fixedHeaderBody: HT,
  selectableRow: hE,
  rowAnimation: aE,
  sm: pE,
  edit: PT,
  selectItemsWrapper: dE,
  paginationStartButton: oE,
  paginationLeftButton: eE,
  paginationRightButton: sE,
  paginationEndButton: tE,
  loadingItemsWrapper: FT,
  loadingProgressBarWrapper: XT,
  loadingProgressBar: UT,
  loadingMessage: YT,
  loadingPaginationRowsText: KT,
  loadingPaginationSelectWrapper: zT,
  loadingPaginationNav: jT,
  loadingColumn: WT,
  noFoundMessageWrapper: qT,
  noFoundMessage: GT
}, wE = {
  table: "string",
  tableHeader: "string",
  column: "string",
  pagination: "string",
  selectWrapper: "string",
  scroll: "string",
  tableBordered: "string",
  paginationBordered: "string",
  borderless: "string",
  checkboxRowWrapper: "string",
  checkboxRow: "string",
  checkboxHeaderWrapper: "string",
  checkboxHeader: "string",
  row: "string",
  rowItem: "string",
  striped: "string",
  sortIconWrapper: "string",
  sortIcon: "string",
  paginationRowsText: "string",
  paginationNav: "string",
  paginationButtonsWrapper: "string",
  hoverRow: "string",
  borderColor: "string",
  color: "string",
  fixedHeader: "string",
  fixedHeaderBody: "string",
  selectableRow: "string",
  rowAnimation: "string",
  sm: "string",
  edit: "string",
  selectItemsWrapper: "string",
  paginationStartButton: "string",
  paginationLeftButton: "string",
  paginationRightButton: "string",
  paginationEndButton: "string",
  loadingItemsWrapper: "string",
  loadingProgressBarWrapper: "string",
  loadingProgressBar: "string",
  loadingMessage: "string",
  loadingPaginationRowsText: "string",
  loadingPaginationSelectWrapper: "string",
  loadingPaginationNav: "string",
  loadingColumn: "string",
  noFoundMessageWrapper: "string",
  noFoundMessage: "string"
};
class Hh {
  constructor(t, e = {}, i = {}, n = {}) {
    this._element = t, this._options = this._getOptions(i), this._classes = this._getClasses(n), this._sortReverse = !1, this._activePage = 0, this._search = "", this._searchColumn = null, this._paginationLeft = null, this._paginationRight = null, this._paginationStart = null, this._paginationEnd = null, this._select = null, this._selectInstance = null, this._selected = [], this._checkboxes = null, this._headerCheckbox = null, this._rows = this._getRows(e.rows), this._columns = this._getColumns(e.columns), this._element && (A.setData(t, ki, this), this._perfectScrollbar = null, this._setup());
  }
  // Getters
  static get NAME() {
    return Vi;
  }
  get columns() {
    return this._columns.map((t, e) => {
      let i = {
        ...AE,
        field: `field_${e}`,
        columnIndex: e
      };
      return typeof t == "string" ? i.label = t : typeof t == "object" && (i = {
        ...i,
        ...t
      }), I("column", i, CE), i;
    });
  }
  get rows() {
    return this._rows.map((t, e) => {
      const i = {
        rowIndex: e
      };
      return Array.isArray(t) ? this.columns.forEach((n, o) => {
        t[o] === 0 ? i[n.field] = t[o] : i[n.field] = t[o] || this._options.defaultValue;
      }) : typeof t == "object" && this.columns.forEach((n) => {
        t[n.field] === 0 ? i[n.field] = t[n.field] : i[n.field] = t[n.field] || this._options.defaultValue;
      }), i;
    });
  }
  get searchResult() {
    return dT(this.rows, this._search, this._searchColumn);
  }
  get computedRows() {
    let t = [...this.searchResult];
    return this._options.sortOrder && (t = hT({
      rows: t,
      field: this._options.sortField,
      order: this._options.sortOrder
    })), this._options.pagination && (this._options.entries === "All" ? t = Bl({
      rows: t,
      entries: t.length,
      activePage: this._activePage
    }) : t = Bl({
      rows: t,
      entries: this._options.entries,
      activePage: this._activePage
    })), t;
  }
  get pages() {
    return this._options.entries === "All" ? 1 : Math.ceil(this.searchResult.length / this._options.entries);
  }
  get navigationText() {
    const t = this._activePage * this._options.entries;
    return this.searchResult.length === 0 ? `0 ${this._options.ofText} 0` : this._options.entries === "All" ? `1 - ${this.searchResult.length} ${this._options.ofText} ${this.searchResult.length}` : `${t + 1} - ${this.computedRows.length + t} ${this._options.ofText} ${this.searchResult.length}`;
  }
  get tableOptions() {
    return {
      classes: this._classes,
      columns: this.columns,
      rows: this.computedRows,
      noFoundMessage: this._options.noFoundMessage,
      edit: this._options.edit,
      loading: this._options.loading,
      loaderClass: this._options.loaderClass,
      loadingMessage: this._options.loadingMessage,
      selectable: this._options.selectable,
      multi: this._options.multi,
      bordered: this._options.bordered,
      borderless: this._options.borderless,
      striped: this._options.striped,
      hover: this._options.hover,
      fixedHeader: this._options.fixedHeader,
      sm: this._options.sm,
      sortIconTemplate: this._options.sortIconTemplate,
      pagination: {
        enable: this._options.pagination,
        text: this.navigationText,
        entries: this._options.entries,
        entriesOptions: this._options.entriesOptions,
        fullPagination: this._options.fullPagination,
        rowsText: this._options.rowsText,
        ofText: this._options.ofText,
        allText: this._options.allText,
        paginationStartIconTemplate: this._options.paginationStartIconTemplate,
        paginationLeftIconTemplate: this._options.paginationLeftIconTemplate,
        paginationRightIconTemplate: this._options.paginationRightIconTemplate,
        paginationEndIconTemplate: this._options.paginationEndIconTemplate,
        classes: this._classes
      },
      forceSort: this._options.forceSort
    };
  }
  // Public
  update(t, e = {}) {
    t && t.rows && (this._rows = t.rows), t && t.columns && (this._columns = t.columns), this._clearClassList(e), this._options = this._getOptions({ ...this._options, ...e }), this._setup(), this._performSort();
  }
  dispose() {
    this._selectInstance && this._selectInstance.dispose(), A.removeData(this._element, ki), this._removeEventListeners(), this._perfectScrollbar.destroy(), this._element = null;
  }
  search(t, e) {
    this._search = t, this._searchColumn = e, this._activePage = 0, this._options.pagination && this._toggleDisableState(), this._renderRows(), this._options.maxHeight && (this._perfectScrollbar.element.scrollTop = 0, this._perfectScrollbar.update());
  }
  sort(t, e = "asc") {
    this._options.sortOrder = e, typeof t == "string" ? this._options.sortField = this.columns.find(
      (n) => n.label === t
    ).field : this._options.sortField = t.field;
    const i = d.findOne(
      `[data-te-sort="${this._options.sortField}"]`,
      this._element
    );
    this._activePage = 0, this._toggleDisableState(), this._renderRows(), this._setActiveSortIcon(i);
  }
  setActivePage(t) {
    t < this.pages && this._changeActivePage(t);
  }
  // Private
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...yE,
      ...e,
      ...t
    }, I(Vi, t, wE), t;
  }
  _changeActivePage(t) {
    this._activePage = t, this._toggleDisableState(), this._renderRows();
  }
  _clearClassList(t) {
    ["hover", "bordered", "borderless", "sm", "striped"].forEach((e) => {
      this._options[e] && !t[e] && h.removeDataAttribute(`data-te-${e}`);
    });
  }
  _emitSelectEvent() {
    c.trigger(this._element, ET, {
      selectedRows: this.rows.filter(
        (t) => this._selected.indexOf(t.rowIndex) !== -1
      ),
      selectedIndexes: this._selected,
      allSelected: this._selected.length === this.rows.length
    });
  }
  _getRows(t = []) {
    const e = d.findOne("tbody", this._element);
    return e ? [...d.find("tr", e).map((n) => d.find("td", n).map((o) => o.innerHTML)), ...t] : t;
  }
  _getColumns(t = []) {
    const e = d.findOne("thead", this._element);
    if (!e)
      return t;
    const i = d.findOne("tr", e);
    return [...d.find("th", i).map((o) => ({
      label: o.innerHTML,
      ...h.getDataAttributes(o)
    })), ...t];
  }
  _getCSSValue(t) {
    return typeof t == "string" ? t : `${t}px`;
  }
  _getOptions(t) {
    const e = {
      ...EE,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(Vi, e, TE), e;
  }
  _setActiveRows() {
    d.find(Ti, this._element).forEach((t) => {
      this._selected.includes(h.getDataAttribute(t, "index")) ? h.addClass(t, `active ${this._classes.selectableRow}`) : h.removeClass(t, `active ${this._classes.selectableRow}`);
    });
  }
  _setEntries(t) {
    this._options = this._getOptions({
      ...this._options,
      entries: t.target.value
    }), this._activePage > this.pages - 1 && (this._activePage = this.pages - 1), this._toggleDisableState(), this._renderRows();
  }
  _setSelected() {
    d.find(xo, this._element).forEach(
      (t) => {
        const e = h.getDataAttribute(t, "rowIndex");
        t.checked = this._selected.includes(e);
      }
    ), this._setActiveRows();
  }
  _setActiveSortIcon(t) {
    d.find(ko, this._element).forEach((e) => {
      const i = this._options.sortOrder === "desc" && e === t ? 180 : 0;
      h.style(e, {
        transform: `rotate(${i}deg)`
      }), e === t && this._options.sortOrder ? h.addClass(e, "opacity-100") : h.removeClass(e, "opacity-100");
    });
  }
  _setup() {
    this._renderTable(), this._options.pagination && this._setupPagination(), this._options.edit && this._setupEditable(), this._options.clickableRows && this._setupClickableRows(), this._options.selectable && this._setupSelectable(), this._setupScroll(), this._setupSort();
  }
  _setupClickableRows() {
    d.find(Ti, this._element).forEach((t) => {
      const e = h.getDataAttribute(t, "index");
      h.addClass(t, "cursor-pointer"), c.on(t, "click", (i) => {
        d.matches(i.target, xo) || c.trigger(this._element, CT, {
          index: e,
          row: this.rows[e]
        });
      });
    });
  }
  _setupEditable() {
    d.find(Ti, this._element).forEach((t) => {
      const e = h.getDataAttribute(t, "index");
      d.find(wo, t).forEach((i) => {
        c.on(i, "input", (n) => this._updateRow(n, e));
      });
    });
  }
  _setupScroll() {
    const t = d.findOne(uT, this._element), e = {};
    if (this._options.maxHeight && (e.maxHeight = this._getCSSValue(this._options.maxHeight)), this._options.maxWidth) {
      const i = this._getCSSValue(this._options.maxWidth);
      e.maxWidth = i, h.style(this._element, { maxWidth: i });
    }
    if (h.style(t, e), h.addClass(t, `${this._classes.scroll}`), this._options.fixedHeader) {
      let i = d.find(pT, this._element);
      this._options.selectable && (i = i.filter((n, o) => (h.addClass(
        n,
        `${this._classes.fixedHeader} ${this._classes.color}`
      ), o !== 0))), i.forEach((n, o) => {
        h.addClass(
          n,
          `${this._classes.fixedHeader} ${this._classes.color}`
        ), this.columns[o].fixed && h.addClass(n, "!z-40");
      });
    }
    this._perfectScrollbar = new Bh(t);
  }
  _setupSort() {
    d.find(ko, this._element).forEach((t) => {
      const e = h.getDataAttribute(t, "sort"), [i] = d.parents(t, "th");
      if (this.columns.sort)
        h.addClass(i, "cursor-pointer");
      else
        return;
      e === this._options.sortField && this._setActiveSortIcon(t), c.on(i, "click", () => {
        this._options.sortField === e && this._options.sortOrder === "asc" ? this._options.sortOrder = "desc" : this._options.sortField === e && this._options.sortOrder === "desc" ? this._options.sortOrder = this._options.forceSort ? "asc" : null : this._options.sortOrder = "asc", this._options.sortField = e, this._activePage = 0, this._performSort(), this._setActiveSortIcon(t);
      });
    });
  }
  _performSort() {
    this._toggleDisableState(), this._renderRows();
  }
  _setupSelectable() {
    this._checkboxes = d.find(xo, this._element), this._headerCheckbox = d.findOne(
      _T,
      this._element
    ), c.on(
      this._headerCheckbox,
      "input",
      (t) => this._toggleSelectAll(t)
    ), this._checkboxes.forEach((t) => {
      const e = h.getDataAttribute(t, "rowIndex");
      c.on(
        t,
        "input",
        (i) => this._toggleSelectRow(i, e)
      );
    });
  }
  _setupPagination() {
    this._paginationRight = d.findOne(
      fT,
      this._element
    ), this._paginationLeft = d.findOne(
      mT,
      this._element
    ), c.on(
      this._paginationRight,
      "click",
      () => this._changeActivePage(this._activePage + 1)
    ), c.on(
      this._paginationLeft,
      "click",
      () => this._changeActivePage(this._activePage - 1)
    ), this._options.fullPagination && (this._paginationStart = d.findOne(
      gT,
      this._element
    ), this._paginationEnd = d.findOne(
      bT,
      this._element
    ), c.on(
      this._paginationStart,
      "click",
      () => this._changeActivePage(0)
    ), c.on(
      this._paginationEnd,
      "click",
      () => this._changeActivePage(this.pages - 1)
    )), this._toggleDisableState(), this._setupPaginationSelect();
  }
  _setupPaginationSelect() {
    this._select = d.findOne(TT, this._element), this._selectInstance = new kr(this._select), c.on(
      this._select,
      "valueChange.te.select",
      (t) => this._setEntries(t)
    );
  }
  _removeEventListeners() {
    this._options.pagination && (c.off(this._paginationRight, "click"), c.off(this._paginationLeft, "click"), c.off(this._select, "valueChange.te.select"), this._options.fullPagination && (c.off(this._paginationStart, "click"), c.off(this._paginationEnd, "click"))), this._options.edit && d.find(wo, this._element).forEach((t) => {
      c.off(t, "input");
    }), this._options.clickableRows && d.find(Ti, this._element).forEach((t) => {
      c.off(t, "click");
    }), d.find(ko, this._element).forEach((t) => {
      const [e] = d.parents(t, "th");
      c.off(e, "click");
    }), this._options.selectable && (c.off(this._headerCheckbox, "input"), this._checkboxes.forEach((t) => {
      c.off(t, "input");
    }));
  }
  _renderTable() {
    this._element.innerHTML = Pl(this.tableOptions).table, this._formatCells(), c.trigger(this._element, Hl);
  }
  _renderRows() {
    const t = d.findOne("tbody", this._element);
    if (this._options.pagination) {
      const e = d.findOne(
        vT,
        this._element
      );
      e.innerText = this.navigationText;
    }
    t.innerHTML = Pl(this.tableOptions).rows, this._formatCells(), this._options.edit && this._setupEditable(), this._options.selectable && (this._setupSelectable(), this._setSelected()), this._options.clickableRows && this._setupClickableRows(), c.trigger(this._element, Hl);
  }
  _formatCells() {
    d.find(Ti, this._element).forEach((e) => {
      const i = h.getDataAttribute(e, "index");
      d.find(wo, e).forEach((o) => {
        const r = h.getDataAttribute(o, "field"), a = this.columns.find((l) => l.field === r);
        a && a.format !== null && a.format(o, this.rows[i][r]);
      });
    });
  }
  _toggleDisableState() {
    this._options.pagination !== !1 && (this._activePage === 0 || this._options.loading ? (this._paginationLeft.setAttribute("disabled", ""), this._options.fullPagination && this._paginationStart.setAttribute("disabled", "")) : (this._paginationLeft.removeAttribute("disabled"), this._options.fullPagination && this._paginationStart.removeAttribute("disabled")), this._activePage === this.pages - 1 || this._options.loading || this.pages === 0 ? (this._paginationRight.setAttribute("disabled", ""), this._options.fullPagination && this._paginationEnd.setAttribute("disabled", "")) : (this._paginationRight.removeAttribute("disabled"), this._options.fullPagination && this._paginationEnd.removeAttribute("disabled")));
  }
  _toggleSelectAll(t) {
    t.target.checked ? this._selected = this.rows.map((e) => e.rowIndex) : this._selected = [], this._setSelected(), this._emitSelectEvent();
  }
  _toggleSelectRow(t, e) {
    t.target.checked ? this._options.multi && !this._selected.includes(e) ? this._selected = [...this._selected, e] : (this._selected = [e], this._checkboxes.forEach((i) => {
      i !== t.target && (i.checked = !1);
    })) : this._selected = this._selected.filter((i) => i !== e), this._options.multi && !t.target.checked && (this._headerCheckbox.checked = !1), this._setActiveRows(), this._emitSelectEvent();
  }
  _updateRow(t, e) {
    const i = h.getDataAttribute(t.target, "field"), n = t.target.textContent, o = this._rows[e];
    if (Array.isArray(o)) {
      const a = this.columns.find((l) => l.field === i).columnIndex;
      o[a] = n;
    } else
      o[i] = n;
    c.trigger(this._element, AT, {
      rows: this._rows,
      columns: this._columns
    });
  }
  static jQueryInterface(t, e, i) {
    return this.each(function() {
      let n = A.getData(this, ki);
      const o = typeof t == "object" && t;
      if (!(!n && /dispose/.test(t)) && (n || (n = new Hh(this, o, e)), typeof t == "string")) {
        if (typeof n[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        n[t](e, i);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, ki);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Vl = "rating", sn = "te.rating", kE = "data-te-rating-init", xE = "[data-te-rating-icon-ref]", ci = `.${sn}`, OE = "ArrowLeft", SE = "ArrowRight", IE = {
  tooltip: "string",
  value: "(string|number)",
  readonly: "boolean",
  after: "string",
  before: "string",
  dynamic: "boolean",
  active: "string"
}, DE = {
  tooltip: "top",
  value: "",
  readonly: !1,
  after: "",
  before: "",
  dynamic: !1,
  active: "fill-current"
}, Wl = `onSelect${ci}`, $E = `onHover${ci}`, Fl = `keyup${ci}`, Yl = `focusout${ci}`, jl = `keydown${ci}`, Kl = `mousedown${ci}`;
class GA {
  constructor(t, e) {
    this._element = t, this._icons = d.find(xE, this._element), this._options = this._getConfig(e), this._index = -1, this._savedIndex = null, this._originalClassList = [], this._originalIcons = [], this._fn = {}, this._tooltips = [], this._element && (A.setData(t, sn, this), this._init());
  }
  // Getters
  static get NAME() {
    return Vl;
  }
  dispose() {
    A.removeData(this._element, sn), this._options.readonly || (c.off(this._element, Fl), c.off(this._element, Yl), c.off(this._element, jl), this._element.removeEventListener("mouseleave", this._fn.mouseleave), this._icons.forEach((t, e) => {
      c.off(t, Kl), t.removeEventListener("mouseenter", this._fn.mouseenter[e]), h.removeClass(t, "cursor-pointer");
    }), this._tooltips.forEach((t) => {
      t._element.removeAttribute(kE), t.dispose();
    }), this._icons.forEach((t) => t.removeAttribute("tabIndex"))), this._element = null;
  }
  // Private
  _init() {
    this._options.readonly || (this._bindMouseEnter(), this._bindMouseLeave(), this._bindMouseDown(), this._bindKeyDown(), this._bindKeyUp(), this._bindFocusLost(), this._icons.forEach((t) => {
      h.addClass(t, "cursor-pointer");
    })), this._options.dynamic && (this._saveOriginalClassList(), this._saveOriginalIcons()), this._setCustomText(), this._setToolTips(), this._options.value && (this._index = this._options.value - 1, this._updateRating(this._index));
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...DE,
      ...e,
      ...t
    }, I(Vl, t, IE), t;
  }
  _bindMouseEnter() {
    this._fn.mouseenter = [], this._icons.forEach((t, e) => {
      t.addEventListener(
        "mouseenter",
        // this._fn.mouseenter[i] is needed to create reference and unpin events after call dispose
        // prettier-ignore
        this._fn.mouseenter[e] = (i) => {
          this._index = this._icons.indexOf(i.target), this._updateRating(this._index), this._triggerEvents(t, $E);
        }
      );
    });
  }
  _bindMouseLeave() {
    this._element.addEventListener(
      "mouseleave",
      // this._fn.mouseleave is needed to create reference and unpin events after call dispose
      // prettier-ignore
      this._fn.mouseleave = () => {
        this._savedIndex !== null ? (this._updateRating(this._savedIndex), this._index = this._savedIndex) : this._options.value ? (this._updateRating(this._options.value - 1), this._index = this._options.value - 1) : (this._index = -1, this._clearRating());
      }
    );
  }
  _bindMouseDown() {
    this._icons.forEach((t) => {
      c.on(t, Kl, () => {
        this._setElementOutline("none"), this._savedIndex = this._index, this._triggerEvents(t, Wl);
      });
    });
  }
  _bindKeyDown() {
    this._element.tabIndex = 0, c.on(
      this._element,
      jl,
      (t) => this._updateAfterKeyDown(t)
    );
  }
  _bindKeyUp() {
    c.on(
      this._element,
      Fl,
      () => this._setElementOutline("auto")
    );
  }
  _bindFocusLost() {
    c.on(
      this._element,
      Yl,
      () => this._setElementOutline("none")
    );
  }
  _setElementOutline(t) {
    this._element.style.outline = t;
  }
  _triggerEvents(t, e) {
    c.trigger(t, e, {
      value: this._index + 1
    });
  }
  _updateAfterKeyDown(t) {
    const e = this._icons.length - 1, i = this._index;
    t.key === SE && this._index < e && (this._index += 1), t.key === OE && this._index > -1 && (this._index -= 1), i !== this._index && (this._savedIndex = this._index, this._updateRating(this._savedIndex), this._triggerEvents(this._icons[this._savedIndex], Wl));
  }
  _updateRating(t) {
    this._clearRating(), this._options.dynamic && this._restoreOriginalIcon(t), this._icons.forEach((e, i) => {
      i <= t && h.addClass(e.querySelector("svg"), this._options.active);
    });
  }
  _clearRating() {
    this._icons.forEach((t, e) => {
      const i = t.querySelector("svg");
      this._options.dynamic && (t.classList = this._originalClassList[e], i.innerHTML = this._originalIcons[e]), h.removeClass(i, this._options.active);
    });
  }
  _setToolTips() {
    this._icons.forEach((t, e) => {
      const i = h.getDataAttribute(t, "toggle");
      t.title && !i && (h.setDataAttribute(t, "toggle", "tooltip"), this._tooltips[e] = new ri(t, {
        placement: this._options.tooltip
      }));
    });
  }
  _setCustomText() {
    this._icons.forEach((t) => {
      const e = h.getDataAttribute(t, "after"), i = h.getDataAttribute(t, "before");
      e && t.insertAdjacentHTML("afterEnd", e), i && t.insertAdjacentHTML("beforeBegin", i);
    });
  }
  _saveOriginalClassList() {
    this._icons.forEach((t) => {
      const e = t.classList.value;
      this._originalClassList.push(e);
    });
  }
  _saveOriginalIcons() {
    this._icons.forEach((t) => {
      const e = t.querySelector("svg").innerHTML;
      this._originalIcons.push(e);
    });
  }
  _restoreOriginalIcon(t) {
    const e = this._originalClassList[t], i = this._originalIcons[t];
    this._icons.forEach((n, o) => {
      if (o <= t) {
        const r = n.querySelector("svg");
        r.innerHTML = i, n.classList = e;
      }
    });
  }
  // Static
  static getInstance(t) {
    return A.getData(t, sn);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Oo = "popconfirm", xi = "te.popconfirm", Vh = `.${xi}`, LE = `cancel${Vh}`, NE = `confirm${Vh}`, ME = "[data-te-popconfirm-body]", So = "data-te-popconfirm-popover", RE = "data-te-popconfirm-modal", zl = "data-te-popconfirm-backdrop", PE = {
  popconfirmMode: "string",
  message: "string",
  cancelText: "(null|string)",
  okText: "(null|string)",
  popconfirmIconTemplate: "string",
  cancelLabel: "(null|string)",
  confirmLabel: "(null|string)",
  position: "(null|string)"
}, BE = {
  popconfirmMode: "inline",
  message: "Are you sure?",
  cancelText: "Cancel",
  okText: "OK",
  popconfirmIconTemplate: "",
  cancelLabel: "Cancel",
  confirmLabel: "Confirm",
  position: "bottom"
}, HE = {
  backdrop: "string",
  body: "string",
  btnCancel: "string",
  btnConfirm: "string",
  btnsContainer: "string",
  fade: "string",
  icon: "string",
  message: "string",
  messageText: "string",
  modal: "string",
  popover: "string"
}, VE = {
  backdrop: "h-full w-full z-[1070] fixed top-0 left-0 bg-[#00000066] flex justify-center items-center",
  body: "p-[1rem] bg-white rounded-[0.5rem] opacity-0 dark:bg-neutral-700",
  btnCancel: "inline-block rounded bg-primary-100 px-4 pb-[5px] pt-[6px] text-xs font-medium uppercase leading-normal text-primary-700 transition duration-150 ease-in-out hover:bg-primary-accent-100 focus:bg-primary-accent-100 focus:outline-none focus:ring-0 active:bg-primary-accent-200",
  btnConfirm: "inline-block rounded bg-primary px-4 pb-[5px] pt-[6px] text-xs font-medium uppercase leading-normal text-white shadow-[0_4px_9px_-4px_#3b71ca] transition duration-150 ease-in-out hover:bg-primary-600 hover:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] focus:bg-primary-600 focus:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] focus:outline-none focus:ring-0 active:bg-primary-700 active:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] dark:shadow-[0_4px_9px_-4px_rgba(59,113,202,0.5)] dark:hover:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)] dark:focus:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)] dark:active:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)]",
  btnsContainer: "flex justify-end space-x-2",
  fade: "transition-opacity duration-[150ms] ease-linear",
  icon: "pr-2",
  message: "flex mb-3",
  messageText: "text-neutral-600 dark:text-white",
  modal: "absolute w-[300px] z-[1080] shadow-sm rounded-[0.5rem]",
  popover: "w-[300px] border-0 rounded-[0.5rem] z-[1080] shadow-sm"
};
class Wh {
  constructor(t, e, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._popper = null, this._cancelButton = "", this._confirmButton = "", this._isOpen = !1, this._uid = this._element.id ? `popconfirm-${this._element.id}` : et("popconfirm-"), t && A.setData(t, xi, this), this._clickHandler = this.open.bind(this), c.on(this._element, "click", this._clickHandler);
  }
  // Getters
  static get NAME() {
    return Oo;
  }
  get container() {
    return d.findOne(`#${this._uid}`);
  }
  get popconfirmBody() {
    return d.findOne(
      ME,
      this.container
    );
  }
  // Public
  dispose() {
    (this._isOpen || this.container !== null) && this.close(), A.removeData(this._element, xi), c.off(this._element, "click", this._clickHandler), this._element = null;
  }
  open() {
    this._isOpen || (this._options.popconfirmMode === "inline" ? this._openPopover(this._getPopoverTemplate()) : this._openModal(this._getModalTemplate()), this._handleCancelButtonClick(), this._handleConfirmButtonClick(), this._listenToEscapeKey(), this._listenToOutsideClick());
  }
  close() {
    if (this._isOpen) {
      if (this._popper !== null || d.findOne(`[${So}]`) !== null)
        c.on(
          this.popconfirmBody,
          "transitionend",
          this._handlePopconfirmTransitionEnd.bind(this)
        ), h.removeClass(this.popconfirmBody, "opacity-100");
      else {
        const t = d.findOne(
          `[${zl}]`
        );
        h.removeClass(this.popconfirmBody, "opacity-100"), document.body.removeChild(t), this._isOpen = !1;
      }
      c.off(document, "click", this._handleOutsideClick.bind(this)), c.off(document, "keydown", this._handleEscapeKey.bind(this));
    }
  }
  _handlePopconfirmTransitionEnd(t) {
    if (t.target !== this.popconfirmBody)
      return;
    const e = d.findOne(
      `[${So}]`
    );
    c.off(this.popconfirmBody, "transitionend"), this._isOpen && t && t.propertyName === "opacity" && (this._popper.destroy(), e && document.body.removeChild(e), this._isOpen = !1);
  }
  // Private
  _getPopoverTemplate() {
    const t = $("div"), e = this._getPopconfirmTemplate();
    return t.setAttribute(So, ""), h.addClass(t, this._classes.popover), t.id = this._uid, t.innerHTML = e, t;
  }
  _getModalTemplate() {
    const t = $("div"), e = this._getPopconfirmTemplate();
    return t.setAttribute(RE, ""), h.addClass(t, `${this._classes.modal}`), t.id = this._uid, t.innerHTML = e, t;
  }
  _getPopconfirmTemplate() {
    return `<div data-te-popconfirm-body class="${this._classes.body}">
      <p class="${this._classes.message}">
      ${this._options.popconfirmIconTemplate ? `<span class="${this._classes.icon}">${this._options.popconfirmIconTemplate}</span>` : ""}
      <span class="${this._classes.messageText}">${this._options.message}</span>
      </p>
      <div class="${this._classes.btnsContainer}">
      ${this._options.cancelText ? `<button type="button" data-te-ripple-init data-te-ripple-color="light" id="popconfirm-button-cancel" aria-label="${this._options.cancelLabel}"
        class="${this._classes.btnCancel}">${this._options.cancelText}</button>` : ""}
      <button type="button" data-te-ripple-init data-te-ripple-color="light" id="popconfirm-button-confirm"
      aria-label="${this._options.confirmLabel}"
      class="${this._classes.btnConfirm}">${this._options.okText ? this._options.okText : "Ok"}</button>
      </div>
    </div>`;
  }
  _getConfig(t) {
    return t = {
      ...BE,
      ...h.getDataAttributes(this._element),
      ...t
    }, I(Oo, t, PE), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...VE,
      ...e,
      ...t
    }, I(Oo, t, HE), t;
  }
  _openPopover(t) {
    this._popper = se(this._element, t, {
      placement: this._translatePositionValue(),
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 5]
          }
        }
      ]
    }), document.body.appendChild(t), setTimeout(() => {
      h.addClass(
        this.popconfirmBody,
        `${this._classes.fade} opacity-100`
      ), this._isOpen = !0;
    }, 0);
  }
  _openModal(t) {
    const e = $("div");
    e.setAttribute(zl, ""), h.addClass(e, this._classes.backdrop), document.body.appendChild(e), e.appendChild(t), h.addClass(this.popconfirmBody, "opacity-100"), this._isOpen = !0;
  }
  _handleCancelButtonClick() {
    const t = this.container;
    this._cancelButton = d.findOne(
      "#popconfirm-button-cancel",
      t
    ), ei.getOrCreateInstance(this._cancelButton, { rippleColor: "light" }), this._cancelButton !== null && c.on(this._cancelButton, "click", () => {
      this.close(), c.trigger(this._element, LE);
    });
  }
  _handleConfirmButtonClick() {
    const t = this.container;
    this._confirmButton = d.findOne(
      "#popconfirm-button-confirm",
      t
    ), ei.getOrCreateInstance(this._confirmButton, { rippleColor: "light" }), c.on(this._confirmButton, "click", () => {
      this.close(), c.trigger(this._element, NE);
    });
  }
  _listenToEscapeKey() {
    c.on(document, "keydown", this._handleEscapeKey.bind(this));
  }
  _handleEscapeKey(t) {
    t.keyCode === we && this.close();
  }
  _listenToOutsideClick() {
    c.on(document, "click", this._handleOutsideClick.bind(this));
  }
  _handleOutsideClick(t) {
    const e = this.container, i = t.target === e, n = e && e.contains(t.target), o = t.target === this._element, r = this._element && this._element.contains(t.target);
    !i && !n && !o && !r && this.close();
  }
  _translatePositionValue() {
    switch (this._options.position) {
      case "top left":
        return "top-end";
      case "top":
        return "top";
      case "top right":
        return "top-start";
      case "bottom left":
        return "bottom-end";
      case "bottom":
        return "bottom";
      case "bottom right":
        return "bottom-start";
      case "left":
        return "left";
      case "left top":
        return "left-end";
      case "left bottom":
        return "left-start";
      case "right":
        return "right";
      case "right top":
        return "right-end";
      case "right bottom":
        return "right-start";
      case void 0:
        return "bottom";
      default:
        return "bottom";
    }
  }
  // Static
  static jQueryInterface(t, e) {
    return this.each(function() {
      const i = A.getData(this, xi), n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t))) {
        if (!i)
          return new Wh(this, n);
        if (typeof t == "string") {
          if (typeof i[t] > "u")
            throw new TypeError(`No method named "${t}"`);
          i[t](e);
        }
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, xi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const Io = "lightbox", Oi = "te.lightbox", WE = `.${Oi}`, FE = ".data-api", Me = `click${WE}${FE}`, Fh = "[data-te-lightbox-init]", YE = `${Fh} img:not([data-te-lightbox-disabled])`, Ul = "data-te-lightbox-caption", jE = "data-te-lightbox-disabled", Dt = "data-te-lightbox-active", KE = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 12h-15m0 0l6.75 6.75M4.5 12l6.75-6.75" />
</svg>
`, zE = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12h15m0 0l-6.75-6.75M19.5 12l-6.75 6.75" />
</svg>
`, UE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
</svg>
`, XE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25" />
</svg>
`, GE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6" />
</svg>
`, qE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
<path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM13.5 10.5h-6" />
</svg>
`, ZE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-4 h-4">
  <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
</svg>
`, QE = {
  container: "string",
  zoomLevel: "(number|string)",
  prevIconTemplate: "string",
  nextIconTemplate: "string",
  showFullscreenIconTemplate: "string",
  hideFullscreenIconTemplate: "string",
  zoomInIconTemplate: "string",
  closeIconTemplate: "string",
  zoomOutIconTemplate: "string",
  spinnerContent: "string"
}, JE = {
  container: "body",
  zoomLevel: 1,
  prevIconTemplate: KE,
  nextIconTemplate: zE,
  showFullscreenIconTemplate: UE,
  hideFullscreenIconTemplate: XE,
  zoomInIconTemplate: GE,
  zoomOutIconTemplate: qE,
  closeIconTemplate: ZE,
  spinnerContent: "Loading..."
}, t0 = {
  caption: "text-white text-ellipsis overflow-hidden whitespace-nowrap mx-[10px] text-center",
  captionWrapper: "fixed left-0 bottom-0 w-full h-[50px] flex justify-center items-center",
  closeBtn: "border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  fullscreenBtn: "border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  gallery: "invisible fixed left-0 top-0 w-full h-full z-[1100] pointer-events-none opacity-0 bg-[#000000e6] transition-all duration-[400ms] motion-reduce:transition-none",
  galleryContent: "fixed top-[50px] left-[50px] w-[calc(100%-100px)] h-[calc(100%-100px)]",
  galleryCounter: "flex justify-center items-center px-[10px] mb-0 h-full text-[#b3b3b3]",
  img: "absolute left-0 top-0 w-full max-h-full h-auto cursor-pointer pointer-events-auto",
  imgWrapper: "absolute top-0 left-0 w-full h-full opacity-0 transform scale-[0.25] transition-all duration-[400ms] ease-out pointer-events-none motion-reduce:transition-none motion-reduce:transform-none",
  leftTools: "float-left h-full",
  loader: "fixed left-0 top-0 z-[2] w-full h-full text-neutral-50 opacity-1 flex justify-center items-center pointer-events-none transition-opacity duration-[1000ms] motion-reduce:transition-none",
  nextBtn: "border-none bg-transparent w-full h-[50px] flex justify-center items-center text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  nextBtnWrapper: "fixed right-0 top-0 w-[50px] h-full flex justify-center items-center transition-opacity duration-[400ms] motion-reduce:transition-none",
  prevBtn: "border-none bg-transparent w-full h-[50px] flex justify-center items-center text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none",
  prevBtnWrapper: "fixed left-0 top-0 w-[50px] h-full flex justify-center items-center transition-opacity duration-[400ms] motion-reduce:transition-none",
  rightTools: "float-right",
  spinner: "inline-block h-8 w-8 animate-[spinner-grow_0.75s_linear_infinite] rounded-full bg-current align-[-0.125em] motion-reduce:animate-[spinner-grow_1.5s_linear_infinite]",
  spinnerContent: "!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]",
  toolbar: "absolute top-0 left-0 w-full h-[50px] z-20 transition-opacity duration-[400ms] motion-reduce:transition-none",
  vertical: "h-full max-h-full w-auto",
  zoomBtn: "border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none"
}, e0 = {
  caption: "string",
  captionWrapper: "string",
  closeBtn: "string",
  fullscreenBtn: "string",
  gallery: "string",
  galleryContent: "string",
  galleryCounter: "string",
  img: "string",
  imgWrapper: "string",
  leftTools: "string",
  loader: "string",
  nextBtn: "string",
  nextBtnWrapper: "string",
  prevBtn: "string",
  prevBtnWrapper: "string",
  rightTools: "string",
  spinner: "string",
  spinnerContent: "string",
  toolbar: "string",
  vertical: "string",
  zoomBtn: "string"
};
class nn {
  constructor(t, e = {}, i) {
    this._element = t, this._options = e, this._classes = this._getClasses(i), this._getContainer(), this._id = `lightbox-${Math.random().toString(36).substr(2, 9)}`, this._activeImg = 0, this._images = [], this._zoom = 1, this._gallery = null, this._galleryToolbar = null, this._galleryContent = null, this._loader = null, this._imgCounter = null, this._animating = !1, this._fullscreen = !1, this._zoomBtn = null, this._fullscreenBtn = null, this._toolsToggleTimer = 0, this._mousedown = !1, this._mousedownPositionX = 0, this._mousedownPositionY = 0, this._originalPositionX = 0, this._originalPositionY = 0, this._positionX = 0, this._positionY = 0, this._zoomTimer = 0, this._tapCounter = 0, this._tapTime = 0, this._rightArrow = null, this._leftArrowWrapper = null, this._rightArrowWrapper = null, this._initiated = !1, this._multitouch = !1, this._touchZoomPosition = [], this._element && (A.setData(t, Oi, this), this.init());
  }
  // Getters
  static get NAME() {
    return Io;
  }
  get activeImg() {
    return this._activeImg;
  }
  get currentImg() {
    return d.findOne(
      `[${Dt}]`,
      this._galleryContent
    );
  }
  get options() {
    const t = {
      ...JE,
      ...h.getDataAttributes(this._element),
      ...this._options
    };
    return I(Io, t, QE), t;
  }
  // Public
  init() {
    this._initiated || (this._appendTemplate(), this._initiated = !0);
  }
  open(t = 0) {
    this._getImages(), this._setActiveImg(t), this._sortImages(), this._triggerEvents("open", "opened"), this._loadImages().then((e) => {
      this._resizeImages(e), this._toggleTemplate(), this._addEvents(), this._focusFullscreenBtn();
    });
  }
  close() {
    this.reset(), this._removeEvents(), this._toggleTemplate(), this._triggerEvents("close", "closed");
  }
  slide(t = "right") {
    this._animating === !0 || this._images.length <= 1 || (this._triggerEvents("slide", "slided"), this._beforeSlideEvents(), t === "right" && this._slideHorizontally(t), t === "left" && this._slideHorizontally(t), t === "first" && this._slideToTarget(t), t === "last" && this._slideToTarget(t), this._afterSlideEvents());
  }
  zoomIn() {
    this._zoom >= 3 || (this._triggerEvents("zoomIn", "zoomedIn"), this._zoom += parseFloat(this.options.zoomLevel), h.style(this.currentImg.parentNode, {
      transform: `scale(${this._zoom})`
    }), this._updateZoomBtn());
  }
  zoomOut() {
    this._zoom <= 1 || (this._triggerEvents("zoomOut", "zoomedOut"), this._zoom -= parseFloat(this.options.zoomLevel), h.style(this.currentImg.parentNode, {
      transform: `scale(${this._zoom})`
    }), this._updateZoomBtn(), this._updateImgPosition());
  }
  toggleFullscreen() {
    this._fullscreen === !1 ? (this._fullscreenBtn.setAttribute(Dt, ""), this._fullscreenBtn.innerHTML = this.options.hideFullscreenIconTemplate, this._gallery.requestFullscreen && this._gallery.requestFullscreen(), this._fullscreen = !0) : (this._fullscreenBtn.removeAttribute(Dt), document.exitFullscreen && document.exitFullscreen(), this._fullscreen = !1);
  }
  reset() {
    this._restoreDefaultFullscreen(), this._restoreDefaultPosition(), this._restoreDefaultZoom(), clearTimeout(this._toolsToggleTimer), clearTimeout(this._doubleTapTimer);
  }
  dispose() {
    c.off(
      document,
      Me,
      YE,
      this.toggle
    ), this._galleryContent && this._removeEvents(), this._gallery && this._gallery.remove(), A.removeData(this._element, Oi), this._element = null;
  }
  // Private
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...t0,
      ...e,
      ...t
    }, I(Io, t, e0), t;
  }
  _getImages() {
    const e = d.find("img", this._element).filter(
      (i) => !i.hasAttribute(jE)
    );
    this._images = e;
  }
  _getContainer() {
    this._container = d.findOne(this.options.container);
  }
  _setActiveImg(t) {
    this._activeImg = typeof t == "number" ? t : this._images.indexOf(t.target);
  }
  _appendTemplate() {
    this._gallery = $("div"), h.addClass(this._gallery, `${this._classes.gallery}`), this._element.dataset.id = this._id, this._gallery.id = this._id, this._appendLoader(), this._appendToolbar(), this._appendContent(), this._appendArrows(), this._appendCaption(), this._container.append(this._gallery);
  }
  _appendToolbar() {
    this._galleryToolbar = $("div"), this._imgCounter = $("p"), this._fullscreenBtn = $("button"), this._zoomBtn = $("button");
    const t = $("button"), e = $("div"), i = $("div");
    h.addClass(this._galleryToolbar, `${this._classes.toolbar}`), h.addClass(this._imgCounter, `${this._classes.galleryCounter}`), h.addClass(this._fullscreenBtn, `${this._classes.fullscreenBtn}`), h.addClass(this._zoomBtn, `${this._classes.zoomInBtn}`), h.addClass(this._zoomBtn, this._classes.zoomBtn), h.addClass(e, `${this._classes.leftTools}`), h.addClass(i, `${this._classes.rightTools}`), h.addClass(t, `${this._classes.closeBtn}`), this._fullscreenBtn.innerHTML = this.options.showFullscreenIconTemplate, t.innerHTML = this.options.closeIconTemplate, this._zoomBtn.innerHTML = this.options.zoomInIconTemplate, this._fullscreenBtn.setAttribute("aria-label", "Toggle fullscreen"), this._zoomBtn.setAttribute("aria-label", "Zoom in"), t.setAttribute("aria-label", "Close"), c.on(
      this._fullscreenBtn,
      Me,
      () => this.toggleFullscreen()
    ), c.on(
      this._zoomBtn,
      Me,
      () => this._toggleZoom()
    ), c.on(t, Me, () => this.close()), e.append(this._imgCounter), i.append(this._fullscreenBtn), i.append(this._zoomBtn), i.append(t), this._galleryToolbar.append(e), this._galleryToolbar.append(i), this._gallery.append(this._galleryToolbar);
  }
  _appendContent() {
    this._galleryContent = $("div"), h.addClass(
      this._galleryContent,
      `${this._classes.galleryContent}`
    ), this._gallery.append(this._galleryContent);
  }
  _appendLoader() {
    this._loader = $("div");
    const t = $("div"), e = $("span");
    h.addClass(this._loader, `${this._classes.loader}`), h.addClass(t, `${this._classes.spinner}`), h.addClass(e, `${this._classes.spinnerContent}`), t.setAttribute("role", "status"), e.innerHTML = this.options.spinnerContent, t.append(e), this._loader.append(t), this._gallery.append(this._loader);
  }
  _appendArrows() {
    this._leftArrowWrapper = $("div"), h.addClass(
      this._leftArrowWrapper,
      `${this._classes.prevBtnWrapper}`
    );
    const t = $("button");
    t.setAttribute("aria-label", "Previous"), h.addClass(t, `${this._classes.prevBtn}`), c.on(t, Me, () => this.slide("left")), this._leftArrowWrapper.append(t), this._rightArrowWrapper = $("div"), h.addClass(
      this._rightArrowWrapper,
      `${this._classes.nextBtnWrapper}`
    ), this._rightArrow = $("button"), this._rightArrow.setAttribute("aria-label", "Next"), h.addClass(this._rightArrow, `${this._classes.nextBtn}`), c.on(this._rightArrow, Me, () => this.slide()), this._rightArrowWrapper.append(this._rightArrow), this._rightArrow.innerHTML = this.options.nextIconTemplate, t.innerHTML = this.options.prevIconTemplate, this._getImages(), !(this._images.length <= 1) && (this._gallery.append(this._leftArrowWrapper), this._gallery.append(this._rightArrowWrapper));
  }
  _appendCaption() {
    const t = $("div"), e = $("p");
    e.setAttribute(Ul, ""), h.addClass(t, `${this._classes.captionWrapper}`), h.addClass(e, `${this._classes.caption}`), t.append(e), this._gallery.append(t);
  }
  _sortImages() {
    for (let t = 0; t < this._activeImg; t++)
      this._images.push(this._images.shift());
  }
  async _loadImages() {
    const t = [], e = [];
    this._galleryContent.innerHTML = "";
    let i = 0;
    return this._images.forEach((n, o) => {
      t.push(
        new Promise((r) => {
          const a = new Image(), l = $("div");
          h.addClass(l, `${this._classes.imgWrapper}`), h.addClass(a, `${this._classes.img}`), this._addImgStyles(a, l, i, o, n), l.append(a), this._galleryContent.append(l), a.onload = r, a.src = n.dataset.teImg || n.src, e.push(a), i += 100;
        })
      );
    }), await Promise.all(t), e;
  }
  _addImgStyles(t, e, i, n, o) {
    t.alt = o.alt, t.draggable = !1, h.style(e, {
      position: "absolute",
      left: `${i}%`,
      top: 0
    }), (o.dataset.teCaption || o.dataset.teCaption === "") && (t.dataset.caption = o.dataset.teCaption), i === 0 ? (o.width < o.height && h.addClass(t, `${this._classes.vertical}`), h.style(e, { opacity: 1 }), t.setAttribute(Dt, "")) : t.removeAttribute(Dt), n === this._images.length - 1 && this._images.length > 1 && h.style(e, { left: "-100%" });
  }
  _resizeImages(t) {
    t.forEach((e) => {
      this._calculateImgSize(e);
    });
  }
  _calculateImgSize(t) {
    t.width >= t.height ? (t.style.width = "100%", t.style.maxWidth = "100%", t.style.height = "auto", t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`, t.style.left = 0) : (t.style.height = "100%", t.style.maxHeight = "100%", t.style.width = "auto", t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`, t.style.top = 0), t.width >= t.parentNode.offsetWidth && (t.style.width = `${t.parentNode.offsetWidth}px`, t.style.height = "auto", t.style.left = 0, t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`), t.height >= t.parentNode.offsetHeight && (t.style.height = `${t.parentNode.offsetHeight}px`, t.style.width = "auto", t.style.top = 0, t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`), this._positionX = parseFloat(t.style.left) || 0, this._positionY = parseFloat(t.style.top) || 0;
  }
  _onResize() {
    this._images = d.find("img", this._galleryContent), this._images.forEach((t) => {
      this._calculateImgSize(t);
    });
  }
  _onFullscreenChange() {
    (document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement) === void 0 && (this._fullscreen = !1, this._fullscreenBtn.innerHTML = this.options.showFullscreenIconTemplate, this._fullscreenBtn.removeAttribute(Dt));
  }
  _beforeSlideEvents() {
    this._animationStart(), this._restoreDefaultZoom(), this._restoreDefaultPosition(), this._resetDoubleTap();
  }
  _slideHorizontally(t) {
    this._images = d.find("img", this._galleryContent), this._images.forEach((e) => {
      let i;
      t === "right" ? (i = parseInt(e.parentNode.style.left, 10) - 100, i < -100 && (i = (this._images.length - 2) * 100)) : (i = parseInt(e.parentNode.style.left, 10) + 100, i === (this._images.length - 1) * 100 && (i = -100)), this._slideImg(e, i);
    }), this._updateActiveImg(t);
  }
  _slideImg(t, e) {
    e === 0 ? (t.setAttribute(Dt, ""), h.style(t.parentNode, { opacity: 1, transform: "scale(1)" })) : (t.removeAttribute(Dt), h.style(t.parentNode, {
      opacity: 0,
      transform: "scale(0.25)"
    })), t.parentNode.style.left = `${e}%`;
  }
  _slideToTarget(t) {
    t === "first" && this._activeImg === 0 || t === "last" && this._activeImg === this._images.length - 1 || (this.reset(), this._removeEvents(), this._showLoader(), this._getImages(), this._activeImg = t === "first" ? 0 : this._images.length - 1, this._sortImages(), h.style(this.currentImg.parentNode, {
      transform: "scale(0.25)",
      opacity: 0
    }), setTimeout(() => {
      this._loadImages().then((e) => {
        this._resizeImages(e), this._addEvents(), this._updateCaption(), this._hideLoader(), setTimeout(() => {
          h.style(this.currentImg.parentNode, {
            transform: "scale(1)",
            opacity: 1
          });
        }, 10);
      });
    }, 400));
  }
  _updateActiveImg(t) {
    t === "right" && (this._activeImg === this._images.length - 1 ? this._activeImg = 0 : this._activeImg++), t === "left" && (this._activeImg === 0 ? this._activeImg = this._images.length - 1 : this._activeImg--);
  }
  _afterSlideEvents() {
    this._updateCounter(), this._updateCaption();
  }
  _updateCounter() {
    this._images.length <= 1 || setTimeout(() => {
      this._imgCounter.innerHTML = `${this._activeImg + 1} / ${this._images.length}`;
    }, 200);
  }
  _updateCaption() {
    setTimeout(() => {
      let t = this.currentImg.alt;
      (this.currentImg.dataset.caption || this.currentImg.dataset.caption === "") && (t = this.currentImg.dataset.caption), d.findOne(
        `[${Ul}]`,
        this._gallery
      ).innerHTML = t;
    }, 200);
  }
  _toggleTemplate() {
    this._gallery.style.visibility === "visible" ? (h.style(this.currentImg.parentNode, {
      transform: "scale(0.25)"
    }), setTimeout(() => {
      this._hideGallery(), this._enableScroll(), this._showLoader();
    }, 100)) : (this._showGallery(), this._disableScroll(), this._updateCounter(), this._updateCaption(), this._setToolsToggleTimout(), this._hideLoader());
  }
  _showLoader() {
    h.style(this._loader, { opacity: 1 });
  }
  _hideLoader() {
    h.style(this._loader, { opacity: 0 });
  }
  _hideGallery() {
    h.style(this._gallery, {
      opacity: 0,
      pointerEvents: "none",
      visibility: "hidden"
    });
  }
  _showGallery() {
    h.style(this._gallery, {
      opacity: 1,
      pointerEvents: "initial",
      visibility: "visible"
    }), setTimeout(() => {
      h.style(this.currentImg.parentNode, { transform: "scale(1)" });
    }, 50);
  }
  _toggleZoom() {
    this._zoom !== 1 ? this.zoomOut() : this.zoomIn();
  }
  _updateZoomBtn() {
    this._zoom > 1 ? (this._zoomBtn.setAttribute(Dt, ""), this._zoomBtn.setAttribute("aria-label", "Zoom out"), this._zoomBtn.innerHTML = this.options.zoomOutIconTemplate) : (this._zoomBtn.removeAttribute(Dt), this._zoomBtn.setAttribute("aria-label", "Zoom in"), this._zoomBtn.innerHTML = this.options.zoomInIconTemplate);
  }
  _updateImgPosition() {
    this._zoom === 1 && this._restoreDefaultPosition();
  }
  _addEvents() {
    const t = d.find("img", this._galleryContent);
    this._onWindowTouchmove = this._onWindowTouchmove.bind(this), this._onWindowTouchstart = this._onWindowTouchstart.bind(this), this._onImgMousedown = this._onMousedown.bind(this), this._onImgMousemove = this._onMousemove.bind(this), this._onImgWheel = this._onZoom.bind(this), this._onImgMouseup = this._onMouseup.bind(this), this._onImgTouchend = this._onTouchend.bind(this), this._onImgDoubleClick = this._onDoubleClick.bind(this), this._onWindowResize = this._onResize.bind(this), this._onWindowFullscreenChange = this._onFullscreenChange.bind(this), this._onAnyImgAction = this._resetToolsToggler.bind(this), this._onGalleryClick = this._onBackdropClick.bind(this), this._onKeyupEvent = this._onKeyup.bind(this), this._onRightArrowKeydownEvent = this._onRightArrowKeydown.bind(this), this._onFullscreenBtnKeydownEvent = this._onFullscreenBtnKeydown.bind(this), t.forEach((e) => {
      c.on(e, "mousedown", this._onImgMousedown, {
        passive: !0
      }), c.on(e, "touchstart", this._onImgMousedown, {
        passive: !0
      }), c.on(e, "mousemove", this._onImgMousemove, {
        passive: !0
      }), c.on(e, "touchmove", this._onImgMousemove, {
        passive: !0
      }), c.on(e, "wheel", this._onImgWheel, { passive: !0 }), c.on(e, "dblclick", this._onImgDoubleClick, {
        passive: !0
      });
    }), document.addEventListener("touchmove", this._onWindowTouchmove, {
      passive: !1
    }), c.on(window, "touchstart", this._onWindowTouchstart), c.on(window, "mouseup", this._onImgMouseup), c.on(window, "touchend", this._onImgTouchend), c.on(window, "resize", this._onWindowResize), c.on(window, "orientationchange", this._onWindowResize), c.on(window, "keyup", this._onKeyupEvent), c.on(window, "fullscreenchange", this._onWindowFullscreenChange), c.on(this._gallery, "mousemove", this._onAnyImgAction), c.on(this._gallery, "click", this._onGalleryClick), c.on(
      this._rightArrow,
      "keydown",
      this._onRightArrowKeydownEvent
    ), c.on(
      this._fullscreenBtn,
      "keydown",
      this._onFullscreenBtnKeydownEvent
    );
  }
  _removeEvents() {
    d.find("img", this._galleryContent).forEach((e) => {
      c.off(e, "mousedown", this._onImgMousedown), c.off(e, "touchstart", this._onImgMousedown), c.off(e, "mousemove", this._onImgMousemove), c.off(e, "touchmove", this._onImgMousemove), c.off(e, "wheel", this._onImgWheel), c.off(e, "dblclick", this._onImgDoubleClick);
    }), document.removeEventListener("touchmove", this._onWindowTouchmove, {
      passive: !1
    }), c.off(window, "touchstart", this._onWindowTouchstart), c.off(window, "mouseup", this._onImgMouseup), c.off(window, "touchend", this._onImgTouchend), c.off(window, "resize", this._onWindowResize), c.off(window, "orientationchange", this._onWindowResize), c.off(window, "keyup", this._onKeyupEvent), c.off(
      window,
      "fullscreenchange",
      this._onWindowFullscreenChange
    ), c.off(this._gallery, "mousemove", this._onAnyImgAction), c.off(this._gallery, "click", this._onGalleryClick), c.off(
      this._rightArrow,
      "keydown",
      this._onRightArrowKeydownEvent
    ), c.off(
      this._fullscreenBtn,
      "keydown",
      this._onFullscreenBtnKeydownEvent
    );
  }
  _onMousedown(t) {
    const e = t.touches, i = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;
    this._originalPositionX = parseFloat(this.currentImg.style.left) || 0, this._originalPositionY = parseFloat(this.currentImg.style.top) || 0, this._positionX = this._originalPositionX, this._positionY = this._originalPositionY, this._mousedownPositionX = i * (1 / this._zoom) - this._positionX, this._mousedownPositionY = n * (1 / this._zoom) - this._positionY, this._mousedown = !0, t.type === "touchstart" && t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);
  }
  _onMousemove(t) {
    if (!this._mousedown)
      return;
    const e = t.touches, i = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;
    if (e && this._resetToolsToggler(), !this._multitouch)
      if (this._zoom !== 1)
        this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, this._positionY = n * (1 / this._zoom) - this._mousedownPositionY, h.style(this.currentImg, {
          left: `${this._positionX}px`,
          top: `${this._positionY}px`
        });
      else {
        if (this._images.length <= 1)
          return;
        this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, h.style(this.currentImg, { left: `${this._positionX}px` });
      }
  }
  _onMouseup(t) {
    this._mousedown = !1, this._moveImg(t.target);
  }
  _onTouchend(t) {
    this._mousedown = !1, this._multitouch ? t.targetTouches.length === 0 && (this._multitouch = !1, this._touchZoomPosition = []) : this._multitouch || (this._checkDoubleTap(t), this._moveImg(t.target));
  }
  _calculateTouchZoom(t) {
    const e = Math.hypot(
      this._touchZoomPosition[1].pageX - this._touchZoomPosition[0].pageX,
      this._touchZoomPosition[1].pageY - this._touchZoomPosition[0].pageY
    ), i = Math.hypot(
      t.touches[1].pageX - t.touches[0].pageX,
      t.touches[1].pageY - t.touches[0].pageY
    ), n = Math.abs(e - i), o = t.view.screen.width;
    n > o * 0.03 && (e <= i ? this.zoomIn() : this.zoomOut(), this._touchZoomPosition = t.touches);
  }
  _onWindowTouchstart(t) {
    t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);
  }
  _onWindowTouchmove(t) {
    t.preventDefault(), t.type === "touchmove" && t.targetTouches.length > 1 && this._calculateTouchZoom(t);
  }
  _onRightArrowKeydown(t) {
    switch (t.keyCode) {
      case 9:
        if (t.shiftKey)
          break;
        t.preventDefault(), this._focusFullscreenBtn();
        break;
    }
  }
  _onFullscreenBtnKeydown(t) {
    switch (t.keyCode) {
      case 9:
        if (!t.shiftKey)
          break;
        t.preventDefault(), this._focusRightArrow();
        break;
    }
  }
  _onKeyup(t) {
    switch (this._resetToolsToggler(), t.keyCode) {
      case 39:
        this.slide();
        break;
      case 37:
        this.slide("left");
        break;
      case 27:
        this.close();
        break;
      case 36:
        this.slide("first");
        break;
      case 35:
        this.slide("last");
        break;
      case 38:
        this.zoomIn();
        break;
      case 40:
        this.zoomOut();
        break;
    }
  }
  _focusFullscreenBtn() {
    setTimeout(() => {
      this._fullscreenBtn.focus();
    }, 100);
  }
  _focusRightArrow() {
    this._rightArrow.focus();
  }
  _moveImg(t) {
    if (this._multitouch || this._zoom !== 1 || t !== this.currentImg || this._images.length <= 1)
      return;
    const e = this._positionX - this._originalPositionX;
    e > 0 ? this.slide("left") : e < 0 && this.slide();
  }
  _checkDoubleTap(t) {
    clearTimeout(this._doubleTapTimer);
    const i = (/* @__PURE__ */ new Date()).getTime() - this._tapTime;
    this._tapCounter > 0 && i < 500 ? (this._onDoubleClick(t), this._doubleTapTimer = setTimeout(() => {
      this._tapTime = (/* @__PURE__ */ new Date()).getTime(), this._tapCounter = 0;
    }, 300)) : (this._tapCounter++, this._tapTime = (/* @__PURE__ */ new Date()).getTime());
  }
  _resetDoubleTap() {
    this._tapTime = 0, this._tapCounter = 0, clearTimeout(this._doubleTapTimer);
  }
  _onDoubleClick(t) {
    this._multitouch || (t.touches || this._setNewPositionOnZoomIn(t), this._zoom !== 1 ? this._restoreDefaultZoom() : this.zoomIn());
  }
  _onZoom(t) {
    if (t.deltaY > 0)
      this.zoomOut();
    else {
      if (this._zoom >= 3)
        return;
      this._setNewPositionOnZoomIn(t), this.zoomIn();
    }
  }
  _onBackdropClick(t) {
    this._resetToolsToggler(), t.target.tagName === "DIV" && this.close();
  }
  _setNewPositionOnZoomIn(t) {
    clearTimeout(this._zoomTimer), this._positionX = window.innerWidth / 2 - t.offsetX - 50, this._positionY = window.innerHeight / 2 - t.offsetY - 50, this.currentImg.style.transition = "all 0.5s ease-out", this.currentImg.style.left = `${this._positionX}px`, this.currentImg.style.top = `${this._positionY}px`, this._zoomTimer = setTimeout(() => {
      this.currentImg.style.transition = "none";
    }, 500);
  }
  _resetToolsToggler() {
    this._showTools(), clearTimeout(this._toolsToggleTimer), this._setToolsToggleTimout();
  }
  _setToolsToggleTimout() {
    this._toolsToggleTimer = setTimeout(() => {
      this._hideTools(), clearTimeout(this._toolsToggleTimer);
    }, 4e3);
  }
  _hideTools() {
    h.style(this._galleryToolbar, { opacity: 0 }), h.style(this._leftArrowWrapper, { opacity: 0 }), h.style(this._rightArrowWrapper, { opacity: 0 });
  }
  _showTools() {
    h.style(this._galleryToolbar, { opacity: 1 }), h.style(this._leftArrowWrapper, { opacity: 1 }), h.style(this._rightArrowWrapper, { opacity: 1 });
  }
  _disableScroll() {
    h.addClass(document.body, "overflow-y-hidden relative"), document.documentElement.scrollHeight > document.documentElement.clientHeight && h.addClass(document.body, "md:pr-[17px]");
  }
  _enableScroll() {
    setTimeout(() => {
      h.removeClass(document.body, "overflow-y-hidden relative"), h.removeClass(document.body, "md:pr-[17px]");
    }, 300);
  }
  _animationStart() {
    this._animating = !0, setTimeout(() => {
      this._animating = !1;
    }, 400);
  }
  _restoreDefaultZoom() {
    this._zoom !== 1 && (this._zoom = 1, h.style(this.currentImg.parentNode, {
      transform: `scale(${this._zoom})`
    }), this._updateZoomBtn(), this._updateImgPosition());
  }
  _restoreDefaultFullscreen() {
    this._fullscreen && this.toggleFullscreen();
  }
  _restoreDefaultPosition() {
    clearTimeout(this._zoomTimer);
    const t = this.currentImg;
    h.style(this.currentImg.parentNode, { left: 0, top: 0 }), h.style(this.currentImg, {
      transition: "all 0.5s ease-out",
      left: 0,
      top: 0
    }), this._calculateImgSize(t), setTimeout(() => {
      h.style(this.currentImg, { transition: "none" });
    }, 500);
  }
  async _triggerEvents(t, e) {
    c.trigger(this._element, `${t}.te.lightbox`), e && await setTimeout(() => {
      c.trigger(this._element, `${e}.te.lightbox`);
    }, 505);
  }
  static getInstance(t) {
    return A.getData(t, Oi);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static toggle() {
    return function(t) {
      const e = d.closest(
        t.target,
        `${Fh}`
      );
      (nn.getInstance(e) || new nn(e)).open(t);
    };
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, Oi);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new nn(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
}
const i0 = {
  isRequired: "This is required",
  isEmail: "Please enter a valid email address",
  isLongerThan: "This field must be longer than {length} characters",
  isShorterThan: "This field must be shorter than {length} characters",
  isChecked: "This is required",
  isPhone: "Please enter a valid phone number",
  isNumber: "Expected value with type Number",
  isString: "Expected value with type String",
  isBoolean: "Expected value with type Boolean",
  isDate: "Please enter a valid date",
  is12hFormat: "Please enter a valid time in 12h format",
  is24hFormat: "Please enter a valid time in 24h format"
}, s0 = {
  isRequired: (s, t) => (s == null ? void 0 : s.trim()) ? !0 : t,
  isEmail: (s, t) => /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(s) ? !0 : t,
  isLongerThan: (s, t, e) => s.length > e ? !0 : t.replace("{length}", e),
  isShorterThan: (s, t, e) => s.length < e ? !0 : t.replace("{length}", e),
  isChecked: (s) => s ? !0 : "This is required",
  isPhone: (s, t) => s.length === 9 ? !0 : t,
  isNumber: (s, t) => s && !isNaN(Number(s)) ? !0 : t,
  isString: (s, t) => typeof s == "string" ? !0 : t,
  isBoolean: (s, t) => typeof s == "boolean" ? !0 : t,
  isDate: (s, t) => {
    const e = /^([0-9]{1,2})\/([0-9]{1,2})\/([0-9]{4})$/;
    return s.match(e) ? !0 : t;
  },
  is12hFormat: (s, t) => {
    const e = /^(0?[1-9]|1[0-2]):[0-5][0-9] [APap][mM]$/;
    return s.match(e) ? !0 : t;
  },
  is24hFormat: (s, t) => {
    const e = /^(?:[01]\d|2[0-3]):[0-5][0-9]$/;
    return s.match(e) ? !0 : t;
  }
}, Do = "validation", ir = "te.validation", yn = `.${ir}`, Yh = "data-te-validate", Ls = "data-te-validated", Ns = "data-te-validation-state", Ms = "data-te-validation-feedback", $o = "data-te-valid-feedback", Rs = "data-te-invalid-feedback", Xl = "data-te-validation-ruleset", n0 = "data-te-submit-btn-ref", o0 = `[${Yh}]`, r0 = "[data-te-input-notch-ref] div", a0 = `[${n0}]`, l0 = `validated${yn}`, c0 = `valid${yn}`, h0 = `invalid${yn}`, d0 = `changed${yn}`, u0 = {
  validFeedback: "string",
  invalidFeedback: "string",
  disableFeedback: "boolean",
  customRules: "object",
  customErrorMessages: "object",
  activeValidation: "boolean",
  submitCallback: "(function|null)"
}, Gl = {
  validFeedback: "Looks good!",
  invalidFeedback: "Something is wrong!",
  disableFeedback: !1,
  customRules: {},
  customErrorMessages: {},
  activeValidation: !1,
  submitCallback: null
}, p0 = {
  // default notch
  notchLeadingValid: "border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[-1px_0_0_#14a44d,_0_1px_0_0_#14a44d,_0_-1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]",
  notchMiddleValid: "border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[0_1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]",
  notchTrailingValid: "border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[1px_0_0_#14a44d,_0_-1px_0_0_#14a44d,_0_1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]",
  notchLeadingInvalid: "border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[-1px_0_0_#dc4c64,_0_1px_0_0_#dc4c64,_0_-1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]",
  notchMiddleInvalid: "border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[0_1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]",
  notchTrailingInvalid: "border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[1px_0_0_#dc4c64,_0_-1px_0_0_#dc4c64,_0_1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]",
  // basic inputs
  basicInputValid: "!border-[#14a44d] focus:!border-[#14a44d] focus:!shadow-[inset_0_0_0_1px_#14a44d]",
  basicInputInvalid: "!border-[#dc4c64] focus:!border-[#dc4c64] focus:!shadow-[inset_0_0_0_1px_#dc4c64]",
  // checkbox
  checkboxValid: "checked:!border-[#14a44d] checked:!bg-[#14a44d] checked:after:!bg-[#14a44d]",
  checkboxInvalid: "checked:!border-[#dc4c64] checked:!bg-[#dc4c64] checked:after:!bg-[#dc4c64]",
  radioValid: "checked:!border-[#14a44d] checked:after:!bg-[#14a44d]",
  radioInvalid: "checked:!border-[#dc4c64] checked:after:!bg-[#dc4c64]",
  // labels
  labelValid: "!text-[#14a44d]",
  labelInvalid: "!text-[#dc4c64]",
  // feedback
  validFeedback: "absolute top-full left-0 m-1 w-auto text-sm text-[#14a44d] animate-[fade-in_0.3s_both]",
  invalidFeedback: "absolute top-full left-0 m-1 w-auto text-sm text-[#dc4c64] animate-[fade-in_0.3s_both]",
  // element validated
  elementValidated: "mb-8"
}, _0 = {
  notchLeadingValid: "string",
  notchMiddleValid: "string",
  notchTrailingValid: "string",
  notchLeadingInvalid: "string",
  notchMiddleInvalid: "string",
  notchTrailingInvalid: "string",
  basicInputValid: "string",
  basicInputInvalid: "string",
  checkboxValid: "string",
  checkboxInvalid: "string",
  radioValid: "string",
  radioInvalid: "string",
  labelValid: "string",
  labelInvalid: "string",
  validFeedback: "string",
  invalidFeedback: "string",
  elementValidated: "string"
};
class jh extends ft {
  constructor(t, e, i) {
    super(t), this._element = t, this._element && A.setData(t, ir, this), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._isValid = !0, this._shouldApplyInputEvents = !0, this._submitCallback = null, this._errorMessages = {
      ...i0,
      ...this._config.customErrorMessages
    }, this._validationElements = this._getValidationElements(), this._validationElements.forEach(({ element: n, input: o }) => {
      this._createFeedbackWrapper(n, o);
    }), this._validationObserver = this._watchForValidationChanges(), this._validationObserver.observe(this._element, { attributes: !0 }), this._submitButton = null, this._handleSubmitButton(), this._validationResult = [];
  }
  // Getters
  static get DefaultType() {
    return u0;
  }
  static get Default() {
    return Gl;
  }
  static get NAME() {
    return Do;
  }
  // Public
  dispose() {
    var t;
    (t = this._validationObserver) == null || t.disconnect(), this._validationObserver = null, this._submitCallback = null, this._element.removeAttribute(Ls), this._removeInputEvents(), this._removeValidationTraces(), this._validationResult = [], this._submitButton && c.off(this._submitButton, "click"), this._config.activeValidation && (this._validationElements.forEach((e) => {
      const { input: i } = e;
      c.off(i, "input");
    }), this._shouldApplyInputEvents = !0);
  }
  // Private
  _removeValidationTraces() {
    this._removeFeedbackWrapper(), this._validationElements.forEach(({ element: t, classes: e, initialHTML: i }) => {
      t.className = e, t.innerHTML = i, t.removeAttribute(Ns), t.removeAttribute(Rs), t.removeAttribute($o);
    }), this._validationElements = [];
  }
  _getValidationElements() {
    return d.find(
      o0,
      this._element
    ).map((e) => {
      const i = d.findOne("input", e) || d.findOne("textarea", e), n = d.findOne("select", e);
      return {
        id: i.name || i.id || (n == null ? void 0 : n.name) || et("validation-"),
        element: e,
        type: e.getAttribute(Yh),
        input: i,
        validFeedback: e.getAttribute($o),
        invalidFeedback: e.getAttribute(Rs),
        classes: e.className,
        initialHTML: e.innerHTML,
        ruleset: e.getAttribute(Xl)
      };
    });
  }
  _createFeedbackWrapper(t, e) {
    if (t.querySelectorAll(`[${Ms}]`).length > 0)
      return;
    const i = document.createElement("span");
    i.setAttribute(Ms, ""), e.parentNode.appendChild(i);
  }
  _removeFeedbackWrapper() {
    d.find(
      `[${Ms}]`,
      this._element
    ).forEach((e) => {
      e.remove();
    });
  }
  _watchForValidationChanges() {
    return new MutationObserver((e) => {
      e.forEach((i) => {
        const { attributeName: n } = i;
        n === Ls && (this._handleValidation(), this._config.activeValidation && this._shouldApplyInputEvents && this._applyInputEvents());
      });
    });
  }
  _handleValidation() {
    this._element.getAttribute(Ls) && (this._validationResult = [], this._isValid = !0, this._validationElements.forEach(
      (t) => this._validateSingleElement(t)
    ), this._emitEvents(this._isValid), this._submitCallback && this._submitCallback(this._isValid));
  }
  _validateSingleElement(t) {
    var p;
    const { element: e, type: i, input: n, ruleset: o, id: r } = t;
    o && this._validateByRuleset(t);
    const a = e.getAttribute(Ns);
    if (a !== "valid" && a !== "invalid")
      return;
    const l = a.replace(
      a.charAt(0),
      a.charAt(0).toUpperCase()
    );
    i === "input" && this._restyleNotches(e, l), i === "basic" && this._restyleBasicInputs(n, l), (i === "checkbox" || i === "radio") && this._restyleCheckboxes(n, l, i), this._restyleLabels(e, l), a === "invalid" && (this._isValid = !1), this._config.disableFeedback || this._applyFeedback(e, a), c.trigger(this._element, d0, {
      value: {
        name: r,
        result: a,
        validation: (p = this._validationResult[r]) == null ? void 0 : p.validation
      }
    });
  }
  _validateByRuleset({ element: t, type: e, invalidFeedback: i, input: n, id: o }) {
    const r = this._getRuleset(t);
    if (!r.length)
      return;
    const a = e === "checkbox" || e === "radio" ? n.checked : n.value;
    let l = "", p = [];
    for (const u of r) {
      const _ = u.callback(
        a,
        this._errorMessages[u.name] || this._config.invalidFeedback,
        u.parameter
      );
      p.push({
        result: _ === !0,
        name: u.name,
        fullName: u.fullName
      }), typeof _ == "string" && !l && (l = _);
    }
    if (this._validationResult[o] = { element: t, validation: p }, !l) {
      t.setAttribute(Ns, "valid");
      return;
    }
    t.setAttribute(Ns, "invalid"), i || t.setAttribute(Rs, l);
  }
  _handleInputChange(t) {
    this._validateSingleElement(t);
  }
  _getRuleset(t) {
    const i = t.getAttribute(Xl).split("|");
    let n = [];
    const o = {
      ...s0,
      ...this._config.customRules
    };
    return i.forEach((r) => {
      const a = this._getRuleData(r, o);
      a.callback ? n.push(a) : console.warn(`Rule ${r} does not exist`);
    }), n;
  }
  _getRuleData(t, e) {
    const i = t.split("(");
    return {
      callback: e[i[0]],
      parameter: i[1] ? i[1].split(")")[0] : null,
      name: i[0],
      fullName: t
    };
  }
  _applyFeedback(t, e) {
    const i = d.findOne(
      `[${Ms}]`,
      t
    ), n = t.getAttribute($o) || this._config.validFeedback, o = t.getAttribute(Rs) || this._config.invalidFeedback;
    h.addClass(t, this._classes.elementValidated), i.textContent = e === "valid" ? n : o, i.className = this._classes[e === "valid" ? "validFeedback" : "invalidFeedback"];
  }
  _restyleCheckboxes(t, e, i) {
    h.removeClass(t, this._classes.checkboxValid), h.removeClass(t, this._classes.checkboxInvalid), h.addClass(t, this._classes[`${i}${e}`]);
  }
  _restyleBasicInputs(t, e) {
    h.removeClass(t, this._classes.basicInputValid), h.removeClass(t, this._classes.basicInputInvalid), h.addClass(t, this._classes[`basicInput${e}`]);
  }
  _restyleNotches(t, e) {
    d.find(r0, t).forEach((n, o) => {
      let r = o === 0 ? "notchLeading" : o === 1 ? "notchMiddle" : "notchTrailing";
      n.className = "", h.addClass(n, ph[r]), r += e, h.addClass(n, this._classes[r]);
    });
  }
  _restyleLabels(t, e) {
    const i = d.find("label", t);
    i.length && i.forEach((n) => {
      h.removeClass(n, this._classes.labelValid), h.removeClass(n, this._classes.labelInvalid), h.addClass(n, this._classes[`label${e}`]);
    });
  }
  _emitEvents(t) {
    if (c.trigger(this._element, l0), t) {
      c.trigger(this._element, c0, {
        value: this._validationResult
      });
      return;
    }
    c.trigger(this._element, h0, {
      value: this._validationResult
    });
  }
  _applyInputEvents() {
    this._validationElements.forEach((t) => {
      const { input: e, element: i } = t;
      c.on(
        e,
        "input",
        () => this._handleInputChange(t)
      ), c.on(
        i,
        "valueChange.te.select",
        () => this._delayedInputChange(t)
      ), c.on(
        i,
        "itemSelect.te.autocomplete",
        () => this._delayedInputChange(t)
      );
    }), this._shouldApplyInputEvents = !1;
  }
  _removeInputEvents() {
    this._validationElements.forEach((t) => {
      const { input: e, element: i } = t;
      c.off(
        e,
        "input",
        () => this._handleInputChange(t)
      ), c.off(
        i,
        "valueChange.te.select",
        () => this._delayedInputChange(t)
      ), c.off(
        i,
        "itemSelect.te.autocomplete",
        () => this._delayedInputChange(t)
      );
    });
  }
  _delayedInputChange(t) {
    setTimeout(() => {
      this._handleInputChange(t);
    }, 10);
  }
  _handleSubmitButton() {
    this._submitButton = d.findOne(
      a0,
      this._element
    ), this._submitButton && c.on(
      this._submitButton,
      "click",
      (t) => this._handleSubmitButtonClick(t)
    );
  }
  _handleSubmitButtonClick(t) {
    if (this._element.setAttribute(Ls, !0), this._config.submitCallback) {
      this._submitCallback = (e) => this._config.submitCallback(t, e);
      return;
    }
  }
  _getConfig(t) {
    return t = {
      ...Gl,
      ...h.getDataAttributes(this._element),
      ...typeof t == "object" && t ? t : {}
    }, I(Do, t, this.constructor.DefaultType), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...p0,
      ...e,
      ...t
    }, I(Do, t, _0), t;
  }
  // Static
  static getInstance(t) {
    return A.getData(t, ir);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static jQueryInterface(t) {
    return this.each(function() {
      const e = jh.getOrCreateInstance(this);
      if (typeof t == "string") {
        if (e[t] === void 0 || t.startsWith("_") || t === "constructor")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
class Qi {
  _getCoordinates(t) {
    const [e] = t.touches;
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  _getDirection({ x: t, y: e }) {
    return {
      x: {
        direction: t < 0 ? "left" : "right",
        value: Math.abs(t)
      },
      y: {
        direction: e < 0 ? "up" : "down",
        value: Math.abs(e)
      }
    };
  }
  _getOrigin({ x: t, y: e }, { x: i, y: n }) {
    return {
      x: t - i,
      y: e - n
    };
  }
  _getDistanceBetweenTwoPoints(t, e, i, n) {
    return Math.hypot(e - t, n - i);
  }
  _getMidPoint({ x1: t, x2: e, y1: i, y2: n }) {
    return {
      x: (t + e) / 2,
      y: (i + n) / 2
    };
  }
  _getVectorLength({ x1: t, x2: e, y1: i, y2: n }) {
    return Math.sqrt((e - t) ** 2 + (n - i) ** 2);
  }
  _getRightMostTouch(t) {
    let e = null;
    const i = Number.MIN_VALUE;
    return t.forEach((n) => {
      n.clientX > i && (e = n);
    }), e;
  }
  _getAngle(t, e, i, n) {
    return Math.atan2(n - e, i - t);
  }
  _getAngularDistance(t, e) {
    return e - t;
  }
  _getCenterXY({ x1: t, x2: e, y1: i, y2: n }) {
    return {
      x: t + (e - t) / 2,
      y: i + (n - i) / 2
    };
  }
  _getPinchTouchOrigin(t) {
    const [e, i] = t, n = {
      x1: e.clientX,
      x2: i.clientX,
      y1: e.clientY,
      y2: i.clientY
    };
    return [this._getVectorLength(n), this._getCenterXY(n)];
  }
  _getPosition({ x1: t, x2: e, y1: i, y2: n }) {
    return { x1: t, x2: e, y1: i, y2: n };
  }
}
const Lo = "press", f0 = "pressup", m0 = {
  time: "number",
  pointers: "number"
}, g0 = {
  time: 250,
  pointers: 1
};
class b0 extends Qi {
  constructor(t, e = {}) {
    super(), this._element = t, this._options = this._getConfig(e), this._timer = null;
  }
  // Getters
  static get NAME() {
    return Lo;
  }
  handleTouchStart(t) {
    const { time: e, pointers: i } = this._options;
    t.touches.length === i && (this._timer = setTimeout(() => {
      c.trigger(this._element, Lo, { touch: t, time: e }), c.trigger(this._element, f0, { touch: t });
    }, e));
  }
  handleTouchEnd() {
    clearTimeout(this._timer);
  }
  _getConfig(t) {
    const e = {
      ...g0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(Lo, e, m0), e;
  }
}
const v0 = "swipe", T0 = {
  threshold: "number",
  direction: "string"
}, E0 = {
  threshold: 10,
  direction: "all"
};
class C0 {
  constructor(t, e) {
    this._element = t, this._startPosition = null, this._options = this._getConfig(e);
  }
  handleTouchStart(t) {
    this._startPosition = this._getCoordinates(t);
  }
  handleTouchMove(t) {
    if (!this._startPosition)
      return;
    const e = this._getCoordinates(t), i = {
      x: e.x - this._startPosition.x,
      y: e.y - this._startPosition.y
    }, n = this._getDirection(i);
    if (this._options.direction === "all") {
      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)
        return;
      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;
      c.trigger(this._element, `swipe${r}`, { touch: t }), c.trigger(this._element, "swipe", { touch: t, direction: r }), this._startPosition = null;
      return;
    }
    const o = this._options.direction === "left" || this._options === "right" ? "x" : "y";
    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (c.trigger(this._element, `swipe${n[o].direction}`, {
      touch: t
    }), this._startPosition = null);
  }
  handleTouchEnd() {
    this._startPosition = null;
  }
  _getCoordinates(t) {
    const [e] = t.touches;
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  _getDirection(t) {
    return {
      x: {
        direction: t.x < 0 ? "left" : "right",
        value: Math.abs(t.x)
      },
      y: {
        direction: t.y < 0 ? "up" : "down",
        value: Math.abs(t.y)
      }
    };
  }
  _getConfig(t) {
    const e = {
      ...E0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(v0, e, T0), e;
  }
}
const Zt = "pan", A0 = `${Zt}start`, y0 = `${Zt}end`, w0 = `${Zt}move`, k0 = "left", x0 = "right", O0 = {
  threshold: "number",
  direction: "string",
  pointers: "number"
}, S0 = {
  threshold: 20,
  direction: "all",
  pointers: 1
};
class I0 extends Qi {
  constructor(t, e = {}) {
    super(), this._element = t, this._options = this._getConfig(e), this._startTouch = null;
  }
  // Getters
  static get NAME() {
    return Zt;
  }
  handleTouchStart(t) {
    this._startTouch = this._getCoordinates(t), this._movedTouch = t, c.trigger(this._element, A0, { touch: t });
  }
  handleTouchMove(t) {
    t.type === "touchmove" && t.preventDefault();
    const { threshold: e, direction: i } = this._options, n = this._getCoordinates(t), o = this._getCoordinates(this._movedTouch), r = this._getOrigin(n, this._startTouch), a = this._getOrigin(n, o), l = this._getDirection(r), p = this._getDirection(a), { x: u, y: _ } = l;
    if (i === "all" && (_.value > e || u.value > e)) {
      const g = _.value > u.value ? _.direction : u.direction;
      c.trigger(this._element, `${Zt}${g}`, { touch: t }), c.trigger(this._element, Zt, {
        ...a,
        touch: t
      });
    }
    const f = i === k0 || i === x0 ? "x" : "y";
    p[f].direction === i && l[f].value > e && c.trigger(this._element, `${Zt}${i}`, {
      touch: t,
      [f]: n[f] - o[f]
    }), this._movedTouch = t, c.trigger(this._element, w0, { touch: t });
  }
  handleTouchEnd(t) {
    t.type === "touchend" && t.preventDefault(), this._movedTouch = null, this._startTouch = null, c.trigger(this._element, y0, { touch: t });
  }
  _getConfig(t) {
    const e = {
      ...S0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(Zt, e, O0), e;
  }
}
const Ue = "pinch", D0 = `${Ue}end`, $0 = `${Ue}start`, L0 = `${Ue}move`, N0 = {
  threshold: "number",
  pointers: "number"
}, M0 = {
  threshold: 10,
  pointers: 2
};
class R0 extends Qi {
  constructor(t, e = {}) {
    super(), this._element = t, this._options = this._getConfig(e), this._startTouch = null, this._origin = null, this._touch = null, this._math = null, this._ratio = null;
  }
  // Getters
  static get NAME() {
    return Ue;
  }
  get isNumber() {
    return typeof this._startTouch == "number" && typeof this._touch == "number" && // eslint-disable-next-line no-restricted-globals
    !isNaN(this._startTouch) && // eslint-disable-next-line no-restricted-globals
    !isNaN(this._touch);
  }
  handleTouchStart(t) {
    if (t.touches.length !== this._options.pointers)
      return;
    t.type === "touchstart" && t.preventDefault();
    const [e, i] = this._getPinchTouchOrigin(t.touches);
    this._touch = e, this._origin = i, this._startTouch = this._touch, c.trigger(this._element, $0, {
      touch: t,
      ratio: this._ratio,
      origin: this._origin
    });
  }
  handleTouchMove(t) {
    const { threshold: e, pointers: i } = this._options;
    t.touches.length === i && (t.type === "touchmove" && t.preventDefault(), this._touch = this._getPinchTouchOrigin(t.touches)[0], this._ratio = this._touch / this._startTouch, this.isNumber && (this._origin.x > e || this._origin.y > e) && (this._startTouch = this._touch, c.trigger(this._element, Ue, {
      touch: t,
      ratio: this._ratio,
      origin: this._origin
    }), c.trigger(this._element, L0, {
      touch: t,
      ratio: this._ratio,
      origin: this._origin
    })));
  }
  handleTouchEnd(t) {
    this.isNumber && (this._startTouch = null, c.trigger(this._element, D0, {
      touch: t,
      ratio: this._ratio,
      origin: this._origin
    }));
  }
  _getConfig(t) {
    const e = {
      ...M0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(Ue, e, N0), e;
  }
}
const No = "tap", P0 = {
  interval: "number",
  time: "number",
  taps: "number",
  pointers: "number"
}, B0 = {
  interval: 500,
  time: 250,
  taps: 1,
  pointers: 1
};
class H0 extends Qi {
  constructor(t, e) {
    super(), this._element = t, this._options = this._getConfig(e), this._timer = null, this._tapCount = 0;
  }
  // Getters
  static get NAME() {
    return No;
  }
  handleTouchStart(t) {
    const { x: e, y: i } = this._getCoordinates(t), { interval: n, taps: o, pointers: r } = this._options;
    return t.touches.length === r && (this._tapCount += 1, this._tapCount === 1 && (this._timer = setTimeout(() => {
      this._tapCount = 0;
    }, n)), this._tapCount === o && (clearTimeout(this._timer), this._tapCount = 0, c.trigger(this._element, No, {
      touch: t,
      origin: {
        x: e,
        y: i
      }
    }))), t;
  }
  handleTouchEnd() {
  }
  handleTouchMove() {
  }
  _getConfig(t) {
    const e = {
      ...B0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(No, e, P0), e;
  }
}
const Wi = "rotate", V0 = `${Wi}end`, W0 = `${Wi}start`, F0 = {
  angle: "number",
  pointers: "number"
}, Y0 = {
  angle: 0,
  pointers: 2
};
class j0 extends Qi {
  constructor(t, e) {
    super(), this._element = t, this._options = this._getConfig(e), this._origin = {};
  }
  // Getters
  static get NAME() {
    return Wi;
  }
  handleTouchStart(t) {
    t.type === "touchstart" && t.preventDefault(), !(t.touches.length < 2) && (this._startTouch = t, this._origin = {}, c.trigger(this._element, W0, { touch: t }));
  }
  handleTouchMove(t) {
    t.type === "touchmove" && t.preventDefault();
    let e, i;
    const n = t.touches;
    if (n.length === 1 && this._options.pointers === 1) {
      const { left: o, top: r, width: a, height: l } = this._element.getBoundingClientRect();
      e = {
        x: o + a / 2,
        y: r + l / 2
      }, i = n[0];
    } else if (t.touches.length === 2 && this._options.pointers === 2) {
      const [o, r] = t.touches, a = {
        x1: r.clientX,
        x2: o.clientX,
        y1: r.clientY,
        y2: o.clientY
      };
      e = this._getMidPoint(a), i = this._getRightMostTouch(t.touches);
    } else
      return;
    this.currentAngle = this._getAngle(
      e.x,
      e.y,
      i.clientX,
      i.clientY
    ), this._origin.initialAngle ? (this._origin.change = this._getAngularDistance(
      this._origin.previousAngle,
      this.currentAngle
    ), this._origin.distance += this._origin.change) : (this._origin.initialAngle = this._origin.previousAngle = this.currentAngle, this._origin.distance = this._origin.change = 0), this._origin.previousAngle = this.currentAngle, this.rotate = {
      currentAngle: this.currentAngle,
      distance: this._origin.distance,
      change: this._origin.change
    }, c.trigger(this._element, Wi, { ...this.rotate, touch: t });
  }
  handleTouchEnd(t) {
    t.type === "touchend" && t.preventDefault(), this._origin = {}, c.trigger(this._element, V0, { touch: t });
  }
  _getConfig(t) {
    const e = {
      ...Y0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(Wi, e, F0), e;
  }
}
const sr = "touch", Mo = `te.${sr}`, K0 = {
  event: "string"
}, z0 = {
  event: "swipe"
};
class Kh {
  constructor(t, e = {}) {
    this._element = t, this._options = this._getConfig(e), this._event = this._options.event, this.swipe = this._event === "swipe" ? new C0(t, e) : null, this.press = this._event === "press" ? new b0(t, e) : null, this.pan = this._event === "pan" ? new I0(t, e) : null, this.pinch = this._event === "pinch" ? new R0(t, e) : null, this.tap = this._event === "tap" ? new H0(t, e) : null, this.rotate = this._event === "rotate" ? new j0(t, e) : null, this._touchStartHandler = (i) => this._handleTouchStart(i), this._touchMoveHandler = (i) => this._handleTouchMove(i), this._touchEndHandler = (i) => this._handleTouchEnd(i), c.on(this._element, "touchstart", this._touchStartHandler), c.on(this._element, "touchmove", this._touchMoveHandler), c.on(this._element, "touchend", this._touchEndHandler), this._element && A.setData(t, Mo, this);
  }
  // Getters
  static get NAME() {
    return sr;
  }
  dispose() {
    c.off(this._element, "touchstart", this._touchStartHandler), c.off(this._element, "touchmove", this._touchMoveHandler), c.off(this._element, "touchend", this._touchEndHandler), this.swipe = null, this.press = null, this.pan = null, this.pinch = null, this.tap = null, this.rotate = null;
  }
  _getConfig(t) {
    const e = {
      ...z0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(sr, e, K0), e;
  }
  _handleTouchStart(t) {
    this[this._event].handleTouchStart(t);
  }
  _handleTouchMove(t) {
    this[this._event].handleTouchMove && this[this._event].handleTouchMove(t);
  }
  _handleTouchEnd(t) {
    this[this._event].handleTouchEnd(t);
  }
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, Mo);
      const i = typeof t == "object" && t;
      if (!(!e && /dispose/.test(t)) && (e || (e = new Kh(this, i)), typeof t == "string")) {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        return e[t];
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, Mo);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const nr = "smoothScroll", Si = `te.${nr}`, Or = `.${Si}`, U0 = {
  container: "string",
  offset: "number",
  easing: "string",
  duration: "number"
}, X0 = {
  container: "body",
  offset: 0,
  easing: "linear",
  duration: 500
}, G0 = `scrollStart${Or}`, q0 = `scrollEnd${Or}`, Z0 = `scrollCancel${Or}`;
class zh {
  constructor(t, e = {}) {
    this._element = t, this._options = this._getConfig(e), this._href = this._element.getAttribute("href"), this.isCancel = !1, this._element && (A.setData(t, Si, this), this._setup());
  }
  // getters
  static get NAME() {
    return nr;
  }
  get isWindow() {
    return this._options.container === "body";
  }
  get containerToScroll() {
    return this.isWindow ? document.documentElement : d.findOne(
      this._options.container,
      document.documentElement
    );
  }
  get elFromHrefExist() {
    return !!d.findOne(this._href, this.containerToScroll);
  }
  get offsetFromEl() {
    const t = this.containerToScroll.scrollTop, e = d.findOne(this._href, this.containerToScroll);
    if (this.isWindow)
      return h.offset(e).top - this._options.offset + t;
    const i = e.getBoundingClientRect().y, n = this.containerToScroll.getBoundingClientRect().y;
    return i - n - this._options.offset + t;
  }
  get easingFunction() {
    const t = this._options.easing, e = `_motion${t[0].toUpperCase()}${t.slice(1)}`;
    return this[e] ? this[e] : this._motionLinear;
  }
  // public
  dispose() {
    c.off(this._element, "click", this._handleClick), A.removeData(this._element, Si), this._element = null;
  }
  cancelScroll() {
    this.isCancel = !0;
  }
  // private
  _getConfig(t) {
    const e = {
      ...X0,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(nr, e, U0), e;
  }
  _inViewport() {
    if (this.isWindow)
      return !0;
    const t = this.containerToScroll.getBoundingClientRect();
    return t.top >= 0 && t.bottom <= (window.innerHeight || document.documentElement.clientHeight);
  }
  _setup() {
    const t = typeof this._href < "u", e = this._href.includes("#");
    t && e && this.elFromHrefExist && (this._scrollOnClickEvent(), this._preventNativeScroll());
  }
  _scrollOnClickEvent() {
    c.on(this._element, "click", (t) => {
      this._handleClick(t);
    });
  }
  _handleClick(t) {
    t.preventDefault(), this.isCancel = !1, c.trigger(this._element, G0);
    const e = this.containerToScroll, i = this.containerToScroll.scrollTop, n = this.offsetFromEl, o = 0, r = 1 / this._options.duration, a = 4.25, l = this.easingFunction;
    this._inViewport() ? this._scrollOnNextTick(
      e,
      i,
      n,
      o,
      r,
      a,
      l
    ) : (this._scrollOnNextTick(
      document.documentElement,
      document.documentElement.scrollTop,
      this.containerToScroll.offsetTop,
      o,
      r,
      a,
      l
    ), setTimeout(() => {
      this._scrollOnNextTick(
        e,
        i,
        n,
        o,
        r,
        a,
        l
      ), this.isCancel = !1;
    }, this._options.duration));
  }
  _scrollOnNextTick(t, e, i, n, o, r, a) {
    const l = n < 0, p = n > 1, u = o <= 0;
    if (l || p || u || this.isCancel) {
      if (this.isCancel) {
        this.isInViewport && (this.isCancel = !1), c.trigger(this._element, Z0);
        return;
      }
      c.trigger(this._element, q0), t.scrollTop = i;
      return;
    }
    t.scrollTo({
      top: e - (e - i) * a(n)
    }), n += o * r, setTimeout(() => {
      this._scrollOnNextTick(
        t,
        e,
        i,
        n,
        o,
        r,
        a
      );
    });
  }
  _preventDefault(t) {
    t.preventDefault();
  }
  _preventNativeScroll() {
    let t = !1;
    try {
      window.addEventListener(
        "test",
        null,
        Object.defineProperty({}, "passive", {
          get: () => t = !0
        })
      );
    } catch (n) {
      this._scrollError = n;
    }
    const e = t ? { passive: !1 } : !1, i = "onwheel" in $("div") ? "wheel" : "mousewheel";
    this.isWindow && (this._deleteScrollOnStart(e, i), this._addScrollOnEnd(e, i), this._addScrollOnCancel(e, i));
  }
  _deleteScrollOnStart(t, e) {
    c.on(this._element, "scrollStart.te.smoothScroll", () => {
      window.addEventListener(e, this._preventDefault, t), window.addEventListener("touchmove", this._preventDefault, t);
    });
  }
  _addScrollOnEnd(t, e) {
    c.on(this._element, "scrollEnd.te.smoothScroll", () => {
      window.removeEventListener(e, this._preventDefault, t), window.removeEventListener("touchmove", this._preventDefault, t);
    });
  }
  _addScrollOnCancel(t, e) {
    c.on(this._element, "scrollCancel.te.smoothScroll", () => {
      window.removeEventListener(e, this._preventDefault, t), window.removeEventListener("touchmove", this._preventDefault, t);
    });
  }
  // Motions
  // Linear
  _motionLinear(t) {
    return t;
  }
  // Ease-In
  _motionEaseInQuad(t) {
    return t * t;
  }
  _motionEaseInCubic(t) {
    return t * t * t;
  }
  _motionEaseInQuart(t) {
    return t * t * t * t;
  }
  _motionEaseInQuint(t) {
    return t * t * t * t * t;
  }
  // Ease-In-Out
  _motionEaseInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }
  _motionEaseInOutCubic(t) {
    return t /= 0.5, t < 1 ? t * t * t / 2 : (t -= 2, (t * t * t + 2) / 2);
  }
  _motionEaseInOutQuart(t) {
    return t /= 0.5, t < 1 ? 0.5 * t * t * t * t : (t -= 2, -(t * t * t * t - 2) / 2);
  }
  _motionEaseInOutQuint(t) {
    return t /= 0.5, t < 1 ? t * t * t * t * t / 2 : (t -= 2, (t * t * t * t * t + 2) / 2);
  }
  // Ease-Out
  _motionEaseOutQuad(t) {
    return -t * (t - 2);
  }
  _motionEaseOutCubic(t) {
    return t--, t * t * t + 1;
  }
  _motionEaseOutQuart(t) {
    return t--, -(t * t * t * t - 1);
  }
  _motionEaseOutQuint(t) {
    return t--, t * t * t * t * t + 1;
  }
  // static
  static getInstance(t) {
    return A.getData(t, Si);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, Si);
      const i = typeof t == "object" && t;
      if (e || (e = new zh(this, i)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const ql = "lazyLoad", Ps = "te.lazyLoad", Q0 = "[data-te-lazy-load-init]", Zl = "data-te-lazy-load", J0 = "onLoad.te.lazy", tC = "onError.te.lazy", Ql = ["img", "video"], eC = {
  lazySrc: "(string|null)",
  lazyDelay: "number",
  lazyAnimation: "string",
  lazyOffset: "number",
  lazyPlaceholder: "(string|undefined)",
  lazyError: "(string|undefined)"
}, iC = {
  lazySrc: null,
  lazyDelay: 500,
  lazyAnimation: "[fade-in_1s_ease-in-out]",
  lazyOffset: 0
};
class or {
  constructor(t, e) {
    this._element = t, this._element && A.setData(t, Ps, this), this._options = this._getConfig(e), this.scrollHandler = this._scrollHandler.bind(this), this.errorHandler = this._setElementError.bind(this), this._childrenInstances = null, this._init();
  }
  // Getters
  static get NAME() {
    return ql;
  }
  get offsetValues() {
    return this._element.getBoundingClientRect();
  }
  get inViewport() {
    if (this.parent) {
      const t = this.parent.getBoundingClientRect();
      return t.y > 0 && t.y < window.innerHeight && this.offsetValues.y >= t.y && this.offsetValues.y <= t.y + t.height && this.offsetValues.y <= window.innerHeight;
    }
    return this.offsetValues.top + this._options.lazyOffset <= window.innerHeight && this.offsetValues.bottom >= 0;
  }
  get parent() {
    const [t] = d.parents(
      this._element,
      Q0
    );
    return t;
  }
  get node() {
    return this._element.nodeName;
  }
  get isContainer() {
    return !d.matches(this._element, Ql);
  }
  // Public
  dispose() {
    A.removeData(this._element, Ps), this._animation && (this._animation.dispose(), this._animation = null), this._element = null, this._childrenInstances && this._childrenInstances.forEach((t) => t.dispose());
  }
  // Private
  _init() {
    if (this._element.setAttribute(Zl, ""), this.isContainer) {
      this._setupContainer();
      return;
    }
    this._setupElement();
  }
  _setupElement() {
    c.one(this._element, "error", this.errorHandler), this._options.lazyPlaceholder && this._setPlaceholder(), this._animation = new wr(this._element, {
      animation: `${this._options.lazyAnimation}`,
      animationStart: "onLoad"
    }), c.one(this._element, "load", () => this._scrollHandler()), this.parent && c.on(this.parent, "scroll", this.scrollHandler), c.on(window, "scroll", this.scrollHandler);
  }
  _scrollHandler() {
    this.inViewport && (this._timeout = setTimeout(() => {
      this._setSrc(), this._element.removeAttribute(Zl), this._removeAttrs(), this._animation.init();
    }, this._options.lazyDelay), this.parent && c.off(this.parent, "scroll", this.scrollHandler), c.off(window, "scroll", this.scrollHandler));
  }
  _setElementError() {
    !this._options.lazyError || this._element.src === this._options.lazyError ? this._element.alt = "404 not found" : this._element.setAttribute("src", this._options.lazyError), c.trigger(this._element, tC);
  }
  _setSrc() {
    this._element.setAttribute("src", this._options.lazySrc), c.trigger(this._element, J0);
  }
  _setPlaceholder() {
    this.node === "IMG" ? this._element.setAttribute("src", this._options.lazyPlaceholder) : this.node === "VIDEO" && this._element.setAttribute("poster", this._options.lazyPlaceholder);
  }
  _removeAttrs() {
    ["src", "delay", "animation", "placeholder", "offset", "error"].forEach(
      (t) => {
        h.removeDataAttribute(this._element, `lazy-${t}`);
      }
    );
  }
  _setupContainer() {
    this._childrenInstances = d.children(
      this._element,
      Ql
    ).map((t) => new or(t, this._options));
  }
  _getConfig(t) {
    const e = {
      ...iC,
      ...t,
      ...h.getDataAttributes(this._element)
    };
    return I(ql, e, eC), e;
  }
  // Static
  static getInstance(t) {
    return A.getData(t, Ps);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, Ps);
      const i = typeof t == "object" && t;
      if (e || (e = new or(this, i)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const Jl = "clipboard", Ii = "te.clipboard", sC = `.${Ii}`, nC = {
  clipboardTarget: null
}, oC = {
  clipboardTarget: "null|string"
}, rC = `copy${sC}`;
class Uh {
  constructor(t, e = {}) {
    this._element = t, this._options = e, this._element && (A.setData(t, Ii, this), this._initCopy = this._initCopy.bind(this), this._setup());
  }
  // Getters
  static get NAME() {
    return Jl;
  }
  get options() {
    const t = {
      ...nC,
      ...h.getDataAttributes(this._element),
      ...this._options
    };
    return I(Jl, t, oC), t;
  }
  get clipboardTarget() {
    return d.findOne(this.options.clipboardTarget);
  }
  get copyText() {
    const t = this.clipboardTarget.hasAttribute(
      "data-te-clipboard-text"
    ), e = this.clipboardTarget.value, i = this.clipboardTarget.textContent;
    return t ? this.clipboardTarget.getAttribute("data-te-clipboard-text") : e || i;
  }
  // Public
  dispose() {
    c.off(this._element, "click", this._initCopy), A.removeData(this._element, Ii), this._element = null;
  }
  // Private
  _setup() {
    c.on(this._element, "click", this._initCopy);
  }
  _initCopy() {
    const t = this._createNewInput();
    document.body.appendChild(t), this._selectInput(t), c.trigger(this._element, rC, {
      copyText: this.copyText
    }), t.remove();
  }
  _createNewInput() {
    const t = this.clipboardTarget.tagName === "TEXTAREA" ? "textarea" : "input", e = $(t);
    return e.value = this.copyText, h.addClass(e, "-left-[9999px] absolute"), e;
  }
  _selectInput(t) {
    t.select(), t.focus(), t.setSelectionRange(0, 99999), document.execCommand("copy");
  }
  // Static
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, Ii);
      const i = typeof t == "object" && t;
      if (e || (e = new Uh(this, i)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, Ii);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const rr = "infiniteScroll", Bs = `te.${rr}`, aC = {
  infiniteDirection: "y"
}, lC = {
  infiniteDirection: "string"
};
class Xh {
  constructor(t, e) {
    this._element = t, this._element && A.setData(t, Bs, this), this._options = this._getConfig(e), this.scrollHandler = this._scrollHandler.bind(this), this._init();
  }
  // Getters
  static get NAME() {
    return rr;
  }
  get rect() {
    return this._element.getBoundingClientRect();
  }
  get condition() {
    return this._element === window ? Math.abs(
      window.scrollY + window.innerHeight - document.documentElement.scrollHeight
    ) < 1 : this._options.infiniteDirection === "x" ? this.rect.width + this._element.scrollLeft + 10 >= this._element.scrollWidth : Math.ceil(this.rect.height + this._element.scrollTop) >= this._element.scrollHeight;
  }
  // Public
  dispose() {
    c.off(this._element, "scroll", this.scrollHandler), A.removeData(this._element, Bs), this._element = null;
  }
  // Private
  _init() {
    c.on(this._element, "scroll", () => this._scrollHandler());
  }
  _scrollHandler() {
    this.condition && c.trigger(this._element, "complete.te.infiniteScroll"), c.off(this._element, "scroll", this.scrollHandler);
  }
  _getConfig(t) {
    const e = {
      ...aC,
      ...this._element !== window ? h.getDataAttributes(this._element) : {},
      ...t
    };
    return I(rr, e, lC), e;
  }
  // Static
  static getInstance(t) {
    return A.getData(t, Bs);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, Bs);
      const i = typeof t == "object" && t;
      if (e || (e = new Xh(this, i)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
function cC({ backdropID: s }, t) {
  const e = $("div");
  return h.addClass(
    e,
    `${t.backdrop} ${t.backdropColor}`
  ), e.id = s, e;
}
const Fi = "loadingManagement", Hs = `te.${Fi}`, hC = "[data-te-loading-icon-ref]", dC = "[data-te-loading-text-ref]", uC = `show.te.${Fi}`, pC = {
  backdrop: "(null|boolean)",
  backdropID: "(null|string|number)",
  delay: "(null|number)",
  loader: "(null|string|number)",
  parentSelector: "(null|string)",
  loadingIcon: "boolean",
  loadingText: "boolean",
  scroll: "boolean"
}, _C = {
  backdrop: !0,
  backdropID: null,
  delay: 0,
  loader: "",
  parentSelector: null,
  scroll: !0,
  loadingText: !0,
  loadingIcon: !0
}, fC = {
  loadingSpinner: "absolute top-[50%] left-[50%] -translate-x-[50%] -translate-y-[50%] flex flex-col justify-center items-center z-40",
  spinnerColor: "text-primary dark:text-primary-400",
  backdrop: "w-full h-full fixed top-0 left-0 bottom-0 right-0 z-30",
  backdropColor: "bg-[rgba(0,0,0,0.4)]"
}, mC = {
  loadingSpinner: "string",
  spinnerColor: "string",
  backdrop: "string",
  backdropColor: "string"
};
class Gh {
  constructor(t, e = {}, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._element && A.setData(t, Hs, this), this._backdropElement = null, this._parentElement = d.findOne(this._options.parentSelector), this._loadingIcon = d.findOne(
      hC,
      this._element
    ), this._loadingText = d.findOne(
      dC,
      this._element
    ), this.init();
  }
  // Getters
  static get NAME() {
    return Fi;
  }
  // Public
  init() {
    const t = this._loadingIcon.cloneNode(!0), e = this._loadingText.cloneNode(!0);
    this._removeElementsOnStart(), setTimeout(() => {
      h.addClass(
        this._element,
        `${this._classes.loadingSpinner} ${this._classes.spinnerColor}`
      ), this._setBackdrop(), this._setLoadingIcon(t), this._setLoadingText(e), this._setScrollOption(), c.trigger(this._element, uC);
    }, this._options.delay);
  }
  dispose() {
    A.removeData(this._element, Hs), h.removeClass(
      this._element,
      `${this._classes.loadingSpinner} ${this._classes.spinnerColor}`
    );
    const t = this._options.delay;
    setTimeout(() => {
      this._removeBackdrop(), this._backdropElement = null, this._element = null, this._options = null;
    }, t);
  }
  // Private
  _setBackdrop() {
    const { backdrop: t } = this._options;
    t && (this._backdropElement = cC(this._options, this._classes), this._parentElement !== null ? (h.addClass(this._element, "absolute"), h.addClass(this._parentElement, "relative"), h.addClass(this._backdropElement, "absolute"), this._parentElement.appendChild(this._backdropElement)) : (h.addClass(this._element, "!fixed"), document.body.appendChild(this._backdropElement), document.body.appendChild(this._element)));
  }
  _removeBackdrop() {
    const { backdrop: t } = this._options;
    t && (this._parentElement !== null ? (h.removeClass(this._element, "absolute"), h.removeClass(this._parentElement, "relative"), this._backdropElement.remove()) : (this._backdropElement.remove(), this._element.remove()));
  }
  _setLoadingIcon(t) {
    if (!this._options.loadingIcon) {
      t.remove();
      return;
    }
    this._element.appendChild(t), t.id = this._options.loader;
  }
  _setLoadingText(t) {
    if (!this._options.loadingText) {
      t.remove();
      return;
    }
    this._element.appendChild(t);
  }
  _removeElementsOnStart() {
    this._element !== null && (this._loadingIcon.remove(), this._loadingText.remove());
  }
  _setScrollOption() {
    if (this._options.scroll) {
      if (this._parentElement === null) {
        h.addClass(document.body, "overflow-auto");
        return;
      }
      h.addClass(this._parentElement, "overflow-auto");
    } else {
      if (this._parentElement === null) {
        h.addClass(document.body, "overflow-hidden");
        return;
      }
      h.addClass(this._parentElement, "overflow-hidden");
    }
  }
  _getConfig(t) {
    const e = {
      ..._C,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(Fi, e, pC), e;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...fC,
      ...e,
      ...t
    }, I(Fi, t, mC), t;
  }
  // Static
  static getInstance(t) {
    return A.getData(t, Hs);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
  static jQueryInterface(t) {
    return this.each(function() {
      let e = A.getData(this, Hs);
      const i = typeof t == "object" && t;
      if (e || (e = new Gh(this, i)), typeof t == "string") {
        if (typeof e[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        e[t](this);
      }
    });
  }
}
const gC = (s) => {
  const t = /^(0?[1-9]|1[012])(:[0-5]\d) [APap][mM]$/, e = /^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/;
  return s.match(t) || s.match(e);
}, bC = (s) => s && Object.prototype.toString.call(s) === "[object Date]" && !isNaN(s), vC = (s) => s.getMonth(), TC = (s) => s.getFullYear(), EC = (s) => s.match(/[^(dmy)]{1,}/g), CC = (s, t, e, i) => {
  let n;
  e[0] !== e[1] ? n = e[0] + e[1] : n = e[0];
  const o = new RegExp(`[${n}]`), r = s.split(o), a = t.split(o), l = t.indexOf("mmm") !== -1, p = [];
  for (let b = 0; b < a.length; b++)
    a[b].indexOf("yy") !== -1 && (p[0] = { value: r[b], format: a[b] }), a[b].indexOf("m") !== -1 && (p[1] = { value: r[b], format: a[b] }), a[b].indexOf("d") !== -1 && a[b].length <= 2 && (p[2] = { value: r[b], format: a[b] });
  let u;
  t.indexOf("mmmm") !== -1 ? u = i.monthsFull : u = i.monthsShort;
  const _ = Number(p[0].value), f = l ? AC(p[1].value, u) : Number(p[1].value) - 1, g = Number(p[2].value);
  return Ct(_, f, g);
}, AC = (s, t) => t.findIndex((e) => e === s), yC = (s, t, e) => `
  <button type="button" class="${e.pickerIcon}" data-te-datepicker-toggle-button-ref>
    ${s}
  </button>
  <button type="button" class="${e.pickerIcon}" data-te-timepicker-toggle-button-ref>
    ${t}
  </button>
`, wC = (s, t) => `
  <button type="button" class="${t.toggleButton}" data-te-date-timepicker-toggle-ref>
    ${s} 
  </button>
`, on = "datetimepicker", Di = `te.${on}`, Sr = `.${Di}`, qh = "data-te-datepicker-init", Zh = "data-te-timepicker-init", kC = "data-te-datepicker-header", xC = "data-te-datepicker-cancel-button-ref", OC = "data-te-datepicker-ok-button-ref", Ro = "data-te-timepicker-wrapper", tc = "data-te-timepicker-cancel", SC = "data-te-timepicker-submit", IC = "data-te-timepicker-clear", ec = "data-te-buttons-timepicker", DC = "data-te-date-timepicker-toggle-ref", $C = "data-te-datepicker-toggle-button-ref", LC = "data-te-timepicker-toggle-button-ref", NC = `[${Zh}]`, MC = `[${qh}]`, RC = `[${DC}]`, PC = `[${LC}]`, BC = "[data-te-input-notch-ref]", HC = "[data-te-date-timepicker-toggle-ref]", VC = "[data-te-timepicker-elements-wrapper]", WC = "[data-te-timepicker-clock-wrapper]", FC = `open${Sr}`, YC = `close${Sr}`, jC = `datetimeChange${Sr}`, ic = "close.te.datepicker", sc = "input.te.timepicker", Re = $("div"), nc = {
  inline: !1,
  toggleButton: !0,
  container: "body",
  disabled: !1,
  disablePast: !1,
  disableFuture: !1,
  defaultTime: "",
  defaultDate: "",
  timepicker: {},
  datepicker: {},
  showFormat: !1,
  dateTimepickerToggleIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
  <path fill-rule="evenodd" d="M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z" clip-rule="evenodd" />
  </svg>`,
  datepickerToggleIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
  <path fill-rule="evenodd" d="M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z" clip-rule="evenodd" />
  </svg>`,
  timepickerToggleIconTemplate: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>`
}, KC = {
  inline: "boolean",
  toggleButton: "boolean",
  container: "string",
  disabled: "boolean",
  disablePast: "boolean",
  disableFuture: "boolean",
  defaultTime: "(string|date|number)",
  defaultDate: "(string|date|number)",
  timepicker: "object",
  datepicker: "object",
  showFormat: "boolean",
  dateTimepickerToggleIconTemplate: "string",
  datepickerToggleIconTemplate: "string",
  timepickerToggleIconTemplate: "string"
}, zC = {
  toggleButton: "flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200",
  pickerIcon: "[&>svg]:w-6 [&>svg]:h-6 [&>svg]:mx-auto [&>svg]:pointer-events-none w-1/2 px-1.5 py-[1px] rounded-[10px] min-h-[40px] cursor-pointer outline-none border-none text-white hover:bg-primary-600 dark:hover:bg-neutral-600",
  buttonsContainer: "flex justify-evenly items-end bg-primary dark:bg-zinc-800 dark:data-[te-buttons-timepicker]:bg-zinc-700",
  timepicker: {},
  datepicker: {}
}, UC = {
  toggleButton: "string",
  pickerIcon: "string",
  buttonsContainer: "string",
  timepicker: "object",
  datepicker: "object"
};
class Qh {
  constructor(t, e, i) {
    this._element = t, this._input = d.findOne("input", this._element), this._options = this._getConfig(e), this._classes = this._getClasses(i), this._timepicker = null, this._datepicker = null, this._dateValue = this._options.defaultDate ? this._options.defaultDate : "", this._timeValue = this._options.defaultTime ? this._options.defaultTime : "", this._isInvalidTimeFormat = !1, this._format = this._options.datepicker.format ? this._options.datepicker.format : "dd/mm/yyyy", this._cancel = !1, this._scrollBar = new ti(), this._element && A.setData(t, Di, this), this._init();
  }
  // Getters
  static get NAME() {
    return on;
  }
  get toggleButton() {
    return d.findOne(RC, this._element);
  }
  get notch() {
    return d.findOne(BC, this._element);
  }
  dispose() {
    c.off(this._element, "click", this._openDatePicker), c.off(this._input, "input", this._handleInput), c.off(this._element, "click"), A.removeData(this._element, Di), this._removeTimePicker(), this._removeDatepicker(), this.toggleButton.remove(), this._options = nc, this._timepicker = null, this._datepicker = null, this._dateValue = null, this._timeValue = null, this._isInvalidTimeFormat = null;
  }
  update(t = {}) {
    const e = this._getConfig({ ...this._options, ...t });
    this.dispose(), this._options = e, this._init();
  }
  // Private
  _init() {
    this._addDatepicker(), this._addTimePicker(), this._appendToggleButton(), this._listenToToggleClick(), this._listenToUserInput(), this._disableInput(), this._setInitialDefaultInput(), this._applyFormatPlaceholder(), this._options.disablePast && this._handleTimepickerDisablePast(), this._options.disableFuture && this._handleTimepickerDisableFuture();
  }
  _removeDatepicker() {
    const t = this._element.querySelector(MC);
    t && t.remove();
  }
  _addDatepicker() {
    const t = $("div");
    t.id = this._element.id ? `datepicker-${this._element.id}` : et("datepicker-");
    const e = '<input type="text">';
    t.innerHTML = e, t.setAttribute(qh, ""), this._element.appendChild(t), h.addClass(t, "hidden");
    let i = {
      ...this._options.datepicker,
      container: this._options.container,
      disablePast: this._options.disablePast,
      disableFuture: this._options.disableFuture
    };
    (this._options.inline || this._options.datepicker.inline) && (i = { ...i, inline: !0 }), this._datepicker = new og(t, i, {
      ...this._classes.datepicker
    }), this._datepicker._input.value = this._dateValue;
  }
  _removeTimePicker() {
    const t = this._element.querySelector(NC);
    t && (t.remove(), this._scrollBar.reset());
  }
  _addTimePicker() {
    const t = $("div");
    t.id = this._element.id ? `timepicker-${this._element.id}` : et("timepicker-");
    const e = '<input type="text">';
    t.innerHTML = e, t.setAttribute(Zh, ""), this._element.appendChild(t), h.addClass(t, "hidden");
    let i = {
      ...this._options.timepicker,
      container: this._options.container
    };
    (this._options.inline || this._options.timepicker.inline) && (i = { ...i, inline: !0 }), this._timepicker = new Sg(t, i, {
      ...this._classes.timepicker
    }), this._timepicker.input.value = this._timeValue;
  }
  _addIconButtons() {
    if (h.addClass(Re, this._classes.buttonsContainer), Re.innerHTML = yC(
      this._options.datepickerToggleIconTemplate,
      this._options.timepickerToggleIconTemplate,
      this._classes
    ), Re.removeAttribute(ec), !(this._options.inline || this._options.datepicker.inline)) {
      if (this._scrollBar.hide(), this._datepicker._isOpen)
        d.findOne(
          `[${kC}]`,
          document.body
        ).appendChild(Re);
      else if (this._timepicker._modal && !this._options.timepicker.inline) {
        const t = d.findOne(
          VC,
          document.body
        ), e = d.findOne(
          WC,
          document.body
        );
        Re.setAttribute(ec, ""), t.insertBefore(Re, e);
      }
    }
  }
  _enableOrDisableToggleButton() {
    this._options.disabled ? (this.toggleButton.disabled = !0, h.addClass(this.toggleButton, "pointer-events-none")) : (this.toggleButton.disabled = !1, h.removeClass(this.toggleButton, "pointer-events-none"));
  }
  _appendToggleButton() {
    this._options.toggleButton && (this._element.insertAdjacentHTML(
      "beforeend",
      wC(
        this._options.dateTimepickerToggleIconTemplate,
        this._classes
      )
    ), this._enableOrDisableToggleButton());
  }
  _applyFormatPlaceholder() {
    this._options.showFormat && (this._input.placeholder = this._format);
  }
  _listenToCancelClick() {
    const t = d.findOne(
      `[${xC}]`,
      document.body
    );
    c.one(t, "mousedown", () => {
      this._cancel = !0, this._scrollBar.reset(), c.off(t, "mousedown");
    });
  }
  _listenToToggleClick() {
    c.on(this._element, "click", HC, (t) => {
      t.preventDefault(), this._openDatePicker();
    });
  }
  _listenToUserInput() {
    c.on(this._input, "input", (t) => {
      this._handleInput(t.target.value);
    });
  }
  _disableInput() {
    this._options.disabled && (this._input.disabled = "true");
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...nc,
      ...e,
      ...t
    }, I(on, t, KC), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...zC,
      ...e,
      ...t
    }, I(on, t, UC), t;
  }
  _handleInput(t) {
    const e = t.split(", "), i = EC(this._format), n = e[0], o = e[1] || "", r = CC(
      n,
      this._format,
      i,
      this._datepicker._options
    );
    e.length === 2 && (bC(r) && gC(o) ? (this._dateValue = n, this._timeValue = o, this._datepicker._input.value = this._dateValue, this._datepicker._activeDate = this._dateValue, this._datepicker._selectedYear = TC(r), this._datepicker._selectedMonth = vC(r), this._datepicker._headerDate = r, this._timepicker.input.value = this._timeValue, this._timepicker._isInvalidTimeFormat = !1) : (this._datepicker._activeDate = /* @__PURE__ */ new Date(), this._datepicker._selectedDate = null, this._datepicker._selectedMonth = null, this._datepicker._selectedYear = null, this._datepicker._headerDate = null, this._datepicker._headerMonth = null, this._datepicker._headerYear = null, this._timepicker._isInvalidTimeFormat = !0));
  }
  _openDatePicker() {
    if (c.trigger(this._element, FC).defaultPrevented)
      return;
    this._datepicker.open(), this._options.inline || this._scrollBar.hide(), (this._options.inline || this._options.datepicker.inline) && this._openDropdownDate(), this._addIconButtons(), this._listenToCancelClick(), this._options.inline && this._datepicker._isOpen && h.addClass(this.toggleButton, "pointer-events-none"), c.one(this._datepicker._element, ic, () => {
      if (this._dateValue = this._datepicker._input.value, this._updateInputValue(), this._cancel) {
        this._cancel = !1;
        return;
      }
      let i = !1;
      c.on(this._datepicker.container, "click", (n) => {
        !this._datepicker._selectedDate && n.target.hasAttribute(OC) || i || (this._openTimePicker(), i = !0, setTimeout(() => {
          i = !1;
        }, 500));
      }), setTimeout(() => {
        d.findOne(
          `[${Ro}]`,
          document.body
        ) || this._scrollBar.reset();
      }, 10), this._options.inline && h.removeClass(this.toggleButton, "pointer-events-none");
    });
    const e = d.findOne(
      PC,
      document.body
    );
    c.on(e, "click", () => {
      this._datepicker.close(), this._scrollBar.hide(), c.trigger(this._datepicker._element, ic);
    });
  }
  _handleTimepickerDisablePast() {
    const t = /* @__PURE__ */ new Date();
    t.setHours(0, 0, 0, 0), c.on(
      this._datepicker._element,
      "dateChange.te.datepicker",
      () => {
        this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({ disablePast: !0 }) : this._timepicker.update({ disablePast: !1 });
      }
    );
  }
  _handleTimepickerDisableFuture() {
    const t = /* @__PURE__ */ new Date();
    t.setHours(0, 0, 0, 0), c.on(
      this._datepicker._element,
      "dateChange.te.datepicker",
      () => {
        this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({ disableFuture: !0 }) : this._timepicker.update({ disableFuture: !1 });
      }
    );
  }
  _handleEscapeKey() {
    c.one(document.body, "keyup", () => {
      setTimeout(() => {
        d.findOne(
          `[${Ro}]`,
          document.body
        ) || this._scrollBar.reset();
      }, 250);
    });
  }
  _handleCancelButton() {
    const t = d.findOne(
      `[${tc}]`,
      document.body
    );
    c.one(t, "mousedown", () => {
      this._scrollBar.reset();
    });
  }
  _openDropdownDate() {
    const t = this._datepicker._popper;
    t.state.elements.reference = this._input, this._scrollBar.reset();
  }
  _openTimePicker() {
    c.trigger(this._timepicker.elementToggle, "click"), setTimeout(() => {
      if (this._addIconButtons(), (this._options.inline || this._options.timepicker.inline) && this._openDropdownTime(), this._timepicker._modal) {
        const t = d.findOne(
          `[${tc}]`,
          document.body
        );
        this._handleEscapeKey(), this._handleCancelButton(), c.on(this._timepicker._modal, "click", (e) => {
          (e.target.hasAttribute(Ro) || e.target.hasAttribute(SC)) && setTimeout(() => {
            this._scrollBar.reset();
          }, 200), e.target.hasAttribute(IC) && c.trigger(
            this._timepicker._element,
            sc
          ), e.target.hasAttribute($C) && (c.trigger(t, "click"), setTimeout(() => {
            this._openDatePicker(), this._scrollBar.hide();
          }, 200));
        });
      }
    }), c.one(this._timepicker._element, sc, () => {
      this._timeValue = this._timepicker.input.value, this._updateInputValue(), c.trigger(this._element, YC);
    });
  }
  _openDropdownTime() {
    const t = this._timepicker._popper;
    t.state.elements.reference = this._input, t.update(), this._scrollBar.reset();
  }
  _setInitialDefaultInput() {
    (this._options.defaultDate || this._options.defaultTime) && this._updateInputValue();
  }
  _updateInputValue() {
    this._timeValue && this._dateValue && (this._input.value = `${this._dateValue}, ${this._timeValue}`, c.trigger(
      this._element,
      jC,
      { value: this._input.value }
    ).defaultPrevented) || (c.trigger(this._input, "focus"), this.notch && this.notch.removeAttribute("data-te-input-focused"));
  }
  // static
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, Di);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new Qh(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, Di);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const rn = "sticky", $i = `te.${rn}`, Jh = `.${$i}`, XC = `active${Jh}`, GC = `inactive${Jh}`, qC = {
  stickyAnimationSticky: "",
  stickyAnimationUnsticky: "",
  stickyBoundary: !1,
  stickyDelay: 0,
  stickyDirection: "down",
  stickyMedia: 0,
  stickyOffset: 0,
  stickyPosition: "top",
  stickyZIndex: 100
}, ZC = {
  stickyAnimationSticky: "string",
  stickyAnimationUnsticky: "string",
  stickyBoundary: "(boolean|string)",
  stickyDelay: "number",
  stickyDirection: "string",
  stickyMedia: "number",
  stickyOffset: "number",
  stickyPosition: "string",
  stickyZIndex: "(string|number)"
}, QC = {
  stickyActive: ""
}, JC = {
  stickyActive: "string"
};
class td {
  constructor(t, e, i) {
    this._element = t, this._hiddenElement = null, this._elementPositionStyles = {}, this._scrollDirection = "", this._isSticked = !1, this._elementOffsetTop = null, this._scrollTop = 0, this._pushPoint = "", this._manuallyDeactivated = !1, this._element && (this._options = this._getConfig(e), this._classes = this._getClasses(i), A.setData(t, $i, this), this._init());
  }
  // Getters
  static get NAME() {
    return rn;
  }
  // Public
  dispose() {
    const { stickyAnimationUnsticky: t } = this._options;
    let { animationDuration: e } = getComputedStyle(this._element);
    e = t !== "" ? parseFloat(e) * 1e3 : 0, this._disableSticky(), setTimeout(() => {
      A.removeData(this._element, $i), this._element = null, this._options = null, this._hiddenElement = null, this._elementPositionStyles = null, this._scrollDirection = null, this._isSticked = null, this._elementOffsetTop = null, this._scrollTop = null, this._pushPoint = null, this._manuallyDeactivated = null;
    }, e);
  }
  active() {
    this._isSticked || (this._createHiddenElement(), this._enableSticky(), this._changeBoundaryPosition(), this._isSticked = !0, this._manuallyDeactivated = !1);
  }
  inactive() {
    this._isSticked && (this._disableSticky(), this._isSticked = !1, this._manuallyDeactivated = !0);
  }
  // Private
  _init() {
    this._userActivityListener();
  }
  _userActivityListener() {
    c.on(window, "resize", () => {
      this._updateElementPosition(), this._updateElementOffset();
    }), c.on(window, "scroll", () => {
      if (!this._element || window.innerWidth <= this._options.stickyMedia || this._manuallyDeactivated)
        return;
      const t = document.documentElement, { stickyDirection: e } = this._options, i = window.pageYOffset || t.scrollTop;
      this._updateElementOffset(), this._updatePushPoint(), this._updateScrollDirection(i), this._clearInProgressAnimations();
      const n = [this._scrollDirection, "both"].includes(
        e
      ), o = this._pushPoint <= i, r = o && !this._isSticked && n, a = (!o || !n) && this._isSticked;
      r && (this._createHiddenElement(), this._enableSticky(), this._changeBoundaryPosition(), this._isSticked = !0), a && (this._disableSticky(), this._isSticked = !1), this._isSticked && (this._updatePosition({ styles: this._elementPositionStyles }), this._changeBoundaryPosition()), this._scrollTop = i <= 0 ? 0 : i;
    });
  }
  _updatePushPoint() {
    this._options.stickyPosition === "top" ? this._pushPoint = this._elementOffsetTop - this._options.stickyDelay : this._pushPoint = this._elementOffsetTop + this._element.height - document.body.scrollHeight + this._options.stickyDelay;
  }
  _updateElementOffset() {
    this._hiddenElement ? this._elementOffsetTop = this._hiddenElement.offsetTop : this._elementOffsetTop = this._element.offsetTop, this._options.stickyAnimationUnsticky && (this._elementOffsetTop += this._element.height || 0);
  }
  _updateElementPosition() {
    if (this._hiddenElement) {
      const { left: t } = this._hiddenElement.getBoundingClientRect();
      this._elementPositionStyles = {
        left: `${t}px`
      };
    } else
      this._elementPositionStyles = {};
    this._setStyle(this._element, this._elementPositionStyles);
  }
  _updateScrollDirection(t) {
    t > this._scrollTop ? this._scrollDirection = "down" : this._scrollDirection = "up";
  }
  _clearInProgressAnimations() {
    const t = this._scrollDirection === "up", e = this._element.classList.contains(
      this._options.stickyAnimationUnsticky
    ), i = window.scrollY <= this._elementOffsetTop - this._element.height;
    t && e && i && (this._removeUnstickyAnimation(), this._resetStyles(), this._removeHiddenElement());
  }
  _enableSticky() {
    const {
      stickyAnimationSticky: t,
      stickyAnimationUnsticky: e,
      stickyOffset: i,
      stickyPosition: n,
      stickyZIndex: o
    } = this._options, { height: r, left: a, width: l } = this._element.getBoundingClientRect();
    t !== "" && this._toggleClass(
      t,
      e,
      this._element
    ), this._toggleClass(this._classes.stickyActive, "", this._element), this._setStyle(this._element, {
      top: n === "top" && `${0 + i}px`,
      bottom: n === "bottom" && `${0 + i}px`,
      height: `${r}px`,
      width: `${l}px`,
      left: `${a}px`,
      zIndex: `${o}`,
      position: "fixed"
    }), this._hiddenElement.hidden = !1, c.trigger(this._element, XC);
  }
  _changeBoundaryPosition() {
    const { stickyPosition: t, stickyBoundary: e, stickyOffset: i } = this._options, { height: n } = this._element.getBoundingClientRect(), o = {
      height: this._element.parentElement.getBoundingClientRect().height,
      ...this._getOffset(this._element.parentElement)
    };
    let r;
    const a = d.findOne(e);
    a ? r = this._getOffset(a).top - n - i : r = o.height + o[t] - n - i;
    const l = t === "top", p = t === "bottom", u = e, _ = r < 0, f = r > o.height - n;
    let g;
    l && (_ && u ? g = { top: `${i + r}px` } : g = { top: `${i + 0}px` }), p && (_ && u ? g = { bottom: `${i + r}px` } : f && u ? g = { bottom: `${i + o.bottom}px` } : g = { bottom: `${i + 0}px` }), this._setStyle(this._element, g);
  }
  _disableSticky() {
    const { stickyAnimationUnsticky: t, stickyAnimationSticky: e } = this._options;
    let { animationDuration: i } = getComputedStyle(this._element);
    i = t !== "" ? parseFloat(i) * 1e3 : 0, this._options.stickyAnimationUnsticky !== "" && this._toggleClass(
      t,
      e,
      this._element
    ), setTimeout(() => {
      this._element.classList.contains(e) || (this._removeUnstickyAnimation(), this._resetStyles(), this._removeHiddenElement(), this._toggleClass("", this._classes.stickyActive, this._element), c.trigger(this._element, GC));
    }, i);
  }
  _createHiddenElement() {
    this._hiddenElement || (this._hiddenElement = this._copyElement(this._element));
  }
  _removeHiddenElement() {
    this._hiddenElement && (this._hiddenElement.remove(), this._hiddenElement = null);
  }
  _removeUnstickyAnimation() {
    this._toggleClass("", this._options.stickyAnimationUnsticky, this._element);
  }
  _resetStyles() {
    this._setStyle(this._element, {
      top: null,
      bottom: null,
      position: null,
      left: null,
      zIndex: null,
      width: null,
      height: null
    });
  }
  _updatePosition({ styles: t }) {
    this._setStyle(this._element, t);
  }
  _toggleClass(t, e, i) {
    t && h.addClass(i, t), e && h.removeClass(i, e);
  }
  _getOffset(t) {
    const e = h.offset(t), i = t.getBoundingClientRect(), n = e.left === 0 && e.top === 0 ? 0 : window.innerHeight - i.bottom;
    return {
      ...e,
      bottom: n
    };
  }
  _copyElement(t) {
    const { height: e, width: i } = t.getBoundingClientRect(), n = t.cloneNode(!1);
    return n.hidden = !0, this._setStyle(n, {
      height: `${e}px`,
      width: `${i}px`,
      opacity: "0"
    }), t.parentElement.insertBefore(n, t), n;
  }
  _getConfig(t = {}) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...qC,
      ...e,
      ...t
    }, I(rn, t, ZC), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...QC,
      ...e,
      ...t
    }, I(rn, t, JC), t;
  }
  _setStyle(t, e) {
    Object.keys(e).forEach((i) => {
      t.style[i] = e[i];
    });
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, $i);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose|hide/.test(t)) && (i || (i = new td(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, $i);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const tA = "data-te-autocomplete-dropdown-ref", eA = "data-te-autocomplete-items-list-ref", iA = "data-te-autocomplete-item-ref", sA = "data-te-autocomplete-loader-ref";
function nA(s, t) {
  const { id: e, items: i, width: n, options: o } = s, r = $("div");
  h.addClass(r, t.dropdownContainer), h.addStyle(r, { width: `${n}px` }), r.setAttribute("id", e);
  const a = $("div");
  a.setAttribute(tA, ""), h.addClass(a, t.dropdown);
  const l = $("ul"), p = o.listHeight;
  l.setAttribute(eA, ""), h.addClass(l, t.autocompleteList), h.addClass(l, t.scrollbar), h.addStyle(l, { maxHeight: `${p}px` }), l.setAttribute("role", "listbox");
  const u = ed(i, o);
  return l.innerHTML = u, a.appendChild(l), r.appendChild(a), r;
}
function ed(s = [], t, e) {
  const i = t.displayValue, n = t.itemContent;
  return `
    ${s.map((o, r) => {
    const a = typeof n == "function" ? pn(n(o), sh, null) : i(o);
    return `<li data-te-index="${r}" role="option" class="${e}" ${iA} >${a}</li>`;
  }).join("")}
  `;
}
function oA(s) {
  const t = $("div");
  t.setAttribute(sA, ""), h.addClass(t, s.autocompleteLoader), h.addClass(t, s.spinnerIcon), t.setAttribute("role", "status");
  const e = '<span class="absolute -m-px h-px w-px overflow-hidden whitespace-nowrap border-0 p-0 [clip:rect(0,0,0,0)]">Loading...</span>';
  return t.innerHTML = e, t;
}
function rA(s, t) {
  return `<li class="${t.autocompleteItem}">${s}</li>`;
}
const Po = "autocomplete", Li = "te.autocomplete", Pe = "data-te-input-state-active", Bo = "data-te-autocomplete-item-active", oc = "data-te-input-focused", rc = "data-te-autocomplete-state-open", aA = "data-te-autocomplete-custom-content-ref", lA = "[data-te-autocomplete-dropdown-ref]", Vs = "[data-te-autocomplete-items-list-ref]", ac = "[data-te-autocomplete-item-ref]", cA = "[data-te-autocomplete-loader-ref]", hA = `[${aA}]`, dA = "[data-te-input-notch-ref]", wn = `.${Li}`, uA = `close${wn}`, pA = `open${wn}`, lc = `itemSelect${wn}`, _A = `update${wn}`, fA = {
  autoSelect: !1,
  container: "body",
  customContent: "",
  debounce: 300,
  displayValue: (s) => s,
  filter: null,
  itemContent: null,
  listHeight: 190,
  loaderCloseDelay: 300,
  noResults: "No results found",
  threshold: 0
}, mA = {
  autoSelect: "boolean",
  container: "string",
  customContent: "string",
  debounce: "number",
  displayValue: "function",
  filter: "(null|function)",
  itemContent: "(null|function)",
  listHeight: "number",
  loaderCloseDelay: "number",
  noResults: "string",
  threshold: "number"
}, gA = {
  autocompleteItem: "flex flex-row items-center justify-between w-full px-4 py-[0.4375rem] truncate text-gray-700 bg-transparent select-none cursor-pointer hover:[&:not([data-te-autocomplete-option-disabled])]:bg-black/5 data-[te-autocomplete-item-active]:bg-black/5 data-[data-te-autocomplete-option-disabled]:text-gray-400 data-[data-te-autocomplete-option-disabled]:cursor-default dark:text-gray-200 dark:hover:[&:not([data-te-autocomplete-option-disabled])]:bg-white/30 dark:data-[te-autocomplete-item-active]:bg-white/30",
  autocompleteList: "list-none m-0 p-0 overflow-y-auto",
  autocompleteLoader: "absolute right-1 top-2 w-[1.4rem] h-[1.4rem] border-[0.15em]",
  dropdown: "relative outline-none min-w-[100px] m-0 scale-y-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-autocomplete-state-open]:scale-y-100 data-[te-autocomplete-state-open]:opacity-100 dark:bg-zinc-700",
  dropdownContainer: "z-[1070]",
  scrollbar: "[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded",
  spinnerIcon: "inline-block h-8 w-8 animate-spin rounded-full border-4 border-solid border-current border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]"
}, bA = {
  autocompleteItem: "string",
  autocompleteList: "string",
  autocompleteLoader: "string",
  dropdown: "string",
  dropdownContainer: "string",
  scrollbar: "string",
  spinnerIcon: "string"
};
class id {
  constructor(t, e, i) {
    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._getContainer(), this._input = d.findOne("input", t), this._notch = d.findOne(dA, t), this._customContent = d.findOne(
      hA,
      t
    ), this._loader = oA(this._classes), this._popper = null, this._debounceTimeoutId = null, this._loaderTimeout = null, this._activeItemIndex = -1, this._activeItem = null, this._filteredResults = null, this._lastQueryValue = null, this._canOpenOnFocus = !0, this._isOpen = !1, this._outsideClickHandler = this._handleOutsideClick.bind(this), this._inputFocusHandler = this._handleInputFocus.bind(this), this._userInputHandler = this._handleUserInput.bind(this), this._keydownHandler = this._handleKeydown.bind(this), t && A.setData(t, Li, this), this._init();
  }
  static get NAME() {
    return Po;
  }
  get filter() {
    return this._options.filter;
  }
  get dropdown() {
    return d.findOne(lA, this._dropdownContainer);
  }
  get items() {
    return d.find(ac, this._dropdownContainer);
  }
  get itemsList() {
    return d.findOne(Vs, this._dropdownContainer);
  }
  initSearch(t) {
    this._filterResults(t);
  }
  _getContainer() {
    this._container = d.findOne(this._options.container);
  }
  _getConfig(t) {
    const e = h.getDataAttributes(this._element);
    return t = {
      ...fA,
      ...e,
      ...t
    }, I(Po, t, mA), t;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...gA,
      ...e,
      ...t
    }, I(Po, t, bA), t;
  }
  _init() {
    this._initDropdown(), this._updateInputState(), this._setInputAriaAttributes(), this._listenToInputFocus(), this._listenToUserInput(), this._listenToKeydown();
  }
  _initDropdown() {
    this._dropdownContainerId = this._element.id ? `autocomplete-dropdown-${this._element.id}` : et("autocomplete-dropdown-");
    const t = {
      id: this._dropdownContainerId,
      items: [],
      width: this._input.offsetWidth,
      options: this._options
    };
    if (this._dropdownContainer = nA(t, this._classes), this._options.customContent !== "") {
      const e = this._options.customContent, i = pn(
        e,
        sh,
        null
      );
      this.dropdown.insertAdjacentHTML("beforeend", i);
    }
  }
  _setInputAriaAttributes() {
    this._input.setAttribute("role", "combobox"), this._input.setAttribute("aria-expanded", !1), this._input.setAttribute("aria-owns", this._dropdownContainerId), this._input.setAttribute("aria-haspopup", !0), this._input.setAttribute("autocomplete", "off");
  }
  _updateInputState() {
    var t, e;
    this._input.value !== "" || this._isOpen ? (this._input.setAttribute(Pe, ""), (t = this._notch) == null || t.setAttribute(Pe, "")) : (this._input.removeAttribute(Pe), (e = this._notch) == null || e.removeAttribute(Pe));
  }
  _listenToInputFocus() {
    c.on(this._input, "focus", this._inputFocusHandler);
  }
  _handleInputFocus(t) {
    const { value: e } = t.target, i = this._options.threshold;
    if (!this._canOpenOnFocus) {
      this._canOpenOnFocus = !0;
      return;
    }
    e.length < i || (this._lastQueryValue !== e ? this._filterResults(e) : this.open());
  }
  _listenToWindowResize() {
    c.on(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleWindowResize() {
    this._dropdownContainer && this._updateDropdownWidth();
  }
  _updateDropdownWidth() {
    const t = this._input.offsetWidth;
    h.addStyle(this._dropdownContainer, { width: `${t}px` });
  }
  _listenToUserInput() {
    c.on(this._input, "input", this._userInputHandler);
  }
  _handleUserInput(t) {
    const { value: e } = t.target, i = this._options.threshold, n = this._options.debounce;
    if (this.filter) {
      if (e.length < i) {
        this._isOpen && this.close();
        return;
      }
      this._debounceFilter(e, n);
    }
  }
  _debounceFilter(t, e) {
    this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {
      this._filterResults(t);
    }, e);
  }
  _filterResults(t) {
    this._lastQueryValue = t;
    const e = this.filter(t);
    this._isPromise(e) ? this._asyncUpdateResults(e) : this._updateResults(e);
  }
  _isPromise(t) {
    return !!t && typeof t.then == "function";
  }
  _asyncUpdateResults(t) {
    this._resetActiveItem(), this._showLoader(), t.then((e) => {
      this._updateResults(e), this._loaderTimeout = setTimeout(() => {
        this._hideLoader(), this._loaderTimeout = null;
      }, this._options.loaderCloseDelay);
    });
  }
  _resetActiveItem() {
    const t = this._activeItem;
    t && (t.removeAttribute(Bo), this._activeItem = null, this._activeItemIndex = -1);
  }
  _showLoader() {
    this._element.appendChild(this._loader);
  }
  _hideLoader() {
    d.findOne(cA, this._element) && this._element.removeChild(this._loader);
  }
  _updateResults(t) {
    this._resetActiveItem(), this._filteredResults = t, c.trigger(this._element, _A, { results: t });
    const e = d.findOne(
      Vs,
      this._dropdownContainer
    ), i = ed(
      t,
      this._options,
      this._classes.autocompleteItem
    ), n = rA(
      this._options.noResults,
      this._classes
    );
    t.length === 0 && this._options.noResults !== "" ? e.innerHTML = n : e.innerHTML = i, this._isOpen || this.open(), this._popper && this._popper.forceUpdate();
  }
  _listenToKeydown() {
    c.on(this._element, "keydown", this._keydownHandler);
  }
  _handleKeydown(t) {
    this._isOpen ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);
  }
  _handleOpenKeydown(t) {
    const e = t.keyCode;
    if (e === ke && this._options.autoSelect && this._selectActiveItem(), e === we || e === U && t.altKey) {
      this.close(), this._input.focus();
      return;
    }
    if (e === we || e === U && t.altKey || e === ke) {
      this.close(), this._input.focus();
      return;
    }
    switch (e) {
      case z:
        this._setActiveItem(this._activeItemIndex + 1), this._scrollToItem(this._activeItem);
        break;
      case U:
        this._setActiveItem(this._activeItemIndex - 1), this._scrollToItem(this._activeItem);
        break;
      case Te:
        this._activeItemIndex > -1 ? (this._setActiveItem(0), this._scrollToItem(this._activeItem)) : this._input.setSelectionRange(0, 0);
        break;
      case Ee:
        if (this._activeItemIndex > -1)
          this._setActiveItem(this.items.length - 1), this._scrollToItem(this._activeItem);
        else {
          const n = this._input.value.length;
          this._input.setSelectionRange(n, n);
        }
        break;
      case it:
        if (t.preventDefault(), this._activeItemIndex > -1) {
          const n = this._filteredResults[this._activeItemIndex];
          this._handleSelection(n);
        }
        return;
      default:
        return;
    }
    t.preventDefault();
  }
  _setActiveItem(t) {
    const e = this.items;
    e[t] && this._updateActiveItem(e[t], t);
  }
  _updateActiveItem(t, e) {
    const i = this._activeItem;
    i && i.removeAttribute(Bo), t.setAttribute(Bo, ""), this._activeItemIndex = e, this._activeItem = t;
  }
  _scrollToItem(t) {
    if (!t)
      return;
    const e = this.itemsList, i = e.offsetHeight, n = this.items.indexOf(t), o = t.offsetHeight, r = e.scrollTop;
    if (n > -1) {
      const a = n * o, l = a + o > r + i;
      a < r ? e.scrollTop = a : l ? e.scrollTop = a - i + o : e.scrollTop = r;
    }
  }
  _handleClosedKeydown(t) {
    t.key === "Enter" && t.preventDefault();
    const e = t.keyCode;
    (e === it || e === z || e === z) && this.open();
  }
  open() {
    this._lastQueryValue === null && this._filterResults("");
    const t = c.trigger(this._element, pA);
    this._isOpen || t.defaultPrevented || (this._updateDropdownWidth(), this._listenToWindowResize(), this._popper = se(this._element, this._dropdownContainer, {
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 1]
          }
        }
      ]
    }), this._container.appendChild(this._dropdownContainer), this._listenToOutsideClick(), this._listenToItemsClick(), setTimeout(() => {
      this.dropdown.setAttribute(rc, ""), this._isOpen = !0, this._setInputActiveStyles(), this._updateInputState();
    }, 0));
  }
  _listenToOutsideClick() {
    c.on(document, "click", this._outsideClickHandler);
  }
  _handleOutsideClick(t) {
    const e = this._input === t.target, i = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);
    !e && !i && !n && this.close();
  }
  _listenToItemsClick() {
    const t = d.findOne(
      Vs,
      this._dropdownContainer
    );
    c.on(t, "click", this._handleItemsClick.bind(this));
  }
  _handleItemsClick(t) {
    const e = d.closest(t.target, ac), i = h.getDataAttribute(e, "index"), n = this._filteredResults[i];
    this._handleSelection(n);
  }
  _selectActiveItem() {
    const t = this._filteredResults[this._activeItemIndex];
    if (!t)
      return;
    const e = this._options.displayValue(t);
    c.trigger(this._element, lc, {
      value: t
    }).defaultPrevented || setTimeout(() => {
      this._canOpenOnFocus = !1, this._updateInputValue(e), this._updateInputState();
    }, 0);
  }
  _handleSelection(t) {
    const e = this._options.displayValue(t), i = c.trigger(this._element, lc, {
      value: t
    });
    t !== void 0 && (i.defaultPrevented || setTimeout(() => {
      this._canOpenOnFocus = !1, this._updateInputValue(e), this._updateInputState(), this._input.focus(), this.close();
    }, 0));
  }
  _updateInputValue(t) {
    this._input.value = t;
  }
  _setInputActiveStyles() {
    this._input.setAttribute(oc, "");
  }
  close() {
    var e;
    const t = c.trigger(this._element, uA);
    !this._isOpen || t.defaultPrevented || (this._resetActiveItem(), this._removeDropdownEvents(), this.dropdown.removeAttribute(rc), c.on(
      this.dropdown,
      "transitionend",
      this._handleDropdownTransitionEnd.bind(this)
    ), this._input.removeAttribute(oc), this._input.value || (this._input.removeAttribute(Pe), (e = this._notch) == null || e.removeAttribute(Pe)));
  }
  _removeDropdownEvents() {
    const t = d.findOne(
      Vs,
      this._dropdownContainer
    );
    c.off(t, "click"), c.off(document, "click", this._outsideClickHandler), c.off(window, "resize", this._handleWindowResize.bind(this));
  }
  _handleDropdownTransitionEnd(t) {
    this._isOpen && t && t.propertyName === "opacity" && (this._popper.destroy(), this._dropdownContainer && this._container.removeChild(this._dropdownContainer), this._isOpen = !1, c.off(this.dropdown, "transitionend"), this._canOpenOnFocus = !0);
  }
  dispose() {
    this._isOpen && this.close(), this._removeInputAndElementEvents(), this._dropdownContainer.remove(), A.removeData(this._element, Li);
  }
  _removeInputAndElementEvents() {
    c.off(this._input, "focus", this._inputFocusHandler), c.off(this._input, "input", this._userInputHandler), c.off(this._element, "keydown", this._keydownHandler);
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, Li);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose/.test(t)) && (i || (i = new id(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, Li);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const vA = (s, t) => `<div class="${s.connectContainer}" ${t}>
  <div class="${s.connect}"></div>
  </div>`, TA = (s, t) => `<div class="${s.hand}" ${t}>
    <span></span>
  </div>`, EA = (s, t) => `
    <span class="${s.tooltip}" ${t}>
      <span class="${s.tooltipValue}"></span>
    </span>
    `, pe = (s) => s.type === "touchmove" ? s.touches[0].clientX : s.clientX, an = "multiRangeSlider", ln = `te.${an}`, CA = `.${ln}`, cc = `valueChanged${CA}`, _e = "data-te-active", hc = "data-te-multi-range-slider-hand-ref", dc = "data-te-multi-range-slider-connect-ref", uc = "data-te-multi-range-slider-tooltip-ref", AA = {
  max: "number",
  min: "number",
  numberOfRanges: "number",
  startValues: "(array|string)",
  step: "(string|null|number)",
  tooltip: "boolean"
}, yA = {
  max: 100,
  min: 0,
  numberOfRanges: 2,
  startValues: [0, 100],
  step: null,
  tooltip: !1
}, wA = {
  connect: "z-10 h-full w-full bg-[#eee] will-change-transform dark:bg-[#4f4f4f]",
  connectContainer: "relative border-[1px] border-[#eee] z-0 h-full w-full overflow-hidden dark:border-[#4f4f4f]",
  container: "apperance-none relative m-auto w-full cursor-pointer h-1 border-0 bg-transparent p-0 focus:outline-none dark:border-[#4f4f4f]",
  hand: "apperance-none absolute top-[50%] border-0 -mt-1 h-4 w-4 cursor-pointer rounded-[50%] border-0 bg-primary transition-colors ease-in-out will-change-transform active:bg-[#c4d4ef] active:z-60",
  tooltip: "absolute -top-[18px] origin-[50%_50%] -translate-x-[6px] -rotate-45 scale-0 rounded-bl-none rounded-br-2xl rounded-tl-2xl rounded-tr-2xl bg-primary text-white transition-all duration-[200ms] data-[te-active]:-top-[38px] data-[te-active]:scale-100",
  tooltipValue: "block h-[30px] w-[30px] -translate-x-[6px] translate-y-[6px] rotate-45 text-center text-[10px]"
}, kA = {
  container: "string",
  connectContainer: "string",
  connect: "string",
  hand: "string",
  tooltip: "string",
  tooltipValue: "string"
};
class sd extends ft {
  constructor(t, e, i) {
    super(t), this._options = this._getConfig(e), this._mousemove = !1, this._classes = this._getClasses(i), this._maxTranslation = null, this._minTranslation = null, this._currentStepValue = null, this._canChangeStep = !1, this.init();
  }
  // Getters
  static get NAME() {
    return an;
  }
  get hands() {
    return d.find(`[${hc}]`, this._element);
  }
  get connect() {
    return d.findOne(`[${dc}]`, this._element);
  }
  get leftConnectRect() {
    return this.connect.getBoundingClientRect().left;
  }
  get handActive() {
    return d.findOne(`[${_e}]`);
  }
  get activeTooltipValue() {
    return d.find(`[${uc}]`).filter(
      (n) => n.hasAttribute(_e)
    )[0].children[0];
  }
  // Public
  init() {
    this._setContainerClasses(), this._setRangeConnectsElement(), this._setRangeHandleElements(), this._setMaxAndMinTranslation(), this._setTransofrmationOnStart(), this._handleClickEventOnHand(), this._handleEndMoveEventDocument(), this._handleClickOnRange(), this._setTooltipToHand();
  }
  dispose() {
    A.removeData(this._element, ln), this._options = null, this._mousemove = null, this._maxTranslation = null, this._minTranslation = null, this._currentStepValue = null, this._canChangeStep = null, this.hands.forEach((t) => {
      K.off(t, "mousedown touchstart"), K.off(t, "mouseup touchend");
    }), K.off(document, "mousemove touchmove"), K.off(document, "mouseup touchend"), K.off(this.connect, "mousedown touchstart");
  }
  // Private
  _setMaxAndMinTranslation() {
    this._maxTranslation = this.connect.offsetWidth - this.hands[0].offsetWidth / 2, this._minTranslation = this.connect.offsetLeft - this.hands[0].offsetWidth / 2;
  }
  _setTransofrmationOnStart() {
    const { max: t, min: e } = this._options;
    let { startValues: i } = this._options;
    typeof i == "string" && (i = JSON.parse(i.replace(/'/g, '"'))), i.length === 0 ? this.hands.forEach((n) => {
      h.setDataAttribute(
        n,
        "translation",
        Math.round(this._minTranslation)
      ), h.addStyle(n, {
        transform: `translate(${this._minTranslation}px,-25%)`
      });
    }) : this.hands.forEach((n, o) => {
      if (i[o] > t || i[o] < e)
        return;
      if (i[o] === void 0) {
        h.setDataAttribute(
          n,
          "translation",
          Math.round(this._maxTranslation)
        ), h.addStyle(n, {
          transform: `translate(${this._maxTranslation}px,-25%)`,
          zIndex: this.hands.length - o
        });
        return;
      }
      const a = (i[o] - e) / (t - e) * this.connect.offsetWidth - n.offsetWidth / 2;
      h.setDataAttribute(
        n,
        "translation",
        Math.round(a)
      ), h.addStyle(n, {
        transform: `translate(${a}px,-25%)`,
        zIndex: this.hands.length - o
      });
    });
  }
  _handleOutOfMaxRangeValue(t, e) {
    this._updateHand(t, this._maxTranslation), this._options.tooltip && (this.activeTooltipValue.innerText = e);
  }
  _handleOutOfMinRangeValue(t, e) {
    this._updateHand(t, this._minTranslation), this._options.tooltip && (this.activeTooltipValue.innerText = e);
  }
  _handleNormalMove(t, e, i) {
    this._updateHand(t, e), this._options.tooltip && (this.activeTooltipValue.innerText = Math.round(i));
  }
  _handleClickEventOnHand() {
    const { max: t, min: e, step: i } = this._options;
    this.hands.forEach((n) => {
      K.on(n, "mousedown touchstart", (o) => {
        if (this._mousemove = !0, n.setAttribute(_e, ""), this._options.tooltip && n.children[1].setAttribute(_e, ""), this._handleMoveEvent(n), this._handleEndMoveEvent(n, o), !this._canChangeStep && i !== null)
          return;
        const r = pe(o) - this.leftConnectRect - n.offsetWidth / 2, a = (pe(o) - this.leftConnectRect) / (this.connect.offsetWidth / (t - e)) % (t - e);
        r >= this._maxTranslation ? this._handleOutOfMaxRangeValue(n, t) : r <= this._minTranslation ? this._handleOutOfMinRangeValue(n, e) : this._handleNormalMove(n, r, a);
      });
    });
  }
  _setContainerClasses() {
    h.addClass(this._element, this._classes.container);
  }
  _setRangeConnectsElement() {
    this._element.insertAdjacentHTML(
      "afterbegin",
      vA(
        {
          connectContainer: this._classes.connectContainer,
          connect: this._classes.connect
        },
        dc
      )
    );
  }
  _setRangeHandleElements() {
    for (let t = 0; t < this._options.numberOfRanges; t++)
      this._element.insertAdjacentHTML(
        "beforeend",
        TA({ hand: this._classes.hand }, hc)
      );
    this.hands.forEach((t, e) => {
      t.setAttribute("aria-orientation", "horizontal"), t.setAttribute("role", "slider"), h.setDataAttribute(t, "handle", e);
    });
  }
  _setTooltipToHand() {
    this._options.tooltip && this.hands.forEach((t) => t.insertAdjacentHTML(
      "beforeend",
      EA(
        {
          tooltip: this._classes.tooltip,
          tooltipValue: this._classes.tooltipValue
        },
        uc
      )
    ));
  }
  _handleMoveEvent(t) {
    const { tooltip: e, step: i } = this._options;
    K.on(document, "mousemove touchmove", (n) => {
      n.type === "mousemove" && n.preventDefault();
      const { max: o, min: r, numberOfRanges: a } = this._options;
      if (t.hasAttribute(_e)) {
        const l = (pe(n) - this.leftConnectRect) / this.connect.offsetWidth * o;
        let p = (pe(n) - this.leftConnectRect) / (this.connect.offsetWidth / (o - r)) % (o - r) + r;
        if ((this._currentStepValue === Math.round(p) || Math.round(p) % i !== 0) && i !== null) {
          this._canChangeStep = !1;
          return;
        }
        this._canChangeStep = !0;
        let u = pe(n) - this.leftConnectRect - t.offsetWidth / 2;
        const _ = h.getDataAttribute(
          this.handActive,
          "handle"
        ), f = h.getDataAttribute(
          this.handActive,
          "translation"
        );
        if (p < r)
          u = r - t.offsetWidth / 2, p = r;
        else if (l >= o)
          return;
        const g = this.hands.map(
          (m) => h.getDataAttribute(m, "translation")
        );
        if (a < 2)
          Math.round(p) % i === 0 && i !== null ? (this._currentStepValue = Math.round(p), h.addStyle(t, {
            transform: `translate(${u}px,-25%)`
          }), e && (this.activeTooltipValue.innerText = Math.round(p))) : i === null && (h.addStyle(t, {
            transform: `translate(${u}px,-25%)`
          }), e && (this.activeTooltipValue.innerText = Math.round(p))), h.setDataAttribute(t, "translation", u);
        else {
          const m = _ > 0 && _ < a - 1;
          let b = u, v = !1;
          const T = g[_ + 1], y = g[_ - 1];
          _ === 0 && f >= T ? (b = T, v = u <= b) : _ === a - 1 && f <= y ? (b = y, v = u >= b) : m && (f >= T || f <= y) && (b = f >= T ? T : y, v = b === T ? u <= b : u >= b), Math.round(p) % i === 0 && i !== null ? (this._currentStepValue = Math.round(p), h.addStyle(t, {
            transform: `translate(${b}px,-25%)`
          }), e && b === u && this.activeTooltipValue !== null && (this.activeTooltipValue.innerText = Math.round(p))) : i === null && (h.addStyle(t, {
            transform: `translate(${b}px,-25%)`
          }), e && b === u && this.activeTooltipValue !== null && (this.activeTooltipValue.innerText = Math.round(p))), h.setDataAttribute(
            t,
            "translation",
            v ? u : b
          );
        }
        this._canChangeStep && this._handleEventChangeValuesOnRange();
      }
    });
  }
  _handleEventChangeValuesOnRange() {
    const { max: t, min: e, numberOfRanges: i } = this._options, n = (r) => {
      const a = r.getBoundingClientRect().left - this.leftConnectRect + r.offsetWidth / 2;
      let l = a / (this.connect.offsetWidth / (t - e)) % (t - e);
      return a === this.connect.offsetWidth ? l = t : l += e, h.setDataAttribute(r, "value", Math.round(l * 10) / 10), { value: l };
    };
    if (i < 2) {
      const { value: r } = n(this.hands[0]);
      c.trigger(this._element, cc, {
        values: { value: r + e, rounded: Math.round(r + e) }
      });
      return;
    }
    const o = this.hands.map((r) => n(r));
    c.trigger(this._element, cc, {
      values: {
        value: o.map(({ value: r }) => r + e),
        rounded: o.map(({ value: r }) => Math.round(r + e))
      }
    });
  }
  _resetHandState(t, e) {
    c.off(t, e), t.removeAttribute(_e), this._options.tooltip && t.children[1].removeAttribute(_e);
  }
  _handleEndMoveEventDocument() {
    K.on(document, "mouseup touchend", () => {
      this._mousemove && (this.hands.forEach((t) => {
        this._resetHandState(t, "mousemove");
      }), K.off(document, "mousemove touchmove"), this._mousemove = !1);
    });
  }
  _handleEndMoveEvent(t) {
    K.on(t, "mouseup touchend", () => {
      this._resetHandState(t, "mousemove"), K.off(document, "mousemove touchmove"), this._mousemove = !1;
    });
  }
  _handleClickOnRange() {
    this._options.step === null && K.on(this.connect, "mousedown touchstart", (t) => {
      const e = [];
      let i = 0;
      if (this.hands.forEach((n) => {
        this._mousemove = !0;
        const o = pe(t), r = n.offsetWidth, a = h.getDataAttribute(
          n,
          "translation"
        ), l = o - this.leftConnectRect - r / 2;
        this._options.numberOfRanges < 2 ? this._updateHand(n, l) : (e.push(Math.abs(l - a)), e.forEach((p, u) => {
          p < e[i] && (i = u);
        }));
      }), this._options.numberOfRanges >= 2) {
        const n = pe(t) - this.leftConnectRect - this.hands[i].offsetWidth / 2;
        this._updateAdjacentHands(i, n);
      }
      this._handleEventChangeValuesOnRange();
    });
  }
  _updateHand(t, e) {
    h.addStyle(t, {
      transform: `translate(${e}px,-25%)`
    }), h.setDataAttribute(t, "translation", e);
  }
  _updateAdjacentHands(t, e) {
    const i = this.hands[t + 1], n = this.hands[t - 1], o = i ? h.getDataAttribute(i, "translation") : void 0, r = n ? h.getDataAttribute(n, "translation") : void 0;
    i && e > o ? this._updateHand(i, e) : n && e < r ? this._updateHand(n, e) : this._updateHand(this.hands[t], e);
  }
  _getConfig(t) {
    const e = {
      ...yA,
      ...h.getDataAttributes(this._element),
      ...t
    };
    return I(an, e, AA), e;
  }
  _getClasses(t) {
    const e = h.getDataClassAttributes(this._element);
    return t = {
      ...wA,
      ...e,
      ...t
    }, I(an, t, kA), t;
  }
  static jQueryInterface(t, e) {
    return this.each(function() {
      let i = A.getData(this, ln);
      const n = typeof t == "object" && t;
      if (!(!i && /dispose|hide/.test(t)) && (i || (i = new sd(this, n)), typeof t == "string")) {
        if (typeof i[t] > "u")
          throw new TypeError(`No method named "${t}"`);
        i[t](e);
      }
    });
  }
  static getInstance(t) {
    return A.getData(t, ln);
  }
  static getOrCreateInstance(t, e = {}) {
    return this.getInstance(t) || new this(t, typeof e == "object" ? e : null);
  }
}
const xA = (s) => {
  gc(() => {
    const t = mc();
    if (t) {
      const e = s.NAME, i = t.fn[e];
      t.fn[e] = s.jQueryInterface, t.fn[e].Constructor = s, t.fn[e].noConflict = () => (t.fn[e] = i, s.jQueryInterface);
    }
  });
}, OA = (s, t) => {
  c.on(
    document,
    `click.te.${s.NAME}`,
    t,
    function(e) {
      e.preventDefault(), s.getOrCreateInstance(this).toggle();
    }
  );
}, SA = (s, t) => {
  c.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), be(this))
        return;
      s.getOrCreateInstance(this).show();
    }
  );
}, IA = (s, t) => {
  c.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      const i = te(this);
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), be(this))
        return;
      c.one(i, s.EVENT_HIDDEN, () => {
        Mt(this) && this.focus();
      });
      const n = d.findOne(s.OPEN_SELECTOR);
      n && n !== i && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    }
  );
}, DA = (s, t) => {
  c.on(
    document,
    `click.te.${s.NAME}`,
    t,
    (e) => {
      e.preventDefault();
      const i = e.target.closest(t);
      s.getOrCreateInstance(i).toggle();
    }
  );
}, $A = (s, t) => {
  c.on(
    document,
    `click.te.${s.NAME}`,
    t,
    function(e) {
      const i = te(this);
      ["A", "AREA"].includes(this.tagName) && e.preventDefault(), c.one(i, s.EVENT_SHOW, (r) => {
        r.defaultPrevented || c.one(i, s.EVENT_HIDDEN, () => {
          Mt(this) && this.focus();
        });
      });
      const n = d.findOne(
        `[${s.OPEN_SELECTOR}="true"]`
      );
      n && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);
    }
  );
}, LA = (s, t) => {
  c.one(
    document,
    "mousedown",
    t,
    s.autoInitial(new s())
  );
}, NA = (s, t) => {
  c.on(
    document,
    `click.te.${s.NAME}.data-api`,
    t,
    function(e) {
      (e.target.tagName === "A" || e.delegateTarget && e.delegateTarget.tagName === "A") && e.preventDefault();
      const i = lr(this);
      d.find(i).forEach((o) => {
        s.getOrCreateInstance(o, { toggle: !1 }).toggle();
      });
    }
  );
}, MA = (s, t) => {
  [].slice.call(
    document.querySelectorAll(t)
  ).map(function(i) {
    return new s(i);
  });
}, RA = (s, t) => {
  [].slice.call(
    document.querySelectorAll(t)
  ).map(function(i) {
    return new s(i);
  });
}, PA = (s, t) => {
  d.find(t).forEach((e) => {
    new s(e);
  }), c.on(
    document,
    `click.te.${s.NAME}.data-api`,
    `${t} img:not([data-te-lightbox-disabled])`,
    s.toggle()
  );
}, BA = (s, t) => {
  const e = (o) => o[0] === "{" && o[o.length - 1] === "}" || o[0] === "[" && o[o.length - 1] === "]", i = (o) => typeof o != "string" ? o : e(o) ? JSON.parse(o.replace(/'/g, '"')) : o, n = (o) => {
    const r = {};
    return Object.keys(o).forEach((a) => {
      if (a.match(/dataset.*/)) {
        const l = a.slice(7, 8).toLowerCase().concat(a.slice(8));
        r[l] = i(o[a]);
      }
    }), r;
  };
  d.find(t).forEach((o) => {
    if (h.getDataAttribute(o, "chart") !== "bubble" && h.getDataAttribute(o, "chart") !== "scatter") {
      const r = h.getDataAttributes(o), a = {
        data: {
          datasets: [n(r)]
        }
      };
      return r.chart && (a.type = r.chart), r.labels && (a.data.labels = JSON.parse(r.labels.replace(/'/g, '"'))), new s(o, {
        ...a,
        ...wi[a.type]
      });
    }
    return null;
  });
};
class HA {
  constructor() {
    this.inits = [];
  }
  get initialized() {
    return this.inits;
  }
  isInited(t) {
    return this.inits.includes(t);
  }
  add(t) {
    this.isInited(t) || this.inits.push(t);
  }
}
const ar = new HA(), Ni = {
  alert: {
    name: "Alert",
    selector: "[data-te-alert-init]",
    isToggler: !1
  },
  animation: {
    name: "Animate",
    selector: "[data-te-animation-init]",
    isToggler: !1
  },
  carousel: {
    name: "Carousel",
    selector: "[data-te-carousel-init]",
    isToggler: !1
  },
  chips: {
    name: "ChipsInput",
    selector: "[data-te-chips-input-init]",
    isToggler: !1
  },
  chip: {
    name: "Chip",
    selector: "[data-te-chip-init]",
    isToggler: !1,
    onInit: "init"
  },
  datepicker: {
    name: "Datepicker",
    selector: "[data-te-datepicker-init]",
    isToggler: !1
  },
  datetimepicker: {
    name: "Datetimepicker",
    selector: "[data-te-date-timepicker-init]",
    isToggler: !1
  },
  input: {
    name: "Input",
    selector: "[data-te-input-wrapper-init]",
    isToggler: !1
  },
  perfectScrollbar: {
    name: "PerfectScrollbar",
    selector: "[data-te-perfect-scrollbar-init]",
    isToggler: !1
  },
  rating: {
    name: "Rating",
    selector: "[data-te-rating-init]",
    isToggler: !1
  },
  scrollspy: {
    name: "ScrollSpy",
    selector: "[data-te-spy='scroll']",
    isToggler: !1
  },
  select: {
    name: "Select",
    selector: "[data-te-select-init]",
    isToggler: !1
  },
  sidenav: {
    name: "Sidenav",
    selector: "[data-te-sidenav-init]",
    isToggler: !1
  },
  stepper: {
    name: "Stepper",
    selector: "[data-te-stepper-init]",
    isToggler: !1
  },
  timepicker: {
    name: "Timepicker",
    selector: "[data-te-timepicker-init]",
    isToggler: !1
  },
  toast: {
    name: "Toast",
    selector: "[data-te-toast-init]",
    isToggler: !1
  },
  datatable: {
    name: "Datatable",
    selector: "[data-te-datatable-init]"
  },
  popconfirm: {
    name: "Popconfirm",
    selector: "[data-te-toggle='popconfirm']"
  },
  validation: {
    name: "Validation",
    selector: "[data-te-validation-init]"
  },
  smoothScroll: {
    name: "SmoothScroll",
    selector: "a[data-te-smooth-scroll-init]"
  },
  lazyLoad: {
    name: "LazyLoad",
    selector: "[data-te-lazy-load-init]"
  },
  clipboard: {
    name: "Clipboard",
    selector: "[data-te-clipboard-init]"
  },
  infiniteScroll: {
    name: "InfiniteScroll",
    selector: "[data-te-infinite-scroll-init]"
  },
  loadingManagement: {
    name: "LoadingManagement",
    selector: "[data-te-loading-management-init]"
  },
  sticky: {
    name: "Sticky",
    selector: "[data-te-sticky-init]"
  },
  multiRangeSlider: {
    name: "MultiRangeSlider",
    selector: "[data-te-multi-range-slider-init]"
  },
  // advancedInits
  chart: {
    name: "Chart",
    selector: "[data-te-chart]",
    isToggler: !1,
    advanced: BA
  },
  // togglers
  button: {
    name: "Button",
    selector: "[data-te-toggle='button']",
    isToggler: !0,
    callback: DA
  },
  collapse: {
    name: "Collapse",
    selector: "[data-te-collapse-init]",
    isToggler: !0,
    callback: NA
  },
  dropdown: {
    name: "Dropdown",
    selector: "[data-te-dropdown-toggle-ref]",
    isToggler: !0,
    callback: OA
  },
  modal: {
    name: "Modal",
    selector: "[data-te-toggle='modal']",
    isToggler: !0,
    callback: $A
  },
  ripple: {
    name: "Ripple",
    selector: "[data-te-ripple-init]",
    isToggler: !0,
    callback: LA
  },
  offcanvas: {
    name: "Offcanvas",
    selector: "[data-te-offcanvas-toggle]",
    isToggler: !0,
    callback: IA
  },
  tab: {
    name: "Tab",
    selector: "[data-te-toggle='tab'], [data-te-toggle='pill'], [data-te-toggle='list']",
    isToggler: !0,
    callback: SA
  },
  tooltip: {
    name: "Tooltip",
    selector: "[data-te-toggle='tooltip']",
    isToggler: !1,
    callback: MA
  },
  popover: {
    name: "Popover",
    selector: "[data-te-toggle='popover']",
    isToggler: !0,
    callback: RA
  },
  lightbox: {
    name: "Lightbox",
    selector: "[data-te-lightbox-init]",
    isToggler: !0,
    callback: PA
  },
  touch: {
    name: "Touch",
    selector: "[data-te-touch-init]"
  }
}, VA = (s) => Ni[s.NAME] || null, WA = (s, t) => {
  if (!s || !t.allowReinits && ar.isInited(s.NAME))
    return;
  ar.add(s.NAME);
  const e = VA(s), i = (e == null ? void 0 : e.isToggler) || !1;
  if (xA(s), e != null && e.advanced) {
    e == null || e.advanced(s, e == null ? void 0 : e.selector);
    return;
  }
  if (i) {
    e == null || e.callback(s, e == null ? void 0 : e.selector);
    return;
  }
  d.find(e == null ? void 0 : e.selector).forEach((n) => {
    let o = s.getInstance(n);
    o || (o = new s(n), e != null && e.onInit && o[e.onInit]());
  });
}, FA = (s, t) => {
  s.forEach((e) => WA(e, t));
}, YA = {
  allowReinits: !1,
  checkOtherImports: !1
}, qA = (s, t = {}) => {
  t = { ...YA, ...t };
  const e = Object.keys(Ni).map((i) => {
    if (!!document.querySelector(Ni[i].selector)) {
      const o = s[Ni[i].name];
      return !o && !ar.isInited(i) && t.checkOtherImports && console.warn(
        `Please import ${Ni[i].name} from "tw-elements" package and add it to a object parameter inside "initTE" function`
      ), o;
    }
  });
  FA(e, t);
};

//# sourceMappingURL=tw-elements.es.min.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfc2VsZWN0Ml9kaXN0X2pzX3NlbGVjdDJfanMtbm9kZV9tb2R1bGVzX3NlbGVjdDJfZGlzdF9jc3Nfc2VsZWN0Ml9jc3Mtbm9kLWZlZDMzNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSxLQUEwQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFlBQVk7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsbUJBQW1CLGlDQUFpQztBQUNwRCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7O0FBR0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTLDZCQUE2QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7O0FBRWYsU0FBUzs7QUFFVDtBQUNBLFNBQVMsZ0NBQWdDO0FBQ3pDLFNBQVMsbUJBQW1CO0FBQzVCLFNBQVMscUNBQXFDO0FBQzlDLFNBQVM7QUFDVCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0UsVUFBVTtBQUM1RSx1Q0FBdUMsMkJBQTJCO0FBQ2xFO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsdUVBQXVFO0FBQ3BGO0FBQ0E7QUFDQSxhQUFhLDRCQUE0QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFpRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxXQUFXLDRDQUE0QztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFNBQVMsR0FBRztBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsMkJBQTJCLHdCQUF3Qjs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMkNBQTJDO0FBQzNDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxxQ0FBcUM7QUFDOUUscUNBQXFDLHNDQUFzQztBQUMzRSxxQ0FBcUMscUNBQXFDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZOztBQUVaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQyxzQ0FBc0M7QUFDdEMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixhQUFhO0FBQ3JDLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7OztBQUdBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUEsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxPQUFPO0FBQ2hCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsY0FBYzs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1Q0FBdUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUF1RDtBQUMvRTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwrQ0FBK0M7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZUFBZSxvQ0FBb0M7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7OztBQUdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xC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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhEQUE4RDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTzs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtEQUFrRCwwQkFBMEI7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNB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LGlCQUFpQjtBQUM1QixZQUFZLGlCQUFpQjtBQUM3QixlQUFlO0FBQ2YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTLG1CQUFtQjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUEsS0FBSztBQUNMOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLFlBQVksU0FBUztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBOztBQUVBLGNBQWM7O0FBRWQ7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLE1BQU07QUFDTjs7QUFFQSxZQUFZO0FBQ1osSUFBSTtBQUNKO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkMsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQSxlQUFlLHFEQUFxRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLElBQTBDO0FBQy9DLENBQUMsaUNBQWtCLEVBQUUsbUNBQUU7QUFDdkI7QUFDQSxFQUFFO0FBQUEsa0dBQUU7QUFDSjs7Ozs7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsRUFBRTs7Ozs7Ozs7Ozs7QUMzOVVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxJQUFJLGlDQUFPLENBQUMseUVBQVEsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQy9CLElBQUksS0FBSyxFQXFCTjtBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGVBQWU7QUFDdEIsV0FBVyxXQUFXLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMENBQTBDO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQix5QkFBeUI7QUFDN0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLHdCQUF3QjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLHNCQUFzQjtBQUM1Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDOztBQUV2Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQyxRQUFRO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIsR0FBRyxRQUFROztBQUV2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsNkJBQTZCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQyx3Q0FBd0MsT0FBTztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxzQ0FBc0M7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlFQUF5RSxxQ0FBcUM7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDRDQUE0QztBQUMvQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywwQkFBMEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSywwR0FBMEcsY0FBYztBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTyxXQUFXLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx3Q0FBd0M7QUFDM0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsd01BQXdNO0FBQzNNO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsT0FBTztBQUNqRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1QixLQUFLO0FBQ0wsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9CQUFvQjtBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCw2REFBNkQ7QUFDN0QsV0FBVztBQUNYLGlDQUFpQywrQkFBK0I7QUFDaEUsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEMsR0FBRztBQUNIO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUE0RDtBQUN2RTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRCxHQUFHO0FBQ3BELEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQ3BCLGVBQWUsR0FBRyxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsRUFBRSxHQUFHLGtCQUFrQixHQUFHLEVBQUUsR0FBRyxnQkFBZ0IsR0FBRyxFQUFFLEdBQUcsNmhCQUE2aEIsY0FBYyxJQUFJLGNBQWMsV0FBVyxjQUFjLElBQUksY0FBYztBQUM3dkI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtXQUFrVyxHQUFHO0FBQ3JXO0FBQ0E7QUFDQSxLQUFLLGtEQUFrRCxHQUFHO0FBQzFEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0ZBQStGLEdBQUcsc0RBQXNELEdBQUc7QUFDM0osT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlDQUF5QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHlDQUF5QztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEdBQUc7QUFDdkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQyxjQUFjLEdBQUcsZ0JBQWdCLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLDBMQUEwTCxHQUFHLEtBQUssR0FBRztBQUNoUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZUFBZSxnQ0FBZ0M7QUFDcEQsMkVBQTJFLGlCQUFpQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlDQUF5QztBQUN6RTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxHQUFHO0FBQ3ZELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QyxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxFQUFFLCtCQUErQixFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRCxHQUFHLGlDQUFpQyxHQUFHLEVBQUUsR0FBRztBQUMvRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvRkFBb0YsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsMEJBQTBCLEdBQUc7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNlRBQTZULEdBQUc7QUFDaFU7QUFDQSxvRkFBb0Ysa0JBQWtCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxHQUFHO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhDQUE4QyxHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixHQUFHO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0RBQW9ELEdBQUc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDLGVBQWUsR0FBRyxlQUFlLEdBQUcsa0JBQWtCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsZUFBZSxHQUFHLEVBQUUsR0FBRyxnQkFBZ0IsR0FBRyxFQUFFLEdBQUcsOFZBQThWLEdBQUcsRUFBRSxHQUFHLFdBQVcsSUFBSTtBQUMxcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0hBQStILEdBQUc7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSwwRUFBMEUsRUFBRTtBQUN0RztBQUNBO0FBQ0Esb0ZBQW9GLEVBQUU7QUFDdEY7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNB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O0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixFQUFFO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVLEdBQUc7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEdBQUcsSUFBSSxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsR0FBRyxJQUFJLGdCQUFnQjtBQUNqRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QixFQUFFLEVBQUU7QUFDekM7QUFDQTtBQUNBLFNBQVMsMkJBQTJCLEVBQUUsRUFBRTtBQUN4QztBQUNBO0FBQ0EsU0FBUyw2QkFBNkIsRUFBRSxFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpQkFBaUIseUNBQXlDLDBCQUEwQixnRUFBZ0Usc0JBQXNCO0FBQ2pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx3QkFBd0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkJBQTZCO0FBQ3RELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRyxJQUFJLHFCQUFxQjtBQUN0QztBQUNBLFVBQVUsR0FBRyxJQUFJLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysc0NBQXNDLHdCQUF3QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUssSUFBSSxNQUFNLEVBQUUsRUFBRTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsRUFBRSx3Q0FBd0MsY0FBYztBQUMvRjtBQUNBO0FBQ0E7QUFDQSw0SEFBNEgsZUFBZTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Es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NkIsRUFBRTtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTtBQUNYO0FBQ0E7QUFDQSxTQUFTLEVBQUU7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsbUJBQW1CLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxPQUFPLHNCQUFzQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx3QkFBd0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixFQUFFLHVCQUF1QixFQUFFO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxFQUFFO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFdBQVcscUJBQXFCLEtBQUs7QUFDL0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyx1QkFBdUIsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0IsR0FBRyxnckJBQWdyQixHQUFHO0FBQzExQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnQkFBZ0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SkFBdUosd0NBQXdDLEVBQUUsd0NBQXdDO0FBQ3pPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSEFBa0gsa0JBQWtCLG1DQUFtQyxpQkFBaUI7QUFDeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVSxFQUFFLEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUIsSUFBSSxJQUFJLGlCQUFpQixnQ0FBZ0MsTUFBTSxnQ0FBZ0M7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBMEIsOEVBQThFLG9CQUFvQjtBQUMxSTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEMsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBLGlCQUFpQixFQUFFO0FBQ25CLG1CQUFtQixhQUFhO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQiw2REFBNkQsY0FBYztBQUNySCw4QkFBOEIsRUFBRTtBQUNoQyx3Q0FBd0MsZ0JBQWdCO0FBQ3hELFVBQVU7QUFDVjtBQUNBLG1DQUFtQyxHQUFHLHVDQUF1QyxHQUFHO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxTQUFTLG1CQUFtQjtBQUM1QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQsZ0JBQWdCLG1DQUFtQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLHdDQUF3QyxrQkFBa0I7QUFDMUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsR0FBRyxjQUFjLEdBQUcsV0FBVyxHQUFHLHNCQUFzQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLHVCQUF1QixHQUFHLHlHQUF5RyxHQUFHLGFBQWEsR0FBRyxZQUFZLEdBQUcsRUFBRSxHQUFHLFlBQVksR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyw0RkFBNEYsR0FBRyxhQUFhLEdBQUc7QUFDbGU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQixjQUFjLElBQUksY0FBYztBQUNwRDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPLDhCQUE4QixXQUFXO0FBQ2hEO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyQkFBMkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DQUFvQyxVQUFVLGlCQUFpQjtBQUMvRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUMsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVEsd05BQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlYQUEyQztBQUM1RDtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvSUFBb0k7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUSxRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0JBQXNCLDhDQUE4QywwQkFBMEIsRUFBRSxzQkFBc0IsRUFBRSx5QkFBeUIsT0FBTyxPQUFPLElBQUksOEJBQThCLEVBQUUsc0JBQXNCLEVBQUUseUJBQXlCO0FBQ3JTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLHFKQUFxSix3QkFBd0I7QUFDN0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxFQUFFO0FBQ3RFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5Q0FBeUMsRUFBRTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLDRCQUE0QixnQ0FBZ0MsNEJBQTRCO0FBQ2hMLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUU7QUFDL0IsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQSx3Q0FBd0MscUJBQXFCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCLEVBQUUsb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCLEVBQUUsb0JBQW9CO0FBQzlEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBLGtEQUFrRCxtQkFBbUIsRUFBRSxXQUFXO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxpQkFBaUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVUsRUFBRSxLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLFlBQVk7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsT0FBTyxHQUFHO0FBQ1Y7QUFDQTtBQUNBLENBQUM7QUFDRCw4QkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUMsaUJBQWlCO0FBQ2xCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQTBDRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VsZWN0Mi9kaXN0L2pzL3NlbGVjdDIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNsaWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi1hY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9lcy1ub3QtZXhjZWVkLXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLWlzLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS1pcy1kZW5vLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtaXMtaW9zLXBlYmJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLWlzLWlvcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLWlzLW5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS1pcy13ZWJvcy13ZWJraXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1hY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLWNsYXVzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaG9zdC1yZXBvcnQtZXJyb3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21ha2UtYnVpbHQtaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21hdGgtdHJ1bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29yZGluYXJ5LXRvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BlcmZvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Byb21pc2UtY29uc3RydWN0b3ItZGV0ZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wcm9taXNlLW5hdGl2ZS1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcHJvbWlzZS1yZXNvbHZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wcm9taXNlLXN0YXRpY3MtaW5jb3JyZWN0LWl0ZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdjgtcHJvdG90eXBlLWRlZmluZS1idWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3ZhbGlkYXRlLWFyZ3VtZW50cy1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmNhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLnJhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLnJlamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UucmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHctZWxlbWVudHMvZGlzdC9qcy90dy1lbGVtZW50cy5lcy5taW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjcuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMy0wOC0yOFQxMzozN1pcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgdHJhYy0xNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGZsYXQgPSBhcnIuZmxhdCA/IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0cmV0dXJuIGFyci5mbGF0LmNhbGwoIGFycmF5ICk7XG59IDogZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmNvbmNhdC5hcHBseSggW10sIGFycmF5ICk7XG59O1xuXG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG5cdFx0Ly8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG5cdFx0Ly8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cblx0XHQvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG5cdFx0Ly8gU3VwcG9ydDogUXRXZWIgPD0zLjguNSwgV2ViS2l0IDw9NTM0LjM0LCB3a2h0bWx0b3BkZiB0b29sIDw9MC4xMi41XG5cdFx0Ly8gUGx1cyBmb3Igb2xkIFdlYktpdCwgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIGNvbGxlY3Rpb25zXG5cdFx0Ly8gKGUuZy4sIGB0eXBlb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIikgPT09IFwiZnVuY3Rpb25cImApLiAoZ2gtNDc1Nilcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCIgJiZcblx0XHRcdHR5cGVvZiBvYmouaXRlbSAhPT0gXCJmdW5jdGlvblwiO1xuXHR9O1xuXG5cbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXIgdmVyc2lvbiA9IFwiMy43LjFcIixcblxuXHRyaHRtbFN1ZmZpeCA9IC9IVE1MJC9pLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXZlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICggaSArIDEgKSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0b2RkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIHByb3ZpZGVkIGNvbnRleHQ7IGZhbGxzIGJhY2sgdG8gdGhlIGdsb2JhbCBvbmVcblx0Ly8gaWYgbm90IHNwZWNpZmllZC5cblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUsIG9wdGlvbnMsIGRvYyApIHtcblx0XHRET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSwgZG9jICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXG5cdC8vIFJldHJpZXZlIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuXHR0ZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbm9kZSxcblx0XHRcdHJldCA9IFwiXCIsXG5cdFx0XHRpID0gMCxcblx0XHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdGlmICggIW5vZGVUeXBlICkge1xuXG5cdFx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdFx0d2hpbGUgKCAoIG5vZGUgPSBlbGVtWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRcdHJldCArPSBqUXVlcnkudGV4dCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH1cblx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnRFbGVtZW50LnRleHRDb250ZW50O1xuXHRcdH1cblx0XHRpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0aXNYTUxEb2M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lc3BhY2UgPSBlbGVtICYmIGVsZW0ubmFtZXNwYWNlVVJJLFxuXHRcdFx0ZG9jRWxlbSA9IGVsZW0gJiYgKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdC8vIEFzc3VtZSBIVE1MIHdoZW4gZG9jdW1lbnRFbGVtZW50IGRvZXNuJ3QgeWV0IGV4aXN0LCBzdWNoIGFzIGluc2lkZVxuXHRcdC8vIGRvY3VtZW50IGZyYWdtZW50cy5cblx0XHRyZXR1cm4gIXJodG1sU3VmZml4LnRlc3QoIG5hbWVzcGFjZSB8fCBkb2NFbGVtICYmIGRvY0VsZW0ubm9kZU5hbWUgfHwgXCJIVE1MXCIgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBmbGF0KCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHRcdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cblxuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuXHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufVxudmFyIHBvcCA9IGFyci5wb3A7XG5cblxudmFyIHNvcnQgPSBhcnIuc29ydDtcblxuXG52YXIgc3BsaWNlID0gYXJyLnNwbGljZTtcblxuXG52YXIgd2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIjtcblxuXG52YXIgcnRyaW1DU1MgPSBuZXcgUmVnRXhwKFxuXHRcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLFxuXHRcImdcIlxuKTtcblxuXG5cblxuLy8gTm90ZTogYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxualF1ZXJ5LmNvbnRhaW5zID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdHZhciBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblxuXHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0XHQvLyBJRSBkb2Vzbid0IGhhdmUgYGNvbnRhaW5zYCBvbiBTVkcuXG5cdFx0YS5jb250YWlucyA/XG5cdFx0XHRhLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0KSApO1xufTtcblxuXG5cblxuLy8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cbi8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xudmFyIHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXHg4MC1cXHVGRkZGXFx3LV0vZztcblxuZnVuY3Rpb24gZmNzc2VzY2FwZSggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHR9XG5cblx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdH1cblxuXHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdHJldHVybiBcIlxcXFxcIiArIGNoO1xufVxuXG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKCBzZWwgKyBcIlwiICkucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuXG5cblxudmFyIHByZWZlcnJlZERvYyA9IGRvY3VtZW50LFxuXHRwdXNoTmF0aXZlID0gcHVzaDtcblxuKCBmdW5jdGlvbigpIHtcblxudmFyIGksXG5cdEV4cHIsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXHRwdXNoID0gcHVzaE5hdGl2ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdGRvY3VtZW50LFxuXHRkb2N1bWVudEVsZW1lbnQsXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdG1hdGNoZXMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0galF1ZXJ5LmV4cGFuZG8sXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8XCIgK1xuXHRcdFwibG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNpZGVudC10b2tlbi1kaWFncmFtXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIj98XFxcXFxcXFxbXlxcXFxyXFxcXG5cXFxcZl18W1xcXFx3LV18W15cXDAtXFxcXHg3Zl0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJsZWFkaW5nQ29tYmluYXRvciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0SUQ6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRDTEFTUzogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRUQUc6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRBVFRSOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRQU0VVRE86IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdENISUxEOiBuZXcgUmVnRXhwKFxuXHRcdFx0XCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICtcblx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICtcblx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdGJvb2w6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0bmVlZHNDb250ZXh0OiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCI/fFxcXFxcXFxcKFteXFxcXHJcXFxcblxcXFxmXSlcIiwgXCJnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIGVzY2FwZSwgbm9uSGV4ICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlLnNsaWNlKCAxICkgLSAweDEwMDAwO1xuXG5cdFx0aWYgKCBub25IZXggKSB7XG5cblx0XHRcdC8vIFN0cmlwIHRoZSBiYWNrc2xhc2ggcHJlZml4IGZyb20gYSBub24taGV4IGVzY2FwZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIG5vbkhleDtcblx0XHR9XG5cblx0XHQvLyBSZXBsYWNlIGEgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlIHdpdGggdGhlIGVuY29kZWQgVW5pY29kZSBjb2RlIHBvaW50XG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMStcblx0XHQvLyBGb3IgdmFsdWVzIG91dHNpZGUgdGhlIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZSAoQk1QKSwgbWFudWFsbHkgY29uc3RydWN0IGFcblx0XHQvLyBzdXJyb2dhdGUgcGFpclxuXHRcdHJldHVybiBoaWdoIDwgMCA/XG5cdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXM7IHNlZSBgc2V0RG9jdW1lbnRgLlxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRS9FZGdlLlxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRpbkRpc2FibGVkRmllbGRzZXQgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgbm9kZU5hbWUoIGVsZW0sIFwiZmllbGRzZXRcIiApO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIEFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiB0aHJvdyB1bmV4cGVjdGVkbHlcbi8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM5M1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KCBhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApICksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7XG5cdFx0YXBwbHk6IGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hOYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbCggZWxzICkgKTtcblx0XHR9LFxuXHRcdGNhbGw6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0XHRwdXNoTmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApICk7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBmaW5kKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKCBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKCBtID0gbWF0Y2hbIDEgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRwdXNoLmNhbGwoIHJlc3VsdHMsIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoIGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkgKSAmJlxuXHRcdFx0XHRcdFx0XHRmaW5kLmNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRwdXNoLmNhbGwoIHJlc3VsdHMsIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDIgXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKCBtID0gbWF0Y2hbIDMgXSApICYmIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggIW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoICFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cblx0XHRcdFx0Ly8gcVNBIGNvbnNpZGVycyBlbGVtZW50cyBvdXRzaWRlIGEgc2NvcGluZyByb290IHdoZW4gZXZhbHVhdGluZyBjaGlsZCBvclxuXHRcdFx0XHQvLyBkZXNjZW5kYW50IGNvbWJpbmF0b3JzLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LlxuXHRcdFx0XHQvLyBJbiBzdWNoIGNhc2VzLCB3ZSB3b3JrIGFyb3VuZCB0aGUgYmVoYXZpb3IgYnkgcHJlZml4aW5nIGV2ZXJ5IHNlbGVjdG9yIGluIHRoZVxuXHRcdFx0XHQvLyBsaXN0IHdpdGggYW4gSUQgc2VsZWN0b3IgcmVmZXJlbmNpbmcgdGhlIHNjb3BlIGNvbnRleHQuXG5cdFx0XHRcdC8vIFRoZSB0ZWNobmlxdWUgaGFzIHRvIGJlIHVzZWQgYXMgd2VsbCB3aGVuIGEgbGVhZGluZyBjb21iaW5hdG9yIGlzIHVzZWRcblx0XHRcdFx0Ly8gYXMgc3VjaCBzZWxlY3RvcnMgYXJlIG5vdCByZWNvZ25pemVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwuXG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHRlY2huaXF1ZS5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggcmRlc2NlbmQudGVzdCggc2VsZWN0b3IgKSB8fCBybGVhZGluZ0NvbWJpbmF0b3IudGVzdCggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gV2UgY2FuIHVzZSA6c2NvcGUgaW5zdGVhZCBvZiB0aGUgSUQgaGFjayBpZiB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdC8vIHN1cHBvcnRzIGl0ICYgaWYgd2UncmUgbm90IGNoYW5naW5nIHRoZSBjb250ZXh0LlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW5cblx0XHRcdFx0XHQvLyBzdHJpY3QtY29tcGFyaW5nIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICE9IGNvbnRleHQgfHwgIXN1cHBvcnQuc2NvcGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0XHRpZiAoICggbmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApICkgKSB7XG5cdFx0XHRcdFx0XHRcdG5pZCA9IGpRdWVyeS5lc2NhcGVTZWxlY3RvciggbmlkICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAoIG5pZCA9IGV4cGFuZG8gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzWyBpIF0gPSAoIG5pZCA/IFwiI1wiICsgbmlkIDogXCI6c2NvcGVcIiApICsgXCIgXCIgK1xuXHRcdFx0XHRcdFx0XHR0b1NlbGVjdG9yKCBncm91cHNbIGkgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbUNTUywgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXNcblx0XHQvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL2lzc3Vlcy8xNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoIGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUgKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBqUXVlcnkgc2VsZWN0b3IgbW9kdWxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblxuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApIHx8IG5vZGVOYW1lKCBlbGVtLCBcImJ1dHRvblwiICkgKSAmJlxuXHRcdFx0ZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExK1xuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0aW5EaXNhYmxlZEZpZWxkc2V0KCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoIGogPSBtYXRjaEluZGV4ZXNbIGkgXSApIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFsgaiBdID0gISggbWF0Y2hlc1sgaiBdID0gc2VlZFsgaiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIGpRdWVyeSBzZWxlY3RvciBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW25vZGVdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIHNldERvY3VtZW50KCBub2RlICkge1xuXHR2YXIgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoIGRvYyA9PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhalF1ZXJ5LmlzWE1MRG9jKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IGlPUyA3IG9ubHksIElFIDkgLSAxMStcblx0Ly8gT2xkZXIgYnJvd3NlcnMgZGlkbid0IHN1cHBvcnQgdW5wcmVmaXhlZCBgbWF0Y2hlc2AuXG5cdG1hdGNoZXMgPSBkb2N1bWVudEVsZW1lbnQubWF0Y2hlcyB8fFxuXHRcdGRvY3VtZW50RWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2N1bWVudEVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3I7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnNcblx0Ly8gKHNlZSB0cmFjLTEzOTM2KS5cblx0Ly8gTGltaXQgdGhlIGZpeCB0byBJRSAmIEVkZ2UgTGVnYWN5OyBkZXNwaXRlIEVkZ2UgMTUrIGltcGxlbWVudGluZyBgbWF0Y2hlc2AsXG5cdC8vIGFsbCBJRSA5KyBhbmQgRWRnZSBMZWdhY3kgdmVyc2lvbnMgaW1wbGVtZW50IGBtc01hdGNoZXNTZWxlY3RvcmAgYXMgd2VsbC5cblx0aWYgKCBkb2N1bWVudEVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3IgJiZcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0cHJlZmVycmVkRG9jICE9IGRvY3VtZW50ICYmXG5cdFx0KCBzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldyApICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGpRdWVyeS5leHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHxcblx0XHRcdCFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggalF1ZXJ5LmV4cGFuZG8gKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUuXG5cdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRyZXR1cm4gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblx0fSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0Ly8gSUUvRWRnZSBkb24ndCBzdXBwb3J0IHRoZSA6c2NvcGUgcHNldWRvLWNsYXNzLlxuXHRzdXBwb3J0LnNjb3BlID0gYXNzZXJ0KCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggXCI6c2NvcGVcIiApO1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogQ2hyb21lIDEwNSAtIDExMSBvbmx5LCBTYWZhcmkgMTUuNCAtIDE2LjMgb25seVxuXHQvLyBNYWtlIHN1cmUgdGhlIGA6aGFzKClgIGFyZ3VtZW50IGlzIHBhcnNlZCB1bmZvcmdpdmluZ2x5LlxuXHQvLyBXZSBpbmNsdWRlIGAqYCBpbiB0aGUgdGVzdCB0byBkZXRlY3QgYnVnZ3kgaW1wbGVtZW50YXRpb25zIHRoYXQgYXJlXG5cdC8vIF9zZWxlY3RpdmVseV8gZm9yZ2l2aW5nIChzcGVjaWZpY2FsbHkgd2hlbiB0aGUgbGlzdCBpbmNsdWRlcyBhdCBsZWFzdFxuXHQvLyBvbmUgdmFsaWQgc2VsZWN0b3IpLlxuXHQvLyBOb3RlIHRoYXQgd2UgdHJlYXQgY29tcGxldGUgbGFjayBvZiBzdXBwb3J0IGZvciBgOmhhcygpYCBhcyBpZiBpdCB3ZXJlXG5cdC8vIHNwZWMtY29tcGxpYW50IHN1cHBvcnQsIHdoaWNoIGlzIGZpbmUgYmVjYXVzZSB1c2Ugb2YgYDpoYXMoKWAgaW4gc3VjaFxuXHQvLyBlbnZpcm9ubWVudHMgd2lsbCBmYWlsIGluIHRoZSBxU0EgcGF0aCBhbmQgZmFsbCBiYWNrIHRvIGpRdWVyeSB0cmF2ZXJzYWxcblx0Ly8gYW55d2F5LlxuXHRzdXBwb3J0LmNzc0hhcyA9IGFzc2VydCggZnVuY3Rpb24oKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIFwiOmhhcygqLDpqcWZha2UpXCIgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlci5JRCA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kLklEID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlci5JRCA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmQuSUQgPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZC5UQUcgPSBmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZC5DTEFTUyA9IGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHRcdHZhciBpbnB1dDtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPVxuXHRcdFx0XCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBkaXNhYmxlZD0nZGlzYWJsZWQnPlwiICtcblx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdC8vIFN1cHBvcnQ6IGlPUyA8PTcgLSA4IG9ubHlcblx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5IGluIHNvbWUgWE1MIGRvY3VtZW50c1xuXHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW3NlbGVjdGVkXVwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBpT1MgPD03IC0gOCBvbmx5XG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIn49XCIgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBpT1MgOCBvbmx5XG5cdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLiMuK1srfl1cIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTEwNSssIEZpcmVmb3ggPD0xMDQrLCBTYWZhcmkgPD0xNS40K1xuXHRcdC8vIEluIHNvbWUgb2YgdGhlIGRvY3VtZW50IGtpbmRzLCB0aGVzZSBzZWxlY3RvcnMgd291bGRuJ3Qgd29yayBuYXRpdmVseS5cblx0XHQvLyBUaGlzIGlzIHByb2JhYmx5IE9LIGJ1dCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2Ugd2FudCB0byBtYWludGFpblxuXHRcdC8vIGhhbmRsaW5nIHRoZW0gdGhyb3VnaCBqUXVlcnkgdHJhdmVyc2FsIGluIGpRdWVyeSAzLnguXG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCI6Y2hlY2tlZFwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmNoZWNrZWRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG5cdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MTA1KywgRmlyZWZveCA8PTEwNCssIFNhZmFyaSA8PTE1LjQrXG5cdFx0Ly8gSW4gc29tZSBvZiB0aGUgZG9jdW1lbnQga2luZHMsIHRoZXNlIHNlbGVjdG9ycyB3b3VsZG4ndCB3b3JrIG5hdGl2ZWx5LlxuXHRcdC8vIFRoaXMgaXMgcHJvYmFibHkgT0sgYnV0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3ZSB3YW50IHRvIG1haW50YWluXG5cdFx0Ly8gaGFuZGxpbmcgdGhlbSB0aHJvdWdoIGpRdWVyeSB0cmF2ZXJzYWwgaW4galF1ZXJ5IDMueC5cblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCI6ZGlzYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRSAxMS9FZGdlIGRvbid0IGZpbmQgZWxlbWVudHMgb24gYSBgW25hbWU9JyddYCBxdWVyeSBpbiBzb21lIGNhc2VzLlxuXHRcdC8vIEFkZGluZyBhIHRlbXBvcmFyeSBhdHRyaWJ1dGUgdG8gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgc2VsZWN0aW9uIHdvcmtzXG5cdFx0Ly8gYXJvdW5kIHRoZSBpc3N1ZS5cblx0XHQvLyBJbnRlcmVzdGluZ2x5LCBJRSAxMCAmIG9sZGVyIGRvbid0IHNlZW0gdG8gaGF2ZSB0aGUgaXNzdWUuXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIlwiICk7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbmFtZT0nJ11cIiApLmxlbmd0aCApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqbmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKj1cIiArXG5cdFx0XHRcdHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdH1cblx0fSApO1xuXG5cdGlmICggIXN1cHBvcnQuY3NzSGFzICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDEwNSAtIDExMCssIFNhZmFyaSAxNS40IC0gMTYuMytcblx0XHQvLyBPdXIgcmVndWxhciBgdHJ5LWNhdGNoYCBtZWNoYW5pc20gZmFpbHMgdG8gZGV0ZWN0IG5hdGl2ZWx5LXVuc3VwcG9ydGVkXG5cdFx0Ly8gcHNldWRvLWNsYXNzZXMgaW5zaWRlIGA6aGFzKClgIChzdWNoIGFzIGA6aGFzKDpjb250YWlucyhcIkZvb1wiKSlgKVxuXHRcdC8vIGluIGJyb3dzZXJzIHRoYXQgcGFyc2UgdGhlIGA6aGFzKClgIGFyZ3VtZW50IGFzIGEgZm9yZ2l2aW5nIHNlbGVjdG9yIGxpc3QuXG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3NlbGVjdG9ycy8jcmVsYXRpb25hbCBub3cgcmVxdWlyZXMgdGhlIGFyZ3VtZW50XG5cdFx0Ly8gdG8gYmUgcGFyc2VkIHVuZm9yZ2l2aW5nbHksIGJ1dCBicm93c2VycyBoYXZlIG5vdCB5ZXQgZnVsbHkgYWRqdXN0ZWQuXG5cdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmhhc1wiICk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKCBcInxcIiApICk7XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCAhc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlICkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRmaW5kLmNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGEgKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGZpbmQuY29udGFpbnMoIHByZWZlcnJlZERvYywgYiApICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBhICkgLSBpbmRleE9mLmNhbGwoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59XG5cbmZpbmQubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIGZpbmQoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5maW5kLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHRzZXREb2N1bWVudCggZWxlbSApO1xuXG5cdGlmICggZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBleHByLCB0cnVlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZpbmQoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5maW5kLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuXG5maW5kLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIHRyYWMtMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRpZiAoIHZhbCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcbn07XG5cbmZpbmQuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0Ly9cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCtcblx0Ly8gVGVzdGluZyBmb3IgZGV0ZWN0aW5nIGR1cGxpY2F0ZXMgaXMgdW5wcmVkaWN0YWJsZSBzbyBpbnN0ZWFkIGFzc3VtZSB3ZSBjYW4ndFxuXHQvLyBkZXBlbmQgb24gZHVwbGljYXRlIGRldGVjdGlvbiBpbiBhbGwgYnJvd3NlcnMgd2l0aG91dCBhIHN0YWJsZSBzb3J0LlxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5zb3J0U3RhYmxlO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHNsaWNlLmNhbGwoIHJlc3VsdHMsIDAgKTtcblx0c29ydC5jYWxsKCByZXN1bHRzLCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHNwbGljZS5jYWxsKCByZXN1bHRzLCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbmpRdWVyeS5mbi51bmlxdWVTb3J0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LnVuaXF1ZVNvcnQoIHNsaWNlLmFwcGx5KCB0aGlzICkgKSApO1xufTtcblxuRXhwciA9IGpRdWVyeS5leHByID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdEFUVFI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFsgMyBdID0gKCBtYXRjaFsgMyBdIHx8IG1hdGNoWyA0IF0gfHwgbWF0Y2hbIDUgXSB8fCBcIlwiIClcblx0XHRcdFx0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbIDIgXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFsgMyBdID0gXCIgXCIgKyBtYXRjaFsgMyBdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRDSElMRDogZnVuY3Rpb24oIG1hdGNoICkge1xuXG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMSBdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0XHRmaW5kLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFsgNCBdID0gKyggbWF0Y2hbIDQgXSA/XG5cdFx0XHRcdFx0bWF0Y2hbIDUgXSArICggbWF0Y2hbIDYgXSB8fCAxICkgOlxuXHRcdFx0XHRcdDIgKiAoIG1hdGNoWyAzIF0gPT09IFwiZXZlblwiIHx8IG1hdGNoWyAzIF0gPT09IFwib2RkXCIgKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRtYXRjaFsgNSBdID0gKyggKCBtYXRjaFsgNyBdICsgbWF0Y2hbIDggXSApIHx8IG1hdGNoWyAzIF0gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRmaW5kLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0UFNFVURPOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFsgNiBdICYmIG1hdGNoWyAyIF07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByLkNISUxELnRlc3QoIG1hdGNoWyAwIF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSBtYXRjaFsgNCBdIHx8IG1hdGNoWyA1IF0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdCggZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkgKSAmJlxuXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoIGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCApICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRUQUc6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIGV4cGVjdGVkTm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBlbGVtLCBleHBlY3RlZE5vZGVOYW1lICk7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdENMQVNTOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQoIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICtcblx0XHRcdFx0XHRcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkgKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoXG5cdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHxcblx0XHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8XG5cdFx0XHRcdFx0XHRcdFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9ICk7XG5cdFx0fSxcblxuXHRcdEFUVFI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBmaW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCI9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdCA9PT0gY2hlY2s7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCIhPVwiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQgIT09IGNoZWNrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwiXj1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCIqPVwiICkge1xuXHRcdFx0XHRcdHJldHVybiBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwiJD1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwifj1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiIClcblx0XHRcdFx0XHRcdC5pbmRleE9mKCBjaGVjayApID4gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCJ8PVwiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Q0hJTEQ6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBfYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSBub2RlWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlTmFtZSggbm9kZSwgbmFtZSApIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gcGFyZW50WyBleHBhbmRvIF0gfHwgKCBwYXJlbnRbIGV4cGFuZG8gXSA9IHt9ICk7XG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gb3V0ZXJDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoIGVsZW1bIGV4cGFuZG8gXSA9IHt9ICk7XG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGVOYW1lKCBub2RlLCBuYW1lICkgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0UFNFVURPOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblxuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0ZmluZC5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIGpRdWVyeSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZi5jYWxsKCBzZWVkLCBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblxuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdG5vdDogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW1DU1MsIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpIF0gPSAhKCBtYXRjaGVzWyBpIF0gPSBlbGVtICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0Ly8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9pc3N1ZXMvMjk5KVxuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHRoYXM6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZmluZCggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHRjb250YWluczogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgalF1ZXJ5LnRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRsYW5nOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KCBsYW5nIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0ZmluZC5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcInhtbDpsYW5nXCIgKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSggXCJsYW5nXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKCBlbGVtID0gZWxlbS5wYXJlbnROb2RlICkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHR0YXJnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdHJvb3Q6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50RWxlbWVudDtcblx0XHR9LFxuXG5cdFx0Zm9jdXM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiZcblx0XHRcdFx0ZG9jdW1lbnQuaGFzRm9jdXMoKSAmJlxuXHRcdFx0XHQhISggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCApO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRlbmFibGVkOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRkaXNhYmxlZDogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdGNoZWNrZWQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0cmV0dXJuICggbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICYmICEhZWxlbS5jaGVja2VkICkgfHxcblx0XHRcdFx0KCBub2RlTmFtZSggZWxlbSwgXCJvcHRpb25cIiApICYmICEhZWxlbS5zZWxlY3RlZCApO1xuXHRcdH0sXG5cblx0XHRzZWxlY3RlZDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTErXG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcblx0XHRcdC8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byB0cmVhdCB0aGUgZGVmYXVsdCBvcHRpb24gYXNcblx0XHRcdC8vIHNlbGVjdGVkIHdoZW4gaW4gYW4gb3B0Z3JvdXAuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0ZW1wdHk6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3MuZW1wdHkoIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdGhlYWRlcjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdGlucHV0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0YnV0dG9uOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8XG5cdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImJ1dHRvblwiICk7XG5cdFx0fSxcblxuXHRcdHRleHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICYmIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8MTAgb25seVxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyXG5cdFx0XHRcdC8vIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoICggYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICkgPT0gbnVsbCB8fFxuXHRcdFx0XHRcdGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdGZpcnN0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9ICksXG5cblx0XHRsYXN0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0gKSxcblxuXHRcdGVxOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9ICksXG5cblx0XHRldmVuOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0b2RkOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0bHQ6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0aWYgKCBhcmd1bWVudCA8IDAgKSB7XG5cdFx0XHRcdGkgPSBhcmd1bWVudCArIGxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAoIGFyZ3VtZW50ID4gbGVuZ3RoICkge1xuXHRcdFx0XHRpID0gbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IGFyZ3VtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0Z3Q6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3MubnRoID0gRXhwci5wc2V1ZG9zLmVxO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbmZ1bmN0aW9uIHRva2VuaXplKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKCBtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWyAwIF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKCB0b2tlbnMgPSBbXSApICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoICggbWF0Y2ggPSBybGVhZGluZ0NvbWJpbmF0b3IuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbIDAgXS5yZXBsYWNlKCBydHJpbUNTUywgXCIgXCIgKVxuXHRcdFx0fSApO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKCBtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkgKSAmJiAoICFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KCBtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSApICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRpZiAoIHBhcnNlT25seSApIHtcblx0XHRyZXR1cm4gc29GYXIubGVuZ3RoO1xuXHR9XG5cblx0cmV0dXJuIHNvRmFyID9cblx0XHRmaW5kLmVycm9yKCBzZWxlY3RvciApIDpcblxuXHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn1cblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1sgaSBdLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKCBlbGVtWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgbm9kZU5hbWUoIGVsZW0sIHNraXAgKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAoIG9sZENhY2hlID0gb3V0ZXJDYWNoZVsga2V5IF0gKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAoIG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAoIG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzWyBpIF0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbIDAgXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRmaW5kKCBzZWxlY3RvciwgY29udGV4dHNbIGkgXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLCBtYXRjaGVyT3V0LFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8XG5cdFx0XHRcdG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLFxuXHRcdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXM7XG5cblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cblx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyXG5cdFx0XHQvLyBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0bWF0Y2hlck91dCA9IHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRyZXN1bHRzO1xuXG5cdFx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXJJbjtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICggZWxlbSA9IHRlbXBbIGkgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbIGkgXSBdID0gISggbWF0Y2hlckluWyBwb3N0TWFwWyBpIF0gXSA9IGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblxuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKCBtYXRjaGVySW5bIGkgXSA9IGVsZW0gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAoIG1hdGNoZXJPdXQgPSBbXSApLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSAmJlxuXHRcdFx0XHRcdFx0KCB0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YuY2FsbCggc2VlZCwgZWxlbSApIDogcHJlTWFwWyBpIF0gKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkWyB0ZW1wIF0gPSAhKCByZXN1bHRzWyB0ZW1wIF0gPSBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAwIF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVsgXCIgXCIgXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdCggY2hlY2tDb250ZXh0ID0gY29udGV4dCApLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50XG5cdFx0XHQvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL2lzc3Vlcy8yOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIGkgXS50eXBlIF0gKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKCBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlciApIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zWyBpIF0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbIGkgXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIGogXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3RvcihcblxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKVxuXHRcdFx0XHRcdFx0XHQuY29uY2F0KCB7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSApXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbUNTUywgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAoIHRva2VucyA9IHRva2Vucy5zbGljZSggaiApICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kLlRBRyggXCIqXCIsIG91dGVybW9zdCApLFxuXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoIGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xICksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBpT1MgPD03IC0gOSBvbmx5XG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmdcblx0XHRcdC8vIGVsZW1lbnRzIGJ5IGlkLiAoc2VlIHRyYWMtMTQxNDIpXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cHVzaC5jYWxsKCByZXN1bHRzLCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblxuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0gKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoICggbWF0Y2hlciA9IHNldE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISggdW5tYXRjaGVkWyBpIF0gfHwgc2V0TWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFsgaSBdID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5mdW5jdGlvbiBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblxuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFsgaSBdICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3Rvcixcblx0XHRcdG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufVxuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggalF1ZXJ5J3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBqUXVlcnkgc2VsZWN0b3IgY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbmZ1bmN0aW9uIHNlbGVjdCggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKCBzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yICkgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKCB0b2tlbiA9IHRva2Vuc1sgMCBdICkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAxIF0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmQuSUQoXG5cdFx0XHRcdHRva2VuLm1hdGNoZXNbIDAgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRjb250ZXh0XG5cdFx0XHQpIHx8IFtdIClbIDAgXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHIubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zWyBpIF07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKCB0eXBlID0gdG9rZW4udHlwZSApIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoIGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSApICkge1xuXG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoICggc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1sgMCBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWyAwIF0udHlwZSApICYmXG5cdFx0XHRcdFx0XHR0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpICkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIC0gNC4xK1xuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoIFwiXCIgKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKCBcIlwiICkgPT09IGV4cGFuZG87XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCAtIDQuMStcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKSApICYgMTtcbn0gKTtcblxualF1ZXJ5LmZpbmQgPSBmaW5kO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlID0galF1ZXJ5LnVuaXF1ZVNvcnQ7XG5cbi8vIFRoZXNlIGhhdmUgYWx3YXlzIGJlZW4gcHJpdmF0ZSwgYnV0IHRoZXkgdXNlZCB0byBiZSBkb2N1bWVudGVkIGFzIHBhcnQgb2Zcbi8vIFNpenpsZSBzbyBsZXQncyBtYWludGFpbiB0aGVtIGZvciBub3cgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHB1cnBvc2VzLlxuZmluZC5jb21waWxlID0gY29tcGlsZTtcbmZpbmQuc2VsZWN0ID0gc2VsZWN0O1xuZmluZC5zZXREb2N1bWVudCA9IHNldERvY3VtZW50O1xuZmluZC50b2tlbml6ZSA9IHRva2VuaXplO1xuXG5maW5kLmVzY2FwZSA9IGpRdWVyeS5lc2NhcGVTZWxlY3RvcjtcbmZpbmQuZ2V0VGV4dCA9IGpRdWVyeS50ZXh0O1xuZmluZC5pc1hNTCA9IGpRdWVyeS5pc1hNTERvYztcbmZpbmQuc2VsZWN0b3JzID0galF1ZXJ5LmV4cHI7XG5maW5kLnN1cHBvcnQgPSBqUXVlcnkuc3VwcG9ydDtcbmZpbmQudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWVTb3J0O1xuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxufSApKCk7XG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKHRyYWMtOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKHRyYWMtMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIGpRdWVyeSNmaW5kXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdGlmICggZWxlbS5jb250ZW50RG9jdW1lbnQgIT0gbnVsbCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMStcblx0XHRcdC8vIDxvYmplY3Q+IGVsZW1lbnRzIHdpdGggbm8gYGRhdGFgIGF0dHJpYnV0ZSBoYXMgYW4gb2JqZWN0XG5cdFx0XHQvLyBgY29udGVudERvY3VtZW50YCB3aXRoIGEgYG51bGxgIHByb3RvdHlwZS5cblx0XHRcdGdldFByb3RvKCBlbGVtLmNvbnRlbnREb2N1bWVudCApICkge1xuXG5cdFx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG5cdFx0Ly8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG5cdFx0Ly8gZG9uJ3Qgc3VwcG9ydCBpdC5cblx0XHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcblx0XHRcdGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIF9pLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0gaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MuZXJyb3IgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgZXJyb3IsIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0RXJyb3JIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5lcnJvciA9IGpRdWVyeS5EZWZlcnJlZC5nZXRFcnJvckhvb2soKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBkZXByZWNhdGVkIGFsaWFzIG9mIHRoZSBhYm92ZS4gV2hpbGUgdGhlIG5hbWUgc3VnZ2VzdHNcblx0XHRcdFx0XHRcdFx0XHQvLyByZXR1cm5pbmcgdGhlIHN0YWNrLCBub3QgYW4gZXJyb3IgaW5zdGFuY2UsIGpRdWVyeSBqdXN0IHBhc3Nlc1xuXHRcdFx0XHRcdFx0XHRcdC8vIGl0IGRpcmVjdGx5IHRvIGBjb25zb2xlLndhcm5gIHNvIGJvdGggd2lsbCB3b3JrOyBhbiBpbnN0YW5jZVxuXHRcdFx0XHRcdFx0XHRcdC8vIGp1c3QgYmV0dGVyIGNvb3BlcmF0ZXMgd2l0aCBzb3VyY2UgbWFwcy5cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5lcnJvciA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBwcmltYXJ5IERlZmVycmVkXG5cdFx0XHRwcmltYXJ5ID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdHByaW1hcnkucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIHByaW1hcnkuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgcHJpbWFyeS5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBwcmltYXJ5LnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBwcmltYXJ5LnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIHByaW1hcnkucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByaW1hcnkucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG4vLyBJZiBgalF1ZXJ5LkRlZmVycmVkLmdldEVycm9ySG9va2AgaXMgZGVmaW5lZCwgYGFzeW5jRXJyb3JgIGlzIGFuIGVycm9yXG4vLyBjYXB0dXJlZCBiZWZvcmUgdGhlIGFzeW5jIGJhcnJpZXIgdG8gZ2V0IHRoZSBvcmlnaW5hbCBlcnJvciBjYXVzZVxuLy8gd2hpY2ggbWF5IG90aGVyd2lzZSBiZSBoaWRkZW4uXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgYXN5bmNFcnJvciApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsXG5cdFx0XHRlcnJvci5zdGFjaywgYXN5bmNFcnJvciApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgdHJhYy02NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBfa2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBfYWxsLCBsZXR0ZXIgKSB7XG5cdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbn1cblxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKHRyYWMtOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlIHRyYWMtODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKHRyYWMtMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG5cdHZhciBpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0XHR9LFxuXHRcdGNvbXBvc2VkID0geyBjb21wb3NlZDogdHJ1ZSB9O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCssIGlPUyAxMC4wIC0gMTAuMiBvbmx5XG5cdC8vIENoZWNrIGF0dGFjaG1lbnQgYWNyb3NzIHNoYWRvdyBET00gYm91bmRhcmllcyB3aGVuIHBvc3NpYmxlIChnaC0zNTA0KVxuXHQvLyBTdXBwb3J0OiBpT1MgMTAuMC0xMC4yIG9ubHlcblx0Ly8gRWFybHkgaU9TIDEwIHZlcnNpb25zIHN1cHBvcnQgYGF0dGFjaFNoYWRvd2AgYnV0IG5vdCBgZ2V0Um9vdE5vZGVgLFxuXHQvLyBsZWFkaW5nIHRvIGVycm9ycy4gV2UgbmVlZCB0byBjaGVjayBmb3IgYGdldFJvb3ROb2RlYC5cblx0aWYgKCBkb2N1bWVudEVsZW1lbnQuZ2V0Um9vdE5vZGUgKSB7XG5cdFx0aXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRSb290Tm9kZSggY29tcG9zZWQgKSA9PT0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdH07XG5cdH1cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpc0F0dGFjaGVkKCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9IGVsZW0ubm9kZVR5cGUgJiZcblx0XHRcdCggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMDtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHR9XG5cblx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKHRyYWMtMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICh0cmFjLTE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gSUUgPD05IHJlcGxhY2VzIDxvcHRpb24+IHRhZ3Mgd2l0aCB0aGVpciBjb250ZW50cyB3aGVuIGluc2VydGVkIG91dHNpZGUgb2Zcblx0Ly8gdGhlIHNlbGVjdCBlbGVtZW50LlxuXHRkaXYuaW5uZXJIVE1MID0gXCI8b3B0aW9uPjwvb3B0aW9uPlwiO1xuXHRzdXBwb3J0Lm9wdGlvbiA9ICEhZGl2Lmxhc3RDaGlsZDtcbn0gKSgpO1xuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICh0cmFjLTEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5pZiAoICFzdXBwb3J0Lm9wdGlvbiApIHtcblx0d3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uID0gWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdO1xufVxuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAodHJhYy0xNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKHRyYWMtMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGF0dGFjaGVkID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBhdHRhY2hlZCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxudmFyIHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gT25seSBhdHRhY2ggZXZlbnRzIHRvIG9iamVjdHMgdGhhdCBhY2NlcHQgZGF0YVxuXHRcdGlmICggIWFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSBPYmplY3QuY3JlYXRlKCBudWxsICk7XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cblx0XHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApLFxuXG5cdFx0XHRoYW5kbGVycyA9IChcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHQpWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG5cdFx0XHRcdC8vIHNwZWNpYWxseSB1bml2ZXJzYWwgb3IgaXRzIG5hbWVzcGFjZXMgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGV2ZW50J3MuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0XHRldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICh0cmFjLTEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAodHJhYy02OTExLCB0cmFjLTgxNjUsIHRyYWMtMTEzODIsIHRyYWMtMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAodHJhYy0xMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBpc1NldHVwICkge1xuXG5cdC8vIE1pc3NpbmcgYGlzU2V0dXBgIGluZGljYXRlcyBhIHRyaWdnZXIgY2FsbCwgd2hpY2ggbXVzdCBmb3JjZSBzZXR1cCB0aHJvdWdoIGpRdWVyeS5ldmVudC5hZGRcblx0aWYgKCAhaXNTZXR1cCApIHtcblx0XHRpZiAoIGRhdGFQcml2LmdldCggZWwsIHR5cGUgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHJldHVyblRydWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVnaXN0ZXIgdGhlIGNvbnRyb2xsZXIgYXMgYSBzcGVjaWFsIHVuaXZlcnNhbCBoYW5kbGVyIGZvciBhbGwgZXZlbnQgbmFtZXNwYWNlc1xuXHRkYXRhUHJpdi5zZXQoIGVsLCB0eXBlLCBmYWxzZSApO1xuXHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwge1xuXHRcdG5hbWVzcGFjZTogZmFsc2UsXG5cdFx0aGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJlc3VsdCxcblx0XHRcdFx0c2F2ZWQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0aWYgKCAoIGV2ZW50LmlzVHJpZ2dlciAmIDEgKSAmJiB0aGlzWyB0eXBlIF0gKSB7XG5cblx0XHRcdFx0Ly8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcblx0XHRcdFx0aWYgKCAhc2F2ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdHRoaXNbIHR5cGUgXSgpO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgZmFsc2UgKTtcblxuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSBvdXRlciBzeW50aGV0aWMgZXZlbnRcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmdcblx0XHRcdFx0Ly8gdGhlIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZCApIHtcblxuXHRcdFx0XHQvLyAuLi5hbmQgY2FwdHVyZSB0aGUgcmVzdWx0XG5cdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cdFx0XHRcdFx0c2F2ZWRbIDAgXSxcblx0XHRcdFx0XHRzYXZlZC5zbGljZSggMSApLFxuXHRcdFx0XHRcdHRoaXNcblx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdC8vIEFib3J0IGhhbmRsaW5nIG9mIHRoZSBuYXRpdmUgZXZlbnQgYnkgYWxsIGpRdWVyeSBoYW5kbGVycyB3aGlsZSBhbGxvd2luZ1xuXHRcdFx0XHQvLyBuYXRpdmUgaGFuZGxlcnMgb24gdGhlIHNhbWUgZWxlbWVudCB0byBydW4uIE9uIHRhcmdldCwgdGhpcyBpcyBhY2hpZXZlZFxuXHRcdFx0XHQvLyBieSBzdG9wcGluZyBpbW1lZGlhdGUgcHJvcGFnYXRpb24ganVzdCBvbiB0aGUgalF1ZXJ5IGV2ZW50LiBIb3dldmVyLFxuXHRcdFx0XHQvLyB0aGUgbmF0aXZlIGV2ZW50IGlzIHJlLXdyYXBwZWQgYnkgYSBqUXVlcnkgb25lIG9uIGVhY2ggbGV2ZWwgb2YgdGhlXG5cdFx0XHRcdC8vIHByb3BhZ2F0aW9uIHNvIHRoZSBvbmx5IHdheSB0byBzdG9wIGl0IGZvciBqUXVlcnkgaXMgdG8gc3RvcCBpdCBmb3Jcblx0XHRcdFx0Ly8gZXZlcnlvbmUgdmlhIG5hdGl2ZSBgc3RvcFByb3BhZ2F0aW9uKClgLiBUaGlzIGlzIG5vdCBhIHByb2JsZW0gZm9yXG5cdFx0XHRcdC8vIGZvY3VzL2JsdXIgd2hpY2ggZG9uJ3QgYnViYmxlLCBidXQgaXQgZG9lcyBhbHNvIHN0b3AgY2xpY2sgb24gY2hlY2tib3hlc1xuXHRcdFx0XHQvLyBhbmQgcmFkaW9zLiBXZSBhY2NlcHQgdGhpcyBsaW1pdGF0aW9uLlxuXHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0ZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKHRyYWMtNTA0LCB0cmFjLTEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y29kZTogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cdHdoaWNoOiB0cnVlXG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG5qUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggdHlwZSwgZGVsZWdhdGVUeXBlICkge1xuXG5cdGZ1bmN0aW9uIGZvY3VzTWFwcGVkSGFuZGxlciggbmF0aXZlRXZlbnQgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExK1xuXHRcdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGZvY3VzaW4vZm9jdXNvdXQgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50c1xuXHRcdFx0Ly8gZm9jdXMvYmx1ci4gVGhpcyBpcyBiZWNhdXNlIHRoZSBmb3JtZXIgYXJlIHN5bmNocm9ub3VzIGluIElFIHdoaWxlIHRoZSBsYXR0ZXJcblx0XHRcdC8vIGFyZSBhc3luYy4gSW4gb3RoZXIgYnJvd3NlcnMsIGFsbCB0aG9zZSBoYW5kbGVycyBhcmUgaW52b2tlZCBzeW5jaHJvbm91c2x5LlxuXG5cdFx0XHQvLyBgaGFuZGxlYCBmcm9tIHByaXZhdGUgZGF0YSB3b3VsZCBhbHJlYWR5IHdyYXAgdGhlIGV2ZW50LCBidXQgd2UgbmVlZFxuXHRcdFx0Ly8gdG8gY2hhbmdlIHRoZSBgdHlwZWAgaGVyZS5cblx0XHRcdHZhciBoYW5kbGUgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiaGFuZGxlXCIgKSxcblx0XHRcdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXHRcdFx0ZXZlbnQudHlwZSA9IG5hdGl2ZUV2ZW50LnR5cGUgPT09IFwiZm9jdXNpblwiID8gXCJmb2N1c1wiIDogXCJibHVyXCI7XG5cdFx0XHRldmVudC5pc1NpbXVsYXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIEZpcnN0LCBoYW5kbGUgZm9jdXNpbi9mb2N1c291dFxuXHRcdFx0aGFuZGxlKCBuYXRpdmVFdmVudCApO1xuXG5cdFx0XHQvLyAuLi50aGVuLCBoYW5kbGUgZm9jdXMvYmx1clxuXHRcdFx0Ly9cblx0XHRcdC8vIGZvY3VzL2JsdXIgZG9uJ3QgYnViYmxlIHdoaWxlIGZvY3VzaW4vZm9jdXNvdXQgZG87IHNpbXVsYXRlIHRoZSBmb3JtZXIgYnkgb25seVxuXHRcdFx0Ly8gaW52b2tpbmcgdGhlIGhhbmRsZXIgYXQgdGhlIGxvd2VyIGxldmVsLlxuXHRcdFx0aWYgKCBldmVudC50YXJnZXQgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQgKSB7XG5cblx0XHRcdFx0Ly8gVGhlIHNldHVwIHBhcnQgY2FsbHMgYGxldmVyYWdlTmF0aXZlYCwgd2hpY2gsIGluIHR1cm4sIGNhbGxzXG5cdFx0XHRcdC8vIGBqUXVlcnkuZXZlbnQuYWRkYCwgc28gZXZlbnQgaGFuZGxlIHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gc2V0XG5cdFx0XHRcdC8vIGJ5IHRoaXMgcG9pbnQuXG5cdFx0XHRcdGhhbmRsZSggZXZlbnQgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3Igbm9uLUlFIGJyb3dzZXJzLCBhdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50XG5cdFx0XHQvLyB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXQuXG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGRlbGVnYXRlVHlwZSwgbmF0aXZlRXZlbnQudGFyZ2V0LFxuXHRcdFx0XHRqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApICk7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSA9IHtcblxuXHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0dmFyIGF0dGFjaGVzO1xuXG5cdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiYmx1clwiLCAuLi4gKVxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUsIHRydWUgKTtcblxuXHRcdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHRcdFx0XHQvLyBXZSB1c2UgdGhlIHNhbWUgbmF0aXZlIGhhbmRsZXIgZm9yIGZvY3VzaW4gJiBmb2N1cyAoYW5kIGZvY3Vzb3V0ICYgYmx1cilcblx0XHRcdFx0Ly8gc28gd2UgbmVlZCB0byBjb29yZGluYXRlIHNldHVwICYgdGVhcmRvd24gcGFydHMgYmV0d2VlbiB0aG9zZSBldmVudHMuXG5cdFx0XHRcdC8vIFVzZSBgZGVsZWdhdGVUeXBlYCBhcyB0aGUga2V5IGFzIGB0eXBlYCBpcyBhbHJlYWR5IHVzZWQgYnkgYGxldmVyYWdlTmF0aXZlYC5cblx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIGRlbGVnYXRlVHlwZSApO1xuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBkZWxlZ2F0ZVR5cGUsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXR0YWNoZXM7XG5cblx0XHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRNb2RlICkge1xuXHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmdldCggdGhpcywgZGVsZWdhdGVUeXBlICkgLSAxO1xuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCB0aGlzLCBkZWxlZ2F0ZVR5cGUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIGRlbGVnYXRlVHlwZSwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gaW5kaWNhdGUgc3RhbmRhcmQgdGVhcmRvd24gc2hvdWxkIGJlIGFwcGxpZWRcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBTdXBwcmVzcyBuYXRpdmUgZm9jdXMgb3IgYmx1ciBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlXG5cdFx0Ly8gYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGV2ZW50LnRhcmdldCwgdHlwZSApO1xuXHRcdH0sXG5cblx0XHRkZWxlZ2F0ZVR5cGU6IGRlbGVnYXRlVHlwZVxuXHR9O1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuXHQvLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG5cdC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG5cdC8vXG5cdC8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuXHQvLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcblx0Ly8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG5cdC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5cdC8vXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0Ly8gVG8gcHJlc2VydmUgcmVsYXRpdmUgZm9jdXNpbi9mb2N1cyAmIGZvY3Vzb3V0L2JsdXIgZXZlbnQgb3JkZXIgZ3VhcmFudGVlZCBvbiB0aGUgMy54IGJyYW5jaCxcblx0Ly8gYXR0YWNoIGEgc2luZ2xlIGhhbmRsZXIgZm9yIGJvdGggZXZlbnRzIGluIElFLlxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZGVsZWdhdGVUeXBlIF0gPSB7XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBIYW5kbGU6IHJlZ3VsYXIgbm9kZXMgKHZpYSBgdGhpcy5vd25lckRvY3VtZW50YCksIHdpbmRvd1xuXHRcdFx0Ly8gKHZpYSBgdGhpcy5kb2N1bWVudGApICYgZG9jdW1lbnQgKHZpYSBgdGhpc2ApLlxuXHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdGRhdGFIb2xkZXIgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgPyB0aGlzIDogZG9jLFxuXHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmdldCggZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0XHRcdC8vIFdlIHVzZSB0aGUgc2FtZSBuYXRpdmUgaGFuZGxlciBmb3IgZm9jdXNpbiAmIGZvY3VzIChhbmQgZm9jdXNvdXQgJiBibHVyKVxuXHRcdFx0Ly8gc28gd2UgbmVlZCB0byBjb29yZGluYXRlIHNldHVwICYgdGVhcmRvd24gcGFydHMgYmV0d2VlbiB0aG9zZSBldmVudHMuXG5cdFx0XHQvLyBVc2UgYGRlbGVnYXRlVHlwZWAgYXMgdGhlIGtleSBhcyBgdHlwZWAgaXMgYWxyZWFkeSB1c2VkIGJ5IGBsZXZlcmFnZU5hdGl2ZWAuXG5cdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCBkZWxlZ2F0ZVR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBmb2N1c01hcHBlZEhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZGF0YVByaXYuc2V0KCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdH0sXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdGRhdGFIb2xkZXIgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgPyB0aGlzIDogZG9jLFxuXHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmdldCggZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlICkgLSAxO1xuXG5cdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCBkZWxlZ2F0ZVR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBmb2N1c01hcHBlZEhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUsIGF0dGFjaGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8IVxcW0NEQVRBXFxbfFxcXVxcXT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuZ2V0KCBzcmMgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZGVzdCwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGZsYXQoIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAodHJhYy04MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZS1lbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSwgZG9jICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVW53cmFwIGEgQ0RBVEEgc2VjdGlvbiBjb250YWluaW5nIHNjcmlwdCBjb250ZW50cy4gVGhpcyBzaG91bGRuJ3QgYmVcblx0XHRcdFx0XHRcdFx0Ly8gbmVlZGVkIGFzIGluIFhNTCBkb2N1bWVudHMgdGhleSdyZSBhbHJlYWR5IG5vdCB2aXNpYmxlIHdoZW5cblx0XHRcdFx0XHRcdFx0Ly8gaW5zcGVjdGluZyBlbGVtZW50IGNvbnRlbnRzIGFuZCBpbiBIVE1MIGRvY3VtZW50cyB0aGV5IGhhdmUgbm9cblx0XHRcdFx0XHRcdFx0Ly8gbWVhbmluZyBidXQgd2UncmUgcHJlc2VydmluZyB0aGF0IGxvZ2ljIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIGJlIHJlbW92ZWQgY29tcGxldGVseSBpbiA0LjAuIFNlZSBnaC00OTA0LlxuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IGpRdWVyeSNmaW5kIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6XG5cdFx0XHQvLyBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciByY3VzdG9tUHJvcCA9IC9eLS0vO1xuXG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICh0cmFjLTE1MDk4LCB0cmFjLTE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5jYWxsKCBlbGVtICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAodHJhYy04OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcblx0XHR9LFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFL0VkZ2UgbWlzcmVwb3J0IGBnZXRDb21wdXRlZFN0eWxlYCBvZiB0YWJsZSByb3dzIHdpdGggd2lkdGgvaGVpZ2h0XG5cdFx0Ly8gc2V0IGluIENTUyB3aGlsZSBgb2Zmc2V0KmAgcHJvcGVydGllcyByZXBvcnQgY29ycmVjdCB2YWx1ZXMuXG5cdFx0Ly8gQmVoYXZpb3IgaW4gSUUgOSBpcyBtb3JlIHN1YnRsZSB0aGFuIGluIG5ld2VyIHZlcnNpb25zICYgaXQgcGFzc2VzXG5cdFx0Ly8gc29tZSB2ZXJzaW9ucyBvZiB0aGlzIHRlc3Q7IG1ha2Ugc3VyZSBub3QgdG8gbWFrZSBpdCBwYXNzIHRoZXJlIVxuXHRcdC8vXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA3MCtcblx0XHQvLyBPbmx5IEZpcmVmb3ggaW5jbHVkZXMgYm9yZGVyIHdpZHRoc1xuXHRcdC8vIGluIGNvbXB1dGVkIGRpbWVuc2lvbnMuIChnaC00NTI5KVxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0YWJsZSwgdHIsIHRyQ2hpbGQsIHRyU3R5bGU7XG5cdFx0XHRpZiAoIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0YWJsZVwiICk7XG5cdFx0XHRcdHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0clwiICk7XG5cdFx0XHRcdHRyQ2hpbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0XHRcdFx0dGFibGUuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGVcIjtcblx0XHRcdFx0dHIuc3R5bGUuY3NzVGV4dCA9IFwiYm94LXNpemluZzpjb250ZW50LWJveDtib3JkZXI6MXB4IHNvbGlkXCI7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDg2K1xuXHRcdFx0XHQvLyBIZWlnaHQgc2V0IHRocm91Z2ggY3NzVGV4dCBkb2VzIG5vdCBnZXQgYXBwbGllZC5cblx0XHRcdFx0Ly8gQ29tcHV0ZWQgaGVpZ2h0IHRoZW4gY29tZXMgYmFjayBhcyAwLlxuXHRcdFx0XHR0ci5zdHlsZS5oZWlnaHQgPSBcIjFweFwiO1xuXHRcdFx0XHR0ckNoaWxkLnN0eWxlLmhlaWdodCA9IFwiOXB4XCI7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA4IENocm9tZSA4Nitcblx0XHRcdFx0Ly8gSW4gb3VyIGJvZHlCYWNrZ3JvdW5kLmh0bWwgaWZyYW1lLFxuXHRcdFx0XHQvLyBkaXNwbGF5IGZvciBhbGwgZGl2IGVsZW1lbnRzIGlzIHNldCB0byBcImlubGluZVwiLFxuXHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgYSBwcm9ibGVtIG9ubHkgaW4gQW5kcm9pZCA4IENocm9tZSA4Ni5cblx0XHRcdFx0Ly8gRW5zdXJpbmcgdGhlIGRpdiBpcyBgZGlzcGxheTogYmxvY2tgXG5cdFx0XHRcdC8vIGdldHMgYXJvdW5kIHRoaXMgaXNzdWUuXG5cdFx0XHRcdHRyQ2hpbGQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnRcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRhYmxlIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyQ2hpbGQgKTtcblxuXHRcdFx0XHR0clN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIHRyICk7XG5cdFx0XHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID0gKCBwYXJzZUludCggdHJTdHlsZS5oZWlnaHQsIDEwICkgK1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0clN0eWxlLmJvcmRlclRvcFdpZHRoLCAxMCApICtcblx0XHRcdFx0XHRwYXJzZUludCggdHJTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCwgMTAgKSApID09PSB0ci5vZmZzZXRIZWlnaHQ7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCB0YWJsZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgdHJhYy0xMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoZ2gtMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdC8vIElFIG9ubHkgc3VwcG9ydHMgYFwiZmxvYXRcImAgaW4gYGdldFByb3BlcnR5VmFsdWVgOyBpbiBjb21wdXRlZCBzdHlsZXNcblx0XHQvLyBpdCdzIG9ubHkgYXZhaWxhYmxlIGFzIGBcImNzc0Zsb2F0XCJgLiBXZSBubyBsb25nZXIgbW9kaWZ5IHByb3BlcnRpZXNcblx0XHQvLyBzZW50IHRvIGAuY3NzKClgIGFwYXJ0IGZyb20gY2FtZWxDYXNpbmcsIHNvIHdlIG5lZWQgdG8gY2hlY2sgYm90aC5cblx0XHQvLyBOb3JtYWxseSwgdGhpcyB3b3VsZCBjcmVhdGUgZGlmZmVyZW5jZSBpbiBiZWhhdmlvcjogaWZcblx0XHQvLyBgZ2V0UHJvcGVydHlWYWx1ZWAgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcsIHRoZSB2YWx1ZSByZXR1cm5lZFxuXHRcdC8vIGJ5IGAuY3NzKClgIHdvdWxkIGJlIGB1bmRlZmluZWRgLiBUaGlzIGlzIHVzdWFsbHkgdGhlIGNhc2UgZm9yXG5cdFx0Ly8gZGlzY29ubmVjdGVkIGVsZW1lbnRzLiBIb3dldmVyLCBpbiBJRSBldmVuIGRpc2Nvbm5lY3RlZCBlbGVtZW50c1xuXHRcdC8vIHdpdGggbm8gc3R5bGVzIHJldHVybiBgXCJub25lXCJgIGZvciBgZ2V0UHJvcGVydHlWYWx1ZSggXCJmbG9hdFwiIClgXG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIGlzQ3VzdG9tUHJvcCAmJiByZXQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMTA1KywgQ2hyb21lIDw9MTA1K1xuXHRcdFx0Ly8gU3BlYyByZXF1aXJlcyB0cmltbWluZyB3aGl0ZXNwYWNlIGZvciBjdXN0b20gcHJvcGVydGllcyAoZ2gtNDkyNikuXG5cdFx0XHQvLyBGaXJlZm94IG9ubHkgdHJpbXMgbGVhZGluZyB3aGl0ZXNwYWNlLiBDaHJvbWUganVzdCBjb2xsYXBzZXNcblx0XHRcdC8vIGJvdGggbGVhZGluZyAmIHRyYWlsaW5nIHdoaXRlc3BhY2UgdG8gYSBzaW5nbGUgc3BhY2UuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gRmFsbCBiYWNrIHRvIGB1bmRlZmluZWRgIGlmIGVtcHR5IHN0cmluZyByZXR1cm5lZC5cblx0XHRcdC8vIFRoaXMgY29sbGFwc2VzIGEgbWlzc2luZyBkZWZpbml0aW9uIHdpdGggcHJvcGVydHkgZGVmaW5lZFxuXHRcdFx0Ly8gYW5kIHNldCB0byBhbiBlbXB0eSBzdHJpbmcgYnV0IHRoZXJlJ3Mgbm8gc3RhbmRhcmQgQVBJXG5cdFx0XHQvLyBhbGxvd2luZyB1cyB0byBkaWZmZXJlbnRpYXRlIHRoZW0gd2l0aG91dCBhIHBlcmZvcm1hbmNlIHBlbmFsdHlcblx0XHRcdC8vIGFuZCByZXR1cm5pbmcgYHVuZGVmaW5lZGAgYWxpZ25zIHdpdGggb2xkZXIgalF1ZXJ5LlxuXHRcdFx0Ly9cblx0XHRcdC8vIHJ0cmltQ1NTIHRyZWF0cyBVKzAwMEQgQ0FSUklBR0UgUkVUVVJOIGFuZCBVKzAwMEMgRk9STSBGRUVEXG5cdFx0XHQvLyBhcyB3aGl0ZXNwYWNlIHdoaWxlIENTUyBkb2VzIG5vdCwgYnV0IHRoaXMgaXMgbm90IGEgcHJvYmxlbVxuXHRcdFx0Ly8gYmVjYXVzZSBDU1MgcHJlcHJvY2Vzc2luZyByZXBsYWNlcyB0aGVtIHdpdGggVSswMDBBIExJTkUgRkVFRFxuXHRcdFx0Ly8gKHdoaWNoICppcyogQ1NTIHdoaXRlc3BhY2UpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNpbnB1dC1wcmVwcm9jZXNzaW5nXG5cdFx0XHRyZXQgPSByZXQucmVwbGFjZSggcnRyaW1DU1MsIFwiJDFcIiApIHx8IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhaXNBdHRhY2hlZCggZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXIgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlLFxuXHR2ZW5kb3JQcm9wcyA9IHt9O1xuXG4vLyBSZXR1cm4gYSB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdIHx8IHZlbmRvclByb3BzWyBuYW1lIF07XG5cblx0aWYgKCBmaW5hbCApIHtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH1cblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH07XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBfZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcblx0dmFyIGkgPSBkaW1lbnNpb24gPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXHRcdGV4dHJhID0gMCxcblx0XHRkZWx0YSA9IDAsXG5cdFx0bWFyZ2luRGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdC8vIENvdW50IG1hcmdpbiBkZWx0YSBzZXBhcmF0ZWx5IHRvIG9ubHkgYWRkIGl0IGFmdGVyIHNjcm9sbCBndXR0ZXIgYWRqdXN0bWVudC5cblx0XHQvLyBUaGlzIGlzIG5lZWRlZCB0byBtYWtlIG5lZ2F0aXZlIG1hcmdpbnMgd29yayB3aXRoIGBvdXRlckhlaWdodCggdHJ1ZSApYCAoZ2gtMzk4MikuXG5cdFx0aWYgKCBib3ggPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRtYXJnaW5EZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBib3ggKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFwicGFkZGluZ1wiIG9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIlxuXHRcdGlmICggIWlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBBZGQgcGFkZGluZ1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcImNvbnRlbnRcIiBvclxuXHRcdC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcblx0XHRcdGlmICggYm94ID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiBvciBcInBhZGRpbmdcIiwgc3VidHJhY3QgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBY2NvdW50IGZvciBwb3NpdGl2ZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyIHdoZW4gcmVxdWVzdGVkIGJ5IHByb3ZpZGluZyBjb21wdXRlZFZhbFxuXHRpZiAoICFpc0JvcmRlckJveCAmJiBjb21wdXRlZFZhbCA+PSAwICkge1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuXHRcdC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cblx0XHRkZWx0YSArPSBNYXRoLm1heCggMCwgTWF0aC5jZWlsKFxuXHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdGNvbXB1dGVkVmFsIC1cblx0XHRcdGRlbHRhIC1cblx0XHRcdGV4dHJhIC1cblx0XHRcdDAuNVxuXG5cdFx0Ly8gSWYgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIHVua25vd24sIHRoZW4gd2UgY2FuJ3QgZGV0ZXJtaW5lIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXJcblx0XHQvLyBVc2UgYW4gZXhwbGljaXQgemVybyB0byBhdm9pZCBOYU4gKGdoLTM5NjQpXG5cdFx0KSApIHx8IDA7XG5cdH1cblxuXHRyZXR1cm4gZGVsdGEgKyBtYXJnaW5EZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gVXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3Igd2hlbiBib3ggc2l6aW5nIGlzIHVucmVsaWFibGUuXG5cdC8vIEluIHRob3NlIGNhc2VzLCB0aGUgY29tcHV0ZWQgdmFsdWUgY2FuIGJlIHRydXN0ZWQgdG8gYmUgYm9yZGVyLWJveC5cblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDEwIC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBJbnRlcmVzdGluZ2x5LCBpbiBzb21lIGNhc2VzIElFIDkgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGlzIGlzc3VlLlxuXHRcdCFzdXBwb3J0LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgbm9kZU5hbWUoIGVsZW0sIFwidHJcIiApIHx8XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0XHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdFx0dmFsID09PSBcImF1dG9cIiB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdFx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApICYmXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSAmIGNvbm5lY3RlZFxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG5cdFx0YXNwZWN0UmF0aW86IHRydWUsXG5cdFx0Ym9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcblx0XHRjb2x1bW5Db3VudDogdHJ1ZSxcblx0XHRmbGV4R3JvdzogdHJ1ZSxcblx0XHRmbGV4U2hyaW5rOiB0cnVlLFxuXHRcdGZvbnRXZWlnaHQ6IHRydWUsXG5cdFx0Z3JpZEFyZWE6IHRydWUsXG5cdFx0Z3JpZENvbHVtbjogdHJ1ZSxcblx0XHRncmlkQ29sdW1uRW5kOiB0cnVlLFxuXHRcdGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcblx0XHRncmlkUm93OiB0cnVlLFxuXHRcdGdyaWRSb3dFbmQ6IHRydWUsXG5cdFx0Z3JpZFJvd1N0YXJ0OiB0cnVlLFxuXHRcdGxpbmVIZWlnaHQ6IHRydWUsXG5cdFx0b3BhY2l0eTogdHJ1ZSxcblx0XHRvcmRlcjogdHJ1ZSxcblx0XHRvcnBoYW5zOiB0cnVlLFxuXHRcdHNjYWxlOiB0cnVlLFxuXHRcdHdpZG93czogdHJ1ZSxcblx0XHR6SW5kZXg6IHRydWUsXG5cdFx0em9vbTogdHJ1ZSxcblxuXHRcdC8vIFNWRy1yZWxhdGVkXG5cdFx0ZmlsbE9wYWNpdHk6IHRydWUsXG5cdFx0Zmxvb2RPcGFjaXR5OiB0cnVlLFxuXHRcdHN0b3BPcGFjaXR5OiB0cnVlLFxuXHRcdHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG5cdFx0c3Ryb2tlT3BhY2l0eTogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAodHJhYy03MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgdHJhYy05MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKHRyYWMtNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBfaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0XHRcdC8vIE9ubHkgcmVhZCBzdHlsZXMucG9zaXRpb24gaWYgdGhlIHRlc3QgaGFzIGEgY2hhbmNlIHRvIGZhaWxcblx0XHRcdFx0Ly8gdG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdy5cblx0XHRcdFx0c2Nyb2xsYm94U2l6ZUJ1Z2d5ID0gIXN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpICYmXG5cdFx0XHRcdFx0c3R5bGVzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIsXG5cblx0XHRcdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtMzk5MSlcblx0XHRcdFx0Ym94U2l6aW5nTmVlZGVkID0gc2Nyb2xsYm94U2l6ZUJ1Z2d5IHx8IGV4dHJhLFxuXHRcdFx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgP1xuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdFx0KSA6XG5cdFx0XHRcdFx0MDtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG5cdFx0XHQvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxuXHRcdFx0aWYgKCBpc0JvcmRlckJveCAmJiBzY3JvbGxib3hTaXplQnVnZ3kgKSB7XG5cdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSB8fFxuXHRcdFx0XHRcdHR3ZWVuLmVsZW0uc3R5bGVbIGZpbmFsUHJvcE5hbWUoIHR3ZWVuLnByb3AgKSBdICE9IG51bGwgKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICh0cmFjLTEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0aXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsICh0cmFjLTEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NOYW1lcywgY3VyLCBjdXJWYWx1ZSwgY2xhc3NOYW1lLCBpLCBmaW5hbFZhbHVlO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzTmFtZXMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0Y3VyID0gdGhpcy5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXNzTmFtZSArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NOYW1lcywgY3VyLCBjdXJWYWx1ZSwgY2xhc3NOYW1lLCBpLCBmaW5hbFZhbHVlO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc05hbWVzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCB0aGlzICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gdGhpcy5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgY2xhc3NOYW1lcywgY2xhc3NOYW1lLCBpLCBzZWxmLFxuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpIF07XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAodHJhYy0xNDY4NiwgdHJhYy0xNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKHRyYWMtMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSB7IGd1aWQ6IERhdGUubm93KCkgfTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sLCBwYXJzZXJFcnJvckVsZW07XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHt9XG5cblx0cGFyc2VyRXJyb3JFbGVtID0geG1sICYmIHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiIClbIDAgXTtcblx0aWYgKCAheG1sIHx8IHBhcnNlckVycm9yRWxlbSApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgKFxuXHRcdFx0cGFyc2VyRXJyb3JFbGVtID9cblx0XHRcdFx0alF1ZXJ5Lm1hcCggcGFyc2VyRXJyb3JFbGVtLmNoaWxkTm9kZXMsIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWwudGV4dENvbnRlbnQ7XG5cdFx0XHRcdH0gKS5qb2luKCBcIlxcblwiICkgOlxuXHRcdFx0XHRkYXRhXG5cdFx0KSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICh0cmFjLTk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICh0cmFjLTk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKHRyYWMtNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKS5tYXAoIGZ1bmN0aW9uKCBfaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gdHJhYy03NjUzLCB0cmFjLTgxMjUsIHRyYWMtODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAodHJhYy0xMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cbm9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyB0cmFjLTk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdID1cblx0XHRcdFx0XHRcdFx0XHRcdCggcmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdIHx8IFtdIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmNvbmNhdCggbWF0Y2hbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaC5qb2luKCBcIiwgXCIgKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICh0cmFjLTEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0IHRyYWMtMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICh0cmFjLTE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gdHJhYy05NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZS5ndWlkKysgKSArXG5cdFx0XHRcdFx0dW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVzZSBhIG5vb3AgY29udmVydGVyIGZvciBtaXNzaW5nIHNjcmlwdCBidXQgbm90IGlmIGpzb25wXG5cdFx0XHRpZiAoICFpc1N1Y2Nlc3MgJiZcblx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIFwic2NyaXB0XCIsIHMuZGF0YVR5cGVzICkgPiAtMSAmJlxuXHRcdFx0XHRqUXVlcnkuaW5BcnJheSggXCJqc29uXCIsIHMuZGF0YVR5cGVzICkgPCAwICkge1xuXHRcdFx0XHRzLmNvbnZlcnRlcnNbIFwidGV4dCBzY3JpcHRcIiBdID0gZnVuY3Rpb24oKSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggX2ksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHR2YXIgaTtcblx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0aWYgKCBpLnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC10eXBlXCIgKSB7XG5cdFx0XHRzLmNvbnRlbnRUeXBlID0gcy5oZWFkZXJzWyBpIF0gfHwgXCJcIjtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsLCBvcHRpb25zLCBkb2MgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICh0cmFjLTExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cblx0XHQvLyBPbmx5IGV2YWx1YXRlIHRoZSByZXNwb25zZSBpZiBpdCBpcyBzdWNjZXNzZnVsIChnaC00MTI2KVxuXHRcdC8vIGRhdGFGaWx0ZXIgaXMgbm90IGludm9rZWQgZm9yIGZhaWx1cmUgcmVzcG9uc2VzLCBzbyB1c2luZyBpdCBpbnN0ZWFkXG5cdFx0Ly8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXG5cdFx0Y29udmVydGVyczoge1xuXHRcdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbigpIHt9XG5cdFx0fSxcblx0XHRkYXRhRmlsdGVyOiBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggcmVzcG9uc2UsIG9wdGlvbnMsIGRvYyApO1xuXHRcdH1cblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyB0cmFjLTE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSB0cmFjLTg2MDUsIHRyYWMtMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vIHRyYWMtMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gb3IgZm9yY2VkLWJ5LWF0dHJzIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiB8fCBzLnNjcmlwdEF0dHJzICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiIClcblx0XHRcdFx0XHQuYXR0ciggcy5zY3JpcHRBdHRycyB8fCB7fSApXG5cdFx0XHRcdFx0LnByb3AoIHsgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LCBzcmM6IHMudXJsIH0gKVxuXHRcdFx0XHRcdC5vbiggXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZS5ndWlkKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBfaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCgge1xuXHRcdHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsXG5cdFx0Y29udGVudDogdHlwZSxcblx0XHRcIlwiOiBcIm91dGVyXCIgKyBuYW1lXG5cdH0sIGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIF9pLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fSxcblxuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXNcblx0XHRcdC5vbiggXCJtb3VzZWVudGVyXCIsIGZuT3ZlciApXG5cdFx0XHQub24oIFwibW91c2VsZWF2ZVwiLCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaChcblx0KCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblxuXHRcdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdFx0fTtcblx0fVxuKTtcblxuXG5cblxuLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG4vLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcbi8vIFJlcXVpcmUgdGhhdCB0aGUgXCJ3aGl0ZXNwYWNlIHJ1blwiIHN0YXJ0cyBmcm9tIGEgbm9uLXdoaXRlc3BhY2Vcbi8vIHRvIGF2b2lkIE8oTl4yKSBiZWhhdmlvciB3aGVuIHRoZSBlbmdpbmUgd291bGQgdHJ5IG1hdGNoaW5nIFwiXFxzKyRcIiBhdCBlYWNoIHNwYWNlIHBvc2l0aW9uLlxudmFyIHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8KFteXFxzXFx1RkVGRlxceEEwXSlbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cbmpRdWVyeS50cmltID0gZnVuY3Rpb24oIHRleHQgKSB7XG5cdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFwiXCIgOlxuXHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICk7XG59O1xuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICh0cmFjLTcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICh0cmFjLTEzNTY2KVxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsIi8qIVxuICogU2VsZWN0MiA0LjEuMC1yYy4wXG4gKiBodHRwczovL3NlbGVjdDIuZ2l0aHViLmlvXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc2VsZWN0Mi9zZWxlY3QyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiAqL1xuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIE5vZGUvQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCBqUXVlcnkpIHtcbiAgICAgIGlmIChqUXVlcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByZXF1aXJlKCdqUXVlcnknKSByZXR1cm5zIGEgZmFjdG9yeSB0aGF0IHJlcXVpcmVzIHdpbmRvdyB0b1xuICAgICAgICAvLyBidWlsZCBhIGpRdWVyeSBpbnN0YW5jZSwgd2Ugbm9ybWFsaXplIGhvdyB3ZSB1c2UgbW9kdWxlc1xuICAgICAgICAvLyB0aGF0IHJlcXVpcmUgdGhpcyBwYXR0ZXJuIGJ1dCB0aGUgd2luZG93IHByb3ZpZGVkIGlzIGEgbm9vcFxuICAgICAgICAvLyBpZiBpdCdzIGRlZmluZWQgKGhvdyBqcXVlcnkgd29ya3MpXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpKHJvb3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmYWN0b3J5KGpRdWVyeSk7XG4gICAgICByZXR1cm4galF1ZXJ5O1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZmFjdG9yeShqUXVlcnkpO1xuICB9XG59IChmdW5jdGlvbiAoalF1ZXJ5KSB7XG4gIC8vIFRoaXMgaXMgbmVlZGVkIHNvIHdlIGNhbiBjYXRjaCB0aGUgQU1EIGxvYWRlciBjb25maWd1cmF0aW9uIGFuZCB1c2UgaXRcbiAgLy8gVGhlIGlubmVyIGZpbGUgc2hvdWxkIGJlIHdyYXBwZWQgKGJ5IGBiYW5uZXIuc3RhcnQuanNgKSBpbiBhIGZ1bmN0aW9uIHRoYXRcbiAgLy8gcmV0dXJucyB0aGUgQU1EIGxvYWRlciByZWZlcmVuY2VzLlxuICB2YXIgUzIgPShmdW5jdGlvbiAoKSB7XG4gIC8vIFJlc3RvcmUgdGhlIFNlbGVjdDIgQU1EIGxvYWRlciBzbyBpdCBjYW4gYmUgdXNlZFxuICAvLyBOZWVkZWQgbW9zdGx5IGluIHRoZSBsYW5ndWFnZSBmaWxlcywgd2hlcmUgdGhlIGxvYWRlciBpcyBub3QgaW5zZXJ0ZWRcbiAgaWYgKGpRdWVyeSAmJiBqUXVlcnkuZm4gJiYgalF1ZXJ5LmZuLnNlbGVjdDIgJiYgalF1ZXJ5LmZuLnNlbGVjdDIuYW1kKSB7XG4gICAgdmFyIFMyID0galF1ZXJ5LmZuLnNlbGVjdDIuYW1kO1xuICB9XG52YXIgUzI7KGZ1bmN0aW9uICgpIHsgaWYgKCFTMiB8fCAhUzIucmVxdWlyZWpzKSB7XG5pZiAoIVMyKSB7IFMyID0ge307IH0gZWxzZSB7IHJlcXVpcmUgPSBTMjsgfVxuLyoqXG4gKiBAbGljZW5zZSBhbG1vbmQgMC4zLjMgQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMuXG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSwgaHR0cDovL2dpdGh1Yi5jb20vcmVxdWlyZWpzL2FsbW9uZC9MSUNFTlNFXG4gKi9cbi8vR29pbmcgc2xvcHB5IHRvIGF2b2lkICd1c2Ugc3RyaWN0JyBzdHJpbmcgY29zdCwgYnV0IHN0cmljdCBwcmFjdGljZXMgc2hvdWxkXG4vL2JlIGZvbGxvd2VkLlxuLypnbG9iYWwgc2V0VGltZW91dDogZmFsc2UgKi9cblxudmFyIHJlcXVpcmVqcywgcmVxdWlyZSwgZGVmaW5lO1xuKGZ1bmN0aW9uICh1bmRlZikge1xuICAgIHZhciBtYWluLCByZXEsIG1ha2VNYXAsIGhhbmRsZXJzLFxuICAgICAgICBkZWZpbmVkID0ge30sXG4gICAgICAgIHdhaXRpbmcgPSB7fSxcbiAgICAgICAgY29uZmlnID0ge30sXG4gICAgICAgIGRlZmluaW5nID0ge30sXG4gICAgICAgIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGFwcyA9IFtdLnNsaWNlLFxuICAgICAgICBqc1N1ZmZpeFJlZ0V4cCA9IC9cXC5qcyQvO1xuXG4gICAgZnVuY3Rpb24gaGFzUHJvcChvYmosIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGhhc093bi5jYWxsKG9iaiwgcHJvcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSByZWxhdGl2ZSBtb2R1bGUgbmFtZSwgbGlrZSAuL3NvbWV0aGluZywgbm9ybWFsaXplIGl0IHRvXG4gICAgICogYSByZWFsIG5hbWUgdGhhdCBjYW4gYmUgbWFwcGVkIHRvIGEgcGF0aC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgcmVsYXRpdmUgbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlTmFtZSBhIHJlYWwgbmFtZSB0aGF0IHRoZSBuYW1lIGFyZyBpcyByZWxhdGl2ZVxuICAgICAqIHRvLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IG5vcm1hbGl6ZWQgbmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBiYXNlTmFtZSkge1xuICAgICAgICB2YXIgbmFtZVBhcnRzLCBuYW1lU2VnbWVudCwgbWFwVmFsdWUsIGZvdW5kTWFwLCBsYXN0SW5kZXgsXG4gICAgICAgICAgICBmb3VuZEksIGZvdW5kU3Rhck1hcCwgc3RhckksIGksIGosIHBhcnQsIG5vcm1hbGl6ZWRCYXNlUGFydHMsXG4gICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlTmFtZSAmJiBiYXNlTmFtZS5zcGxpdChcIi9cIiksXG4gICAgICAgICAgICBtYXAgPSBjb25maWcubWFwLFxuICAgICAgICAgICAgc3Rhck1hcCA9IChtYXAgJiYgbWFwWycqJ10pIHx8IHt9O1xuXG4gICAgICAgIC8vQWRqdXN0IGFueSByZWxhdGl2ZSBwYXRocy5cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSBuYW1lLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgIC8vIElmIHdhbnRpbmcgbm9kZSBJRCBjb21wYXRpYmlsaXR5LCBzdHJpcCAuanMgZnJvbSBlbmRcbiAgICAgICAgICAgIC8vIG9mIElEcy4gSGF2ZSB0byBkbyB0aGlzIGhlcmUsIGFuZCBub3QgaW4gbmFtZVRvVXJsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIG5vZGUgYWxsb3dzIGVpdGhlciAuanMgb3Igbm9uIC5qcyB0byBtYXBcbiAgICAgICAgICAgIC8vIHRvIHNhbWUgZmlsZS5cbiAgICAgICAgICAgIGlmIChjb25maWcubm9kZUlkQ29tcGF0ICYmIGpzU3VmZml4UmVnRXhwLnRlc3QobmFtZVtsYXN0SW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIG5hbWVbbGFzdEluZGV4XSA9IG5hbWVbbGFzdEluZGV4XS5yZXBsYWNlKGpzU3VmZml4UmVnRXhwLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0cyB3aXRoIGEgJy4nIHNvIG5lZWQgdGhlIGJhc2VOYW1lXG4gICAgICAgICAgICBpZiAobmFtZVswXS5jaGFyQXQoMCkgPT09ICcuJyAmJiBiYXNlUGFydHMpIHtcbiAgICAgICAgICAgICAgICAvL0NvbnZlcnQgYmFzZU5hbWUgdG8gYXJyYXksIGFuZCBsb3Agb2ZmIHRoZSBsYXN0IHBhcnQsXG4gICAgICAgICAgICAgICAgLy9zbyB0aGF0IC4gbWF0Y2hlcyB0aGF0ICdkaXJlY3RvcnknIGFuZCBub3QgbmFtZSBvZiB0aGUgYmFzZU5hbWUnc1xuICAgICAgICAgICAgICAgIC8vbW9kdWxlLiBGb3IgaW5zdGFuY2UsIGJhc2VOYW1lIG9mICdvbmUvdHdvL3RocmVlJywgbWFwcyB0b1xuICAgICAgICAgICAgICAgIC8vJ29uZS90d28vdGhyZWUuanMnLCBidXQgd2Ugd2FudCB0aGUgZGlyZWN0b3J5LCAnb25lL3R3bycgZm9yXG4gICAgICAgICAgICAgICAgLy90aGlzIG5vcm1hbGl6YXRpb24uXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEJhc2VQYXJ0cyA9IGJhc2VQYXJ0cy5zbGljZSgwLCBiYXNlUGFydHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZWRCYXNlUGFydHMuY29uY2F0KG5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3N0YXJ0IHRyaW1Eb3RzXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBuYW1lW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYXQgdGhlIHN0YXJ0LCBvciBwcmV2aW91cyB2YWx1ZSBpcyBzdGlsbCAuLixcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCB0aGVtIHNvIHRoYXQgd2hlbiBjb252ZXJ0ZWQgdG8gYSBwYXRoIGl0IG1heVxuICAgICAgICAgICAgICAgICAgICAvLyBzdGlsbCB3b3JrIHdoZW4gY29udmVydGVkIHRvIGEgcGF0aCwgZXZlbiB0aG91Z2hcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgYW4gSUQgaXQgaXMgbGVzcyB0aGFuIGlkZWFsLiBJbiBsYXJnZXIgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsZWFzZXMsIG1heSBiZSBiZXR0ZXIgdG8ganVzdCBraWNrIG91dCBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgKGkgPT09IDEgJiYgbmFtZVsyXSA9PT0gJy4uJykgfHwgbmFtZVtpIC0gMV0gPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLnNwbGljZShpIC0gMSwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpIC09IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2VuZCB0cmltRG90c1xuXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5qb2luKCcvJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL0FwcGx5IG1hcCBjb25maWcgaWYgYXZhaWxhYmxlLlxuICAgICAgICBpZiAoKGJhc2VQYXJ0cyB8fCBzdGFyTWFwKSAmJiBtYXApIHtcbiAgICAgICAgICAgIG5hbWVQYXJ0cyA9IG5hbWUuc3BsaXQoJy8nKTtcblxuICAgICAgICAgICAgZm9yIChpID0gbmFtZVBhcnRzLmxlbmd0aDsgaSA+IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgIG5hbWVTZWdtZW50ID0gbmFtZVBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIvXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJhc2VQYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAvL0ZpbmQgdGhlIGxvbmdlc3QgYmFzZU5hbWUgc2VnbWVudCBtYXRjaCBpbiB0aGUgY29uZmlnLlxuICAgICAgICAgICAgICAgICAgICAvL1NvLCBkbyBqb2lucyBvbiB0aGUgYmlnZ2VzdCB0byBzbWFsbGVzdCBsZW5ndGhzIG9mIGJhc2VQYXJ0cy5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gYmFzZVBhcnRzLmxlbmd0aDsgaiA+IDA7IGogLT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwVmFsdWUgPSBtYXBbYmFzZVBhcnRzLnNsaWNlKDAsIGopLmpvaW4oJy8nKV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYmFzZU5hbWUgc2VnbWVudCBoYXMgIGNvbmZpZywgZmluZCBpZiBpdCBoYXMgb25lIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIG5hbWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBWYWx1ZSA9IG1hcFZhbHVlW25hbWVTZWdtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9NYXRjaCwgdXBkYXRlIG5hbWUgdG8gdGhlIG5ldyB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRNYXAgPSBtYXBWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRJID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vQ2hlY2sgZm9yIGEgc3RhciBtYXAgbWF0Y2gsIGJ1dCBqdXN0IGhvbGQgb24gdG8gaXQsXG4gICAgICAgICAgICAgICAgLy9pZiB0aGVyZSBpcyBhIHNob3J0ZXIgc2VnbWVudCBtYXRjaCBsYXRlciBpbiBhIG1hdGNoaW5nXG4gICAgICAgICAgICAgICAgLy9jb25maWcsIHRoZW4gZmF2b3Igb3ZlciB0aGlzIHN0YXIgbWFwLlxuICAgICAgICAgICAgICAgIGlmICghZm91bmRTdGFyTWFwICYmIHN0YXJNYXAgJiYgc3Rhck1hcFtuYW1lU2VnbWVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRTdGFyTWFwID0gc3Rhck1hcFtuYW1lU2VnbWVudF07XG4gICAgICAgICAgICAgICAgICAgIHN0YXJJID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZm91bmRNYXAgJiYgZm91bmRTdGFyTWFwKSB7XG4gICAgICAgICAgICAgICAgZm91bmRNYXAgPSBmb3VuZFN0YXJNYXA7XG4gICAgICAgICAgICAgICAgZm91bmRJID0gc3Rhckk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3VuZE1hcCkge1xuICAgICAgICAgICAgICAgIG5hbWVQYXJ0cy5zcGxpY2UoMCwgZm91bmRJLCBmb3VuZE1hcCk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVQYXJ0cy5qb2luKCcvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlUmVxdWlyZShyZWxOYW1lLCBmb3JjZVN5bmMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vQSB2ZXJzaW9uIG9mIGEgcmVxdWlyZSBmdW5jdGlvbiB0aGF0IHBhc3NlcyBhIG1vZHVsZU5hbWVcbiAgICAgICAgICAgIC8vdmFsdWUgZm9yIGl0ZW1zIHRoYXQgbWF5IG5lZWQgdG9cbiAgICAgICAgICAgIC8vbG9vayB1cCBwYXRocyByZWxhdGl2ZSB0byB0aGUgbW9kdWxlTmFtZVxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcHMuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgICAgICAvL0lmIGZpcnN0IGFyZyBpcyBub3QgcmVxdWlyZSgnc3RyaW5nJyksIGFuZCB0aGVyZSBpcyBvbmx5XG4gICAgICAgICAgICAvL29uZSBhcmcsIGl0IGlzIHRoZSBhcnJheSBmb3JtIHdpdGhvdXQgYSBjYWxsYmFjay4gSW5zZXJ0XG4gICAgICAgICAgICAvL2EgbnVsbCBzbyB0aGF0IHRoZSBmb2xsb3dpbmcgY29uY2F0IGlzIGNvcnJlY3QuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcS5hcHBseSh1bmRlZiwgYXJncy5jb25jYXQoW3JlbE5hbWUsIGZvcmNlU3luY10pKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlTm9ybWFsaXplKHJlbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VMb2FkKGRlcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZGVmaW5lZFtkZXBOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGxEZXAobmFtZSkge1xuICAgICAgICBpZiAoaGFzUHJvcCh3YWl0aW5nLCBuYW1lKSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSB3YWl0aW5nW25hbWVdO1xuICAgICAgICAgICAgZGVsZXRlIHdhaXRpbmdbbmFtZV07XG4gICAgICAgICAgICBkZWZpbmluZ1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICBtYWluLmFwcGx5KHVuZGVmLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzUHJvcChkZWZpbmVkLCBuYW1lKSAmJiAhaGFzUHJvcChkZWZpbmluZywgbmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gJyArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbmVkW25hbWVdO1xuICAgIH1cblxuICAgIC8vVHVybnMgYSBwbHVnaW4hcmVzb3VyY2UgdG8gW3BsdWdpbiwgcmVzb3VyY2VdXG4gICAgLy93aXRoIHRoZSBwbHVnaW4gYmVpbmcgdW5kZWZpbmVkIGlmIHRoZSBuYW1lXG4gICAgLy9kaWQgbm90IGhhdmUgYSBwbHVnaW4gcHJlZml4LlxuICAgIGZ1bmN0aW9uIHNwbGl0UHJlZml4KG5hbWUpIHtcbiAgICAgICAgdmFyIHByZWZpeCxcbiAgICAgICAgICAgIGluZGV4ID0gbmFtZSA/IG5hbWUuaW5kZXhPZignIScpIDogLTE7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBwcmVmaXggPSBuYW1lLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoaW5kZXggKyAxLCBuYW1lLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtwcmVmaXgsIG5hbWVdO1xuICAgIH1cblxuICAgIC8vQ3JlYXRlcyBhIHBhcnRzIGFycmF5IGZvciBhIHJlbE5hbWUgd2hlcmUgZmlyc3QgcGFydCBpcyBwbHVnaW4gSUQsXG4gICAgLy9zZWNvbmQgcGFydCBpcyByZXNvdXJjZSBJRC4gQXNzdW1lcyByZWxOYW1lIGhhcyBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZC5cbiAgICBmdW5jdGlvbiBtYWtlUmVsUGFydHMocmVsTmFtZSkge1xuICAgICAgICByZXR1cm4gcmVsTmFtZSA/IHNwbGl0UHJlZml4KHJlbE5hbWUpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgYSBuYW1lIG1hcCwgbm9ybWFsaXppbmcgdGhlIG5hbWUsIGFuZCB1c2luZyBhIHBsdWdpblxuICAgICAqIGZvciBub3JtYWxpemF0aW9uIGlmIG5lY2Vzc2FyeS4gR3JhYnMgYSByZWYgdG8gcGx1Z2luXG4gICAgICogdG9vLCBhcyBhbiBvcHRpbWl6YXRpb24uXG4gICAgICovXG4gICAgbWFrZU1hcCA9IGZ1bmN0aW9uIChuYW1lLCByZWxQYXJ0cykge1xuICAgICAgICB2YXIgcGx1Z2luLFxuICAgICAgICAgICAgcGFydHMgPSBzcGxpdFByZWZpeChuYW1lKSxcbiAgICAgICAgICAgIHByZWZpeCA9IHBhcnRzWzBdLFxuICAgICAgICAgICAgcmVsUmVzb3VyY2VOYW1lID0gcmVsUGFydHNbMV07XG5cbiAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xuXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IG5vcm1hbGl6ZShwcmVmaXgsIHJlbFJlc291cmNlTmFtZSk7XG4gICAgICAgICAgICBwbHVnaW4gPSBjYWxsRGVwKHByZWZpeCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL05vcm1hbGl6ZSBhY2NvcmRpbmdcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHBsdWdpbiAmJiBwbHVnaW4ubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHBsdWdpbi5ub3JtYWxpemUobmFtZSwgbWFrZU5vcm1hbGl6ZShyZWxSZXNvdXJjZU5hbWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZShuYW1lLCByZWxSZXNvdXJjZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZShuYW1lLCByZWxSZXNvdXJjZU5hbWUpO1xuICAgICAgICAgICAgcGFydHMgPSBzcGxpdFByZWZpeChuYW1lKTtcbiAgICAgICAgICAgIHByZWZpeCA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgICAgIHBsdWdpbiA9IGNhbGxEZXAocHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vVXNpbmcgcmlkaWN1bG91cyBwcm9wZXJ0eSBuYW1lcyBmb3Igc3BhY2UgcmVhc29uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZjogcHJlZml4ID8gcHJlZml4ICsgJyEnICsgbmFtZSA6IG5hbWUsIC8vZnVsbE5hbWVcbiAgICAgICAgICAgIG46IG5hbWUsXG4gICAgICAgICAgICBwcjogcHJlZml4LFxuICAgICAgICAgICAgcDogcGx1Z2luXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VDb25maWcobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChjb25maWcgJiYgY29uZmlnLmNvbmZpZyAmJiBjb25maWcuY29uZmlnW25hbWVdKSB8fCB7fTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBoYW5kbGVycyA9IHtcbiAgICAgICAgcmVxdWlyZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlUmVxdWlyZShuYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXhwb3J0czogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBlID0gZGVmaW5lZFtuYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkZWZpbmVkW25hbWVdID0ge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb2R1bGU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBuYW1lLFxuICAgICAgICAgICAgICAgIHVyaTogJycsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogZGVmaW5lZFtuYW1lXSxcbiAgICAgICAgICAgICAgICBjb25maWc6IG1ha2VDb25maWcobmFtZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbWFpbiA9IGZ1bmN0aW9uIChuYW1lLCBkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSkge1xuICAgICAgICB2YXIgY2pzTW9kdWxlLCBkZXBOYW1lLCByZXQsIG1hcCwgaSwgcmVsUGFydHMsXG4gICAgICAgICAgICBhcmdzID0gW10sXG4gICAgICAgICAgICBjYWxsYmFja1R5cGUgPSB0eXBlb2YgY2FsbGJhY2ssXG4gICAgICAgICAgICB1c2luZ0V4cG9ydHM7XG5cbiAgICAgICAgLy9Vc2UgbmFtZSBpZiBubyByZWxOYW1lXG4gICAgICAgIHJlbE5hbWUgPSByZWxOYW1lIHx8IG5hbWU7XG4gICAgICAgIHJlbFBhcnRzID0gbWFrZVJlbFBhcnRzKHJlbE5hbWUpO1xuXG4gICAgICAgIC8vQ2FsbCB0aGUgY2FsbGJhY2sgdG8gZGVmaW5lIHRoZSBtb2R1bGUsIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKGNhbGxiYWNrVHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY2FsbGJhY2tUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvL1B1bGwgb3V0IHRoZSBkZWZpbmVkIGRlcGVuZGVuY2llcyBhbmQgcGFzcyB0aGUgb3JkZXJlZFxuICAgICAgICAgICAgLy92YWx1ZXMgdG8gdGhlIGNhbGxiYWNrLlxuICAgICAgICAgICAgLy9EZWZhdWx0IHRvIFtyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGVdIGlmIG5vIGRlcHNcbiAgICAgICAgICAgIGRlcHMgPSAhZGVwcy5sZW5ndGggJiYgY2FsbGJhY2subGVuZ3RoID8gWydyZXF1aXJlJywgJ2V4cG9ydHMnLCAnbW9kdWxlJ10gOiBkZXBzO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBtYXAgPSBtYWtlTWFwKGRlcHNbaV0sIHJlbFBhcnRzKTtcbiAgICAgICAgICAgICAgICBkZXBOYW1lID0gbWFwLmY7XG5cbiAgICAgICAgICAgICAgICAvL0Zhc3QgcGF0aCBDb21tb25KUyBzdGFuZGFyZCBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAgICAgaWYgKGRlcE5hbWUgPT09IFwicmVxdWlyZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBoYW5kbGVycy5yZXF1aXJlKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwTmFtZSA9PT0gXCJleHBvcnRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9Db21tb25KUyBtb2R1bGUgc3BlYyAxLjFcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGhhbmRsZXJzLmV4cG9ydHMobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHVzaW5nRXhwb3J0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZXBOYW1lID09PSBcIm1vZHVsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vQ29tbW9uSlMgbW9kdWxlIHNwZWMgMS4xXG4gICAgICAgICAgICAgICAgICAgIGNqc01vZHVsZSA9IGFyZ3NbaV0gPSBoYW5kbGVycy5tb2R1bGUobmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNQcm9wKGRlZmluZWQsIGRlcE5hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQcm9wKHdhaXRpbmcsIGRlcE5hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQcm9wKGRlZmluaW5nLCBkZXBOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gY2FsbERlcChkZXBOYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hcC5wKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5wLmxvYWQobWFwLm4sIG1ha2VSZXF1aXJlKHJlbE5hbWUsIHRydWUpLCBtYWtlTG9hZChkZXBOYW1lKSwge30pO1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gZGVmaW5lZFtkZXBOYW1lXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArICcgbWlzc2luZyAnICsgZGVwTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXQgPSBjYWxsYmFjayA/IGNhbGxiYWNrLmFwcGx5KGRlZmluZWRbbmFtZV0sIGFyZ3MpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIC8vSWYgc2V0dGluZyBleHBvcnRzIHZpYSBcIm1vZHVsZVwiIGlzIGluIHBsYXksXG4gICAgICAgICAgICAgICAgLy9mYXZvciB0aGF0IG92ZXIgcmV0dXJuIHZhbHVlIGFuZCBleHBvcnRzLiBBZnRlciB0aGF0LFxuICAgICAgICAgICAgICAgIC8vZmF2b3IgYSBub24tdW5kZWZpbmVkIHJldHVybiB2YWx1ZSBvdmVyIGV4cG9ydHMgdXNlLlxuICAgICAgICAgICAgICAgIGlmIChjanNNb2R1bGUgJiYgY2pzTW9kdWxlLmV4cG9ydHMgIT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjanNNb2R1bGUuZXhwb3J0cyAhPT0gZGVmaW5lZFtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVkW25hbWVdID0gY2pzTW9kdWxlLmV4cG9ydHM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXQgIT09IHVuZGVmIHx8ICF1c2luZ0V4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9Vc2UgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSkge1xuICAgICAgICAgICAgLy9NYXkganVzdCBiZSBhbiBvYmplY3QgZGVmaW5pdGlvbiBmb3IgdGhlIG1vZHVsZS4gT25seVxuICAgICAgICAgICAgLy93b3JyeSBhYm91dCBkZWZpbmluZyBpZiBoYXZlIGEgbW9kdWxlIG5hbWUuXG4gICAgICAgICAgICBkZWZpbmVkW25hbWVdID0gY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVxdWlyZWpzID0gcmVxdWlyZSA9IHJlcSA9IGZ1bmN0aW9uIChkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSwgZm9yY2VTeW5jLCBhbHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXBzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcnNbZGVwc10pIHtcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrIGluIHRoaXMgY2FzZSBpcyByZWFsbHkgcmVsTmFtZVxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyc1tkZXBzXShjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL0p1c3QgcmV0dXJuIHRoZSBtb2R1bGUgd2FudGVkLiBJbiB0aGlzIHNjZW5hcmlvLCB0aGVcbiAgICAgICAgICAgIC8vZGVwcyBhcmcgaXMgdGhlIG1vZHVsZSBuYW1lLCBhbmQgc2Vjb25kIGFyZyAoaWYgcGFzc2VkKVxuICAgICAgICAgICAgLy9pcyBqdXN0IHRoZSByZWxOYW1lLlxuICAgICAgICAgICAgLy9Ob3JtYWxpemUgbW9kdWxlIG5hbWUsIGlmIGl0IGNvbnRhaW5zIC4gb3IgLi5cbiAgICAgICAgICAgIHJldHVybiBjYWxsRGVwKG1ha2VNYXAoZGVwcywgbWFrZVJlbFBhcnRzKGNhbGxiYWNrKSkuZik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWRlcHMuc3BsaWNlKSB7XG4gICAgICAgICAgICAvL2RlcHMgaXMgYSBjb25maWcgb2JqZWN0LCBub3QgYW4gYXJyYXkuXG4gICAgICAgICAgICBjb25maWcgPSBkZXBzO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5kZXBzKSB7XG4gICAgICAgICAgICAgICAgcmVxKGNvbmZpZy5kZXBzLCBjb25maWcuY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLnNwbGljZSkge1xuICAgICAgICAgICAgICAgIC8vY2FsbGJhY2sgaXMgYW4gYXJyYXksIHdoaWNoIG1lYW5zIGl0IGlzIGEgZGVwZW5kZW5jeSBsaXN0LlxuICAgICAgICAgICAgICAgIC8vQWRqdXN0IGFyZ3MgaWYgdGhlcmUgYXJlIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgICAgIGRlcHMgPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHJlbE5hbWU7XG4gICAgICAgICAgICAgICAgcmVsTmFtZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHMgPSB1bmRlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vU3VwcG9ydCByZXF1aXJlKFsnYSddKVxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgIC8vSWYgcmVsTmFtZSBpcyBhIGZ1bmN0aW9uLCBpdCBpcyBhbiBlcnJiYWNrIGhhbmRsZXIsXG4gICAgICAgIC8vc28gcmVtb3ZlIGl0LlxuICAgICAgICBpZiAodHlwZW9mIHJlbE5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlbE5hbWUgPSBmb3JjZVN5bmM7XG4gICAgICAgICAgICBmb3JjZVN5bmMgPSBhbHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL1NpbXVsYXRlIGFzeW5jIGNhbGxiYWNrO1xuICAgICAgICBpZiAoZm9yY2VTeW5jKSB7XG4gICAgICAgICAgICBtYWluKHVuZGVmLCBkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL1VzaW5nIGEgbm9uLXplcm8gdmFsdWUgYmVjYXVzZSBvZiBjb25jZXJuIGZvciB3aGF0IG9sZCBicm93c2Vyc1xuICAgICAgICAgICAgLy9kbywgYW5kIGxhdGVzdCBicm93c2VycyBcInVwZ3JhZGVcIiB0byA0IGlmIGxvd2VyIHZhbHVlIGlzIHVzZWQ6XG4gICAgICAgICAgICAvL2h0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RpbWVycy5odG1sI2RvbS13aW5kb3d0aW1lcnMtc2V0dGltZW91dDpcbiAgICAgICAgICAgIC8vSWYgd2FudCBhIHZhbHVlIGltbWVkaWF0ZWx5LCB1c2UgcmVxdWlyZSgnaWQnKSBpbnN0ZWFkIC0tIHNvbWV0aGluZ1xuICAgICAgICAgICAgLy90aGF0IHdvcmtzIGluIGFsbW9uZCBvbiB0aGUgZ2xvYmFsIGxldmVsLCBidXQgbm90IGd1YXJhbnRlZWQgYW5kXG4gICAgICAgICAgICAvL3VubGlrZWx5IHRvIHdvcmsgaW4gb3RoZXIgQU1EIGltcGxlbWVudGF0aW9ucy5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG1haW4odW5kZWYsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKTtcbiAgICAgICAgICAgIH0sIDQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSnVzdCBkcm9wcyB0aGUgY29uZmlnIG9uIHRoZSBmbG9vciwgYnV0IHJldHVybnMgcmVxIGluIGNhc2VcbiAgICAgKiB0aGUgY29uZmlnIHJldHVybiB2YWx1ZSBpcyB1c2VkLlxuICAgICAqL1xuICAgIHJlcS5jb25maWcgPSBmdW5jdGlvbiAoY2ZnKSB7XG4gICAgICAgIHJldHVybiByZXEoY2ZnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhwb3NlIG1vZHVsZSByZWdpc3RyeSBmb3IgZGVidWdnaW5nIGFuZCB0b29saW5nXG4gICAgICovXG4gICAgcmVxdWlyZWpzLl9kZWZpbmVkID0gZGVmaW5lZDtcblxuICAgIGRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBkZXBzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlZSBhbG1vbmQgUkVBRE1FOiBpbmNvcnJlY3QgbW9kdWxlIGJ1aWxkLCBubyBtb2R1bGUgbmFtZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9UaGlzIG1vZHVsZSBtYXkgbm90IGhhdmUgZGVwZW5kZW5jaWVzXG4gICAgICAgIGlmICghZGVwcy5zcGxpY2UpIHtcbiAgICAgICAgICAgIC8vZGVwcyBpcyBub3QgYW4gYXJyYXksIHNvIHByb2JhYmx5IG1lYW5zXG4gICAgICAgICAgICAvL2FuIG9iamVjdCBsaXRlcmFsIG9yIGZhY3RvcnkgZnVuY3Rpb24gZm9yXG4gICAgICAgICAgICAvL3RoZSB2YWx1ZS4gQWRqdXN0IGFyZ3MuXG4gICAgICAgICAgICBjYWxsYmFjayA9IGRlcHM7XG4gICAgICAgICAgICBkZXBzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhc1Byb3AoZGVmaW5lZCwgbmFtZSkgJiYgIWhhc1Byb3Aod2FpdGluZywgbmFtZSkpIHtcbiAgICAgICAgICAgIHdhaXRpbmdbbmFtZV0gPSBbbmFtZSwgZGVwcywgY2FsbGJhY2tdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZS5hbWQgPSB7XG4gICAgICAgIGpRdWVyeTogdHJ1ZVxuICAgIH07XG59KCkpO1xuXG5TMi5yZXF1aXJlanMgPSByZXF1aXJlanM7UzIucmVxdWlyZSA9IHJlcXVpcmU7UzIuZGVmaW5lID0gZGVmaW5lO1xufVxufSgpKTtcblMyLmRlZmluZShcImFsbW9uZFwiLCBmdW5jdGlvbigpe30pO1xuXG4vKiBnbG9iYWwgalF1ZXJ5OmZhbHNlLCAkOmZhbHNlICovXG5TMi5kZWZpbmUoJ2pxdWVyeScsW10sZnVuY3Rpb24gKCkge1xuICB2YXIgXyQgPSBqUXVlcnkgfHwgJDtcblxuICBpZiAoXyQgPT0gbnVsbCAmJiBjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgJ1NlbGVjdDI6IEFuIGluc3RhbmNlIG9mIGpRdWVyeSBvciBhIGpRdWVyeS1jb21wYXRpYmxlIGxpYnJhcnkgd2FzIG5vdCAnICtcbiAgICAgICdmb3VuZC4gTWFrZSBzdXJlIHRoYXQgeW91IGFyZSBpbmNsdWRpbmcgalF1ZXJ5IGJlZm9yZSBTZWxlY3QyIG9uIHlvdXIgJyArXG4gICAgICAnd2ViIHBhZ2UuJ1xuICAgICk7XG4gIH1cblxuICByZXR1cm4gXyQ7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL3V0aWxzJyxbXG4gICdqcXVlcnknXG5dLCBmdW5jdGlvbiAoJCkge1xuICB2YXIgVXRpbHMgPSB7fTtcblxuICBVdGlscy5FeHRlbmQgPSBmdW5jdGlvbiAoQ2hpbGRDbGFzcywgU3VwZXJDbGFzcykge1xuICAgIHZhciBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIGZ1bmN0aW9uIEJhc2VDb25zdHJ1Y3RvciAoKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQ2hpbGRDbGFzcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gU3VwZXJDbGFzcykge1xuICAgICAgaWYgKF9faGFzUHJvcC5jYWxsKFN1cGVyQ2xhc3MsIGtleSkpIHtcbiAgICAgICAgQ2hpbGRDbGFzc1trZXldID0gU3VwZXJDbGFzc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIEJhc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBTdXBlckNsYXNzLnByb3RvdHlwZTtcbiAgICBDaGlsZENsYXNzLnByb3RvdHlwZSA9IG5ldyBCYXNlQ29uc3RydWN0b3IoKTtcbiAgICBDaGlsZENsYXNzLl9fc3VwZXJfXyA9IFN1cGVyQ2xhc3MucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIENoaWxkQ2xhc3M7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0TWV0aG9kcyAodGhlQ2xhc3MpIHtcbiAgICB2YXIgcHJvdG8gPSB0aGVDbGFzcy5wcm90b3R5cGU7XG5cbiAgICB2YXIgbWV0aG9kcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBwcm90bykge1xuICAgICAgdmFyIG0gPSBwcm90b1ttZXRob2ROYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZiBtICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbWV0aG9kcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRob2RzO1xuICB9XG5cbiAgVXRpbHMuRGVjb3JhdGUgPSBmdW5jdGlvbiAoU3VwZXJDbGFzcywgRGVjb3JhdG9yQ2xhc3MpIHtcbiAgICB2YXIgZGVjb3JhdGVkTWV0aG9kcyA9IGdldE1ldGhvZHMoRGVjb3JhdG9yQ2xhc3MpO1xuICAgIHZhciBzdXBlck1ldGhvZHMgPSBnZXRNZXRob2RzKFN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gRGVjb3JhdGVkQ2xhc3MgKCkge1xuICAgICAgdmFyIHVuc2hpZnQgPSBBcnJheS5wcm90b3R5cGUudW5zaGlmdDtcblxuICAgICAgdmFyIGFyZ0NvdW50ID0gRGVjb3JhdG9yQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yLmxlbmd0aDtcblxuICAgICAgdmFyIGNhbGxlZENvbnN0cnVjdG9yID0gU3VwZXJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3I7XG5cbiAgICAgIGlmIChhcmdDb3VudCA+IDApIHtcbiAgICAgICAgdW5zaGlmdC5jYWxsKGFyZ3VtZW50cywgU3VwZXJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IpO1xuXG4gICAgICAgIGNhbGxlZENvbnN0cnVjdG9yID0gRGVjb3JhdG9yQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuICAgICAgfVxuXG4gICAgICBjYWxsZWRDb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIERlY29yYXRvckNsYXNzLmRpc3BsYXlOYW1lID0gU3VwZXJDbGFzcy5kaXNwbGF5TmFtZTtcblxuICAgIGZ1bmN0aW9uIGN0ciAoKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gRGVjb3JhdGVkQ2xhc3M7XG4gICAgfVxuXG4gICAgRGVjb3JhdGVkQ2xhc3MucHJvdG90eXBlID0gbmV3IGN0cigpO1xuXG4gICAgZm9yICh2YXIgbSA9IDA7IG0gPCBzdXBlck1ldGhvZHMubGVuZ3RoOyBtKyspIHtcbiAgICAgIHZhciBzdXBlck1ldGhvZCA9IHN1cGVyTWV0aG9kc1ttXTtcblxuICAgICAgRGVjb3JhdGVkQ2xhc3MucHJvdG90eXBlW3N1cGVyTWV0aG9kXSA9XG4gICAgICAgIFN1cGVyQ2xhc3MucHJvdG90eXBlW3N1cGVyTWV0aG9kXTtcbiAgICB9XG5cbiAgICB2YXIgY2FsbGVkTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgIC8vIFN0dWIgb3V0IHRoZSBvcmlnaW5hbCBtZXRob2QgaWYgaXQncyBub3QgZGVjb3JhdGluZyBhbiBhY3R1YWwgbWV0aG9kXG4gICAgICB2YXIgb3JpZ2luYWxNZXRob2QgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgaWYgKG1ldGhvZE5hbWUgaW4gRGVjb3JhdGVkQ2xhc3MucHJvdG90eXBlKSB7XG4gICAgICAgIG9yaWdpbmFsTWV0aG9kID0gRGVjb3JhdGVkQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVjb3JhdGVkTWV0aG9kID0gRGVjb3JhdG9yQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdW5zaGlmdCA9IEFycmF5LnByb3RvdHlwZS51bnNoaWZ0O1xuXG4gICAgICAgIHVuc2hpZnQuY2FsbChhcmd1bWVudHMsIG9yaWdpbmFsTWV0aG9kKTtcblxuICAgICAgICByZXR1cm4gZGVjb3JhdGVkTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRlY29yYXRlZE1ldGhvZHMubGVuZ3RoOyBkKyspIHtcbiAgICAgIHZhciBkZWNvcmF0ZWRNZXRob2QgPSBkZWNvcmF0ZWRNZXRob2RzW2RdO1xuXG4gICAgICBEZWNvcmF0ZWRDbGFzcy5wcm90b3R5cGVbZGVjb3JhdGVkTWV0aG9kXSA9IGNhbGxlZE1ldGhvZChkZWNvcmF0ZWRNZXRob2QpO1xuICAgIH1cblxuICAgIHJldHVybiBEZWNvcmF0ZWRDbGFzcztcbiAgfTtcblxuICB2YXIgT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICB9O1xuXG4gIE9ic2VydmFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHRoaXMubGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMgfHwge307XG5cbiAgICBpZiAoZXZlbnQgaW4gdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRdID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgICB2YXIgcGFyYW1zID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdGhpcy5saXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyB8fCB7fTtcblxuICAgIC8vIFBhcmFtcyBzaG91bGQgYWx3YXlzIGNvbWUgaW4gYXMgYW4gYXJyYXlcbiAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgIHBhcmFtcyA9IFtdO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBhcmd1bWVudHMgdG8gdGhlIGV2ZW50LCB1c2UgYSB0ZW1wb3Jhcnkgb2JqZWN0XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHBhcmFtcy5wdXNoKHt9KTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGBfdHlwZWAgb2YgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgZXZlbnRcbiAgICBwYXJhbXNbMF0uX3R5cGUgPSBldmVudDtcblxuICAgIGlmIChldmVudCBpbiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgdGhpcy5pbnZva2UodGhpcy5saXN0ZW5lcnNbZXZlbnRdLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIGlmICgnKicgaW4gdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuaW52b2tlKHRoaXMubGlzdGVuZXJzWycqJ10sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuXG4gIE9ic2VydmFibGUucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChsaXN0ZW5lcnMsIHBhcmFtcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBwYXJhbXMpO1xuICAgIH1cbiAgfTtcblxuICBVdGlscy5PYnNlcnZhYmxlID0gT2JzZXJ2YWJsZTtcblxuICBVdGlscy5nZW5lcmF0ZUNoYXJzID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHZhciBjaGFycyA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJhbmRvbUNoYXIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAzNik7XG4gICAgICBjaGFycyArPSByYW5kb21DaGFyLnRvU3RyaW5nKDM2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnM7XG4gIH07XG5cbiAgVXRpbHMuYmluZCA9IGZ1bmN0aW9uIChmdW5jLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIFV0aWxzLl9jb252ZXJ0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZm9yICh2YXIgb3JpZ2luYWxLZXkgaW4gZGF0YSkge1xuICAgICAgdmFyIGtleXMgPSBvcmlnaW5hbEtleS5zcGxpdCgnLScpO1xuXG4gICAgICB2YXIgZGF0YUxldmVsID0gZGF0YTtcblxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNba107XG5cbiAgICAgICAgLy8gTG93ZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXJcbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgZGFzaC1zZXBhcmF0ZWQgYmVjb21lcyBjYW1lbENhc2VcbiAgICAgICAga2V5ID0ga2V5LnN1YnN0cmluZygwLCAxKS50b0xvd2VyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcblxuICAgICAgICBpZiAoIShrZXkgaW4gZGF0YUxldmVsKSkge1xuICAgICAgICAgIGRhdGFMZXZlbFtrZXldID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoayA9PSBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBkYXRhTGV2ZWxba2V5XSA9IGRhdGFbb3JpZ2luYWxLZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YUxldmVsID0gZGF0YUxldmVsW2tleV07XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBkYXRhW29yaWdpbmFsS2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICBVdGlscy5oYXNTY3JvbGwgPSBmdW5jdGlvbiAoaW5kZXgsIGVsKSB7XG4gICAgLy8gQWRhcHRlZCBmcm9tIHRoZSBmdW5jdGlvbiBjcmVhdGVkIGJ5IEBTaGFkb3dTY3JpcHRlclxuICAgIC8vIGFuZCBhZGFwdGVkIGJ5IEBCaWxsQmFycnkgb24gdGhlIFN0YWNrIEV4Y2hhbmdlIENvZGUgUmV2aWV3IHdlYnNpdGUuXG4gICAgLy8gVGhlIG9yaWdpbmFsIGNvZGUgY2FuIGJlIGZvdW5kIGF0XG4gICAgLy8gaHR0cDovL2NvZGVyZXZpZXcuc3RhY2tleGNoYW5nZS5jb20vcS8xMzMzOFxuICAgIC8vIGFuZCB3YXMgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIHRoZSBTaXp6bGUgc2VsZWN0b3IgZW5naW5lLlxuXG4gICAgdmFyICRlbCA9ICQoZWwpO1xuICAgIHZhciBvdmVyZmxvd1ggPSBlbC5zdHlsZS5vdmVyZmxvd1g7XG4gICAgdmFyIG92ZXJmbG93WSA9IGVsLnN0eWxlLm92ZXJmbG93WTtcblxuICAgIC8vQ2hlY2sgYm90aCB4IGFuZCB5IGRlY2xhcmF0aW9uc1xuICAgIGlmIChvdmVyZmxvd1ggPT09IG92ZXJmbG93WSAmJlxuICAgICAgICAob3ZlcmZsb3dZID09PSAnaGlkZGVuJyB8fCBvdmVyZmxvd1kgPT09ICd2aXNpYmxlJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAob3ZlcmZsb3dYID09PSAnc2Nyb2xsJyB8fCBvdmVyZmxvd1kgPT09ICdzY3JvbGwnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCRlbC5pbm5lckhlaWdodCgpIDwgZWwuc2Nyb2xsSGVpZ2h0IHx8XG4gICAgICAkZWwuaW5uZXJXaWR0aCgpIDwgZWwuc2Nyb2xsV2lkdGgpO1xuICB9O1xuXG4gIFV0aWxzLmVzY2FwZU1hcmt1cCA9IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgcmVwbGFjZU1hcCA9IHtcbiAgICAgICdcXFxcJzogJyYjOTI7JyxcbiAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICc8JzogJyZsdDsnLFxuICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgICdcXCcnOiAnJiMzOTsnLFxuICAgICAgJy8nOiAnJiM0NzsnXG4gICAgfTtcblxuICAgIC8vIERvIG5vdCB0cnkgdG8gZXNjYXBlIHRoZSBtYXJrdXAgaWYgaXQncyBub3QgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIG1hcmt1cCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZyhtYXJrdXApLnJlcGxhY2UoL1smPD5cIidcXC9cXFxcXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiByZXBsYWNlTWFwW21hdGNoXTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDYWNoZSBvYmplY3RzIGluIFV0aWxzLl9fY2FjaGUgaW5zdGVhZCBvZiAkLmRhdGEgKHNlZSAjNDM0NilcbiAgVXRpbHMuX19jYWNoZSA9IHt9O1xuXG4gIHZhciBpZCA9IDA7XG4gIFV0aWxzLkdldFVuaXF1ZUVsZW1lbnRJZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgLy8gR2V0IGEgdW5pcXVlIGVsZW1lbnQgSWQuIElmIGVsZW1lbnQgaGFzIG5vIGlkLFxuICAgIC8vIGNyZWF0ZXMgYSBuZXcgdW5pcXVlIG51bWJlciwgc3RvcmVzIGl0IGluIHRoZSBpZFxuICAgIC8vIGF0dHJpYnV0ZSBhbmQgcmV0dXJucyB0aGUgbmV3IGlkIHdpdGggYSBwcmVmaXguXG4gICAgLy8gSWYgYW4gaWQgYWxyZWFkeSBleGlzdHMsIGl0IHNpbXBseSByZXR1cm5zIGl0IHdpdGggYSBwcmVmaXguXG5cbiAgICB2YXIgc2VsZWN0MklkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2VsZWN0Mi1pZCcpO1xuXG4gICAgaWYgKHNlbGVjdDJJZCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gc2VsZWN0MklkO1xuICAgIH1cblxuICAgIC8vIElmIGVsZW1lbnQgaGFzIGlkLCB1c2UgaXQuXG4gICAgaWYgKGVsZW1lbnQuaWQpIHtcbiAgICAgIHNlbGVjdDJJZCA9ICdzZWxlY3QyLWRhdGEtJyArIGVsZW1lbnQuaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdDJJZCA9ICdzZWxlY3QyLWRhdGEtJyArICgrK2lkKS50b1N0cmluZygpICtcbiAgICAgICAgJy0nICsgVXRpbHMuZ2VuZXJhdGVDaGFycyg0KTtcbiAgICB9XG5cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1zZWxlY3QyLWlkJywgc2VsZWN0MklkKTtcblxuICAgIHJldHVybiBzZWxlY3QySWQ7XG4gIH07XG5cbiAgVXRpbHMuU3RvcmVEYXRhID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgLy8gU3RvcmVzIGFuIGl0ZW0gaW4gdGhlIGNhY2hlIGZvciBhIHNwZWNpZmllZCBlbGVtZW50LlxuICAgIC8vIG5hbWUgaXMgdGhlIGNhY2hlIGtleS5cbiAgICB2YXIgaWQgPSBVdGlscy5HZXRVbmlxdWVFbGVtZW50SWQoZWxlbWVudCk7XG4gICAgaWYgKCFVdGlscy5fX2NhY2hlW2lkXSkge1xuICAgICAgVXRpbHMuX19jYWNoZVtpZF0gPSB7fTtcbiAgICB9XG5cbiAgICBVdGlscy5fX2NhY2hlW2lkXVtuYW1lXSA9IHZhbHVlO1xuICB9O1xuXG4gIFV0aWxzLkdldERhdGEgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xuICAgIC8vIFJldHJpZXZlcyBhIHZhbHVlIGZyb20gdGhlIGNhY2hlIGJ5IGl0cyBrZXkgKG5hbWUpXG4gICAgLy8gbmFtZSBpcyBvcHRpb25hbC4gSWYgbm8gbmFtZSBzcGVjaWZpZWQsIHJldHVyblxuICAgIC8vIGFsbCBjYWNoZSBpdGVtcyBmb3IgdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuICAgIC8vIGFuZCBmb3IgYSBzcGVjaWZpZWQgZWxlbWVudC5cbiAgICB2YXIgaWQgPSBVdGlscy5HZXRVbmlxdWVFbGVtZW50SWQoZWxlbWVudCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGlmIChVdGlscy5fX2NhY2hlW2lkXSkge1xuICAgICAgICBpZiAoVXRpbHMuX19jYWNoZVtpZF1bbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBVdGlscy5fX2NhY2hlW2lkXVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJChlbGVtZW50KS5kYXRhKG5hbWUpOyAvLyBGYWxsYmFjayB0byBIVE1MNSBkYXRhIGF0dHJpYnMuXG4gICAgICB9XG4gICAgICByZXR1cm4gJChlbGVtZW50KS5kYXRhKG5hbWUpOyAvLyBGYWxsYmFjayB0byBIVE1MNSBkYXRhIGF0dHJpYnMuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBVdGlscy5fX2NhY2hlW2lkXTtcbiAgICB9XG4gIH07XG5cbiAgVXRpbHMuUmVtb3ZlRGF0YSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgLy8gUmVtb3ZlcyBhbGwgY2FjaGVkIGl0ZW1zIGZvciBhIHNwZWNpZmllZCBlbGVtZW50LlxuICAgIHZhciBpZCA9IFV0aWxzLkdldFVuaXF1ZUVsZW1lbnRJZChlbGVtZW50KTtcbiAgICBpZiAoVXRpbHMuX19jYWNoZVtpZF0gIT0gbnVsbCkge1xuICAgICAgZGVsZXRlIFV0aWxzLl9fY2FjaGVbaWRdO1xuICAgIH1cblxuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNlbGVjdDItaWQnKTtcbiAgfTtcblxuICBVdGlscy5jb3B5Tm9uSW50ZXJuYWxDc3NDbGFzc2VzID0gZnVuY3Rpb24gKGRlc3QsIHNyYykge1xuICAgIHZhciBjbGFzc2VzO1xuXG4gICAgdmFyIGRlc3RpbmF0aW9uQ2xhc3NlcyA9IGRlc3QuZ2V0QXR0cmlidXRlKCdjbGFzcycpLnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuXG4gICAgZGVzdGluYXRpb25DbGFzc2VzID0gZGVzdGluYXRpb25DbGFzc2VzLmZpbHRlcihmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgIC8vIFNhdmUgYWxsIFNlbGVjdDIgY2xhc3Nlc1xuICAgICAgcmV0dXJuIGNsYXp6LmluZGV4T2YoJ3NlbGVjdDItJykgPT09IDA7XG4gICAgfSk7XG5cbiAgICB2YXIgc291cmNlQ2xhc3NlcyA9IHNyYy5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG5cbiAgICBzb3VyY2VDbGFzc2VzID0gc291cmNlQ2xhc3Nlcy5maWx0ZXIoZnVuY3Rpb24gKGNsYXp6KSB7XG4gICAgICAvLyBPbmx5IGNvcHkgbm9uLVNlbGVjdDIgY2xhc3Nlc1xuICAgICAgcmV0dXJuIGNsYXp6LmluZGV4T2YoJ3NlbGVjdDItJykgIT09IDA7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVwbGFjZW1lbnRzID0gZGVzdGluYXRpb25DbGFzc2VzLmNvbmNhdChzb3VyY2VDbGFzc2VzKTtcblxuICAgIGRlc3Quc2V0QXR0cmlidXRlKCdjbGFzcycsIHJlcGxhY2VtZW50cy5qb2luKCcgJykpO1xuICB9O1xuXG4gIHJldHVybiBVdGlscztcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvcmVzdWx0cycsW1xuICAnanF1ZXJ5JyxcbiAgJy4vdXRpbHMnXG5dLCBmdW5jdGlvbiAoJCwgVXRpbHMpIHtcbiAgZnVuY3Rpb24gUmVzdWx0cyAoJGVsZW1lbnQsIG9wdGlvbnMsIGRhdGFBZGFwdGVyKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50O1xuICAgIHRoaXMuZGF0YSA9IGRhdGFBZGFwdGVyO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICBSZXN1bHRzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICB9XG5cbiAgVXRpbHMuRXh0ZW5kKFJlc3VsdHMsIFV0aWxzLk9ic2VydmFibGUpO1xuXG4gIFJlc3VsdHMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHJlc3VsdHMgPSAkKFxuICAgICAgJzx1bCBjbGFzcz1cInNlbGVjdDItcmVzdWx0c19fb3B0aW9uc1wiIHJvbGU9XCJsaXN0Ym94XCI+PC91bD4nXG4gICAgKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2V0KCdtdWx0aXBsZScpKSB7XG4gICAgICAkcmVzdWx0cy5hdHRyKCdhcmlhLW11bHRpc2VsZWN0YWJsZScsICd0cnVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy4kcmVzdWx0cyA9ICRyZXN1bHRzO1xuXG4gICAgcmV0dXJuICRyZXN1bHRzO1xuICB9O1xuXG4gIFJlc3VsdHMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJHJlc3VsdHMuZW1wdHkoKTtcbiAgfTtcblxuICBSZXN1bHRzLnByb3RvdHlwZS5kaXNwbGF5TWVzc2FnZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgZXNjYXBlTWFya3VwID0gdGhpcy5vcHRpb25zLmdldCgnZXNjYXBlTWFya3VwJyk7XG5cbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5oaWRlTG9hZGluZygpO1xuXG4gICAgdmFyICRtZXNzYWdlID0gJChcbiAgICAgICc8bGkgcm9sZT1cImFsZXJ0XCIgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCInICtcbiAgICAgICcgY2xhc3M9XCJzZWxlY3QyLXJlc3VsdHNfX29wdGlvblwiPjwvbGk+J1xuICAgICk7XG5cbiAgICB2YXIgbWVzc2FnZSA9IHRoaXMub3B0aW9ucy5nZXQoJ3RyYW5zbGF0aW9ucycpLmdldChwYXJhbXMubWVzc2FnZSk7XG5cbiAgICAkbWVzc2FnZS5hcHBlbmQoXG4gICAgICBlc2NhcGVNYXJrdXAoXG4gICAgICAgIG1lc3NhZ2UocGFyYW1zLmFyZ3MpXG4gICAgICApXG4gICAgKTtcblxuICAgICRtZXNzYWdlWzBdLmNsYXNzTmFtZSArPSAnIHNlbGVjdDItcmVzdWx0c19fbWVzc2FnZSc7XG5cbiAgICB0aGlzLiRyZXN1bHRzLmFwcGVuZCgkbWVzc2FnZSk7XG4gIH07XG5cbiAgUmVzdWx0cy5wcm90b3R5cGUuaGlkZU1lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJHJlc3VsdHMuZmluZCgnLnNlbGVjdDItcmVzdWx0c19fbWVzc2FnZScpLnJlbW92ZSgpO1xuICB9O1xuXG4gIFJlc3VsdHMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdGhpcy5oaWRlTG9hZGluZygpO1xuXG4gICAgdmFyICRvcHRpb25zID0gW107XG5cbiAgICBpZiAoZGF0YS5yZXN1bHRzID09IG51bGwgfHwgZGF0YS5yZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMuJHJlc3VsdHMuY2hpbGRyZW4oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdyZXN1bHRzOm1lc3NhZ2UnLCB7XG4gICAgICAgICAgbWVzc2FnZTogJ25vUmVzdWx0cydcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhLnJlc3VsdHMgPSB0aGlzLnNvcnQoZGF0YS5yZXN1bHRzKTtcblxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGF0YS5yZXN1bHRzLmxlbmd0aDsgZCsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGEucmVzdWx0c1tkXTtcblxuICAgICAgdmFyICRvcHRpb24gPSB0aGlzLm9wdGlvbihpdGVtKTtcblxuICAgICAgJG9wdGlvbnMucHVzaCgkb3B0aW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLiRyZXN1bHRzLmFwcGVuZCgkb3B0aW9ucyk7XG4gIH07XG5cbiAgUmVzdWx0cy5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoJHJlc3VsdHMsICRkcm9wZG93bikge1xuICAgIHZhciAkcmVzdWx0c0NvbnRhaW5lciA9ICRkcm9wZG93bi5maW5kKCcuc2VsZWN0Mi1yZXN1bHRzJyk7XG4gICAgJHJlc3VsdHNDb250YWluZXIuYXBwZW5kKCRyZXN1bHRzKTtcbiAgfTtcblxuICBSZXN1bHRzLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc29ydGVyID0gdGhpcy5vcHRpb25zLmdldCgnc29ydGVyJyk7XG5cbiAgICByZXR1cm4gc29ydGVyKGRhdGEpO1xuICB9O1xuXG4gIFJlc3VsdHMucHJvdG90eXBlLmhpZ2hsaWdodEZpcnN0SXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJG9wdGlvbnMgPSB0aGlzLiRyZXN1bHRzXG4gICAgICAuZmluZCgnLnNlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1zZWxlY3RhYmxlJyk7XG5cbiAgICB2YXIgJHNlbGVjdGVkID0gJG9wdGlvbnMuZmlsdGVyKCcuc2VsZWN0Mi1yZXN1bHRzX19vcHRpb24tLXNlbGVjdGVkJyk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IHNlbGVjdGVkIG9wdGlvbnNcbiAgICBpZiAoJHNlbGVjdGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBzZWxlY3RlZCBvcHRpb25zLCBoaWdobGlnaHQgdGhlIGZpcnN0XG4gICAgICAkc2VsZWN0ZWQuZmlyc3QoKS50cmlnZ2VyKCdtb3VzZWVudGVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBzZWxlY3RlZCBvcHRpb25zLCBoaWdobGlnaHQgdGhlIGZpcnN0IG9wdGlvblxuICAgICAgLy8gaW4gdGhlIGRyb3Bkb3duXG4gICAgICAkb3B0aW9ucy5maXJzdCgpLnRyaWdnZXIoJ21vdXNlZW50ZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLmVuc3VyZUhpZ2hsaWdodFZpc2libGUoKTtcbiAgfTtcblxuICBSZXN1bHRzLnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuZGF0YS5jdXJyZW50KGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgdmFyIHNlbGVjdGVkSWRzID0gc2VsZWN0ZWQubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzLmlkLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyICRvcHRpb25zID0gc2VsZi4kcmVzdWx0c1xuICAgICAgICAuZmluZCgnLnNlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1zZWxlY3RhYmxlJyk7XG5cbiAgICAgICRvcHRpb25zLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJG9wdGlvbiA9ICQodGhpcyk7XG5cbiAgICAgICAgdmFyIGl0ZW0gPSBVdGlscy5HZXREYXRhKHRoaXMsICdkYXRhJyk7XG5cbiAgICAgICAgLy8gaWQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvIGEgc3RyaW5nIHdoZW4gY29tcGFyaW5nXG4gICAgICAgIHZhciBpZCA9ICcnICsgaXRlbS5pZDtcblxuICAgICAgICBpZiAoKGl0ZW0uZWxlbWVudCAhPSBudWxsICYmIGl0ZW0uZWxlbWVudC5zZWxlY3RlZCkgfHxcbiAgICAgICAgICAgIChpdGVtLmVsZW1lbnQgPT0gbnVsbCAmJiBzZWxlY3RlZElkcy5pbmRleE9mKGlkKSA+IC0xKSkge1xuICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc2VsZWN0Mi1yZXN1bHRzX19vcHRpb24tLXNlbGVjdGVkJyk7XG4gICAgICAgICAgJG9wdGlvbi5hdHRyKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1zZWxlY3RlZCcpO1xuICAgICAgICAgICRvcHRpb24uYXR0cignYXJpYS1zZWxlY3RlZCcsICdmYWxzZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH0pO1xuICB9O1xuXG4gIFJlc3VsdHMucHJvdG90eXBlLnNob3dMb2FkaW5nID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHRoaXMuaGlkZUxvYWRpbmcoKTtcblxuICAgIHZhciBsb2FkaW5nTW9yZSA9IHRoaXMub3B0aW9ucy5nZXQoJ3RyYW5zbGF0aW9ucycpLmdldCgnc2VhcmNoaW5nJyk7XG5cbiAgICB2YXIgbG9hZGluZyA9IHtcbiAgICAgIGRpc2FibGVkOiB0cnVlLFxuICAgICAgbG9hZGluZzogdHJ1ZSxcbiAgICAgIHRleHQ6IGxvYWRpbmdNb3JlKHBhcmFtcylcbiAgICB9O1xuICAgIHZhciAkbG9hZGluZyA9IHRoaXMub3B0aW9uKGxvYWRpbmcpO1xuICAgICRsb2FkaW5nLmNsYXNzTmFtZSArPSAnIGxvYWRpbmctcmVzdWx0cyc7XG5cbiAgICB0aGlzLiRyZXN1bHRzLnByZXBlbmQoJGxvYWRpbmcpO1xuICB9O1xuXG4gIFJlc3VsdHMucHJvdG90eXBlLmhpZGVMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJHJlc3VsdHMuZmluZCgnLmxvYWRpbmctcmVzdWx0cycpLnJlbW92ZSgpO1xuICB9O1xuXG4gIFJlc3VsdHMucHJvdG90eXBlLm9wdGlvbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgb3B0aW9uLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdDItcmVzdWx0c19fb3B0aW9uJyk7XG4gICAgb3B0aW9uLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1zZWxlY3RhYmxlJyk7XG5cbiAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAncm9sZSc6ICdvcHRpb24nXG4gICAgfTtcblxuICAgIHZhciBtYXRjaGVzID0gd2luZG93LkVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHxcbiAgICAgIHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgd2luZG93LkVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcblxuICAgIGlmICgoZGF0YS5lbGVtZW50ICE9IG51bGwgJiYgbWF0Y2hlcy5jYWxsKGRhdGEuZWxlbWVudCwgJzpkaXNhYmxlZCcpKSB8fFxuICAgICAgICAoZGF0YS5lbGVtZW50ID09IG51bGwgJiYgZGF0YS5kaXNhYmxlZCkpIHtcbiAgICAgIGF0dHJzWydhcmlhLWRpc2FibGVkJ10gPSAndHJ1ZSc7XG5cbiAgICAgIG9wdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3QyLXJlc3VsdHNfX29wdGlvbi0tc2VsZWN0YWJsZScpO1xuICAgICAgb3B0aW9uLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1kaXNhYmxlZCcpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmlkID09IG51bGwpIHtcbiAgICAgIG9wdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3QyLXJlc3VsdHNfX29wdGlvbi0tc2VsZWN0YWJsZScpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLl9yZXN1bHRJZCAhPSBudWxsKSB7XG4gICAgICBvcHRpb24uaWQgPSBkYXRhLl9yZXN1bHRJZDtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS50aXRsZSkge1xuICAgICAgb3B0aW9uLnRpdGxlID0gZGF0YS50aXRsZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5jaGlsZHJlbikge1xuICAgICAgYXR0cnMucm9sZSA9ICdncm91cCc7XG4gICAgICBhdHRyc1snYXJpYS1sYWJlbCddID0gZGF0YS50ZXh0O1xuXG4gICAgICBvcHRpb24uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0Mi1yZXN1bHRzX19vcHRpb24tLXNlbGVjdGFibGUnKTtcbiAgICAgIG9wdGlvbi5jbGFzc0xpc3QuYWRkKCdzZWxlY3QyLXJlc3VsdHNfX29wdGlvbi0tZ3JvdXAnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICB2YXIgdmFsID0gYXR0cnNbYXR0cl07XG5cbiAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5jaGlsZHJlbikge1xuICAgICAgdmFyICRvcHRpb24gPSAkKG9wdGlvbik7XG5cbiAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0cm9uZycpO1xuICAgICAgbGFiZWwuY2xhc3NOYW1lID0gJ3NlbGVjdDItcmVzdWx0c19fZ3JvdXAnO1xuXG4gICAgICB0aGlzLnRlbXBsYXRlKGRhdGEsIGxhYmVsKTtcblxuICAgICAgdmFyICRjaGlsZHJlbiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGRhdGEuY2hpbGRyZW4ubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gZGF0YS5jaGlsZHJlbltjXTtcblxuICAgICAgICB2YXIgJGNoaWxkID0gdGhpcy5vcHRpb24oY2hpbGQpO1xuXG4gICAgICAgICRjaGlsZHJlbi5wdXNoKCRjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciAkY2hpbGRyZW5Db250YWluZXIgPSAkKCc8dWw+PC91bD4nLCB7XG4gICAgICAgICdjbGFzcyc6ICdzZWxlY3QyLXJlc3VsdHNfX29wdGlvbnMgc2VsZWN0Mi1yZXN1bHRzX19vcHRpb25zLS1uZXN0ZWQnLFxuICAgICAgICAncm9sZSc6ICdub25lJ1xuICAgICAgfSk7XG5cbiAgICAgICRjaGlsZHJlbkNvbnRhaW5lci5hcHBlbmQoJGNoaWxkcmVuKTtcblxuICAgICAgJG9wdGlvbi5hcHBlbmQobGFiZWwpO1xuICAgICAgJG9wdGlvbi5hcHBlbmQoJGNoaWxkcmVuQ29udGFpbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZW1wbGF0ZShkYXRhLCBvcHRpb24pO1xuICAgIH1cblxuICAgIFV0aWxzLlN0b3JlRGF0YShvcHRpb24sICdkYXRhJywgZGF0YSk7XG5cbiAgICByZXR1cm4gb3B0aW9uO1xuICB9O1xuXG4gIFJlc3VsdHMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCAkY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIGlkID0gY29udGFpbmVyLmlkICsgJy1yZXN1bHRzJztcblxuICAgIHRoaXMuJHJlc3VsdHMuYXR0cignaWQnLCBpZCk7XG5cbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6YWxsJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgc2VsZi5jbGVhcigpO1xuICAgICAgc2VsZi5hcHBlbmQocGFyYW1zLmRhdGEpO1xuXG4gICAgICBpZiAoY29udGFpbmVyLmlzT3BlbigpKSB7XG4gICAgICAgIHNlbGYuc2V0Q2xhc3NlcygpO1xuICAgICAgICBzZWxmLmhpZ2hsaWdodEZpcnN0SXRlbSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOmFwcGVuZCcsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIHNlbGYuYXBwZW5kKHBhcmFtcy5kYXRhKTtcblxuICAgICAgaWYgKGNvbnRhaW5lci5pc09wZW4oKSkge1xuICAgICAgICBzZWxmLnNldENsYXNzZXMoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbigncXVlcnknLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBzZWxmLmhpZGVNZXNzYWdlcygpO1xuICAgICAgc2VsZi5zaG93TG9hZGluZyhwYXJhbXMpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdzZWxlY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWNvbnRhaW5lci5pc09wZW4oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuc2V0Q2xhc3NlcygpO1xuXG4gICAgICBpZiAoc2VsZi5vcHRpb25zLmdldCgnc2Nyb2xsQWZ0ZXJTZWxlY3QnKSkge1xuICAgICAgICBzZWxmLmhpZ2hsaWdodEZpcnN0SXRlbSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCd1bnNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY29udGFpbmVyLmlzT3BlbigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5zZXRDbGFzc2VzKCk7XG5cbiAgICAgIGlmIChzZWxmLm9wdGlvbnMuZ2V0KCdzY3JvbGxBZnRlclNlbGVjdCcpKSB7XG4gICAgICAgIHNlbGYuaGlnaGxpZ2h0Rmlyc3RJdGVtKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBXaGVuIHRoZSBkcm9wZG93biBpcyBvcGVuLCBhcmlhLWV4cGVuZGVkPVwidHJ1ZVwiXG4gICAgICBzZWxmLiRyZXN1bHRzLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuICAgICAgc2VsZi4kcmVzdWx0cy5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICBzZWxmLnNldENsYXNzZXMoKTtcbiAgICAgIHNlbGYuZW5zdXJlSGlnaGxpZ2h0VmlzaWJsZSgpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFdoZW4gdGhlIGRyb3Bkb3duIGlzIGNsb3NlZCwgYXJpYS1leHBlbmRlZD1cImZhbHNlXCJcbiAgICAgIHNlbGYuJHJlc3VsdHMuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgc2VsZi4kcmVzdWx0cy5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICBzZWxmLiRyZXN1bHRzLnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOnRvZ2dsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkaGlnaGxpZ2h0ZWQgPSBzZWxmLmdldEhpZ2hsaWdodGVkUmVzdWx0cygpO1xuXG4gICAgICBpZiAoJGhpZ2hsaWdodGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICRoaWdobGlnaHRlZC50cmlnZ2VyKCdtb3VzZXVwJyk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6c2VsZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRoaWdobGlnaHRlZCA9IHNlbGYuZ2V0SGlnaGxpZ2h0ZWRSZXN1bHRzKCk7XG5cbiAgICAgIGlmICgkaGlnaGxpZ2h0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSBVdGlscy5HZXREYXRhKCRoaWdobGlnaHRlZFswXSwgJ2RhdGEnKTtcblxuICAgICAgaWYgKCRoaWdobGlnaHRlZC5oYXNDbGFzcygnc2VsZWN0Mi1yZXN1bHRzX19vcHRpb24tLXNlbGVjdGVkJykpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdjbG9zZScsIHt9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0Jywge1xuICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6cHJldmlvdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJGhpZ2hsaWdodGVkID0gc2VsZi5nZXRIaWdobGlnaHRlZFJlc3VsdHMoKTtcblxuICAgICAgdmFyICRvcHRpb25zID0gc2VsZi4kcmVzdWx0cy5maW5kKCcuc2VsZWN0Mi1yZXN1bHRzX19vcHRpb24tLXNlbGVjdGFibGUnKTtcblxuICAgICAgdmFyIGN1cnJlbnRJbmRleCA9ICRvcHRpb25zLmluZGV4KCRoaWdobGlnaHRlZCk7XG5cbiAgICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IGF0IHRoZSB0b3AsIGRvbid0IG1vdmUgZnVydGhlclxuICAgICAgLy8gSWYgbm8gb3B0aW9ucywgY3VycmVudEluZGV4IHdpbGwgYmUgLTFcbiAgICAgIGlmIChjdXJyZW50SW5kZXggPD0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXh0SW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuXG4gICAgICAvLyBJZiBub25lIGFyZSBoaWdobGlnaHRlZCwgaGlnaGxpZ2h0IHRoZSBmaXJzdFxuICAgICAgaWYgKCRoaWdobGlnaHRlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbmV4dEluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyICRuZXh0ID0gJG9wdGlvbnMuZXEobmV4dEluZGV4KTtcblxuICAgICAgJG5leHQudHJpZ2dlcignbW91c2VlbnRlcicpO1xuXG4gICAgICB2YXIgY3VycmVudE9mZnNldCA9IHNlbGYuJHJlc3VsdHMub2Zmc2V0KCkudG9wO1xuICAgICAgdmFyIG5leHRUb3AgPSAkbmV4dC5vZmZzZXQoKS50b3A7XG4gICAgICB2YXIgbmV4dE9mZnNldCA9IHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKCkgKyAobmV4dFRvcCAtIGN1cnJlbnRPZmZzZXQpO1xuXG4gICAgICBpZiAobmV4dEluZGV4ID09PSAwKSB7XG4gICAgICAgIHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKDApO1xuICAgICAgfSBlbHNlIGlmIChuZXh0VG9wIC0gY3VycmVudE9mZnNldCA8IDApIHtcbiAgICAgICAgc2VsZi4kcmVzdWx0cy5zY3JvbGxUb3AobmV4dE9mZnNldCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6bmV4dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkaGlnaGxpZ2h0ZWQgPSBzZWxmLmdldEhpZ2hsaWdodGVkUmVzdWx0cygpO1xuXG4gICAgICB2YXIgJG9wdGlvbnMgPSBzZWxmLiRyZXN1bHRzLmZpbmQoJy5zZWxlY3QyLXJlc3VsdHNfX29wdGlvbi0tc2VsZWN0YWJsZScpO1xuXG4gICAgICB2YXIgY3VycmVudEluZGV4ID0gJG9wdGlvbnMuaW5kZXgoJGhpZ2hsaWdodGVkKTtcblxuICAgICAgdmFyIG5leHRJbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG5cbiAgICAgIC8vIElmIHdlIGFyZSBhdCB0aGUgbGFzdCBvcHRpb24sIHN0YXkgdGhlcmVcbiAgICAgIGlmIChuZXh0SW5kZXggPj0gJG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyICRuZXh0ID0gJG9wdGlvbnMuZXEobmV4dEluZGV4KTtcblxuICAgICAgJG5leHQudHJpZ2dlcignbW91c2VlbnRlcicpO1xuXG4gICAgICB2YXIgY3VycmVudE9mZnNldCA9IHNlbGYuJHJlc3VsdHMub2Zmc2V0KCkudG9wICtcbiAgICAgICAgc2VsZi4kcmVzdWx0cy5vdXRlckhlaWdodChmYWxzZSk7XG4gICAgICB2YXIgbmV4dEJvdHRvbSA9ICRuZXh0Lm9mZnNldCgpLnRvcCArICRuZXh0Lm91dGVySGVpZ2h0KGZhbHNlKTtcbiAgICAgIHZhciBuZXh0T2Zmc2V0ID0gc2VsZi4kcmVzdWx0cy5zY3JvbGxUb3AoKSArIG5leHRCb3R0b20gLSBjdXJyZW50T2Zmc2V0O1xuXG4gICAgICBpZiAobmV4dEluZGV4ID09PSAwKSB7XG4gICAgICAgIHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKDApO1xuICAgICAgfSBlbHNlIGlmIChuZXh0Qm90dG9tID4gY3VycmVudE9mZnNldCkge1xuICAgICAgICBzZWxmLiRyZXN1bHRzLnNjcm9sbFRvcChuZXh0T2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czpmb2N1cycsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIHBhcmFtcy5lbGVtZW50WzBdLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1oaWdobGlnaHRlZCcpO1xuICAgICAgcGFyYW1zLmVsZW1lbnRbMF0uc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czptZXNzYWdlJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgc2VsZi5kaXNwbGF5TWVzc2FnZShwYXJhbXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKCQuZm4ubW91c2V3aGVlbCkge1xuICAgICAgdGhpcy4kcmVzdWx0cy5vbignbW91c2V3aGVlbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0b3AgPSBzZWxmLiRyZXN1bHRzLnNjcm9sbFRvcCgpO1xuXG4gICAgICAgIHZhciBib3R0b20gPSBzZWxmLiRyZXN1bHRzLmdldCgwKS5zY3JvbGxIZWlnaHQgLSB0b3AgKyBlLmRlbHRhWTtcblxuICAgICAgICB2YXIgaXNBdFRvcCA9IGUuZGVsdGFZID4gMCAmJiB0b3AgLSBlLmRlbHRhWSA8PSAwO1xuICAgICAgICB2YXIgaXNBdEJvdHRvbSA9IGUuZGVsdGFZIDwgMCAmJiBib3R0b20gPD0gc2VsZi4kcmVzdWx0cy5oZWlnaHQoKTtcblxuICAgICAgICBpZiAoaXNBdFRvcCkge1xuICAgICAgICAgIHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKDApO1xuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBdEJvdHRvbSkge1xuICAgICAgICAgIHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKFxuICAgICAgICAgICAgc2VsZi4kcmVzdWx0cy5nZXQoMCkuc2Nyb2xsSGVpZ2h0IC0gc2VsZi4kcmVzdWx0cy5oZWlnaHQoKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy4kcmVzdWx0cy5vbignbW91c2V1cCcsICcuc2VsZWN0Mi1yZXN1bHRzX19vcHRpb24tLXNlbGVjdGFibGUnLFxuICAgICAgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcblxuICAgICAgdmFyIGRhdGEgPSBVdGlscy5HZXREYXRhKHRoaXMsICdkYXRhJyk7XG5cbiAgICAgIGlmICgkdGhpcy5oYXNDbGFzcygnc2VsZWN0Mi1yZXN1bHRzX19vcHRpb24tLXNlbGVjdGVkJykpIHtcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5nZXQoJ211bHRpcGxlJykpIHtcbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0LFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYudHJpZ2dlcignY2xvc2UnLCB7fSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0Jywge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnQsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kcmVzdWx0cy5vbignbW91c2VlbnRlcicsICcuc2VsZWN0Mi1yZXN1bHRzX19vcHRpb24tLXNlbGVjdGFibGUnLFxuICAgICAgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgdmFyIGRhdGEgPSBVdGlscy5HZXREYXRhKHRoaXMsICdkYXRhJyk7XG5cbiAgICAgIHNlbGYuZ2V0SGlnaGxpZ2h0ZWRSZXN1bHRzKClcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1oaWdobGlnaHRlZCcpXG4gICAgICAgICAgLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAnZmFsc2UnKTtcblxuICAgICAgc2VsZi50cmlnZ2VyKCdyZXN1bHRzOmZvY3VzJywge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBlbGVtZW50OiAkKHRoaXMpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBSZXN1bHRzLnByb3RvdHlwZS5nZXRIaWdobGlnaHRlZFJlc3VsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRoaWdobGlnaHRlZCA9IHRoaXMuJHJlc3VsdHNcbiAgICAuZmluZCgnLnNlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1oaWdobGlnaHRlZCcpO1xuXG4gICAgcmV0dXJuICRoaWdobGlnaHRlZDtcbiAgfTtcblxuICBSZXN1bHRzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJHJlc3VsdHMucmVtb3ZlKCk7XG4gIH07XG5cbiAgUmVzdWx0cy5wcm90b3R5cGUuZW5zdXJlSGlnaGxpZ2h0VmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGhpZ2hsaWdodGVkID0gdGhpcy5nZXRIaWdobGlnaHRlZFJlc3VsdHMoKTtcblxuICAgIGlmICgkaGlnaGxpZ2h0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyICRvcHRpb25zID0gdGhpcy4kcmVzdWx0cy5maW5kKCcuc2VsZWN0Mi1yZXN1bHRzX19vcHRpb24tLXNlbGVjdGFibGUnKTtcblxuICAgIHZhciBjdXJyZW50SW5kZXggPSAkb3B0aW9ucy5pbmRleCgkaGlnaGxpZ2h0ZWQpO1xuXG4gICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB0aGlzLiRyZXN1bHRzLm9mZnNldCgpLnRvcDtcbiAgICB2YXIgbmV4dFRvcCA9ICRoaWdobGlnaHRlZC5vZmZzZXQoKS50b3A7XG4gICAgdmFyIG5leHRPZmZzZXQgPSB0aGlzLiRyZXN1bHRzLnNjcm9sbFRvcCgpICsgKG5leHRUb3AgLSBjdXJyZW50T2Zmc2V0KTtcblxuICAgIHZhciBvZmZzZXREZWx0YSA9IG5leHRUb3AgLSBjdXJyZW50T2Zmc2V0O1xuICAgIG5leHRPZmZzZXQgLT0gJGhpZ2hsaWdodGVkLm91dGVySGVpZ2h0KGZhbHNlKSAqIDI7XG5cbiAgICBpZiAoY3VycmVudEluZGV4IDw9IDIpIHtcbiAgICAgIHRoaXMuJHJlc3VsdHMuc2Nyb2xsVG9wKDApO1xuICAgIH0gZWxzZSBpZiAob2Zmc2V0RGVsdGEgPiB0aGlzLiRyZXN1bHRzLm91dGVySGVpZ2h0KCkgfHwgb2Zmc2V0RGVsdGEgPCAwKSB7XG4gICAgICB0aGlzLiRyZXN1bHRzLnNjcm9sbFRvcChuZXh0T2Zmc2V0KTtcbiAgICB9XG4gIH07XG5cbiAgUmVzdWx0cy5wcm90b3R5cGUudGVtcGxhdGUgPSBmdW5jdGlvbiAocmVzdWx0LCBjb250YWluZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMuZ2V0KCd0ZW1wbGF0ZVJlc3VsdCcpO1xuICAgIHZhciBlc2NhcGVNYXJrdXAgPSB0aGlzLm9wdGlvbnMuZ2V0KCdlc2NhcGVNYXJrdXAnKTtcblxuICAgIHZhciBjb250ZW50ID0gdGVtcGxhdGUocmVzdWx0LCBjb250YWluZXIpO1xuXG4gICAgaWYgKGNvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBlc2NhcGVNYXJrdXAoY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQoY29udGFpbmVyKS5hcHBlbmQoY29udGVudCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSZXN1bHRzO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9rZXlzJyxbXG5cbl0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIEtFWVMgPSB7XG4gICAgQkFDS1NQQUNFOiA4LFxuICAgIFRBQjogOSxcbiAgICBFTlRFUjogMTMsXG4gICAgU0hJRlQ6IDE2LFxuICAgIENUUkw6IDE3LFxuICAgIEFMVDogMTgsXG4gICAgRVNDOiAyNyxcbiAgICBTUEFDRTogMzIsXG4gICAgUEFHRV9VUDogMzMsXG4gICAgUEFHRV9ET1dOOiAzNCxcbiAgICBFTkQ6IDM1LFxuICAgIEhPTUU6IDM2LFxuICAgIExFRlQ6IDM3LFxuICAgIFVQOiAzOCxcbiAgICBSSUdIVDogMzksXG4gICAgRE9XTjogNDAsXG4gICAgREVMRVRFOiA0NlxuICB9O1xuXG4gIHJldHVybiBLRVlTO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9zZWxlY3Rpb24vYmFzZScsW1xuICAnanF1ZXJ5JyxcbiAgJy4uL3V0aWxzJyxcbiAgJy4uL2tleXMnXG5dLCBmdW5jdGlvbiAoJCwgVXRpbHMsIEtFWVMpIHtcbiAgZnVuY3Rpb24gQmFzZVNlbGVjdGlvbiAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIEJhc2VTZWxlY3Rpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gIH1cblxuICBVdGlscy5FeHRlbmQoQmFzZVNlbGVjdGlvbiwgVXRpbHMuT2JzZXJ2YWJsZSk7XG5cbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkc2VsZWN0aW9uID0gJChcbiAgICAgICc8c3BhbiBjbGFzcz1cInNlbGVjdDItc2VsZWN0aW9uXCIgcm9sZT1cImNvbWJvYm94XCIgJyArXG4gICAgICAnIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCI+JyArXG4gICAgICAnPC9zcGFuPidcbiAgICApO1xuXG4gICAgdGhpcy5fdGFiaW5kZXggPSAwO1xuXG4gICAgaWYgKFV0aWxzLkdldERhdGEodGhpcy4kZWxlbWVudFswXSwgJ29sZC10YWJpbmRleCcpICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3RhYmluZGV4ID0gVXRpbHMuR2V0RGF0YSh0aGlzLiRlbGVtZW50WzBdLCAnb2xkLXRhYmluZGV4Jyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JykgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fdGFiaW5kZXggPSB0aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4Jyk7XG4gICAgfVxuXG4gICAgJHNlbGVjdGlvbi5hdHRyKCd0aXRsZScsIHRoaXMuJGVsZW1lbnQuYXR0cigndGl0bGUnKSk7XG4gICAgJHNlbGVjdGlvbi5hdHRyKCd0YWJpbmRleCcsIHRoaXMuX3RhYmluZGV4KTtcbiAgICAkc2VsZWN0aW9uLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcblxuICAgIHRoaXMuJHNlbGVjdGlvbiA9ICRzZWxlY3Rpb247XG5cbiAgICByZXR1cm4gJHNlbGVjdGlvbjtcbiAgfTtcblxuICBCYXNlU2VsZWN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciByZXN1bHRzSWQgPSBjb250YWluZXIuaWQgKyAnLXJlc3VsdHMnO1xuXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2ZvY3VzJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi50cmlnZ2VyKCdmb2N1cycsIGV2dCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2JsdXInLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBzZWxmLl9oYW5kbGVCbHVyKGV2dCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBzZWxmLnRyaWdnZXIoJ2tleXByZXNzJywgZXZ0KTtcblxuICAgICAgaWYgKGV2dC53aGljaCA9PT0gS0VZUy5TUEFDRSkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czpmb2N1cycsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIHNlbGYuJHNlbGVjdGlvbi5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBwYXJhbXMuZGF0YS5fcmVzdWx0SWQpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdzZWxlY3Rpb246dXBkYXRlJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgc2VsZi51cGRhdGUocGFyYW1zLmRhdGEpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gV2hlbiB0aGUgZHJvcGRvd24gaXMgb3BlbiwgYXJpYS1leHBhbmRlZD1cInRydWVcIlxuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ2FyaWEtb3ducycsIHJlc3VsdHNJZCk7XG5cbiAgICAgIHNlbGYuX2F0dGFjaENsb3NlSGFuZGxlcihjb250YWluZXIpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFdoZW4gdGhlIGRyb3Bkb3duIGlzIGNsb3NlZCwgYXJpYS1leHBhbmRlZD1cImZhbHNlXCJcbiAgICAgIHNlbGYuJHNlbGVjdGlvbi5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICBzZWxmLiRzZWxlY3Rpb24ucmVtb3ZlQXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyk7XG4gICAgICBzZWxmLiRzZWxlY3Rpb24ucmVtb3ZlQXR0cignYXJpYS1vd25zJyk7XG5cbiAgICAgIHNlbGYuJHNlbGVjdGlvbi50cmlnZ2VyKCdmb2N1cycpO1xuXG4gICAgICBzZWxmLl9kZXRhY2hDbG9zZUhhbmRsZXIoY29udGFpbmVyKTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbignZW5hYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ3RhYmluZGV4Jywgc2VsZi5fdGFiaW5kZXgpO1xuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbignZGlzYWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuJHNlbGVjdGlvbi5hdHRyKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgIH0pO1xuICB9O1xuXG4gIEJhc2VTZWxlY3Rpb24ucHJvdG90eXBlLl9oYW5kbGVCbHVyID0gZnVuY3Rpb24gKGV2dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVsYXllZCBhcyB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgdGhlIGJvZHkgd2hlbiB0aGUgdGFiXG4gICAgLy8ga2V5IGlzIHByZXNzZWQsIHBvc3NpYmx5IGFsb25nIHdpdGggb3RoZXJzLlxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIERvbid0IHRyaWdnZXIgYGJsdXJgIGlmIHRoZSBmb2N1cyBpcyBzdGlsbCBpbiB0aGUgc2VsZWN0aW9uXG4gICAgICBpZiAoXG4gICAgICAgIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IHNlbGYuJHNlbGVjdGlvblswXSkgfHxcbiAgICAgICAgKCQuY29udGFpbnMoc2VsZi4kc2VsZWN0aW9uWzBdLCBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYudHJpZ2dlcignYmx1cicsIGV2dCk7XG4gICAgfSwgMSk7XG4gIH07XG5cbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUuX2F0dGFjaENsb3NlSGFuZGxlciA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcblxuICAgICQoZG9jdW1lbnQuYm9keSkub24oJ21vdXNlZG93bi5zZWxlY3QyLicgKyBjb250YWluZXIuaWQsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgJHRhcmdldCA9ICQoZS50YXJnZXQpO1xuXG4gICAgICB2YXIgJHNlbGVjdCA9ICR0YXJnZXQuY2xvc2VzdCgnLnNlbGVjdDInKTtcblxuICAgICAgdmFyICRhbGwgPSAkKCcuc2VsZWN0Mi5zZWxlY3QyLWNvbnRhaW5lci0tb3BlbicpO1xuXG4gICAgICAkYWxsLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyA9PSAkc2VsZWN0WzBdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICRlbGVtZW50ID0gVXRpbHMuR2V0RGF0YSh0aGlzLCAnZWxlbWVudCcpO1xuXG4gICAgICAgICRlbGVtZW50LnNlbGVjdDIoJ2Nsb3NlJyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBCYXNlU2VsZWN0aW9uLnByb3RvdHlwZS5fZGV0YWNoQ2xvc2VIYW5kbGVyID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICQoZG9jdW1lbnQuYm9keSkub2ZmKCdtb3VzZWRvd24uc2VsZWN0Mi4nICsgY29udGFpbmVyLmlkKTtcbiAgfTtcblxuICBCYXNlU2VsZWN0aW9uLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgkc2VsZWN0aW9uLCAkY29udGFpbmVyKSB7XG4gICAgdmFyICRzZWxlY3Rpb25Db250YWluZXIgPSAkY29udGFpbmVyLmZpbmQoJy5zZWxlY3Rpb24nKTtcbiAgICAkc2VsZWN0aW9uQ29udGFpbmVyLmFwcGVuZCgkc2VsZWN0aW9uKTtcbiAgfTtcblxuICBCYXNlU2VsZWN0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RldGFjaENsb3NlSGFuZGxlcih0aGlzLmNvbnRhaW5lcik7XG4gIH07XG5cbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgdXBkYXRlYCBtZXRob2QgbXVzdCBiZSBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXMuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gYWJzdHJhY3QgdGhlIFwiZW5hYmxlZFwiIChub3QgXCJkaXNhYmxlZFwiKSBzdGF0ZSBvZiB0aGlzXG4gICAqIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7dHJ1ZX0gaWYgdGhlIGluc3RhbmNlIGlzIG5vdCBkaXNhYmxlZC5cbiAgICogQHJldHVybiB7ZmFsc2V9IGlmIHRoZSBpbnN0YW5jZSBpcyBkaXNhYmxlZC5cbiAgICovXG4gIEJhc2VTZWxlY3Rpb24ucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNEaXNhYmxlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFic3RyYWN0IHRoZSBcImRpc2FibGVkXCIgc3RhdGUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3RydWV9IGlmIHRoZSBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZS5cbiAgICogQHJldHVybiB7ZmFsc2V9IGlmIHRoZSBkaXNhYmxlZCBvcHRpb24gaXMgZmFsc2UuXG4gICAqL1xuICBCYXNlU2VsZWN0aW9uLnByb3RvdHlwZS5pc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZ2V0KCdkaXNhYmxlZCcpO1xuICB9O1xuXG4gIHJldHVybiBCYXNlU2VsZWN0aW9uO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9zZWxlY3Rpb24vc2luZ2xlJyxbXG4gICdqcXVlcnknLFxuICAnLi9iYXNlJyxcbiAgJy4uL3V0aWxzJyxcbiAgJy4uL2tleXMnXG5dLCBmdW5jdGlvbiAoJCwgQmFzZVNlbGVjdGlvbiwgVXRpbHMsIEtFWVMpIHtcbiAgZnVuY3Rpb24gU2luZ2xlU2VsZWN0aW9uICgpIHtcbiAgICBTaW5nbGVTZWxlY3Rpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBVdGlscy5FeHRlbmQoU2luZ2xlU2VsZWN0aW9uLCBCYXNlU2VsZWN0aW9uKTtcblxuICBTaW5nbGVTZWxlY3Rpb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHNlbGVjdGlvbiA9IFNpbmdsZVNlbGVjdGlvbi5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcyk7XG5cbiAgICAkc2VsZWN0aW9uWzBdLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdDItc2VsZWN0aW9uLS1zaW5nbGUnKTtcblxuICAgICRzZWxlY3Rpb24uaHRtbChcbiAgICAgICc8c3BhbiBjbGFzcz1cInNlbGVjdDItc2VsZWN0aW9uX19yZW5kZXJlZFwiPjwvc3Bhbj4nICtcbiAgICAgICc8c3BhbiBjbGFzcz1cInNlbGVjdDItc2VsZWN0aW9uX19hcnJvd1wiIHJvbGU9XCJwcmVzZW50YXRpb25cIj4nICtcbiAgICAgICAgJzxiIHJvbGU9XCJwcmVzZW50YXRpb25cIj48L2I+JyArXG4gICAgICAnPC9zcGFuPidcbiAgICApO1xuXG4gICAgcmV0dXJuICRzZWxlY3Rpb247XG4gIH07XG5cbiAgU2luZ2xlU2VsZWN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIFNpbmdsZVNlbGVjdGlvbi5fX3N1cGVyX18uYmluZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGlkID0gY29udGFpbmVyLmlkICsgJy1jb250YWluZXInO1xuXG4gICAgdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKVxuICAgICAgLmF0dHIoJ2lkJywgaWQpXG4gICAgICAuYXR0cigncm9sZScsICd0ZXh0Ym94JylcbiAgICAgIC5hdHRyKCdhcmlhLXJlYWRvbmx5JywgJ3RydWUnKTtcbiAgICB0aGlzLiRzZWxlY3Rpb24uYXR0cignYXJpYS1sYWJlbGxlZGJ5JywgaWQpO1xuICAgIHRoaXMuJHNlbGVjdGlvbi5hdHRyKCdhcmlhLWNvbnRyb2xzJywgaWQpO1xuXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAvLyBPbmx5IHJlc3BvbmQgdG8gbGVmdCBjbGlja3NcbiAgICAgIGlmIChldnQud2hpY2ggIT09IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnRyaWdnZXIoJ3RvZ2dsZScsIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbignZm9jdXMnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAvLyBVc2VyIGZvY3VzZXMgb24gdGhlIGNvbnRhaW5lclxuICAgIH0pO1xuXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdibHVyJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgLy8gVXNlciBleGl0cyB0aGUgY29udGFpbmVyXG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ2ZvY3VzJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYgKCFjb250YWluZXIuaXNPcGVuKCkpIHtcbiAgICAgICAgc2VsZi4kc2VsZWN0aW9uLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgU2luZ2xlU2VsZWN0aW9uLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHJlbmRlcmVkID0gdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKTtcbiAgICAkcmVuZGVyZWQuZW1wdHkoKTtcbiAgICAkcmVuZGVyZWQucmVtb3ZlQXR0cigndGl0bGUnKTsgLy8gY2xlYXIgdG9vbHRpcCBvbiBlbXB0eVxuICB9O1xuXG4gIFNpbmdsZVNlbGVjdGlvbi5wcm90b3R5cGUuZGlzcGxheSA9IGZ1bmN0aW9uIChkYXRhLCBjb250YWluZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMuZ2V0KCd0ZW1wbGF0ZVNlbGVjdGlvbicpO1xuICAgIHZhciBlc2NhcGVNYXJrdXAgPSB0aGlzLm9wdGlvbnMuZ2V0KCdlc2NhcGVNYXJrdXAnKTtcblxuICAgIHJldHVybiBlc2NhcGVNYXJrdXAodGVtcGxhdGUoZGF0YSwgY29udGFpbmVyKSk7XG4gIH07XG5cbiAgU2luZ2xlU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3Rpb25Db250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICQoJzxzcGFuPjwvc3Bhbj4nKTtcbiAgfTtcblxuICBTaW5nbGVTZWxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGlvbiA9IGRhdGFbMF07XG5cbiAgICB2YXIgJHJlbmRlcmVkID0gdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKTtcbiAgICB2YXIgZm9ybWF0dGVkID0gdGhpcy5kaXNwbGF5KHNlbGVjdGlvbiwgJHJlbmRlcmVkKTtcblxuICAgICRyZW5kZXJlZC5lbXB0eSgpLmFwcGVuZChmb3JtYXR0ZWQpO1xuXG4gICAgdmFyIHRpdGxlID0gc2VsZWN0aW9uLnRpdGxlIHx8IHNlbGVjdGlvbi50ZXh0O1xuXG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICAkcmVuZGVyZWQuYXR0cigndGl0bGUnLCB0aXRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRyZW5kZXJlZC5yZW1vdmVBdHRyKCd0aXRsZScpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2luZ2xlU2VsZWN0aW9uO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9zZWxlY3Rpb24vbXVsdGlwbGUnLFtcbiAgJ2pxdWVyeScsXG4gICcuL2Jhc2UnLFxuICAnLi4vdXRpbHMnXG5dLCBmdW5jdGlvbiAoJCwgQmFzZVNlbGVjdGlvbiwgVXRpbHMpIHtcbiAgZnVuY3Rpb24gTXVsdGlwbGVTZWxlY3Rpb24gKCRlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgTXVsdGlwbGVTZWxlY3Rpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBVdGlscy5FeHRlbmQoTXVsdGlwbGVTZWxlY3Rpb24sIEJhc2VTZWxlY3Rpb24pO1xuXG4gIE11bHRpcGxlU2VsZWN0aW9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRzZWxlY3Rpb24gPSBNdWx0aXBsZVNlbGVjdGlvbi5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcyk7XG5cbiAgICAkc2VsZWN0aW9uWzBdLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdDItc2VsZWN0aW9uLS1tdWx0aXBsZScpO1xuXG4gICAgJHNlbGVjdGlvbi5odG1sKFxuICAgICAgJzx1bCBjbGFzcz1cInNlbGVjdDItc2VsZWN0aW9uX19yZW5kZXJlZFwiPjwvdWw+J1xuICAgICk7XG5cbiAgICByZXR1cm4gJHNlbGVjdGlvbjtcbiAgfTtcblxuICBNdWx0aXBsZVNlbGVjdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChjb250YWluZXIsICRjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBNdWx0aXBsZVNlbGVjdGlvbi5fX3N1cGVyX18uYmluZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGlkID0gY29udGFpbmVyLmlkICsgJy1jb250YWluZXInO1xuICAgIHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJykuYXR0cignaWQnLCBpZCk7XG5cbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi50cmlnZ2VyKCd0b2dnbGUnLCB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oXG4gICAgICAnY2xpY2snLFxuICAgICAgJy5zZWxlY3QyLXNlbGVjdGlvbl9fY2hvaWNlX19yZW1vdmUnLFxuICAgICAgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGl0IGlzIGRpc2FibGVkXG4gICAgICAgIGlmIChzZWxmLmlzRGlzYWJsZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAkcmVtb3ZlID0gJCh0aGlzKTtcbiAgICAgICAgdmFyICRzZWxlY3Rpb24gPSAkcmVtb3ZlLnBhcmVudCgpO1xuXG4gICAgICAgIHZhciBkYXRhID0gVXRpbHMuR2V0RGF0YSgkc2VsZWN0aW9uWzBdLCAnZGF0YScpO1xuXG4gICAgICAgIHNlbGYudHJpZ2dlcigndW5zZWxlY3QnLCB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0LFxuICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbihcbiAgICAgICdrZXlkb3duJyxcbiAgICAgICcuc2VsZWN0Mi1zZWxlY3Rpb25fX2Nob2ljZV9fcmVtb3ZlJyxcbiAgICAgIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiBpdCBpcyBkaXNhYmxlZFxuICAgICAgICBpZiAoc2VsZi5pc0Rpc2FibGVkKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICBNdWx0aXBsZVNlbGVjdGlvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRyZW5kZXJlZCA9IHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJyk7XG4gICAgJHJlbmRlcmVkLmVtcHR5KCk7XG4gICAgJHJlbmRlcmVkLnJlbW92ZUF0dHIoJ3RpdGxlJyk7XG4gIH07XG5cbiAgTXVsdGlwbGVTZWxlY3Rpb24ucHJvdG90eXBlLmRpc3BsYXkgPSBmdW5jdGlvbiAoZGF0YSwgY29udGFpbmVyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcy5vcHRpb25zLmdldCgndGVtcGxhdGVTZWxlY3Rpb24nKTtcbiAgICB2YXIgZXNjYXBlTWFya3VwID0gdGhpcy5vcHRpb25zLmdldCgnZXNjYXBlTWFya3VwJyk7XG5cbiAgICByZXR1cm4gZXNjYXBlTWFya3VwKHRlbXBsYXRlKGRhdGEsIGNvbnRhaW5lcikpO1xuICB9O1xuXG4gIE11bHRpcGxlU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3Rpb25Db250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRjb250YWluZXIgPSAkKFxuICAgICAgJzxsaSBjbGFzcz1cInNlbGVjdDItc2VsZWN0aW9uX19jaG9pY2VcIj4nICtcbiAgICAgICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwic2VsZWN0Mi1zZWxlY3Rpb25fX2Nob2ljZV9fcmVtb3ZlXCIgJyArXG4gICAgICAgICd0YWJpbmRleD1cIi0xXCI+JyArXG4gICAgICAgICAgJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+JyArXG4gICAgICAgICc8L2J1dHRvbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VsZWN0Mi1zZWxlY3Rpb25fX2Nob2ljZV9fZGlzcGxheVwiPjwvc3Bhbj4nICtcbiAgICAgICc8L2xpPidcbiAgICApO1xuXG4gICAgcmV0dXJuICRjb250YWluZXI7XG4gIH07XG5cbiAgTXVsdGlwbGVTZWxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyICRzZWxlY3Rpb25zID0gW107XG5cbiAgICB2YXIgc2VsZWN0aW9uSWRQcmVmaXggPSB0aGlzLiRzZWxlY3Rpb24uZmluZCgnLnNlbGVjdDItc2VsZWN0aW9uX19yZW5kZXJlZCcpXG4gICAgICAuYXR0cignaWQnKSArICctY2hvaWNlLSc7XG5cbiAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBkYXRhW2RdO1xuXG4gICAgICB2YXIgJHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uQ29udGFpbmVyKCk7XG4gICAgICB2YXIgZm9ybWF0dGVkID0gdGhpcy5kaXNwbGF5KHNlbGVjdGlvbiwgJHNlbGVjdGlvbik7XG5cbiAgICAgIHZhciBzZWxlY3Rpb25JZCA9IHNlbGVjdGlvbklkUHJlZml4ICsgVXRpbHMuZ2VuZXJhdGVDaGFycyg0KSArICctJztcblxuICAgICAgaWYgKHNlbGVjdGlvbi5pZCkge1xuICAgICAgICBzZWxlY3Rpb25JZCArPSBzZWxlY3Rpb24uaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3Rpb25JZCArPSBVdGlscy5nZW5lcmF0ZUNoYXJzKDQpO1xuICAgICAgfVxuXG4gICAgICAkc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fY2hvaWNlX19kaXNwbGF5JylcbiAgICAgICAgLmFwcGVuZChmb3JtYXR0ZWQpXG4gICAgICAgIC5hdHRyKCdpZCcsIHNlbGVjdGlvbklkKTtcblxuICAgICAgdmFyIHRpdGxlID0gc2VsZWN0aW9uLnRpdGxlIHx8IHNlbGVjdGlvbi50ZXh0O1xuXG4gICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgJHNlbGVjdGlvbi5hdHRyKCd0aXRsZScsIHRpdGxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbW92ZUl0ZW0gPSB0aGlzLm9wdGlvbnMuZ2V0KCd0cmFuc2xhdGlvbnMnKS5nZXQoJ3JlbW92ZUl0ZW0nKTtcblxuICAgICAgdmFyICRyZW1vdmUgPSAkc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fY2hvaWNlX19yZW1vdmUnKTtcblxuICAgICAgJHJlbW92ZS5hdHRyKCd0aXRsZScsIHJlbW92ZUl0ZW0oKSk7XG4gICAgICAkcmVtb3ZlLmF0dHIoJ2FyaWEtbGFiZWwnLCByZW1vdmVJdGVtKCkpO1xuICAgICAgJHJlbW92ZS5hdHRyKCdhcmlhLWRlc2NyaWJlZGJ5Jywgc2VsZWN0aW9uSWQpO1xuXG4gICAgICBVdGlscy5TdG9yZURhdGEoJHNlbGVjdGlvblswXSwgJ2RhdGEnLCBzZWxlY3Rpb24pO1xuXG4gICAgICAkc2VsZWN0aW9ucy5wdXNoKCRzZWxlY3Rpb24pO1xuICAgIH1cblxuICAgIHZhciAkcmVuZGVyZWQgPSB0aGlzLiRzZWxlY3Rpb24uZmluZCgnLnNlbGVjdDItc2VsZWN0aW9uX19yZW5kZXJlZCcpO1xuXG4gICAgJHJlbmRlcmVkLmFwcGVuZCgkc2VsZWN0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIE11bHRpcGxlU2VsZWN0aW9uO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9zZWxlY3Rpb24vcGxhY2Vob2xkZXInLFtcblxuXSwgZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbGFjZWhvbGRlciAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMucGxhY2Vob2xkZXIgPSB0aGlzLm5vcm1hbGl6ZVBsYWNlaG9sZGVyKG9wdGlvbnMuZ2V0KCdwbGFjZWhvbGRlcicpKTtcblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zKTtcbiAgfVxuXG4gIFBsYWNlaG9sZGVyLnByb3RvdHlwZS5ub3JtYWxpemVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChfLCBwbGFjZWhvbGRlcikge1xuICAgIGlmICh0eXBlb2YgcGxhY2Vob2xkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgaWQ6ICcnLFxuICAgICAgICB0ZXh0OiBwbGFjZWhvbGRlclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gIH07XG5cbiAgUGxhY2Vob2xkZXIucHJvdG90eXBlLmNyZWF0ZVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgJHBsYWNlaG9sZGVyID0gdGhpcy5zZWxlY3Rpb25Db250YWluZXIoKTtcblxuICAgICRwbGFjZWhvbGRlci5odG1sKHRoaXMuZGlzcGxheShwbGFjZWhvbGRlcikpO1xuICAgICRwbGFjZWhvbGRlclswXS5jbGFzc0xpc3QuYWRkKCdzZWxlY3QyLXNlbGVjdGlvbl9fcGxhY2Vob2xkZXInKTtcbiAgICAkcGxhY2Vob2xkZXJbMF0uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0Mi1zZWxlY3Rpb25fX2Nob2ljZScpO1xuXG4gICAgdmFyIHBsYWNlaG9sZGVyVGl0bGUgPSBwbGFjZWhvbGRlci50aXRsZSB8fFxuICAgICAgcGxhY2Vob2xkZXIudGV4dCB8fFxuICAgICAgJHBsYWNlaG9sZGVyLnRleHQoKTtcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJykuYXR0cihcbiAgICAgICd0aXRsZScsXG4gICAgICBwbGFjZWhvbGRlclRpdGxlXG4gICAgKTtcblxuICAgIHJldHVybiAkcGxhY2Vob2xkZXI7XG4gIH07XG5cbiAgUGxhY2Vob2xkZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGRhdGEpIHtcbiAgICB2YXIgc2luZ2xlUGxhY2Vob2xkZXIgPSAoXG4gICAgICBkYXRhLmxlbmd0aCA9PSAxICYmIGRhdGFbMF0uaWQgIT0gdGhpcy5wbGFjZWhvbGRlci5pZFxuICAgICk7XG4gICAgdmFyIG11bHRpcGxlU2VsZWN0aW9ucyA9IGRhdGEubGVuZ3RoID4gMTtcblxuICAgIGlmIChtdWx0aXBsZVNlbGVjdGlvbnMgfHwgc2luZ2xlUGxhY2Vob2xkZXIpIHtcbiAgICAgIHJldHVybiBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICB2YXIgJHBsYWNlaG9sZGVyID0gdGhpcy5jcmVhdGVQbGFjZWhvbGRlcih0aGlzLnBsYWNlaG9sZGVyKTtcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJykuYXBwZW5kKCRwbGFjZWhvbGRlcik7XG4gIH07XG5cbiAgcmV0dXJuIFBsYWNlaG9sZGVyO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9zZWxlY3Rpb24vYWxsb3dDbGVhcicsW1xuICAnanF1ZXJ5JyxcbiAgJy4uL2tleXMnLFxuICAnLi4vdXRpbHMnXG5dLCBmdW5jdGlvbiAoJCwgS0VZUywgVXRpbHMpIHtcbiAgZnVuY3Rpb24gQWxsb3dDbGVhciAoKSB7IH1cblxuICBBbGxvd0NsZWFyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcblxuICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyID09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2V0KCdkZWJ1ZycpICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnU2VsZWN0MjogVGhlIGBhbGxvd0NsZWFyYCBvcHRpb24gc2hvdWxkIGJlIHVzZWQgaW4gY29tYmluYXRpb24gJyArXG4gICAgICAgICAgJ3dpdGggdGhlIGBwbGFjZWhvbGRlcmAgb3B0aW9uLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ21vdXNlZG93bicsICcuc2VsZWN0Mi1zZWxlY3Rpb25fX2NsZWFyJyxcbiAgICAgIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgc2VsZi5faGFuZGxlQ2xlYXIoZXZ0KTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbigna2V5cHJlc3MnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBzZWxmLl9oYW5kbGVLZXlib2FyZENsZWFyKGV2dCwgY29udGFpbmVyKTtcbiAgICB9KTtcbiAgfTtcblxuICBBbGxvd0NsZWFyLnByb3RvdHlwZS5faGFuZGxlQ2xlYXIgPSBmdW5jdGlvbiAoXywgZXZ0KSB7XG4gICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiBpdCBpcyBkaXNhYmxlZFxuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciAkY2xlYXIgPSB0aGlzLiRzZWxlY3Rpb24uZmluZCgnLnNlbGVjdDItc2VsZWN0aW9uX19jbGVhcicpO1xuXG4gICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiBub3RoaW5nIGhhcyBiZWVuIHNlbGVjdGVkXG4gICAgaWYgKCRjbGVhci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICB2YXIgZGF0YSA9IFV0aWxzLkdldERhdGEoJGNsZWFyWzBdLCAnZGF0YScpO1xuXG4gICAgdmFyIHByZXZpb3VzVmFsID0gdGhpcy4kZWxlbWVudC52YWwoKTtcbiAgICB0aGlzLiRlbGVtZW50LnZhbCh0aGlzLnBsYWNlaG9sZGVyLmlkKTtcblxuICAgIHZhciB1bnNlbGVjdERhdGEgPSB7XG4gICAgICBkYXRhOiBkYXRhXG4gICAgfTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NsZWFyJywgdW5zZWxlY3REYXRhKTtcbiAgICBpZiAodW5zZWxlY3REYXRhLnByZXZlbnRlZCkge1xuICAgICAgdGhpcy4kZWxlbWVudC52YWwocHJldmlvdXNWYWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGF0YS5sZW5ndGg7IGQrKykge1xuICAgICAgdW5zZWxlY3REYXRhID0ge1xuICAgICAgICBkYXRhOiBkYXRhW2RdXG4gICAgICB9O1xuXG4gICAgICAvLyBUcmlnZ2VyIHRoZSBgdW5zZWxlY3RgIGV2ZW50LCBzbyBwZW9wbGUgY2FuIHByZXZlbnQgaXQgZnJvbSBiZWluZ1xuICAgICAgLy8gY2xlYXJlZC5cbiAgICAgIHRoaXMudHJpZ2dlcigndW5zZWxlY3QnLCB1bnNlbGVjdERhdGEpO1xuXG4gICAgICAvLyBJZiB0aGUgZXZlbnQgd2FzIHByZXZlbnRlZCwgZG9uJ3QgY2xlYXIgaXQgb3V0LlxuICAgICAgaWYgKHVuc2VsZWN0RGF0YS5wcmV2ZW50ZWQpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC52YWwocHJldmlvdXNWYWwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdpbnB1dCcpLnRyaWdnZXIoJ2NoYW5nZScpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCd0b2dnbGUnLCB7fSk7XG4gIH07XG5cbiAgQWxsb3dDbGVhci5wcm90b3R5cGUuX2hhbmRsZUtleWJvYXJkQ2xlYXIgPSBmdW5jdGlvbiAoXywgZXZ0LCBjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyLmlzT3BlbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2dC53aGljaCA9PSBLRVlTLkRFTEVURSB8fCBldnQud2hpY2ggPT0gS0VZUy5CQUNLU1BBQ0UpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUNsZWFyKGV2dCk7XG4gICAgfVxuICB9O1xuXG4gIEFsbG93Q2xlYXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGRhdGEpIHtcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBkYXRhKTtcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX2NsZWFyJykucmVtb3ZlKCk7XG4gICAgdGhpcy4kc2VsZWN0aW9uWzBdLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdDItc2VsZWN0aW9uLS1jbGVhcmFibGUnKTtcblxuICAgIGlmICh0aGlzLiRzZWxlY3Rpb24uZmluZCgnLnNlbGVjdDItc2VsZWN0aW9uX19wbGFjZWhvbGRlcicpLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0aW9uSWQgPSB0aGlzLiRzZWxlY3Rpb24uZmluZCgnLnNlbGVjdDItc2VsZWN0aW9uX19yZW5kZXJlZCcpXG4gICAgICAuYXR0cignaWQnKTtcblxuICAgIHZhciByZW1vdmVBbGwgPSB0aGlzLm9wdGlvbnMuZ2V0KCd0cmFuc2xhdGlvbnMnKS5nZXQoJ3JlbW92ZUFsbEl0ZW1zJyk7XG5cbiAgICB2YXIgJHJlbW92ZSA9ICQoXG4gICAgICAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJzZWxlY3QyLXNlbGVjdGlvbl9fY2xlYXJcIiB0YWJpbmRleD1cIi0xXCI+JyArXG4gICAgICAgICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPicgK1xuICAgICAgJzwvYnV0dG9uPidcbiAgICApO1xuICAgICRyZW1vdmUuYXR0cigndGl0bGUnLCByZW1vdmVBbGwoKSk7XG4gICAgJHJlbW92ZS5hdHRyKCdhcmlhLWxhYmVsJywgcmVtb3ZlQWxsKCkpO1xuICAgICRyZW1vdmUuYXR0cignYXJpYS1kZXNjcmliZWRieScsIHNlbGVjdGlvbklkKTtcbiAgICBVdGlscy5TdG9yZURhdGEoJHJlbW92ZVswXSwgJ2RhdGEnLCBkYXRhKTtcblxuICAgIHRoaXMuJHNlbGVjdGlvbi5wcmVwZW5kKCRyZW1vdmUpO1xuICAgIHRoaXMuJHNlbGVjdGlvblswXS5jbGFzc0xpc3QuYWRkKCdzZWxlY3QyLXNlbGVjdGlvbi0tY2xlYXJhYmxlJyk7XG4gIH07XG5cbiAgcmV0dXJuIEFsbG93Q2xlYXI7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL3NlbGVjdGlvbi9zZWFyY2gnLFtcbiAgJ2pxdWVyeScsXG4gICcuLi91dGlscycsXG4gICcuLi9rZXlzJ1xuXSwgZnVuY3Rpb24gKCQsIFV0aWxzLCBLRVlTKSB7XG4gIGZ1bmN0aW9uIFNlYXJjaCAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zKTtcbiAgfVxuXG4gIFNlYXJjaC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGRlY29yYXRlZCkge1xuICAgIHZhciBzZWFyY2hMYWJlbCA9IHRoaXMub3B0aW9ucy5nZXQoJ3RyYW5zbGF0aW9ucycpLmdldCgnc2VhcmNoJyk7XG4gICAgdmFyICRzZWFyY2ggPSAkKFxuICAgICAgJzxzcGFuIGNsYXNzPVwic2VsZWN0Mi1zZWFyY2ggc2VsZWN0Mi1zZWFyY2gtLWlubGluZVwiPicgK1xuICAgICAgICAnPHRleHRhcmVhIGNsYXNzPVwic2VsZWN0Mi1zZWFyY2hfX2ZpZWxkXCInK1xuICAgICAgICAnIHR5cGU9XCJzZWFyY2hcIiB0YWJpbmRleD1cIi0xXCInICtcbiAgICAgICAgJyBhdXRvY29ycmVjdD1cIm9mZlwiIGF1dG9jYXBpdGFsaXplPVwibm9uZVwiJyArXG4gICAgICAgICcgc3BlbGxjaGVjaz1cImZhbHNlXCIgcm9sZT1cInNlYXJjaGJveFwiIGFyaWEtYXV0b2NvbXBsZXRlPVwibGlzdFwiID4nICtcbiAgICAgICAgJzwvdGV4dGFyZWE+JyArXG4gICAgICAnPC9zcGFuPidcbiAgICApO1xuXG4gICAgdGhpcy4kc2VhcmNoQ29udGFpbmVyID0gJHNlYXJjaDtcbiAgICB0aGlzLiRzZWFyY2ggPSAkc2VhcmNoLmZpbmQoJ3RleHRhcmVhJyk7XG5cbiAgICB0aGlzLiRzZWFyY2gucHJvcCgnYXV0b2NvbXBsZXRlJywgdGhpcy5vcHRpb25zLmdldCgnYXV0b2NvbXBsZXRlJykpO1xuICAgIHRoaXMuJHNlYXJjaC5hdHRyKCdhcmlhLWxhYmVsJywgc2VhcmNoTGFiZWwoKSk7XG5cbiAgICB2YXIgJHJlbmRlcmVkID0gZGVjb3JhdGVkLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl90cmFuc2ZlclRhYkluZGV4KCk7XG4gICAgJHJlbmRlcmVkLmFwcGVuZCh0aGlzLiRzZWFyY2hDb250YWluZXIpO1xuXG4gICAgcmV0dXJuICRyZW5kZXJlZDtcbiAgfTtcblxuICBTZWFyY2gucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIsICRjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcmVzdWx0c0lkID0gY29udGFpbmVyLmlkICsgJy1yZXN1bHRzJztcbiAgICB2YXIgc2VsZWN0aW9uSWQgPSBjb250YWluZXIuaWQgKyAnLWNvbnRhaW5lcic7XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBjb250YWluZXIsICRjb250YWluZXIpO1xuXG4gICAgc2VsZi4kc2VhcmNoLmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknLCBzZWxlY3Rpb25JZCk7XG5cbiAgICBjb250YWluZXIub24oJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLiRzZWFyY2guYXR0cignYXJpYS1jb250cm9scycsIHJlc3VsdHNJZCk7XG4gICAgICBzZWxmLiRzZWFyY2gudHJpZ2dlcignZm9jdXMnKTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLiRzZWFyY2gudmFsKCcnKTtcbiAgICAgIHNlbGYucmVzaXplU2VhcmNoKCk7XG4gICAgICBzZWxmLiRzZWFyY2gucmVtb3ZlQXR0cignYXJpYS1jb250cm9scycpO1xuICAgICAgc2VsZi4kc2VhcmNoLnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xuICAgICAgc2VsZi4kc2VhcmNoLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ2VuYWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuJHNlYXJjaC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcblxuICAgICAgc2VsZi5fdHJhbnNmZXJUYWJJbmRleCgpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdkaXNhYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi4kc2VhcmNoLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ2ZvY3VzJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi4kc2VhcmNoLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6Zm9jdXMnLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW1zLmRhdGEuX3Jlc3VsdElkKSB7XG4gICAgICAgIHNlbGYuJHNlYXJjaC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBwYXJhbXMuZGF0YS5fcmVzdWx0SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi4kc2VhcmNoLnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdmb2N1c2luJywgJy5zZWxlY3QyLXNlYXJjaC0taW5saW5lJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi50cmlnZ2VyKCdmb2N1cycsIGV2dCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2ZvY3Vzb3V0JywgJy5zZWxlY3QyLXNlYXJjaC0taW5saW5lJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi5faGFuZGxlQmx1cihldnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdrZXlkb3duJywgJy5zZWxlY3QyLXNlYXJjaC0taW5saW5lJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBzZWxmLnRyaWdnZXIoJ2tleXByZXNzJywgZXZ0KTtcblxuICAgICAgc2VsZi5fa2V5VXBQcmV2ZW50ZWQgPSBldnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XG5cbiAgICAgIHZhciBrZXkgPSBldnQud2hpY2g7XG5cbiAgICAgIGlmIChrZXkgPT09IEtFWVMuQkFDS1NQQUNFICYmIHNlbGYuJHNlYXJjaC52YWwoKSA9PT0gJycpIHtcbiAgICAgICAgdmFyICRwcmV2aW91c0Nob2ljZSA9IHNlbGYuJHNlbGVjdGlvblxuICAgICAgICAgIC5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX2Nob2ljZScpLmxhc3QoKTtcblxuICAgICAgICBpZiAoJHByZXZpb3VzQ2hvaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IFV0aWxzLkdldERhdGEoJHByZXZpb3VzQ2hvaWNlWzBdLCAnZGF0YScpO1xuXG4gICAgICAgICAgc2VsZi5zZWFyY2hSZW1vdmVDaG9pY2UoaXRlbSk7XG5cbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdjbGljaycsICcuc2VsZWN0Mi1zZWFyY2gtLWlubGluZScsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGlmIChzZWxmLiRzZWFyY2gudmFsKCkpIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVHJ5IHRvIGRldGVjdCB0aGUgSUUgdmVyc2lvbiBzaG91bGQgdGhlIGBkb2N1bWVudE1vZGVgIHByb3BlcnR5IHRoYXRcbiAgICAvLyBpcyBzdG9yZWQgb24gdGhlIGRvY3VtZW50LiBUaGlzIGlzIG9ubHkgaW1wbGVtZW50ZWQgaW4gSUUgYW5kIGlzXG4gICAgLy8gc2xpZ2h0bHkgY2xlYW5lciB0aGFuIGRvaW5nIGEgdXNlciBhZ2VudCBjaGVjay5cbiAgICAvLyBUaGlzIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUgaW4gRWRnZSwgYnV0IEVkZ2UgYWxzbyBkb2Vzbid0IGhhdmVcbiAgICAvLyB0aGlzIGJ1Zy5cbiAgICB2YXIgbXNpZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbiAgICB2YXIgZGlzYWJsZUlucHV0RXZlbnRzID0gbXNpZSAmJiBtc2llIDw9IDExO1xuXG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgYnJvd3NlcnMgd2hpY2ggZG8gbm90IHN1cHBvcnQgdGhlIGBpbnB1dGAgZXZlbnRcbiAgICAvLyBUaGlzIHdpbGwgcHJldmVudCBkb3VibGUtdHJpZ2dlcmluZyBvZiBldmVudHMgZm9yIGJyb3dzZXJzIHdoaWNoIHN1cHBvcnRcbiAgICAvLyBib3RoIHRoZSBga2V5dXBgIGFuZCBgaW5wdXRgIGV2ZW50cy5cbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oXG4gICAgICAnaW5wdXQuc2VhcmNoY2hlY2snLFxuICAgICAgJy5zZWxlY3QyLXNlYXJjaC0taW5saW5lJyxcbiAgICAgIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgLy8gSUUgd2lsbCB0cmlnZ2VyIHRoZSBgaW5wdXRgIGV2ZW50IHdoZW4gYSBwbGFjZWhvbGRlciBpcyB1c2VkIG9uIGFcbiAgICAgICAgLy8gc2VhcmNoIGJveC4gVG8gZ2V0IGFyb3VuZCB0aGlzIGlzc3VlLCB3ZSBhcmUgZm9yY2VkIHRvIGlnbm9yZSBhbGxcbiAgICAgICAgLy8gYGlucHV0YCBldmVudHMgaW4gSUUgYW5kIGtlZXAgdXNpbmcgYGtleXVwYC5cbiAgICAgICAgaWYgKGRpc2FibGVJbnB1dEV2ZW50cykge1xuICAgICAgICAgIHNlbGYuJHNlbGVjdGlvbi5vZmYoJ2lucHV0LnNlYXJjaCBpbnB1dC5zZWFyY2hjaGVjaycpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuYmluZCB0aGUgZHVwbGljYXRlZCBga2V5dXBgIGV2ZW50XG4gICAgICAgIHNlbGYuJHNlbGVjdGlvbi5vZmYoJ2tleXVwLnNlYXJjaCcpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oXG4gICAgICAna2V5dXAuc2VhcmNoIGlucHV0LnNlYXJjaCcsXG4gICAgICAnLnNlbGVjdDItc2VhcmNoLS1pbmxpbmUnLFxuICAgICAgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAvLyBJRSB3aWxsIHRyaWdnZXIgdGhlIGBpbnB1dGAgZXZlbnQgd2hlbiBhIHBsYWNlaG9sZGVyIGlzIHVzZWQgb24gYVxuICAgICAgICAvLyBzZWFyY2ggYm94LiBUbyBnZXQgYXJvdW5kIHRoaXMgaXNzdWUsIHdlIGFyZSBmb3JjZWQgdG8gaWdub3JlIGFsbFxuICAgICAgICAvLyBgaW5wdXRgIGV2ZW50cyBpbiBJRSBhbmQga2VlcCB1c2luZyBga2V5dXBgLlxuICAgICAgICBpZiAoZGlzYWJsZUlucHV0RXZlbnRzICYmIGV2dC50eXBlID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgc2VsZi4kc2VsZWN0aW9uLm9mZignaW5wdXQuc2VhcmNoIGlucHV0LnNlYXJjaGNoZWNrJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleSA9IGV2dC53aGljaDtcblxuICAgICAgICAvLyBXZSBjYW4gZnJlZWx5IGlnbm9yZSBldmVudHMgZnJvbSBtb2RpZmllciBrZXlzXG4gICAgICAgIGlmIChrZXkgPT0gS0VZUy5TSElGVCB8fCBrZXkgPT0gS0VZUy5DVFJMIHx8IGtleSA9PSBLRVlTLkFMVCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRhYmJpbmcgd2lsbCBiZSBoYW5kbGVkIGR1cmluZyB0aGUgYGtleWRvd25gIHBoYXNlXG4gICAgICAgIGlmIChrZXkgPT0gS0VZUy5UQUIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmhhbmRsZVNlYXJjaChldnQpO1xuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgdHJhbnNmZXIgdGhlIHRhYmluZGV4IGF0dHJpYnV0ZSBmcm9tIHRoZSByZW5kZXJlZFxuICAgKiBzZWxlY3Rpb24gdG8gdGhlIHNlYXJjaCBib3guIFRoaXMgYWxsb3dzIGZvciB0aGUgc2VhcmNoIGJveCB0byBiZSB1c2VkIGFzXG4gICAqIHRoZSBwcmltYXJ5IGZvY3VzIGluc3RlYWQgb2YgdGhlIHNlbGVjdGlvbiBjb250YWluZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTZWFyY2gucHJvdG90eXBlLl90cmFuc2ZlclRhYkluZGV4ID0gZnVuY3Rpb24gKGRlY29yYXRlZCkge1xuICAgIHRoaXMuJHNlYXJjaC5hdHRyKCd0YWJpbmRleCcsIHRoaXMuJHNlbGVjdGlvbi5hdHRyKCd0YWJpbmRleCcpKTtcbiAgICB0aGlzLiRzZWxlY3Rpb24uYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcbiAgfTtcblxuICBTZWFyY2gucHJvdG90eXBlLmNyZWF0ZVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgcGxhY2Vob2xkZXIpIHtcbiAgICB0aGlzLiRzZWFyY2guYXR0cigncGxhY2Vob2xkZXInLCBwbGFjZWhvbGRlci50ZXh0KTtcbiAgfTtcblxuICBTZWFyY2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGRhdGEpIHtcbiAgICB2YXIgc2VhcmNoSGFkRm9jdXMgPSB0aGlzLiRzZWFyY2hbMF0gPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgIHRoaXMuJHNlYXJjaC5hdHRyKCdwbGFjZWhvbGRlcicsICcnKTtcblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGRhdGEpO1xuXG4gICAgdGhpcy5yZXNpemVTZWFyY2goKTtcbiAgICBpZiAoc2VhcmNoSGFkRm9jdXMpIHtcbiAgICAgIHRoaXMuJHNlYXJjaC50cmlnZ2VyKCdmb2N1cycpO1xuICAgIH1cbiAgfTtcblxuICBTZWFyY2gucHJvdG90eXBlLmhhbmRsZVNlYXJjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2l6ZVNlYXJjaCgpO1xuXG4gICAgaWYgKCF0aGlzLl9rZXlVcFByZXZlbnRlZCkge1xuICAgICAgdmFyIGlucHV0ID0gdGhpcy4kc2VhcmNoLnZhbCgpO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoJ3F1ZXJ5Jywge1xuICAgICAgICB0ZXJtOiBpbnB1dFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fa2V5VXBQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBTZWFyY2gucHJvdG90eXBlLnNlYXJjaFJlbW92ZUNob2ljZSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGl0ZW0pIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xuICAgICAgZGF0YTogaXRlbVxuICAgIH0pO1xuXG4gICAgdGhpcy4kc2VhcmNoLnZhbChpdGVtLnRleHQpO1xuICAgIHRoaXMuaGFuZGxlU2VhcmNoKCk7XG4gIH07XG5cbiAgU2VhcmNoLnByb3RvdHlwZS5yZXNpemVTZWFyY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kc2VhcmNoLmNzcygnd2lkdGgnLCAnMjVweCcpO1xuXG4gICAgdmFyIHdpZHRoID0gJzEwMCUnO1xuXG4gICAgaWYgKHRoaXMuJHNlYXJjaC5hdHRyKCdwbGFjZWhvbGRlcicpID09PSAnJykge1xuICAgICAgdmFyIG1pbmltdW1XaWR0aCA9IHRoaXMuJHNlYXJjaC52YWwoKS5sZW5ndGggKyAxO1xuXG4gICAgICB3aWR0aCA9IChtaW5pbXVtV2lkdGggKiAwLjc1KSArICdlbSc7XG4gICAgfVxuXG4gICAgdGhpcy4kc2VhcmNoLmNzcygnd2lkdGgnLCB3aWR0aCk7XG4gIH07XG5cbiAgcmV0dXJuIFNlYXJjaDtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvc2VsZWN0aW9uL3NlbGVjdGlvbkNzcycsW1xuICAnLi4vdXRpbHMnXG5dLCBmdW5jdGlvbiAoVXRpbHMpIHtcbiAgZnVuY3Rpb24gU2VsZWN0aW9uQ1NTICgpIHsgfVxuXG4gIFNlbGVjdGlvbkNTUy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGRlY29yYXRlZCkge1xuICAgIHZhciAkc2VsZWN0aW9uID0gZGVjb3JhdGVkLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgc2VsZWN0aW9uQ3NzQ2xhc3MgPSB0aGlzLm9wdGlvbnMuZ2V0KCdzZWxlY3Rpb25Dc3NDbGFzcycpIHx8ICcnO1xuXG4gICAgaWYgKHNlbGVjdGlvbkNzc0NsYXNzLmluZGV4T2YoJzphbGw6JykgIT09IC0xKSB7XG4gICAgICBzZWxlY3Rpb25Dc3NDbGFzcyA9IHNlbGVjdGlvbkNzc0NsYXNzLnJlcGxhY2UoJzphbGw6JywgJycpO1xuXG4gICAgICBVdGlscy5jb3B5Tm9uSW50ZXJuYWxDc3NDbGFzc2VzKCRzZWxlY3Rpb25bMF0sIHRoaXMuJGVsZW1lbnRbMF0pO1xuICAgIH1cblxuICAgICRzZWxlY3Rpb24uYWRkQ2xhc3Moc2VsZWN0aW9uQ3NzQ2xhc3MpO1xuXG4gICAgcmV0dXJuICRzZWxlY3Rpb247XG4gIH07XG5cbiAgcmV0dXJuIFNlbGVjdGlvbkNTUztcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvc2VsZWN0aW9uL2V2ZW50UmVsYXknLFtcbiAgJ2pxdWVyeSdcbl0sIGZ1bmN0aW9uICgkKSB7XG4gIGZ1bmN0aW9uIEV2ZW50UmVsYXkgKCkgeyB9XG5cbiAgRXZlbnRSZWxheS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVsYXlFdmVudHMgPSBbXG4gICAgICAnb3BlbicsICdvcGVuaW5nJyxcbiAgICAgICdjbG9zZScsICdjbG9zaW5nJyxcbiAgICAgICdzZWxlY3QnLCAnc2VsZWN0aW5nJyxcbiAgICAgICd1bnNlbGVjdCcsICd1bnNlbGVjdGluZycsXG4gICAgICAnY2xlYXInLCAnY2xlYXJpbmcnXG4gICAgXTtcblxuICAgIHZhciBwcmV2ZW50YWJsZUV2ZW50cyA9IFtcbiAgICAgICdvcGVuaW5nJywgJ2Nsb3NpbmcnLCAnc2VsZWN0aW5nJywgJ3Vuc2VsZWN0aW5nJywgJ2NsZWFyaW5nJ1xuICAgIF07XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBjb250YWluZXIsICRjb250YWluZXIpO1xuXG4gICAgY29udGFpbmVyLm9uKCcqJywgZnVuY3Rpb24gKG5hbWUsIHBhcmFtcykge1xuICAgICAgLy8gSWdub3JlIGV2ZW50cyB0aGF0IHNob3VsZCBub3QgYmUgcmVsYXllZFxuICAgICAgaWYgKHJlbGF5RXZlbnRzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHBhcmFtZXRlcnMgc2hvdWxkIGFsd2F5cyBiZSBhbiBvYmplY3RcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgICAgLy8gR2VuZXJhdGUgdGhlIGpRdWVyeSBldmVudCBmb3IgdGhlIFNlbGVjdDIgZXZlbnRcbiAgICAgIHZhciBldnQgPSAkLkV2ZW50KCdzZWxlY3QyOicgKyBuYW1lLCB7XG4gICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICB9KTtcblxuICAgICAgc2VsZi4kZWxlbWVudC50cmlnZ2VyKGV2dCk7XG5cbiAgICAgIC8vIE9ubHkgaGFuZGxlIHByZXZlbnRhYmxlIGV2ZW50cyBpZiBpdCB3YXMgb25lXG4gICAgICBpZiAocHJldmVudGFibGVFdmVudHMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwYXJhbXMucHJldmVudGVkID0gZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBFdmVudFJlbGF5O1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi90cmFuc2xhdGlvbicsW1xuICAnanF1ZXJ5JyxcbiAgJ3JlcXVpcmUnXG5dLCBmdW5jdGlvbiAoJCwgcmVxdWlyZSkge1xuICBmdW5jdGlvbiBUcmFuc2xhdGlvbiAoZGljdCkge1xuICAgIHRoaXMuZGljdCA9IGRpY3QgfHwge307XG4gIH1cblxuICBUcmFuc2xhdGlvbi5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpY3Q7XG4gIH07XG5cbiAgVHJhbnNsYXRpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kaWN0W2tleV07XG4gIH07XG5cbiAgVHJhbnNsYXRpb24ucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uICh0cmFuc2xhdGlvbikge1xuICAgIHRoaXMuZGljdCA9ICQuZXh0ZW5kKHt9LCB0cmFuc2xhdGlvbi5hbGwoKSwgdGhpcy5kaWN0KTtcbiAgfTtcblxuICAvLyBTdGF0aWMgZnVuY3Rpb25zXG5cbiAgVHJhbnNsYXRpb24uX2NhY2hlID0ge307XG5cbiAgVHJhbnNsYXRpb24ubG9hZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmICghKHBhdGggaW4gVHJhbnNsYXRpb24uX2NhY2hlKSkge1xuICAgICAgdmFyIHRyYW5zbGF0aW9ucyA9IHJlcXVpcmUocGF0aCk7XG5cbiAgICAgIFRyYW5zbGF0aW9uLl9jYWNoZVtwYXRoXSA9IHRyYW5zbGF0aW9ucztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRyYW5zbGF0aW9uKFRyYW5zbGF0aW9uLl9jYWNoZVtwYXRoXSk7XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zbGF0aW9uO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kaWFjcml0aWNzJyxbXG5cbl0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRpYWNyaXRpY3MgPSB7XG4gICAgJ1xcdTI0QjYnOiAnQScsXG4gICAgJ1xcdUZGMjEnOiAnQScsXG4gICAgJ1xcdTAwQzAnOiAnQScsXG4gICAgJ1xcdTAwQzEnOiAnQScsXG4gICAgJ1xcdTAwQzInOiAnQScsXG4gICAgJ1xcdTFFQTYnOiAnQScsXG4gICAgJ1xcdTFFQTQnOiAnQScsXG4gICAgJ1xcdTFFQUEnOiAnQScsXG4gICAgJ1xcdTFFQTgnOiAnQScsXG4gICAgJ1xcdTAwQzMnOiAnQScsXG4gICAgJ1xcdTAxMDAnOiAnQScsXG4gICAgJ1xcdTAxMDInOiAnQScsXG4gICAgJ1xcdTFFQjAnOiAnQScsXG4gICAgJ1xcdTFFQUUnOiAnQScsXG4gICAgJ1xcdTFFQjQnOiAnQScsXG4gICAgJ1xcdTFFQjInOiAnQScsXG4gICAgJ1xcdTAyMjYnOiAnQScsXG4gICAgJ1xcdTAxRTAnOiAnQScsXG4gICAgJ1xcdTAwQzQnOiAnQScsXG4gICAgJ1xcdTAxREUnOiAnQScsXG4gICAgJ1xcdTFFQTInOiAnQScsXG4gICAgJ1xcdTAwQzUnOiAnQScsXG4gICAgJ1xcdTAxRkEnOiAnQScsXG4gICAgJ1xcdTAxQ0QnOiAnQScsXG4gICAgJ1xcdTAyMDAnOiAnQScsXG4gICAgJ1xcdTAyMDInOiAnQScsXG4gICAgJ1xcdTFFQTAnOiAnQScsXG4gICAgJ1xcdTFFQUMnOiAnQScsXG4gICAgJ1xcdTFFQjYnOiAnQScsXG4gICAgJ1xcdTFFMDAnOiAnQScsXG4gICAgJ1xcdTAxMDQnOiAnQScsXG4gICAgJ1xcdTAyM0EnOiAnQScsXG4gICAgJ1xcdTJDNkYnOiAnQScsXG4gICAgJ1xcdUE3MzInOiAnQUEnLFxuICAgICdcXHUwMEM2JzogJ0FFJyxcbiAgICAnXFx1MDFGQyc6ICdBRScsXG4gICAgJ1xcdTAxRTInOiAnQUUnLFxuICAgICdcXHVBNzM0JzogJ0FPJyxcbiAgICAnXFx1QTczNic6ICdBVScsXG4gICAgJ1xcdUE3MzgnOiAnQVYnLFxuICAgICdcXHVBNzNBJzogJ0FWJyxcbiAgICAnXFx1QTczQyc6ICdBWScsXG4gICAgJ1xcdTI0QjcnOiAnQicsXG4gICAgJ1xcdUZGMjInOiAnQicsXG4gICAgJ1xcdTFFMDInOiAnQicsXG4gICAgJ1xcdTFFMDQnOiAnQicsXG4gICAgJ1xcdTFFMDYnOiAnQicsXG4gICAgJ1xcdTAyNDMnOiAnQicsXG4gICAgJ1xcdTAxODInOiAnQicsXG4gICAgJ1xcdTAxODEnOiAnQicsXG4gICAgJ1xcdTI0QjgnOiAnQycsXG4gICAgJ1xcdUZGMjMnOiAnQycsXG4gICAgJ1xcdTAxMDYnOiAnQycsXG4gICAgJ1xcdTAxMDgnOiAnQycsXG4gICAgJ1xcdTAxMEEnOiAnQycsXG4gICAgJ1xcdTAxMEMnOiAnQycsXG4gICAgJ1xcdTAwQzcnOiAnQycsXG4gICAgJ1xcdTFFMDgnOiAnQycsXG4gICAgJ1xcdTAxODcnOiAnQycsXG4gICAgJ1xcdTAyM0InOiAnQycsXG4gICAgJ1xcdUE3M0UnOiAnQycsXG4gICAgJ1xcdTI0QjknOiAnRCcsXG4gICAgJ1xcdUZGMjQnOiAnRCcsXG4gICAgJ1xcdTFFMEEnOiAnRCcsXG4gICAgJ1xcdTAxMEUnOiAnRCcsXG4gICAgJ1xcdTFFMEMnOiAnRCcsXG4gICAgJ1xcdTFFMTAnOiAnRCcsXG4gICAgJ1xcdTFFMTInOiAnRCcsXG4gICAgJ1xcdTFFMEUnOiAnRCcsXG4gICAgJ1xcdTAxMTAnOiAnRCcsXG4gICAgJ1xcdTAxOEInOiAnRCcsXG4gICAgJ1xcdTAxOEEnOiAnRCcsXG4gICAgJ1xcdTAxODknOiAnRCcsXG4gICAgJ1xcdUE3NzknOiAnRCcsXG4gICAgJ1xcdTAxRjEnOiAnRFonLFxuICAgICdcXHUwMUM0JzogJ0RaJyxcbiAgICAnXFx1MDFGMic6ICdEeicsXG4gICAgJ1xcdTAxQzUnOiAnRHonLFxuICAgICdcXHUyNEJBJzogJ0UnLFxuICAgICdcXHVGRjI1JzogJ0UnLFxuICAgICdcXHUwMEM4JzogJ0UnLFxuICAgICdcXHUwMEM5JzogJ0UnLFxuICAgICdcXHUwMENBJzogJ0UnLFxuICAgICdcXHUxRUMwJzogJ0UnLFxuICAgICdcXHUxRUJFJzogJ0UnLFxuICAgICdcXHUxRUM0JzogJ0UnLFxuICAgICdcXHUxRUMyJzogJ0UnLFxuICAgICdcXHUxRUJDJzogJ0UnLFxuICAgICdcXHUwMTEyJzogJ0UnLFxuICAgICdcXHUxRTE0JzogJ0UnLFxuICAgICdcXHUxRTE2JzogJ0UnLFxuICAgICdcXHUwMTE0JzogJ0UnLFxuICAgICdcXHUwMTE2JzogJ0UnLFxuICAgICdcXHUwMENCJzogJ0UnLFxuICAgICdcXHUxRUJBJzogJ0UnLFxuICAgICdcXHUwMTFBJzogJ0UnLFxuICAgICdcXHUwMjA0JzogJ0UnLFxuICAgICdcXHUwMjA2JzogJ0UnLFxuICAgICdcXHUxRUI4JzogJ0UnLFxuICAgICdcXHUxRUM2JzogJ0UnLFxuICAgICdcXHUwMjI4JzogJ0UnLFxuICAgICdcXHUxRTFDJzogJ0UnLFxuICAgICdcXHUwMTE4JzogJ0UnLFxuICAgICdcXHUxRTE4JzogJ0UnLFxuICAgICdcXHUxRTFBJzogJ0UnLFxuICAgICdcXHUwMTkwJzogJ0UnLFxuICAgICdcXHUwMThFJzogJ0UnLFxuICAgICdcXHUyNEJCJzogJ0YnLFxuICAgICdcXHVGRjI2JzogJ0YnLFxuICAgICdcXHUxRTFFJzogJ0YnLFxuICAgICdcXHUwMTkxJzogJ0YnLFxuICAgICdcXHVBNzdCJzogJ0YnLFxuICAgICdcXHUyNEJDJzogJ0cnLFxuICAgICdcXHVGRjI3JzogJ0cnLFxuICAgICdcXHUwMUY0JzogJ0cnLFxuICAgICdcXHUwMTFDJzogJ0cnLFxuICAgICdcXHUxRTIwJzogJ0cnLFxuICAgICdcXHUwMTFFJzogJ0cnLFxuICAgICdcXHUwMTIwJzogJ0cnLFxuICAgICdcXHUwMUU2JzogJ0cnLFxuICAgICdcXHUwMTIyJzogJ0cnLFxuICAgICdcXHUwMUU0JzogJ0cnLFxuICAgICdcXHUwMTkzJzogJ0cnLFxuICAgICdcXHVBN0EwJzogJ0cnLFxuICAgICdcXHVBNzdEJzogJ0cnLFxuICAgICdcXHVBNzdFJzogJ0cnLFxuICAgICdcXHUyNEJEJzogJ0gnLFxuICAgICdcXHVGRjI4JzogJ0gnLFxuICAgICdcXHUwMTI0JzogJ0gnLFxuICAgICdcXHUxRTIyJzogJ0gnLFxuICAgICdcXHUxRTI2JzogJ0gnLFxuICAgICdcXHUwMjFFJzogJ0gnLFxuICAgICdcXHUxRTI0JzogJ0gnLFxuICAgICdcXHUxRTI4JzogJ0gnLFxuICAgICdcXHUxRTJBJzogJ0gnLFxuICAgICdcXHUwMTI2JzogJ0gnLFxuICAgICdcXHUyQzY3JzogJ0gnLFxuICAgICdcXHUyQzc1JzogJ0gnLFxuICAgICdcXHVBNzhEJzogJ0gnLFxuICAgICdcXHUyNEJFJzogJ0knLFxuICAgICdcXHVGRjI5JzogJ0knLFxuICAgICdcXHUwMENDJzogJ0knLFxuICAgICdcXHUwMENEJzogJ0knLFxuICAgICdcXHUwMENFJzogJ0knLFxuICAgICdcXHUwMTI4JzogJ0knLFxuICAgICdcXHUwMTJBJzogJ0knLFxuICAgICdcXHUwMTJDJzogJ0knLFxuICAgICdcXHUwMTMwJzogJ0knLFxuICAgICdcXHUwMENGJzogJ0knLFxuICAgICdcXHUxRTJFJzogJ0knLFxuICAgICdcXHUxRUM4JzogJ0knLFxuICAgICdcXHUwMUNGJzogJ0knLFxuICAgICdcXHUwMjA4JzogJ0knLFxuICAgICdcXHUwMjBBJzogJ0knLFxuICAgICdcXHUxRUNBJzogJ0knLFxuICAgICdcXHUwMTJFJzogJ0knLFxuICAgICdcXHUxRTJDJzogJ0knLFxuICAgICdcXHUwMTk3JzogJ0knLFxuICAgICdcXHUyNEJGJzogJ0onLFxuICAgICdcXHVGRjJBJzogJ0onLFxuICAgICdcXHUwMTM0JzogJ0onLFxuICAgICdcXHUwMjQ4JzogJ0onLFxuICAgICdcXHUyNEMwJzogJ0snLFxuICAgICdcXHVGRjJCJzogJ0snLFxuICAgICdcXHUxRTMwJzogJ0snLFxuICAgICdcXHUwMUU4JzogJ0snLFxuICAgICdcXHUxRTMyJzogJ0snLFxuICAgICdcXHUwMTM2JzogJ0snLFxuICAgICdcXHUxRTM0JzogJ0snLFxuICAgICdcXHUwMTk4JzogJ0snLFxuICAgICdcXHUyQzY5JzogJ0snLFxuICAgICdcXHVBNzQwJzogJ0snLFxuICAgICdcXHVBNzQyJzogJ0snLFxuICAgICdcXHVBNzQ0JzogJ0snLFxuICAgICdcXHVBN0EyJzogJ0snLFxuICAgICdcXHUyNEMxJzogJ0wnLFxuICAgICdcXHVGRjJDJzogJ0wnLFxuICAgICdcXHUwMTNGJzogJ0wnLFxuICAgICdcXHUwMTM5JzogJ0wnLFxuICAgICdcXHUwMTNEJzogJ0wnLFxuICAgICdcXHUxRTM2JzogJ0wnLFxuICAgICdcXHUxRTM4JzogJ0wnLFxuICAgICdcXHUwMTNCJzogJ0wnLFxuICAgICdcXHUxRTNDJzogJ0wnLFxuICAgICdcXHUxRTNBJzogJ0wnLFxuICAgICdcXHUwMTQxJzogJ0wnLFxuICAgICdcXHUwMjNEJzogJ0wnLFxuICAgICdcXHUyQzYyJzogJ0wnLFxuICAgICdcXHUyQzYwJzogJ0wnLFxuICAgICdcXHVBNzQ4JzogJ0wnLFxuICAgICdcXHVBNzQ2JzogJ0wnLFxuICAgICdcXHVBNzgwJzogJ0wnLFxuICAgICdcXHUwMUM3JzogJ0xKJyxcbiAgICAnXFx1MDFDOCc6ICdMaicsXG4gICAgJ1xcdTI0QzInOiAnTScsXG4gICAgJ1xcdUZGMkQnOiAnTScsXG4gICAgJ1xcdTFFM0UnOiAnTScsXG4gICAgJ1xcdTFFNDAnOiAnTScsXG4gICAgJ1xcdTFFNDInOiAnTScsXG4gICAgJ1xcdTJDNkUnOiAnTScsXG4gICAgJ1xcdTAxOUMnOiAnTScsXG4gICAgJ1xcdTI0QzMnOiAnTicsXG4gICAgJ1xcdUZGMkUnOiAnTicsXG4gICAgJ1xcdTAxRjgnOiAnTicsXG4gICAgJ1xcdTAxNDMnOiAnTicsXG4gICAgJ1xcdTAwRDEnOiAnTicsXG4gICAgJ1xcdTFFNDQnOiAnTicsXG4gICAgJ1xcdTAxNDcnOiAnTicsXG4gICAgJ1xcdTFFNDYnOiAnTicsXG4gICAgJ1xcdTAxNDUnOiAnTicsXG4gICAgJ1xcdTFFNEEnOiAnTicsXG4gICAgJ1xcdTFFNDgnOiAnTicsXG4gICAgJ1xcdTAyMjAnOiAnTicsXG4gICAgJ1xcdTAxOUQnOiAnTicsXG4gICAgJ1xcdUE3OTAnOiAnTicsXG4gICAgJ1xcdUE3QTQnOiAnTicsXG4gICAgJ1xcdTAxQ0EnOiAnTkonLFxuICAgICdcXHUwMUNCJzogJ05qJyxcbiAgICAnXFx1MjRDNCc6ICdPJyxcbiAgICAnXFx1RkYyRic6ICdPJyxcbiAgICAnXFx1MDBEMic6ICdPJyxcbiAgICAnXFx1MDBEMyc6ICdPJyxcbiAgICAnXFx1MDBENCc6ICdPJyxcbiAgICAnXFx1MUVEMic6ICdPJyxcbiAgICAnXFx1MUVEMCc6ICdPJyxcbiAgICAnXFx1MUVENic6ICdPJyxcbiAgICAnXFx1MUVENCc6ICdPJyxcbiAgICAnXFx1MDBENSc6ICdPJyxcbiAgICAnXFx1MUU0Qyc6ICdPJyxcbiAgICAnXFx1MDIyQyc6ICdPJyxcbiAgICAnXFx1MUU0RSc6ICdPJyxcbiAgICAnXFx1MDE0Qyc6ICdPJyxcbiAgICAnXFx1MUU1MCc6ICdPJyxcbiAgICAnXFx1MUU1Mic6ICdPJyxcbiAgICAnXFx1MDE0RSc6ICdPJyxcbiAgICAnXFx1MDIyRSc6ICdPJyxcbiAgICAnXFx1MDIzMCc6ICdPJyxcbiAgICAnXFx1MDBENic6ICdPJyxcbiAgICAnXFx1MDIyQSc6ICdPJyxcbiAgICAnXFx1MUVDRSc6ICdPJyxcbiAgICAnXFx1MDE1MCc6ICdPJyxcbiAgICAnXFx1MDFEMSc6ICdPJyxcbiAgICAnXFx1MDIwQyc6ICdPJyxcbiAgICAnXFx1MDIwRSc6ICdPJyxcbiAgICAnXFx1MDFBMCc6ICdPJyxcbiAgICAnXFx1MUVEQyc6ICdPJyxcbiAgICAnXFx1MUVEQSc6ICdPJyxcbiAgICAnXFx1MUVFMCc6ICdPJyxcbiAgICAnXFx1MUVERSc6ICdPJyxcbiAgICAnXFx1MUVFMic6ICdPJyxcbiAgICAnXFx1MUVDQyc6ICdPJyxcbiAgICAnXFx1MUVEOCc6ICdPJyxcbiAgICAnXFx1MDFFQSc6ICdPJyxcbiAgICAnXFx1MDFFQyc6ICdPJyxcbiAgICAnXFx1MDBEOCc6ICdPJyxcbiAgICAnXFx1MDFGRSc6ICdPJyxcbiAgICAnXFx1MDE4Nic6ICdPJyxcbiAgICAnXFx1MDE5Ric6ICdPJyxcbiAgICAnXFx1QTc0QSc6ICdPJyxcbiAgICAnXFx1QTc0Qyc6ICdPJyxcbiAgICAnXFx1MDE1Mic6ICdPRScsXG4gICAgJ1xcdTAxQTInOiAnT0knLFxuICAgICdcXHVBNzRFJzogJ09PJyxcbiAgICAnXFx1MDIyMic6ICdPVScsXG4gICAgJ1xcdTI0QzUnOiAnUCcsXG4gICAgJ1xcdUZGMzAnOiAnUCcsXG4gICAgJ1xcdTFFNTQnOiAnUCcsXG4gICAgJ1xcdTFFNTYnOiAnUCcsXG4gICAgJ1xcdTAxQTQnOiAnUCcsXG4gICAgJ1xcdTJDNjMnOiAnUCcsXG4gICAgJ1xcdUE3NTAnOiAnUCcsXG4gICAgJ1xcdUE3NTInOiAnUCcsXG4gICAgJ1xcdUE3NTQnOiAnUCcsXG4gICAgJ1xcdTI0QzYnOiAnUScsXG4gICAgJ1xcdUZGMzEnOiAnUScsXG4gICAgJ1xcdUE3NTYnOiAnUScsXG4gICAgJ1xcdUE3NTgnOiAnUScsXG4gICAgJ1xcdTAyNEEnOiAnUScsXG4gICAgJ1xcdTI0QzcnOiAnUicsXG4gICAgJ1xcdUZGMzInOiAnUicsXG4gICAgJ1xcdTAxNTQnOiAnUicsXG4gICAgJ1xcdTFFNTgnOiAnUicsXG4gICAgJ1xcdTAxNTgnOiAnUicsXG4gICAgJ1xcdTAyMTAnOiAnUicsXG4gICAgJ1xcdTAyMTInOiAnUicsXG4gICAgJ1xcdTFFNUEnOiAnUicsXG4gICAgJ1xcdTFFNUMnOiAnUicsXG4gICAgJ1xcdTAxNTYnOiAnUicsXG4gICAgJ1xcdTFFNUUnOiAnUicsXG4gICAgJ1xcdTAyNEMnOiAnUicsXG4gICAgJ1xcdTJDNjQnOiAnUicsXG4gICAgJ1xcdUE3NUEnOiAnUicsXG4gICAgJ1xcdUE3QTYnOiAnUicsXG4gICAgJ1xcdUE3ODInOiAnUicsXG4gICAgJ1xcdTI0QzgnOiAnUycsXG4gICAgJ1xcdUZGMzMnOiAnUycsXG4gICAgJ1xcdTFFOUUnOiAnUycsXG4gICAgJ1xcdTAxNUEnOiAnUycsXG4gICAgJ1xcdTFFNjQnOiAnUycsXG4gICAgJ1xcdTAxNUMnOiAnUycsXG4gICAgJ1xcdTFFNjAnOiAnUycsXG4gICAgJ1xcdTAxNjAnOiAnUycsXG4gICAgJ1xcdTFFNjYnOiAnUycsXG4gICAgJ1xcdTFFNjInOiAnUycsXG4gICAgJ1xcdTFFNjgnOiAnUycsXG4gICAgJ1xcdTAyMTgnOiAnUycsXG4gICAgJ1xcdTAxNUUnOiAnUycsXG4gICAgJ1xcdTJDN0UnOiAnUycsXG4gICAgJ1xcdUE3QTgnOiAnUycsXG4gICAgJ1xcdUE3ODQnOiAnUycsXG4gICAgJ1xcdTI0QzknOiAnVCcsXG4gICAgJ1xcdUZGMzQnOiAnVCcsXG4gICAgJ1xcdTFFNkEnOiAnVCcsXG4gICAgJ1xcdTAxNjQnOiAnVCcsXG4gICAgJ1xcdTFFNkMnOiAnVCcsXG4gICAgJ1xcdTAyMUEnOiAnVCcsXG4gICAgJ1xcdTAxNjInOiAnVCcsXG4gICAgJ1xcdTFFNzAnOiAnVCcsXG4gICAgJ1xcdTFFNkUnOiAnVCcsXG4gICAgJ1xcdTAxNjYnOiAnVCcsXG4gICAgJ1xcdTAxQUMnOiAnVCcsXG4gICAgJ1xcdTAxQUUnOiAnVCcsXG4gICAgJ1xcdTAyM0UnOiAnVCcsXG4gICAgJ1xcdUE3ODYnOiAnVCcsXG4gICAgJ1xcdUE3MjgnOiAnVFonLFxuICAgICdcXHUyNENBJzogJ1UnLFxuICAgICdcXHVGRjM1JzogJ1UnLFxuICAgICdcXHUwMEQ5JzogJ1UnLFxuICAgICdcXHUwMERBJzogJ1UnLFxuICAgICdcXHUwMERCJzogJ1UnLFxuICAgICdcXHUwMTY4JzogJ1UnLFxuICAgICdcXHUxRTc4JzogJ1UnLFxuICAgICdcXHUwMTZBJzogJ1UnLFxuICAgICdcXHUxRTdBJzogJ1UnLFxuICAgICdcXHUwMTZDJzogJ1UnLFxuICAgICdcXHUwMERDJzogJ1UnLFxuICAgICdcXHUwMURCJzogJ1UnLFxuICAgICdcXHUwMUQ3JzogJ1UnLFxuICAgICdcXHUwMUQ1JzogJ1UnLFxuICAgICdcXHUwMUQ5JzogJ1UnLFxuICAgICdcXHUxRUU2JzogJ1UnLFxuICAgICdcXHUwMTZFJzogJ1UnLFxuICAgICdcXHUwMTcwJzogJ1UnLFxuICAgICdcXHUwMUQzJzogJ1UnLFxuICAgICdcXHUwMjE0JzogJ1UnLFxuICAgICdcXHUwMjE2JzogJ1UnLFxuICAgICdcXHUwMUFGJzogJ1UnLFxuICAgICdcXHUxRUVBJzogJ1UnLFxuICAgICdcXHUxRUU4JzogJ1UnLFxuICAgICdcXHUxRUVFJzogJ1UnLFxuICAgICdcXHUxRUVDJzogJ1UnLFxuICAgICdcXHUxRUYwJzogJ1UnLFxuICAgICdcXHUxRUU0JzogJ1UnLFxuICAgICdcXHUxRTcyJzogJ1UnLFxuICAgICdcXHUwMTcyJzogJ1UnLFxuICAgICdcXHUxRTc2JzogJ1UnLFxuICAgICdcXHUxRTc0JzogJ1UnLFxuICAgICdcXHUwMjQ0JzogJ1UnLFxuICAgICdcXHUyNENCJzogJ1YnLFxuICAgICdcXHVGRjM2JzogJ1YnLFxuICAgICdcXHUxRTdDJzogJ1YnLFxuICAgICdcXHUxRTdFJzogJ1YnLFxuICAgICdcXHUwMUIyJzogJ1YnLFxuICAgICdcXHVBNzVFJzogJ1YnLFxuICAgICdcXHUwMjQ1JzogJ1YnLFxuICAgICdcXHVBNzYwJzogJ1ZZJyxcbiAgICAnXFx1MjRDQyc6ICdXJyxcbiAgICAnXFx1RkYzNyc6ICdXJyxcbiAgICAnXFx1MUU4MCc6ICdXJyxcbiAgICAnXFx1MUU4Mic6ICdXJyxcbiAgICAnXFx1MDE3NCc6ICdXJyxcbiAgICAnXFx1MUU4Nic6ICdXJyxcbiAgICAnXFx1MUU4NCc6ICdXJyxcbiAgICAnXFx1MUU4OCc6ICdXJyxcbiAgICAnXFx1MkM3Mic6ICdXJyxcbiAgICAnXFx1MjRDRCc6ICdYJyxcbiAgICAnXFx1RkYzOCc6ICdYJyxcbiAgICAnXFx1MUU4QSc6ICdYJyxcbiAgICAnXFx1MUU4Qyc6ICdYJyxcbiAgICAnXFx1MjRDRSc6ICdZJyxcbiAgICAnXFx1RkYzOSc6ICdZJyxcbiAgICAnXFx1MUVGMic6ICdZJyxcbiAgICAnXFx1MDBERCc6ICdZJyxcbiAgICAnXFx1MDE3Nic6ICdZJyxcbiAgICAnXFx1MUVGOCc6ICdZJyxcbiAgICAnXFx1MDIzMic6ICdZJyxcbiAgICAnXFx1MUU4RSc6ICdZJyxcbiAgICAnXFx1MDE3OCc6ICdZJyxcbiAgICAnXFx1MUVGNic6ICdZJyxcbiAgICAnXFx1MUVGNCc6ICdZJyxcbiAgICAnXFx1MDFCMyc6ICdZJyxcbiAgICAnXFx1MDI0RSc6ICdZJyxcbiAgICAnXFx1MUVGRSc6ICdZJyxcbiAgICAnXFx1MjRDRic6ICdaJyxcbiAgICAnXFx1RkYzQSc6ICdaJyxcbiAgICAnXFx1MDE3OSc6ICdaJyxcbiAgICAnXFx1MUU5MCc6ICdaJyxcbiAgICAnXFx1MDE3Qic6ICdaJyxcbiAgICAnXFx1MDE3RCc6ICdaJyxcbiAgICAnXFx1MUU5Mic6ICdaJyxcbiAgICAnXFx1MUU5NCc6ICdaJyxcbiAgICAnXFx1MDFCNSc6ICdaJyxcbiAgICAnXFx1MDIyNCc6ICdaJyxcbiAgICAnXFx1MkM3Ric6ICdaJyxcbiAgICAnXFx1MkM2Qic6ICdaJyxcbiAgICAnXFx1QTc2Mic6ICdaJyxcbiAgICAnXFx1MjREMCc6ICdhJyxcbiAgICAnXFx1RkY0MSc6ICdhJyxcbiAgICAnXFx1MUU5QSc6ICdhJyxcbiAgICAnXFx1MDBFMCc6ICdhJyxcbiAgICAnXFx1MDBFMSc6ICdhJyxcbiAgICAnXFx1MDBFMic6ICdhJyxcbiAgICAnXFx1MUVBNyc6ICdhJyxcbiAgICAnXFx1MUVBNSc6ICdhJyxcbiAgICAnXFx1MUVBQic6ICdhJyxcbiAgICAnXFx1MUVBOSc6ICdhJyxcbiAgICAnXFx1MDBFMyc6ICdhJyxcbiAgICAnXFx1MDEwMSc6ICdhJyxcbiAgICAnXFx1MDEwMyc6ICdhJyxcbiAgICAnXFx1MUVCMSc6ICdhJyxcbiAgICAnXFx1MUVBRic6ICdhJyxcbiAgICAnXFx1MUVCNSc6ICdhJyxcbiAgICAnXFx1MUVCMyc6ICdhJyxcbiAgICAnXFx1MDIyNyc6ICdhJyxcbiAgICAnXFx1MDFFMSc6ICdhJyxcbiAgICAnXFx1MDBFNCc6ICdhJyxcbiAgICAnXFx1MDFERic6ICdhJyxcbiAgICAnXFx1MUVBMyc6ICdhJyxcbiAgICAnXFx1MDBFNSc6ICdhJyxcbiAgICAnXFx1MDFGQic6ICdhJyxcbiAgICAnXFx1MDFDRSc6ICdhJyxcbiAgICAnXFx1MDIwMSc6ICdhJyxcbiAgICAnXFx1MDIwMyc6ICdhJyxcbiAgICAnXFx1MUVBMSc6ICdhJyxcbiAgICAnXFx1MUVBRCc6ICdhJyxcbiAgICAnXFx1MUVCNyc6ICdhJyxcbiAgICAnXFx1MUUwMSc6ICdhJyxcbiAgICAnXFx1MDEwNSc6ICdhJyxcbiAgICAnXFx1MkM2NSc6ICdhJyxcbiAgICAnXFx1MDI1MCc6ICdhJyxcbiAgICAnXFx1QTczMyc6ICdhYScsXG4gICAgJ1xcdTAwRTYnOiAnYWUnLFxuICAgICdcXHUwMUZEJzogJ2FlJyxcbiAgICAnXFx1MDFFMyc6ICdhZScsXG4gICAgJ1xcdUE3MzUnOiAnYW8nLFxuICAgICdcXHVBNzM3JzogJ2F1JyxcbiAgICAnXFx1QTczOSc6ICdhdicsXG4gICAgJ1xcdUE3M0InOiAnYXYnLFxuICAgICdcXHVBNzNEJzogJ2F5JyxcbiAgICAnXFx1MjREMSc6ICdiJyxcbiAgICAnXFx1RkY0Mic6ICdiJyxcbiAgICAnXFx1MUUwMyc6ICdiJyxcbiAgICAnXFx1MUUwNSc6ICdiJyxcbiAgICAnXFx1MUUwNyc6ICdiJyxcbiAgICAnXFx1MDE4MCc6ICdiJyxcbiAgICAnXFx1MDE4Myc6ICdiJyxcbiAgICAnXFx1MDI1Myc6ICdiJyxcbiAgICAnXFx1MjREMic6ICdjJyxcbiAgICAnXFx1RkY0Myc6ICdjJyxcbiAgICAnXFx1MDEwNyc6ICdjJyxcbiAgICAnXFx1MDEwOSc6ICdjJyxcbiAgICAnXFx1MDEwQic6ICdjJyxcbiAgICAnXFx1MDEwRCc6ICdjJyxcbiAgICAnXFx1MDBFNyc6ICdjJyxcbiAgICAnXFx1MUUwOSc6ICdjJyxcbiAgICAnXFx1MDE4OCc6ICdjJyxcbiAgICAnXFx1MDIzQyc6ICdjJyxcbiAgICAnXFx1QTczRic6ICdjJyxcbiAgICAnXFx1MjE4NCc6ICdjJyxcbiAgICAnXFx1MjREMyc6ICdkJyxcbiAgICAnXFx1RkY0NCc6ICdkJyxcbiAgICAnXFx1MUUwQic6ICdkJyxcbiAgICAnXFx1MDEwRic6ICdkJyxcbiAgICAnXFx1MUUwRCc6ICdkJyxcbiAgICAnXFx1MUUxMSc6ICdkJyxcbiAgICAnXFx1MUUxMyc6ICdkJyxcbiAgICAnXFx1MUUwRic6ICdkJyxcbiAgICAnXFx1MDExMSc6ICdkJyxcbiAgICAnXFx1MDE4Qyc6ICdkJyxcbiAgICAnXFx1MDI1Nic6ICdkJyxcbiAgICAnXFx1MDI1Nyc6ICdkJyxcbiAgICAnXFx1QTc3QSc6ICdkJyxcbiAgICAnXFx1MDFGMyc6ICdkeicsXG4gICAgJ1xcdTAxQzYnOiAnZHonLFxuICAgICdcXHUyNEQ0JzogJ2UnLFxuICAgICdcXHVGRjQ1JzogJ2UnLFxuICAgICdcXHUwMEU4JzogJ2UnLFxuICAgICdcXHUwMEU5JzogJ2UnLFxuICAgICdcXHUwMEVBJzogJ2UnLFxuICAgICdcXHUxRUMxJzogJ2UnLFxuICAgICdcXHUxRUJGJzogJ2UnLFxuICAgICdcXHUxRUM1JzogJ2UnLFxuICAgICdcXHUxRUMzJzogJ2UnLFxuICAgICdcXHUxRUJEJzogJ2UnLFxuICAgICdcXHUwMTEzJzogJ2UnLFxuICAgICdcXHUxRTE1JzogJ2UnLFxuICAgICdcXHUxRTE3JzogJ2UnLFxuICAgICdcXHUwMTE1JzogJ2UnLFxuICAgICdcXHUwMTE3JzogJ2UnLFxuICAgICdcXHUwMEVCJzogJ2UnLFxuICAgICdcXHUxRUJCJzogJ2UnLFxuICAgICdcXHUwMTFCJzogJ2UnLFxuICAgICdcXHUwMjA1JzogJ2UnLFxuICAgICdcXHUwMjA3JzogJ2UnLFxuICAgICdcXHUxRUI5JzogJ2UnLFxuICAgICdcXHUxRUM3JzogJ2UnLFxuICAgICdcXHUwMjI5JzogJ2UnLFxuICAgICdcXHUxRTFEJzogJ2UnLFxuICAgICdcXHUwMTE5JzogJ2UnLFxuICAgICdcXHUxRTE5JzogJ2UnLFxuICAgICdcXHUxRTFCJzogJ2UnLFxuICAgICdcXHUwMjQ3JzogJ2UnLFxuICAgICdcXHUwMjVCJzogJ2UnLFxuICAgICdcXHUwMUREJzogJ2UnLFxuICAgICdcXHUyNEQ1JzogJ2YnLFxuICAgICdcXHVGRjQ2JzogJ2YnLFxuICAgICdcXHUxRTFGJzogJ2YnLFxuICAgICdcXHUwMTkyJzogJ2YnLFxuICAgICdcXHVBNzdDJzogJ2YnLFxuICAgICdcXHUyNEQ2JzogJ2cnLFxuICAgICdcXHVGRjQ3JzogJ2cnLFxuICAgICdcXHUwMUY1JzogJ2cnLFxuICAgICdcXHUwMTFEJzogJ2cnLFxuICAgICdcXHUxRTIxJzogJ2cnLFxuICAgICdcXHUwMTFGJzogJ2cnLFxuICAgICdcXHUwMTIxJzogJ2cnLFxuICAgICdcXHUwMUU3JzogJ2cnLFxuICAgICdcXHUwMTIzJzogJ2cnLFxuICAgICdcXHUwMUU1JzogJ2cnLFxuICAgICdcXHUwMjYwJzogJ2cnLFxuICAgICdcXHVBN0ExJzogJ2cnLFxuICAgICdcXHUxRDc5JzogJ2cnLFxuICAgICdcXHVBNzdGJzogJ2cnLFxuICAgICdcXHUyNEQ3JzogJ2gnLFxuICAgICdcXHVGRjQ4JzogJ2gnLFxuICAgICdcXHUwMTI1JzogJ2gnLFxuICAgICdcXHUxRTIzJzogJ2gnLFxuICAgICdcXHUxRTI3JzogJ2gnLFxuICAgICdcXHUwMjFGJzogJ2gnLFxuICAgICdcXHUxRTI1JzogJ2gnLFxuICAgICdcXHUxRTI5JzogJ2gnLFxuICAgICdcXHUxRTJCJzogJ2gnLFxuICAgICdcXHUxRTk2JzogJ2gnLFxuICAgICdcXHUwMTI3JzogJ2gnLFxuICAgICdcXHUyQzY4JzogJ2gnLFxuICAgICdcXHUyQzc2JzogJ2gnLFxuICAgICdcXHUwMjY1JzogJ2gnLFxuICAgICdcXHUwMTk1JzogJ2h2JyxcbiAgICAnXFx1MjREOCc6ICdpJyxcbiAgICAnXFx1RkY0OSc6ICdpJyxcbiAgICAnXFx1MDBFQyc6ICdpJyxcbiAgICAnXFx1MDBFRCc6ICdpJyxcbiAgICAnXFx1MDBFRSc6ICdpJyxcbiAgICAnXFx1MDEyOSc6ICdpJyxcbiAgICAnXFx1MDEyQic6ICdpJyxcbiAgICAnXFx1MDEyRCc6ICdpJyxcbiAgICAnXFx1MDBFRic6ICdpJyxcbiAgICAnXFx1MUUyRic6ICdpJyxcbiAgICAnXFx1MUVDOSc6ICdpJyxcbiAgICAnXFx1MDFEMCc6ICdpJyxcbiAgICAnXFx1MDIwOSc6ICdpJyxcbiAgICAnXFx1MDIwQic6ICdpJyxcbiAgICAnXFx1MUVDQic6ICdpJyxcbiAgICAnXFx1MDEyRic6ICdpJyxcbiAgICAnXFx1MUUyRCc6ICdpJyxcbiAgICAnXFx1MDI2OCc6ICdpJyxcbiAgICAnXFx1MDEzMSc6ICdpJyxcbiAgICAnXFx1MjREOSc6ICdqJyxcbiAgICAnXFx1RkY0QSc6ICdqJyxcbiAgICAnXFx1MDEzNSc6ICdqJyxcbiAgICAnXFx1MDFGMCc6ICdqJyxcbiAgICAnXFx1MDI0OSc6ICdqJyxcbiAgICAnXFx1MjREQSc6ICdrJyxcbiAgICAnXFx1RkY0Qic6ICdrJyxcbiAgICAnXFx1MUUzMSc6ICdrJyxcbiAgICAnXFx1MDFFOSc6ICdrJyxcbiAgICAnXFx1MUUzMyc6ICdrJyxcbiAgICAnXFx1MDEzNyc6ICdrJyxcbiAgICAnXFx1MUUzNSc6ICdrJyxcbiAgICAnXFx1MDE5OSc6ICdrJyxcbiAgICAnXFx1MkM2QSc6ICdrJyxcbiAgICAnXFx1QTc0MSc6ICdrJyxcbiAgICAnXFx1QTc0Myc6ICdrJyxcbiAgICAnXFx1QTc0NSc6ICdrJyxcbiAgICAnXFx1QTdBMyc6ICdrJyxcbiAgICAnXFx1MjREQic6ICdsJyxcbiAgICAnXFx1RkY0Qyc6ICdsJyxcbiAgICAnXFx1MDE0MCc6ICdsJyxcbiAgICAnXFx1MDEzQSc6ICdsJyxcbiAgICAnXFx1MDEzRSc6ICdsJyxcbiAgICAnXFx1MUUzNyc6ICdsJyxcbiAgICAnXFx1MUUzOSc6ICdsJyxcbiAgICAnXFx1MDEzQyc6ICdsJyxcbiAgICAnXFx1MUUzRCc6ICdsJyxcbiAgICAnXFx1MUUzQic6ICdsJyxcbiAgICAnXFx1MDE3Ric6ICdsJyxcbiAgICAnXFx1MDE0Mic6ICdsJyxcbiAgICAnXFx1MDE5QSc6ICdsJyxcbiAgICAnXFx1MDI2Qic6ICdsJyxcbiAgICAnXFx1MkM2MSc6ICdsJyxcbiAgICAnXFx1QTc0OSc6ICdsJyxcbiAgICAnXFx1QTc4MSc6ICdsJyxcbiAgICAnXFx1QTc0Nyc6ICdsJyxcbiAgICAnXFx1MDFDOSc6ICdsaicsXG4gICAgJ1xcdTI0REMnOiAnbScsXG4gICAgJ1xcdUZGNEQnOiAnbScsXG4gICAgJ1xcdTFFM0YnOiAnbScsXG4gICAgJ1xcdTFFNDEnOiAnbScsXG4gICAgJ1xcdTFFNDMnOiAnbScsXG4gICAgJ1xcdTAyNzEnOiAnbScsXG4gICAgJ1xcdTAyNkYnOiAnbScsXG4gICAgJ1xcdTI0REQnOiAnbicsXG4gICAgJ1xcdUZGNEUnOiAnbicsXG4gICAgJ1xcdTAxRjknOiAnbicsXG4gICAgJ1xcdTAxNDQnOiAnbicsXG4gICAgJ1xcdTAwRjEnOiAnbicsXG4gICAgJ1xcdTFFNDUnOiAnbicsXG4gICAgJ1xcdTAxNDgnOiAnbicsXG4gICAgJ1xcdTFFNDcnOiAnbicsXG4gICAgJ1xcdTAxNDYnOiAnbicsXG4gICAgJ1xcdTFFNEInOiAnbicsXG4gICAgJ1xcdTFFNDknOiAnbicsXG4gICAgJ1xcdTAxOUUnOiAnbicsXG4gICAgJ1xcdTAyNzInOiAnbicsXG4gICAgJ1xcdTAxNDknOiAnbicsXG4gICAgJ1xcdUE3OTEnOiAnbicsXG4gICAgJ1xcdUE3QTUnOiAnbicsXG4gICAgJ1xcdTAxQ0MnOiAnbmonLFxuICAgICdcXHUyNERFJzogJ28nLFxuICAgICdcXHVGRjRGJzogJ28nLFxuICAgICdcXHUwMEYyJzogJ28nLFxuICAgICdcXHUwMEYzJzogJ28nLFxuICAgICdcXHUwMEY0JzogJ28nLFxuICAgICdcXHUxRUQzJzogJ28nLFxuICAgICdcXHUxRUQxJzogJ28nLFxuICAgICdcXHUxRUQ3JzogJ28nLFxuICAgICdcXHUxRUQ1JzogJ28nLFxuICAgICdcXHUwMEY1JzogJ28nLFxuICAgICdcXHUxRTREJzogJ28nLFxuICAgICdcXHUwMjJEJzogJ28nLFxuICAgICdcXHUxRTRGJzogJ28nLFxuICAgICdcXHUwMTREJzogJ28nLFxuICAgICdcXHUxRTUxJzogJ28nLFxuICAgICdcXHUxRTUzJzogJ28nLFxuICAgICdcXHUwMTRGJzogJ28nLFxuICAgICdcXHUwMjJGJzogJ28nLFxuICAgICdcXHUwMjMxJzogJ28nLFxuICAgICdcXHUwMEY2JzogJ28nLFxuICAgICdcXHUwMjJCJzogJ28nLFxuICAgICdcXHUxRUNGJzogJ28nLFxuICAgICdcXHUwMTUxJzogJ28nLFxuICAgICdcXHUwMUQyJzogJ28nLFxuICAgICdcXHUwMjBEJzogJ28nLFxuICAgICdcXHUwMjBGJzogJ28nLFxuICAgICdcXHUwMUExJzogJ28nLFxuICAgICdcXHUxRUREJzogJ28nLFxuICAgICdcXHUxRURCJzogJ28nLFxuICAgICdcXHUxRUUxJzogJ28nLFxuICAgICdcXHUxRURGJzogJ28nLFxuICAgICdcXHUxRUUzJzogJ28nLFxuICAgICdcXHUxRUNEJzogJ28nLFxuICAgICdcXHUxRUQ5JzogJ28nLFxuICAgICdcXHUwMUVCJzogJ28nLFxuICAgICdcXHUwMUVEJzogJ28nLFxuICAgICdcXHUwMEY4JzogJ28nLFxuICAgICdcXHUwMUZGJzogJ28nLFxuICAgICdcXHUwMjU0JzogJ28nLFxuICAgICdcXHVBNzRCJzogJ28nLFxuICAgICdcXHVBNzREJzogJ28nLFxuICAgICdcXHUwMjc1JzogJ28nLFxuICAgICdcXHUwMTUzJzogJ29lJyxcbiAgICAnXFx1MDFBMyc6ICdvaScsXG4gICAgJ1xcdTAyMjMnOiAnb3UnLFxuICAgICdcXHVBNzRGJzogJ29vJyxcbiAgICAnXFx1MjRERic6ICdwJyxcbiAgICAnXFx1RkY1MCc6ICdwJyxcbiAgICAnXFx1MUU1NSc6ICdwJyxcbiAgICAnXFx1MUU1Nyc6ICdwJyxcbiAgICAnXFx1MDFBNSc6ICdwJyxcbiAgICAnXFx1MUQ3RCc6ICdwJyxcbiAgICAnXFx1QTc1MSc6ICdwJyxcbiAgICAnXFx1QTc1Myc6ICdwJyxcbiAgICAnXFx1QTc1NSc6ICdwJyxcbiAgICAnXFx1MjRFMCc6ICdxJyxcbiAgICAnXFx1RkY1MSc6ICdxJyxcbiAgICAnXFx1MDI0Qic6ICdxJyxcbiAgICAnXFx1QTc1Nyc6ICdxJyxcbiAgICAnXFx1QTc1OSc6ICdxJyxcbiAgICAnXFx1MjRFMSc6ICdyJyxcbiAgICAnXFx1RkY1Mic6ICdyJyxcbiAgICAnXFx1MDE1NSc6ICdyJyxcbiAgICAnXFx1MUU1OSc6ICdyJyxcbiAgICAnXFx1MDE1OSc6ICdyJyxcbiAgICAnXFx1MDIxMSc6ICdyJyxcbiAgICAnXFx1MDIxMyc6ICdyJyxcbiAgICAnXFx1MUU1Qic6ICdyJyxcbiAgICAnXFx1MUU1RCc6ICdyJyxcbiAgICAnXFx1MDE1Nyc6ICdyJyxcbiAgICAnXFx1MUU1Ric6ICdyJyxcbiAgICAnXFx1MDI0RCc6ICdyJyxcbiAgICAnXFx1MDI3RCc6ICdyJyxcbiAgICAnXFx1QTc1Qic6ICdyJyxcbiAgICAnXFx1QTdBNyc6ICdyJyxcbiAgICAnXFx1QTc4Myc6ICdyJyxcbiAgICAnXFx1MjRFMic6ICdzJyxcbiAgICAnXFx1RkY1Myc6ICdzJyxcbiAgICAnXFx1MDBERic6ICdzJyxcbiAgICAnXFx1MDE1Qic6ICdzJyxcbiAgICAnXFx1MUU2NSc6ICdzJyxcbiAgICAnXFx1MDE1RCc6ICdzJyxcbiAgICAnXFx1MUU2MSc6ICdzJyxcbiAgICAnXFx1MDE2MSc6ICdzJyxcbiAgICAnXFx1MUU2Nyc6ICdzJyxcbiAgICAnXFx1MUU2Myc6ICdzJyxcbiAgICAnXFx1MUU2OSc6ICdzJyxcbiAgICAnXFx1MDIxOSc6ICdzJyxcbiAgICAnXFx1MDE1Ric6ICdzJyxcbiAgICAnXFx1MDIzRic6ICdzJyxcbiAgICAnXFx1QTdBOSc6ICdzJyxcbiAgICAnXFx1QTc4NSc6ICdzJyxcbiAgICAnXFx1MUU5Qic6ICdzJyxcbiAgICAnXFx1MjRFMyc6ICd0JyxcbiAgICAnXFx1RkY1NCc6ICd0JyxcbiAgICAnXFx1MUU2Qic6ICd0JyxcbiAgICAnXFx1MUU5Nyc6ICd0JyxcbiAgICAnXFx1MDE2NSc6ICd0JyxcbiAgICAnXFx1MUU2RCc6ICd0JyxcbiAgICAnXFx1MDIxQic6ICd0JyxcbiAgICAnXFx1MDE2Myc6ICd0JyxcbiAgICAnXFx1MUU3MSc6ICd0JyxcbiAgICAnXFx1MUU2Ric6ICd0JyxcbiAgICAnXFx1MDE2Nyc6ICd0JyxcbiAgICAnXFx1MDFBRCc6ICd0JyxcbiAgICAnXFx1MDI4OCc6ICd0JyxcbiAgICAnXFx1MkM2Nic6ICd0JyxcbiAgICAnXFx1QTc4Nyc6ICd0JyxcbiAgICAnXFx1QTcyOSc6ICd0eicsXG4gICAgJ1xcdTI0RTQnOiAndScsXG4gICAgJ1xcdUZGNTUnOiAndScsXG4gICAgJ1xcdTAwRjknOiAndScsXG4gICAgJ1xcdTAwRkEnOiAndScsXG4gICAgJ1xcdTAwRkInOiAndScsXG4gICAgJ1xcdTAxNjknOiAndScsXG4gICAgJ1xcdTFFNzknOiAndScsXG4gICAgJ1xcdTAxNkInOiAndScsXG4gICAgJ1xcdTFFN0InOiAndScsXG4gICAgJ1xcdTAxNkQnOiAndScsXG4gICAgJ1xcdTAwRkMnOiAndScsXG4gICAgJ1xcdTAxREMnOiAndScsXG4gICAgJ1xcdTAxRDgnOiAndScsXG4gICAgJ1xcdTAxRDYnOiAndScsXG4gICAgJ1xcdTAxREEnOiAndScsXG4gICAgJ1xcdTFFRTcnOiAndScsXG4gICAgJ1xcdTAxNkYnOiAndScsXG4gICAgJ1xcdTAxNzEnOiAndScsXG4gICAgJ1xcdTAxRDQnOiAndScsXG4gICAgJ1xcdTAyMTUnOiAndScsXG4gICAgJ1xcdTAyMTcnOiAndScsXG4gICAgJ1xcdTAxQjAnOiAndScsXG4gICAgJ1xcdTFFRUInOiAndScsXG4gICAgJ1xcdTFFRTknOiAndScsXG4gICAgJ1xcdTFFRUYnOiAndScsXG4gICAgJ1xcdTFFRUQnOiAndScsXG4gICAgJ1xcdTFFRjEnOiAndScsXG4gICAgJ1xcdTFFRTUnOiAndScsXG4gICAgJ1xcdTFFNzMnOiAndScsXG4gICAgJ1xcdTAxNzMnOiAndScsXG4gICAgJ1xcdTFFNzcnOiAndScsXG4gICAgJ1xcdTFFNzUnOiAndScsXG4gICAgJ1xcdTAyODknOiAndScsXG4gICAgJ1xcdTI0RTUnOiAndicsXG4gICAgJ1xcdUZGNTYnOiAndicsXG4gICAgJ1xcdTFFN0QnOiAndicsXG4gICAgJ1xcdTFFN0YnOiAndicsXG4gICAgJ1xcdTAyOEInOiAndicsXG4gICAgJ1xcdUE3NUYnOiAndicsXG4gICAgJ1xcdTAyOEMnOiAndicsXG4gICAgJ1xcdUE3NjEnOiAndnknLFxuICAgICdcXHUyNEU2JzogJ3cnLFxuICAgICdcXHVGRjU3JzogJ3cnLFxuICAgICdcXHUxRTgxJzogJ3cnLFxuICAgICdcXHUxRTgzJzogJ3cnLFxuICAgICdcXHUwMTc1JzogJ3cnLFxuICAgICdcXHUxRTg3JzogJ3cnLFxuICAgICdcXHUxRTg1JzogJ3cnLFxuICAgICdcXHUxRTk4JzogJ3cnLFxuICAgICdcXHUxRTg5JzogJ3cnLFxuICAgICdcXHUyQzczJzogJ3cnLFxuICAgICdcXHUyNEU3JzogJ3gnLFxuICAgICdcXHVGRjU4JzogJ3gnLFxuICAgICdcXHUxRThCJzogJ3gnLFxuICAgICdcXHUxRThEJzogJ3gnLFxuICAgICdcXHUyNEU4JzogJ3knLFxuICAgICdcXHVGRjU5JzogJ3knLFxuICAgICdcXHUxRUYzJzogJ3knLFxuICAgICdcXHUwMEZEJzogJ3knLFxuICAgICdcXHUwMTc3JzogJ3knLFxuICAgICdcXHUxRUY5JzogJ3knLFxuICAgICdcXHUwMjMzJzogJ3knLFxuICAgICdcXHUxRThGJzogJ3knLFxuICAgICdcXHUwMEZGJzogJ3knLFxuICAgICdcXHUxRUY3JzogJ3knLFxuICAgICdcXHUxRTk5JzogJ3knLFxuICAgICdcXHUxRUY1JzogJ3knLFxuICAgICdcXHUwMUI0JzogJ3knLFxuICAgICdcXHUwMjRGJzogJ3knLFxuICAgICdcXHUxRUZGJzogJ3knLFxuICAgICdcXHUyNEU5JzogJ3onLFxuICAgICdcXHVGRjVBJzogJ3onLFxuICAgICdcXHUwMTdBJzogJ3onLFxuICAgICdcXHUxRTkxJzogJ3onLFxuICAgICdcXHUwMTdDJzogJ3onLFxuICAgICdcXHUwMTdFJzogJ3onLFxuICAgICdcXHUxRTkzJzogJ3onLFxuICAgICdcXHUxRTk1JzogJ3onLFxuICAgICdcXHUwMUI2JzogJ3onLFxuICAgICdcXHUwMjI1JzogJ3onLFxuICAgICdcXHUwMjQwJzogJ3onLFxuICAgICdcXHUyQzZDJzogJ3onLFxuICAgICdcXHVBNzYzJzogJ3onLFxuICAgICdcXHUwMzg2JzogJ1xcdTAzOTEnLFxuICAgICdcXHUwMzg4JzogJ1xcdTAzOTUnLFxuICAgICdcXHUwMzg5JzogJ1xcdTAzOTcnLFxuICAgICdcXHUwMzhBJzogJ1xcdTAzOTknLFxuICAgICdcXHUwM0FBJzogJ1xcdTAzOTknLFxuICAgICdcXHUwMzhDJzogJ1xcdTAzOUYnLFxuICAgICdcXHUwMzhFJzogJ1xcdTAzQTUnLFxuICAgICdcXHUwM0FCJzogJ1xcdTAzQTUnLFxuICAgICdcXHUwMzhGJzogJ1xcdTAzQTknLFxuICAgICdcXHUwM0FDJzogJ1xcdTAzQjEnLFxuICAgICdcXHUwM0FEJzogJ1xcdTAzQjUnLFxuICAgICdcXHUwM0FFJzogJ1xcdTAzQjcnLFxuICAgICdcXHUwM0FGJzogJ1xcdTAzQjknLFxuICAgICdcXHUwM0NBJzogJ1xcdTAzQjknLFxuICAgICdcXHUwMzkwJzogJ1xcdTAzQjknLFxuICAgICdcXHUwM0NDJzogJ1xcdTAzQkYnLFxuICAgICdcXHUwM0NEJzogJ1xcdTAzQzUnLFxuICAgICdcXHUwM0NCJzogJ1xcdTAzQzUnLFxuICAgICdcXHUwM0IwJzogJ1xcdTAzQzUnLFxuICAgICdcXHUwM0NFJzogJ1xcdTAzQzknLFxuICAgICdcXHUwM0MyJzogJ1xcdTAzQzMnLFxuICAgICdcXHUyMDE5JzogJ1xcJydcbiAgfTtcblxuICByZXR1cm4gZGlhY3JpdGljcztcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZGF0YS9iYXNlJyxbXG4gICcuLi91dGlscydcbl0sIGZ1bmN0aW9uIChVdGlscykge1xuICBmdW5jdGlvbiBCYXNlQWRhcHRlciAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBCYXNlQWRhcHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIFV0aWxzLkV4dGVuZChCYXNlQWRhcHRlciwgVXRpbHMuT2JzZXJ2YWJsZSk7XG5cbiAgQmFzZUFkYXB0ZXIucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgY3VycmVudGAgbWV0aG9kIG11c3QgYmUgZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzLicpO1xuICB9O1xuXG4gIEJhc2VBZGFwdGVyLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHF1ZXJ5YCBtZXRob2QgbXVzdCBiZSBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXMuJyk7XG4gIH07XG5cbiAgQmFzZUFkYXB0ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCAkY29udGFpbmVyKSB7XG4gICAgLy8gQ2FuIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcbiAgfTtcblxuICBCYXNlQWRhcHRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDYW4gYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xuICB9O1xuXG4gIEJhc2VBZGFwdGVyLnByb3RvdHlwZS5nZW5lcmF0ZVJlc3VsdElkID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgZGF0YSkge1xuICAgIHZhciBpZCA9IGNvbnRhaW5lci5pZCArICctcmVzdWx0LSc7XG5cbiAgICBpZCArPSBVdGlscy5nZW5lcmF0ZUNoYXJzKDQpO1xuXG4gICAgaWYgKGRhdGEuaWQgIT0gbnVsbCkge1xuICAgICAgaWQgKz0gJy0nICsgZGF0YS5pZC50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCArPSAnLScgKyBVdGlscy5nZW5lcmF0ZUNoYXJzKDQpO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2VBZGFwdGVyO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kYXRhL3NlbGVjdCcsW1xuICAnLi9iYXNlJyxcbiAgJy4uL3V0aWxzJyxcbiAgJ2pxdWVyeSdcbl0sIGZ1bmN0aW9uIChCYXNlQWRhcHRlciwgVXRpbHMsICQpIHtcbiAgZnVuY3Rpb24gU2VsZWN0QWRhcHRlciAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIFNlbGVjdEFkYXB0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gIH1cblxuICBVdGlscy5FeHRlbmQoU2VsZWN0QWRhcHRlciwgQmFzZUFkYXB0ZXIpO1xuXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChcbiAgICAgIHRoaXMuJGVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKSxcbiAgICAgIGZ1bmN0aW9uIChzZWxlY3RlZEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbSgkKHNlbGVjdGVkRWxlbWVudCkpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBjYWxsYmFjayhkYXRhKTtcbiAgfTtcblxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGRhdGEuc2VsZWN0ZWQgPSB0cnVlO1xuXG4gICAgLy8gSWYgZGF0YS5lbGVtZW50IGlzIGEgRE9NIG5vZGUsIHVzZSBpdCBpbnN0ZWFkXG4gICAgaWYgKFxuICAgICAgZGF0YS5lbGVtZW50ICE9IG51bGwgJiYgZGF0YS5lbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29wdGlvbidcbiAgICApIHtcbiAgICAgIGRhdGEuZWxlbWVudC5zZWxlY3RlZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaW5wdXQnKS50cmlnZ2VyKCdjaGFuZ2UnKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLiRlbGVtZW50LnByb3AoJ211bHRpcGxlJykpIHtcbiAgICAgIHRoaXMuY3VycmVudChmdW5jdGlvbiAoY3VycmVudERhdGEpIHtcbiAgICAgICAgdmFyIHZhbCA9IFtdO1xuXG4gICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgIGRhdGEucHVzaC5hcHBseShkYXRhLCBjdXJyZW50RGF0YSk7XG5cbiAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkYXRhLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgICAgdmFyIGlkID0gZGF0YVtkXS5pZDtcblxuICAgICAgICAgIGlmICh2YWwuaW5kZXhPZihpZCkgPT09IC0xKSB7XG4gICAgICAgICAgICB2YWwucHVzaChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWxlbWVudC52YWwodmFsKTtcbiAgICAgICAgc2VsZi4kZWxlbWVudC50cmlnZ2VyKCdpbnB1dCcpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWwgPSBkYXRhLmlkO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnZhbCh2YWwpO1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdpbnB1dCcpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLiRlbGVtZW50LnByb3AoJ211bHRpcGxlJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhLnNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICBpZiAoXG4gICAgICBkYXRhLmVsZW1lbnQgIT0gbnVsbCAmJlxuICAgICAgZGF0YS5lbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29wdGlvbidcbiAgICApIHtcbiAgICAgIGRhdGEuZWxlbWVudC5zZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2lucHV0JykudHJpZ2dlcignY2hhbmdlJyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnQoZnVuY3Rpb24gKGN1cnJlbnREYXRhKSB7XG4gICAgICB2YXIgdmFsID0gW107XG5cbiAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgY3VycmVudERhdGEubGVuZ3RoOyBkKyspIHtcbiAgICAgICAgdmFyIGlkID0gY3VycmVudERhdGFbZF0uaWQ7XG5cbiAgICAgICAgaWYgKGlkICE9PSBkYXRhLmlkICYmIHZhbC5pbmRleE9mKGlkKSA9PT0gLTEpIHtcbiAgICAgICAgICB2YWwucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWxlbWVudC52YWwodmFsKTtcblxuICAgICAgc2VsZi4kZWxlbWVudC50cmlnZ2VyKCdpbnB1dCcpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0pO1xuICB9O1xuXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCAkY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICBjb250YWluZXIub24oJ3NlbGVjdCcsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIHNlbGYuc2VsZWN0KHBhcmFtcy5kYXRhKTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbigndW5zZWxlY3QnLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBzZWxmLnVuc2VsZWN0KHBhcmFtcy5kYXRhKTtcbiAgICB9KTtcbiAgfTtcblxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFJlbW92ZSBhbnl0aGluZyBhZGRlZCB0byBjaGlsZCBlbGVtZW50c1xuICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnKicpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgLy8gUmVtb3ZlIGFueSBjdXN0b20gZGF0YSBzZXQgYnkgU2VsZWN0MlxuICAgICAgVXRpbHMuUmVtb3ZlRGF0YSh0aGlzKTtcbiAgICB9KTtcbiAgfTtcblxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSBbXTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgJG9wdGlvbnMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCk7XG5cbiAgICAkb3B0aW9ucy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvcHRpb24nICYmXG4gICAgICAgIHRoaXMudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnb3B0Z3JvdXAnXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgJG9wdGlvbiA9ICQodGhpcyk7XG5cbiAgICAgIHZhciBvcHRpb24gPSBzZWxmLml0ZW0oJG9wdGlvbik7XG5cbiAgICAgIHZhciBtYXRjaGVzID0gc2VsZi5tYXRjaGVzKHBhcmFtcywgb3B0aW9uKTtcblxuICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgICAgZGF0YS5wdXNoKG1hdGNoZXMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY2FsbGJhY2soe1xuICAgICAgcmVzdWx0czogZGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLmFkZE9wdGlvbnMgPSBmdW5jdGlvbiAoJG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50LmFwcGVuZCgkb3B0aW9ucyk7XG4gIH07XG5cbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUub3B0aW9uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgb3B0aW9uO1xuXG4gICAgaWYgKGRhdGEuY2hpbGRyZW4pIHtcbiAgICAgIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGdyb3VwJyk7XG4gICAgICBvcHRpb24ubGFiZWwgPSBkYXRhLnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuXG4gICAgICBpZiAob3B0aW9uLnRleHRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9uLnRleHRDb250ZW50ID0gZGF0YS50ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9uLmlubmVyVGV4dCA9IGRhdGEudGV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGF0YS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb24udmFsdWUgPSBkYXRhLmlkO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmRpc2FibGVkKSB7XG4gICAgICBvcHRpb24uZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnNlbGVjdGVkKSB7XG4gICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnRpdGxlKSB7XG4gICAgICBvcHRpb24udGl0bGUgPSBkYXRhLnRpdGxlO1xuICAgIH1cblxuICAgIHZhciBub3JtYWxpemVkRGF0YSA9IHRoaXMuX25vcm1hbGl6ZUl0ZW0oZGF0YSk7XG4gICAgbm9ybWFsaXplZERhdGEuZWxlbWVudCA9IG9wdGlvbjtcblxuICAgIC8vIE92ZXJyaWRlIHRoZSBvcHRpb24ncyBkYXRhIHdpdGggdGhlIGNvbWJpbmVkIGRhdGFcbiAgICBVdGlscy5TdG9yZURhdGEob3B0aW9uLCAnZGF0YScsIG5vcm1hbGl6ZWREYXRhKTtcblxuICAgIHJldHVybiAkKG9wdGlvbik7XG4gIH07XG5cbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUuaXRlbSA9IGZ1bmN0aW9uICgkb3B0aW9uKSB7XG4gICAgdmFyIGRhdGEgPSB7fTtcblxuICAgIGRhdGEgPSBVdGlscy5HZXREYXRhKCRvcHRpb25bMF0sICdkYXRhJyk7XG5cbiAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9uID0gJG9wdGlvblswXTtcblxuICAgIGlmIChvcHRpb24udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb3B0aW9uJykge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgaWQ6ICRvcHRpb24udmFsKCksXG4gICAgICAgIHRleHQ6ICRvcHRpb24udGV4dCgpLFxuICAgICAgICBkaXNhYmxlZDogJG9wdGlvbi5wcm9wKCdkaXNhYmxlZCcpLFxuICAgICAgICBzZWxlY3RlZDogJG9wdGlvbi5wcm9wKCdzZWxlY3RlZCcpLFxuICAgICAgICB0aXRsZTogJG9wdGlvbi5wcm9wKCd0aXRsZScpXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0aW9uLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29wdGdyb3VwJykge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgdGV4dDogJG9wdGlvbi5wcm9wKCdsYWJlbCcpLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIHRpdGxlOiAkb3B0aW9uLnByb3AoJ3RpdGxlJylcbiAgICAgIH07XG5cbiAgICAgIHZhciAkY2hpbGRyZW4gPSAkb3B0aW9uLmNoaWxkcmVuKCdvcHRpb24nKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8ICRjaGlsZHJlbi5sZW5ndGg7IGMrKykge1xuICAgICAgICB2YXIgJGNoaWxkID0gJCgkY2hpbGRyZW5bY10pO1xuXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuaXRlbSgkY2hpbGQpO1xuXG4gICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBkYXRhLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgfVxuXG4gICAgZGF0YSA9IHRoaXMuX25vcm1hbGl6ZUl0ZW0oZGF0YSk7XG4gICAgZGF0YS5lbGVtZW50ID0gJG9wdGlvblswXTtcblxuICAgIFV0aWxzLlN0b3JlRGF0YSgkb3B0aW9uWzBdLCAnZGF0YScsIGRhdGEpO1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUuX25vcm1hbGl6ZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtICE9PSBPYmplY3QoaXRlbSkpIHtcbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgIGlkOiBpdGVtLFxuICAgICAgICB0ZXh0OiBpdGVtXG4gICAgICB9O1xuICAgIH1cblxuICAgIGl0ZW0gPSAkLmV4dGVuZCh7fSwge1xuICAgICAgdGV4dDogJydcbiAgICB9LCBpdGVtKTtcblxuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIHNlbGVjdGVkOiBmYWxzZSxcbiAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAoaXRlbS5pZCAhPSBudWxsKSB7XG4gICAgICBpdGVtLmlkID0gaXRlbS5pZC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChpdGVtLnRleHQgIT0gbnVsbCkge1xuICAgICAgaXRlbS50ZXh0ID0gaXRlbS50ZXh0LnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0uX3Jlc3VsdElkID09IG51bGwgJiYgaXRlbS5pZCAmJiB0aGlzLmNvbnRhaW5lciAhPSBudWxsKSB7XG4gICAgICBpdGVtLl9yZXN1bHRJZCA9IHRoaXMuZ2VuZXJhdGVSZXN1bHRJZCh0aGlzLmNvbnRhaW5lciwgaXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgaXRlbSk7XG4gIH07XG5cbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChwYXJhbXMsIGRhdGEpIHtcbiAgICB2YXIgbWF0Y2hlciA9IHRoaXMub3B0aW9ucy5nZXQoJ21hdGNoZXInKTtcblxuICAgIHJldHVybiBtYXRjaGVyKHBhcmFtcywgZGF0YSk7XG4gIH07XG5cbiAgcmV0dXJuIFNlbGVjdEFkYXB0ZXI7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvYXJyYXknLFtcbiAgJy4vc2VsZWN0JyxcbiAgJy4uL3V0aWxzJyxcbiAgJ2pxdWVyeSdcbl0sIGZ1bmN0aW9uIChTZWxlY3RBZGFwdGVyLCBVdGlscywgJCkge1xuICBmdW5jdGlvbiBBcnJheUFkYXB0ZXIgKCRlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5fZGF0YVRvQ29udmVydCA9IG9wdGlvbnMuZ2V0KCdkYXRhJykgfHwgW107XG5cbiAgICBBcnJheUFkYXB0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgVXRpbHMuRXh0ZW5kKEFycmF5QWRhcHRlciwgU2VsZWN0QWRhcHRlcik7XG5cbiAgQXJyYXlBZGFwdGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xuICAgIEFycmF5QWRhcHRlci5fX3N1cGVyX18uYmluZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XG5cbiAgICB0aGlzLmFkZE9wdGlvbnModGhpcy5jb252ZXJ0VG9PcHRpb25zKHRoaXMuX2RhdGFUb0NvbnZlcnQpKTtcbiAgfTtcblxuICBBcnJheUFkYXB0ZXIucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyICRvcHRpb24gPSB0aGlzLiRlbGVtZW50LmZpbmQoJ29wdGlvbicpLmZpbHRlcihmdW5jdGlvbiAoaSwgZWxtKSB7XG4gICAgICByZXR1cm4gZWxtLnZhbHVlID09IGRhdGEuaWQudG9TdHJpbmcoKTtcbiAgICB9KTtcblxuICAgIGlmICgkb3B0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgJG9wdGlvbiA9IHRoaXMub3B0aW9uKGRhdGEpO1xuXG4gICAgICB0aGlzLmFkZE9wdGlvbnMoJG9wdGlvbik7XG4gICAgfVxuXG4gICAgQXJyYXlBZGFwdGVyLl9fc3VwZXJfXy5zZWxlY3QuY2FsbCh0aGlzLCBkYXRhKTtcbiAgfTtcblxuICBBcnJheUFkYXB0ZXIucHJvdG90eXBlLmNvbnZlcnRUb09wdGlvbnMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciAkZXhpc3RpbmcgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ29wdGlvbicpO1xuICAgIHZhciBleGlzdGluZ0lkcyA9ICRleGlzdGluZy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNlbGYuaXRlbSgkKHRoaXMpKS5pZDtcbiAgICB9KS5nZXQoKTtcblxuICAgIHZhciAkb3B0aW9ucyA9IFtdO1xuXG4gICAgLy8gRmlsdGVyIG91dCBhbGwgaXRlbXMgZXhjZXB0IGZvciB0aGUgb25lIHBhc3NlZCBpbiB0aGUgYXJndW1lbnRcbiAgICBmdW5jdGlvbiBvbmx5SXRlbSAoaXRlbSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykudmFsKCkgPT0gaXRlbS5pZDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkYXRhLmxlbmd0aDsgZCsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuX25vcm1hbGl6ZUl0ZW0oZGF0YVtkXSk7XG5cbiAgICAgIC8vIFNraXAgaXRlbXMgd2hpY2ggd2VyZSBwcmUtbG9hZGVkLCBvbmx5IG1lcmdlIHRoZSBkYXRhXG4gICAgICBpZiAoZXhpc3RpbmdJZHMuaW5kZXhPZihpdGVtLmlkKSA+PSAwKSB7XG4gICAgICAgIHZhciAkZXhpc3RpbmdPcHRpb24gPSAkZXhpc3RpbmcuZmlsdGVyKG9ubHlJdGVtKGl0ZW0pKTtcblxuICAgICAgICB2YXIgZXhpc3RpbmdEYXRhID0gdGhpcy5pdGVtKCRleGlzdGluZ09wdGlvbik7XG4gICAgICAgIHZhciBuZXdEYXRhID0gJC5leHRlbmQodHJ1ZSwge30sIGl0ZW0sIGV4aXN0aW5nRGF0YSk7XG5cbiAgICAgICAgdmFyICRuZXdPcHRpb24gPSB0aGlzLm9wdGlvbihuZXdEYXRhKTtcblxuICAgICAgICAkZXhpc3RpbmdPcHRpb24ucmVwbGFjZVdpdGgoJG5ld09wdGlvbik7XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciAkb3B0aW9uID0gdGhpcy5vcHRpb24oaXRlbSk7XG5cbiAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgIHZhciAkY2hpbGRyZW4gPSB0aGlzLmNvbnZlcnRUb09wdGlvbnMoaXRlbS5jaGlsZHJlbik7XG5cbiAgICAgICAgJG9wdGlvbi5hcHBlbmQoJGNoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgJG9wdGlvbnMucHVzaCgkb3B0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJG9wdGlvbnM7XG4gIH07XG5cbiAgcmV0dXJuIEFycmF5QWRhcHRlcjtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZGF0YS9hamF4JyxbXG4gICcuL2FycmF5JyxcbiAgJy4uL3V0aWxzJyxcbiAgJ2pxdWVyeSdcbl0sIGZ1bmN0aW9uIChBcnJheUFkYXB0ZXIsIFV0aWxzLCAkKSB7XG4gIGZ1bmN0aW9uIEFqYXhBZGFwdGVyICgkZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuYWpheE9wdGlvbnMgPSB0aGlzLl9hcHBseURlZmF1bHRzKG9wdGlvbnMuZ2V0KCdhamF4JykpO1xuXG4gICAgaWYgKHRoaXMuYWpheE9wdGlvbnMucHJvY2Vzc1Jlc3VsdHMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5wcm9jZXNzUmVzdWx0cyA9IHRoaXMuYWpheE9wdGlvbnMucHJvY2Vzc1Jlc3VsdHM7XG4gICAgfVxuXG4gICAgQWpheEFkYXB0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgVXRpbHMuRXh0ZW5kKEFqYXhBZGFwdGVyLCBBcnJheUFkYXB0ZXIpO1xuXG4gIEFqYXhBZGFwdGVyLnByb3RvdHlwZS5fYXBwbHlEZWZhdWx0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgZGF0YTogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gJC5leHRlbmQoe30sIHBhcmFtcywge1xuICAgICAgICAgIHE6IHBhcmFtcy50ZXJtXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zcG9ydDogZnVuY3Rpb24gKHBhcmFtcywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgICAgICB2YXIgJHJlcXVlc3QgPSAkLmFqYXgocGFyYW1zKTtcblxuICAgICAgICAkcmVxdWVzdC50aGVuKHN1Y2Nlc3MpO1xuICAgICAgICAkcmVxdWVzdC5mYWlsKGZhaWx1cmUpO1xuXG4gICAgICAgIHJldHVybiAkcmVxdWVzdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucywgdHJ1ZSk7XG4gIH07XG5cbiAgQWpheEFkYXB0ZXIucHJvdG90eXBlLnByb2Nlc3NSZXN1bHRzID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICBBamF4QWRhcHRlci5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX3JlcXVlc3QgIT0gbnVsbCkge1xuICAgICAgLy8gSlNPTlAgcmVxdWVzdHMgY2Fubm90IGFsd2F5cyBiZSBhYm9ydGVkXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX3JlcXVlc3QuYWJvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgIHR5cGU6ICdHRVQnXG4gICAgfSwgdGhpcy5hamF4T3B0aW9ucyk7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudXJsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsLmNhbGwodGhpcy4kZWxlbWVudCwgcGFyYW1zKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0aW9ucy5kYXRhID0gb3B0aW9ucy5kYXRhLmNhbGwodGhpcy4kZWxlbWVudCwgcGFyYW1zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXF1ZXN0ICgpIHtcbiAgICAgIHZhciAkcmVxdWVzdCA9IG9wdGlvbnMudHJhbnNwb3J0KG9wdGlvbnMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gc2VsZi5wcm9jZXNzUmVzdWx0cyhkYXRhLCBwYXJhbXMpO1xuXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZ2V0KCdkZWJ1ZycpICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAvLyBDaGVjayB0byBtYWtlIHN1cmUgdGhhdCB0aGUgcmVzcG9uc2UgaW5jbHVkZWQgYSBgcmVzdWx0c2Aga2V5LlxuICAgICAgICAgIGlmICghcmVzdWx0cyB8fCAhcmVzdWx0cy5yZXN1bHRzIHx8ICFBcnJheS5pc0FycmF5KHJlc3VsdHMucmVzdWx0cykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdTZWxlY3QyOiBUaGUgQUpBWCByZXN1bHRzIGRpZCBub3QgcmV0dXJuIGFuIGFycmF5IGluIHRoZSAnICtcbiAgICAgICAgICAgICAgJ2ByZXN1bHRzYCBrZXkgb2YgdGhlIHJlc3BvbnNlLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2socmVzdWx0cyk7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gZGV0ZWN0IGlmIGEgcmVxdWVzdCB3YXMgYWJvcnRlZFxuICAgICAgICAvLyBPbmx5IHdvcmtzIGlmIHRoZSB0cmFuc3BvcnQgZXhwb3NlcyBhIHN0YXR1cyBwcm9wZXJ0eVxuICAgICAgICBpZiAoJ3N0YXR1cycgaW4gJHJlcXVlc3QgJiZcbiAgICAgICAgICAgICgkcmVxdWVzdC5zdGF0dXMgPT09IDAgfHwgJHJlcXVlc3Quc3RhdHVzID09PSAnMCcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi50cmlnZ2VyKCdyZXN1bHRzOm1lc3NhZ2UnLCB7XG4gICAgICAgICAgbWVzc2FnZTogJ2Vycm9yTG9hZGluZydcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgc2VsZi5fcmVxdWVzdCA9ICRyZXF1ZXN0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFqYXhPcHRpb25zLmRlbGF5ICYmIHBhcmFtcy50ZXJtICE9IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLl9xdWVyeVRpbWVvdXQpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9xdWVyeVRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9xdWVyeVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChyZXF1ZXN0LCB0aGlzLmFqYXhPcHRpb25zLmRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdCgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQWpheEFkYXB0ZXI7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvdGFncycsW1xuICAnanF1ZXJ5J1xuXSwgZnVuY3Rpb24gKCQpIHtcbiAgZnVuY3Rpb24gVGFncyAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciB0YWdzID0gb3B0aW9ucy5nZXQoJ3RhZ3MnKTtcblxuICAgIHZhciBjcmVhdGVUYWcgPSBvcHRpb25zLmdldCgnY3JlYXRlVGFnJyk7XG5cbiAgICBpZiAoY3JlYXRlVGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY3JlYXRlVGFnID0gY3JlYXRlVGFnO1xuICAgIH1cblxuICAgIHZhciBpbnNlcnRUYWcgPSBvcHRpb25zLmdldCgnaW5zZXJ0VGFnJyk7XG5cbiAgICBpZiAoaW5zZXJ0VGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRUYWcgPSBpbnNlcnRUYWc7XG4gICAgfVxuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFncykpIHtcbiAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGFncy5sZW5ndGg7IHQrKykge1xuICAgICAgICB2YXIgdGFnID0gdGFnc1t0XTtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9ub3JtYWxpemVJdGVtKHRhZyk7XG5cbiAgICAgICAgdmFyICRvcHRpb24gPSB0aGlzLm9wdGlvbihpdGVtKTtcblxuICAgICAgICB0aGlzLiRlbGVtZW50LmFwcGVuZCgkb3B0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBUYWdzLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLl9yZW1vdmVPbGRUYWdzKCk7XG5cbiAgICBpZiAocGFyYW1zLnRlcm0gPT0gbnVsbCB8fCBwYXJhbXMucGFnZSAhPSBudWxsKSB7XG4gICAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwcGVyIChvYmosIGNoaWxkKSB7XG4gICAgICB2YXIgZGF0YSA9IG9iai5yZXN1bHRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9wdGlvbiA9IGRhdGFbaV07XG5cbiAgICAgICAgdmFyIGNoZWNrQ2hpbGRyZW4gPSAoXG4gICAgICAgICAgb3B0aW9uLmNoaWxkcmVuICE9IG51bGwgJiZcbiAgICAgICAgICAhd3JhcHBlcih7XG4gICAgICAgICAgICByZXN1bHRzOiBvcHRpb24uY2hpbGRyZW5cbiAgICAgICAgICB9LCB0cnVlKVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBvcHRpb25UZXh0ID0gKG9wdGlvbi50ZXh0IHx8ICcnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgcGFyYW1zVGVybSA9IChwYXJhbXMudGVybSB8fCAnJykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICB2YXIgY2hlY2tUZXh0ID0gb3B0aW9uVGV4dCA9PT0gcGFyYW1zVGVybTtcblxuICAgICAgICBpZiAoY2hlY2tUZXh0IHx8IGNoZWNrQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYmouZGF0YSA9IGRhdGE7XG4gICAgICAgICAgY2FsbGJhY2sob2JqKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0YWcgPSBzZWxmLmNyZWF0ZVRhZyhwYXJhbXMpO1xuXG4gICAgICBpZiAodGFnICE9IG51bGwpIHtcbiAgICAgICAgdmFyICRvcHRpb24gPSBzZWxmLm9wdGlvbih0YWcpO1xuICAgICAgICAkb3B0aW9uLmF0dHIoJ2RhdGEtc2VsZWN0Mi10YWcnLCAndHJ1ZScpO1xuXG4gICAgICAgIHNlbGYuYWRkT3B0aW9ucyhbJG9wdGlvbl0pO1xuXG4gICAgICAgIHNlbGYuaW5zZXJ0VGFnKGRhdGEsIHRhZyk7XG4gICAgICB9XG5cbiAgICAgIG9iai5yZXN1bHRzID0gZGF0YTtcblxuICAgICAgY2FsbGJhY2sob2JqKTtcbiAgICB9XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBwYXJhbXMsIHdyYXBwZXIpO1xuICB9O1xuXG4gIFRhZ3MucHJvdG90eXBlLmNyZWF0ZVRhZyA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMudGVybSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGVybSA9IHBhcmFtcy50ZXJtLnRyaW0oKTtcblxuICAgIGlmICh0ZXJtID09PSAnJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0ZXJtLFxuICAgICAgdGV4dDogdGVybVxuICAgIH07XG4gIH07XG5cbiAgVGFncy5wcm90b3R5cGUuaW5zZXJ0VGFnID0gZnVuY3Rpb24gKF8sIGRhdGEsIHRhZykge1xuICAgIGRhdGEudW5zaGlmdCh0YWcpO1xuICB9O1xuXG4gIFRhZ3MucHJvdG90eXBlLl9yZW1vdmVPbGRUYWdzID0gZnVuY3Rpb24gKF8pIHtcbiAgICB2YXIgJG9wdGlvbnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ29wdGlvbltkYXRhLXNlbGVjdDItdGFnXScpO1xuXG4gICAgJG9wdGlvbnMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICQodGhpcykucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFRhZ3M7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvdG9rZW5pemVyJyxbXG4gICdqcXVlcnknXG5dLCBmdW5jdGlvbiAoJCkge1xuICBmdW5jdGlvbiBUb2tlbml6ZXIgKGRlY29yYXRlZCwgJGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdG9rZW5pemVyID0gb3B0aW9ucy5nZXQoJ3Rva2VuaXplcicpO1xuXG4gICAgaWYgKHRva2VuaXplciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgICB9XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCAkZWxlbWVudCwgb3B0aW9ucyk7XG4gIH1cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIsICRjb250YWluZXIpIHtcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBjb250YWluZXIsICRjb250YWluZXIpO1xuXG4gICAgdGhpcy4kc2VhcmNoID0gIGNvbnRhaW5lci5kcm9wZG93bi4kc2VhcmNoIHx8IGNvbnRhaW5lci5zZWxlY3Rpb24uJHNlYXJjaCB8fFxuICAgICAgJGNvbnRhaW5lci5maW5kKCcuc2VsZWN0Mi1zZWFyY2hfX2ZpZWxkJyk7XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVBbmRTZWxlY3QgKGRhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgZGF0YSBvYmplY3Qgc28gd2UgY2FuIHVzZSBpdCBmb3IgY2hlY2tzXG4gICAgICB2YXIgaXRlbSA9IHNlbGYuX25vcm1hbGl6ZUl0ZW0oZGF0YSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBkYXRhIG9iamVjdCBhbHJlYWR5IGV4aXN0cyBhcyBhIHRhZ1xuICAgICAgLy8gU2VsZWN0IGl0IGlmIGl0IGRvZXNuJ3RcbiAgICAgIHZhciAkZXhpc3RpbmdPcHRpb25zID0gc2VsZi4kZWxlbWVudC5maW5kKCdvcHRpb24nKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS52YWwoKSA9PT0gaXRlbS5pZDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiBhbiBleGlzdGluZyBvcHRpb24gd2Fzbid0IGZvdW5kIGZvciBpdCwgY3JlYXRlIHRoZSBvcHRpb25cbiAgICAgIGlmICghJGV4aXN0aW5nT3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgdmFyICRvcHRpb24gPSBzZWxmLm9wdGlvbihpdGVtKTtcbiAgICAgICAgJG9wdGlvbi5hdHRyKCdkYXRhLXNlbGVjdDItdGFnJywgdHJ1ZSk7XG5cbiAgICAgICAgc2VsZi5fcmVtb3ZlT2xkVGFncygpO1xuICAgICAgICBzZWxmLmFkZE9wdGlvbnMoWyRvcHRpb25dKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2VsZWN0IHRoZSBpdGVtLCBub3cgdGhhdCB3ZSBrbm93IHRoZXJlIGlzIGFuIG9wdGlvbiBmb3IgaXRcbiAgICAgIHNlbGVjdChpdGVtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWxlY3QgKGRhdGEpIHtcbiAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0Jywge1xuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwYXJhbXMudGVybSA9IHBhcmFtcy50ZXJtIHx8ICcnO1xuXG4gICAgdmFyIHRva2VuRGF0YSA9IHRoaXMudG9rZW5pemVyKHBhcmFtcywgdGhpcy5vcHRpb25zLCBjcmVhdGVBbmRTZWxlY3QpO1xuXG4gICAgaWYgKHRva2VuRGF0YS50ZXJtICE9PSBwYXJhbXMudGVybSkge1xuICAgICAgLy8gUmVwbGFjZSB0aGUgc2VhcmNoIHRlcm0gaWYgd2UgaGF2ZSB0aGUgc2VhcmNoIGJveFxuICAgICAgaWYgKHRoaXMuJHNlYXJjaC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy4kc2VhcmNoLnZhbCh0b2tlbkRhdGEudGVybSk7XG4gICAgICAgIHRoaXMuJHNlYXJjaC50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgfVxuXG4gICAgICBwYXJhbXMudGVybSA9IHRva2VuRGF0YS50ZXJtO1xuICAgIH1cblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIHBhcmFtcywgY2FsbGJhY2spO1xuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUudG9rZW5pemVyID0gZnVuY3Rpb24gKF8sIHBhcmFtcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VwYXJhdG9ycyA9IG9wdGlvbnMuZ2V0KCd0b2tlblNlcGFyYXRvcnMnKSB8fCBbXTtcbiAgICB2YXIgdGVybSA9IHBhcmFtcy50ZXJtO1xuICAgIHZhciBpID0gMDtcblxuICAgIHZhciBjcmVhdGVUYWcgPSB0aGlzLmNyZWF0ZVRhZyB8fCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogcGFyYW1zLnRlcm0sXG4gICAgICAgIHRleHQ6IHBhcmFtcy50ZXJtXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB3aGlsZSAoaSA8IHRlcm0ubGVuZ3RoKSB7XG4gICAgICB2YXIgdGVybUNoYXIgPSB0ZXJtW2ldO1xuXG4gICAgICBpZiAoc2VwYXJhdG9ycy5pbmRleE9mKHRlcm1DaGFyKSA9PT0gLTEpIHtcbiAgICAgICAgaSsrO1xuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFydCA9IHRlcm0uc3Vic3RyKDAsIGkpO1xuICAgICAgdmFyIHBhcnRQYXJhbXMgPSAkLmV4dGVuZCh7fSwgcGFyYW1zLCB7XG4gICAgICAgIHRlcm06IHBhcnRcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZGF0YSA9IGNyZWF0ZVRhZyhwYXJ0UGFyYW1zKTtcblxuICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhkYXRhKTtcblxuICAgICAgLy8gUmVzZXQgdGhlIHRlcm0gdG8gbm90IGluY2x1ZGUgdGhlIHRva2VuaXplZCBwb3J0aW9uXG4gICAgICB0ZXJtID0gdGVybS5zdWJzdHIoaSArIDEpIHx8ICcnO1xuICAgICAgaSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRlcm06IHRlcm1cbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBUb2tlbml6ZXI7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvbWluaW11bUlucHV0TGVuZ3RoJyxbXG5cbl0sIGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWluaW11bUlucHV0TGVuZ3RoIChkZWNvcmF0ZWQsICRlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5taW5pbXVtSW5wdXRMZW5ndGggPSBvcHRpb25zLmdldCgnbWluaW11bUlucHV0TGVuZ3RoJyk7XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCAkZSwgb3B0aW9ucyk7XG4gIH1cblxuICBNaW5pbXVtSW5wdXRMZW5ndGgucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHBhcmFtcy50ZXJtID0gcGFyYW1zLnRlcm0gfHwgJyc7XG5cbiAgICBpZiAocGFyYW1zLnRlcm0ubGVuZ3RoIDwgdGhpcy5taW5pbXVtSW5wdXRMZW5ndGgpIHtcbiAgICAgIHRoaXMudHJpZ2dlcigncmVzdWx0czptZXNzYWdlJywge1xuICAgICAgICBtZXNzYWdlOiAnaW5wdXRUb29TaG9ydCcsXG4gICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICBtaW5pbXVtOiB0aGlzLm1pbmltdW1JbnB1dExlbmd0aCxcbiAgICAgICAgICBpbnB1dDogcGFyYW1zLnRlcm0sXG4gICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICByZXR1cm4gTWluaW11bUlucHV0TGVuZ3RoO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kYXRhL21heGltdW1JbnB1dExlbmd0aCcsW1xuXG5dLCBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1heGltdW1JbnB1dExlbmd0aCAoZGVjb3JhdGVkLCAkZSwgb3B0aW9ucykge1xuICAgIHRoaXMubWF4aW11bUlucHV0TGVuZ3RoID0gb3B0aW9ucy5nZXQoJ21heGltdW1JbnB1dExlbmd0aCcpO1xuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgTWF4aW11bUlucHV0TGVuZ3RoLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBwYXJhbXMudGVybSA9IHBhcmFtcy50ZXJtIHx8ICcnO1xuXG4gICAgaWYgKHRoaXMubWF4aW11bUlucHV0TGVuZ3RoID4gMCAmJlxuICAgICAgICBwYXJhbXMudGVybS5sZW5ndGggPiB0aGlzLm1heGltdW1JbnB1dExlbmd0aCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdyZXN1bHRzOm1lc3NhZ2UnLCB7XG4gICAgICAgIG1lc3NhZ2U6ICdpbnB1dFRvb0xvbmcnLFxuICAgICAgICBhcmdzOiB7XG4gICAgICAgICAgbWF4aW11bTogdGhpcy5tYXhpbXVtSW5wdXRMZW5ndGgsXG4gICAgICAgICAgaW5wdXQ6IHBhcmFtcy50ZXJtLFxuICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgcmV0dXJuIE1heGltdW1JbnB1dExlbmd0aDtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZGF0YS9tYXhpbXVtU2VsZWN0aW9uTGVuZ3RoJyxbXG5cbl0sIGZ1bmN0aW9uICgpe1xuICBmdW5jdGlvbiBNYXhpbXVtU2VsZWN0aW9uTGVuZ3RoIChkZWNvcmF0ZWQsICRlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5tYXhpbXVtU2VsZWN0aW9uTGVuZ3RoID0gb3B0aW9ucy5nZXQoJ21heGltdW1TZWxlY3Rpb25MZW5ndGgnKTtcblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIE1heGltdW1TZWxlY3Rpb25MZW5ndGgucHJvdG90eXBlLmJpbmQgPVxuICAgIGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBjb250YWluZXIsICRjb250YWluZXIpO1xuXG4gICAgICBjb250YWluZXIub24oJ3NlbGVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fY2hlY2tJZk1heGltdW1TZWxlY3RlZCgpO1xuICAgICAgfSk7XG4gIH07XG5cbiAgTWF4aW11bVNlbGVjdGlvbkxlbmd0aC5wcm90b3R5cGUucXVlcnkgPVxuICAgIGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgdGhpcy5fY2hlY2tJZk1heGltdW1TZWxlY3RlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlY29yYXRlZC5jYWxsKHNlbGYsIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gIH07XG5cbiAgTWF4aW11bVNlbGVjdGlvbkxlbmd0aC5wcm90b3R5cGUuX2NoZWNrSWZNYXhpbXVtU2VsZWN0ZWQgPVxuICAgIGZ1bmN0aW9uIChfLCBzdWNjZXNzQ2FsbGJhY2spIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgdGhpcy5jdXJyZW50KGZ1bmN0aW9uIChjdXJyZW50RGF0YSkge1xuICAgICAgICB2YXIgY291bnQgPSBjdXJyZW50RGF0YSAhPSBudWxsID8gY3VycmVudERhdGEubGVuZ3RoIDogMDtcbiAgICAgICAgaWYgKHNlbGYubWF4aW11bVNlbGVjdGlvbkxlbmd0aCA+IDAgJiZcbiAgICAgICAgICBjb3VudCA+PSBzZWxmLm1heGltdW1TZWxlY3Rpb25MZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3Jlc3VsdHM6bWVzc2FnZScsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdtYXhpbXVtU2VsZWN0ZWQnLFxuICAgICAgICAgICAgYXJnczoge1xuICAgICAgICAgICAgICBtYXhpbXVtOiBzZWxmLm1heGltdW1TZWxlY3Rpb25MZW5ndGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBNYXhpbXVtU2VsZWN0aW9uTGVuZ3RoO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bicsW1xuICAnanF1ZXJ5JyxcbiAgJy4vdXRpbHMnXG5dLCBmdW5jdGlvbiAoJCwgVXRpbHMpIHtcbiAgZnVuY3Rpb24gRHJvcGRvd24gKCRlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICBEcm9wZG93bi5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIFV0aWxzLkV4dGVuZChEcm9wZG93biwgVXRpbHMuT2JzZXJ2YWJsZSk7XG5cbiAgRHJvcGRvd24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGRyb3Bkb3duID0gJChcbiAgICAgICc8c3BhbiBjbGFzcz1cInNlbGVjdDItZHJvcGRvd25cIj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VsZWN0Mi1yZXN1bHRzXCI+PC9zcGFuPicgK1xuICAgICAgJzwvc3Bhbj4nXG4gICAgKTtcblxuICAgICRkcm9wZG93bi5hdHRyKCdkaXInLCB0aGlzLm9wdGlvbnMuZ2V0KCdkaXInKSk7XG5cbiAgICB0aGlzLiRkcm9wZG93biA9ICRkcm9wZG93bjtcblxuICAgIHJldHVybiAkZHJvcGRvd247XG4gIH07XG5cbiAgRHJvcGRvd24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcbiAgfTtcblxuICBEcm9wZG93bi5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoJGRyb3Bkb3duLCAkY29udGFpbmVyKSB7XG4gICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcbiAgfTtcblxuICBEcm9wZG93bi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGRyb3Bkb3duIGZyb20gdGhlIERPTVxuICAgIHRoaXMuJGRyb3Bkb3duLnJlbW92ZSgpO1xuICB9O1xuXG4gIHJldHVybiBEcm9wZG93bjtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZHJvcGRvd24vc2VhcmNoJyxbXG4gICdqcXVlcnknXG5dLCBmdW5jdGlvbiAoJCkge1xuICBmdW5jdGlvbiBTZWFyY2ggKCkgeyB9XG5cbiAgU2VhcmNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XG4gICAgdmFyICRyZW5kZXJlZCA9IGRlY29yYXRlZC5jYWxsKHRoaXMpO1xuICAgIHZhciBzZWFyY2hMYWJlbCA9IHRoaXMub3B0aW9ucy5nZXQoJ3RyYW5zbGF0aW9ucycpLmdldCgnc2VhcmNoJyk7XG5cbiAgICB2YXIgJHNlYXJjaCA9ICQoXG4gICAgICAnPHNwYW4gY2xhc3M9XCJzZWxlY3QyLXNlYXJjaCBzZWxlY3QyLXNlYXJjaC0tZHJvcGRvd25cIj4nICtcbiAgICAgICAgJzxpbnB1dCBjbGFzcz1cInNlbGVjdDItc2VhcmNoX19maWVsZFwiIHR5cGU9XCJzZWFyY2hcIiB0YWJpbmRleD1cIi0xXCInICtcbiAgICAgICAgJyBhdXRvY29ycmVjdD1cIm9mZlwiIGF1dG9jYXBpdGFsaXplPVwibm9uZVwiJyArXG4gICAgICAgICcgc3BlbGxjaGVjaz1cImZhbHNlXCIgcm9sZT1cInNlYXJjaGJveFwiIGFyaWEtYXV0b2NvbXBsZXRlPVwibGlzdFwiIC8+JyArXG4gICAgICAnPC9zcGFuPidcbiAgICApO1xuXG4gICAgdGhpcy4kc2VhcmNoQ29udGFpbmVyID0gJHNlYXJjaDtcbiAgICB0aGlzLiRzZWFyY2ggPSAkc2VhcmNoLmZpbmQoJ2lucHV0Jyk7XG5cbiAgICB0aGlzLiRzZWFyY2gucHJvcCgnYXV0b2NvbXBsZXRlJywgdGhpcy5vcHRpb25zLmdldCgnYXV0b2NvbXBsZXRlJykpO1xuICAgIHRoaXMuJHNlYXJjaC5hdHRyKCdhcmlhLWxhYmVsJywgc2VhcmNoTGFiZWwoKSk7XG5cbiAgICAkcmVuZGVyZWQucHJlcGVuZCgkc2VhcmNoKTtcblxuICAgIHJldHVybiAkcmVuZGVyZWQ7XG4gIH07XG5cbiAgU2VhcmNoLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHJlc3VsdHNJZCA9IGNvbnRhaW5lci5pZCArICctcmVzdWx0cyc7XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBjb250YWluZXIsICRjb250YWluZXIpO1xuXG4gICAgdGhpcy4kc2VhcmNoLm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi50cmlnZ2VyKCdrZXlwcmVzcycsIGV2dCk7XG5cbiAgICAgIHNlbGYuX2tleVVwUHJldmVudGVkID0gZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpO1xuICAgIH0pO1xuXG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgYnJvd3NlcnMgd2hpY2ggZG8gbm90IHN1cHBvcnQgdGhlIGBpbnB1dGAgZXZlbnRcbiAgICAvLyBUaGlzIHdpbGwgcHJldmVudCBkb3VibGUtdHJpZ2dlcmluZyBvZiBldmVudHMgZm9yIGJyb3dzZXJzIHdoaWNoIHN1cHBvcnRcbiAgICAvLyBib3RoIHRoZSBga2V5dXBgIGFuZCBgaW5wdXRgIGV2ZW50cy5cbiAgICB0aGlzLiRzZWFyY2gub24oJ2lucHV0JywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgLy8gVW5iaW5kIHRoZSBkdXBsaWNhdGVkIGBrZXl1cGAgZXZlbnRcbiAgICAgICQodGhpcykub2ZmKCdrZXl1cCcpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kc2VhcmNoLm9uKCdrZXl1cCBpbnB1dCcsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIHNlbGYuaGFuZGxlU2VhcmNoKGV2dCk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLiRzZWFyY2guYXR0cigndGFiaW5kZXgnLCAwKTtcbiAgICAgIHNlbGYuJHNlYXJjaC5hdHRyKCdhcmlhLWNvbnRyb2xzJywgcmVzdWx0c0lkKTtcblxuICAgICAgc2VsZi4kc2VhcmNoLnRyaWdnZXIoJ2ZvY3VzJyk7XG5cbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi4kc2VhcmNoLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICB9LCAwKTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLiRzZWFyY2guYXR0cigndGFiaW5kZXgnLCAtMSk7XG4gICAgICBzZWxmLiRzZWFyY2gucmVtb3ZlQXR0cignYXJpYS1jb250cm9scycpO1xuICAgICAgc2VsZi4kc2VhcmNoLnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xuXG4gICAgICBzZWxmLiRzZWFyY2gudmFsKCcnKTtcbiAgICAgIHNlbGYuJHNlYXJjaC50cmlnZ2VyKCdibHVyJyk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFjb250YWluZXIuaXNPcGVuKCkpIHtcbiAgICAgICAgc2VsZi4kc2VhcmNoLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6YWxsJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgaWYgKHBhcmFtcy5xdWVyeS50ZXJtID09IG51bGwgfHwgcGFyYW1zLnF1ZXJ5LnRlcm0gPT09ICcnKSB7XG4gICAgICAgIHZhciBzaG93U2VhcmNoID0gc2VsZi5zaG93U2VhcmNoKHBhcmFtcyk7XG5cbiAgICAgICAgaWYgKHNob3dTZWFyY2gpIHtcbiAgICAgICAgICBzZWxmLiRzZWFyY2hDb250YWluZXJbMF0uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0Mi1zZWFyY2gtLWhpZGUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLiRzZWFyY2hDb250YWluZXJbMF0uY2xhc3NMaXN0LmFkZCgnc2VsZWN0Mi1zZWFyY2gtLWhpZGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOmZvY3VzJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgaWYgKHBhcmFtcy5kYXRhLl9yZXN1bHRJZCkge1xuICAgICAgICBzZWxmLiRzZWFyY2guYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgcGFyYW1zLmRhdGEuX3Jlc3VsdElkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuJHNlYXJjaC5yZW1vdmVBdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBTZWFyY2gucHJvdG90eXBlLmhhbmRsZVNlYXJjaCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICBpZiAoIXRoaXMuX2tleVVwUHJldmVudGVkKSB7XG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLiRzZWFyY2gudmFsKCk7XG5cbiAgICAgIHRoaXMudHJpZ2dlcigncXVlcnknLCB7XG4gICAgICAgIHRlcm06IGlucHV0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9rZXlVcFByZXZlbnRlZCA9IGZhbHNlO1xuICB9O1xuXG4gIFNlYXJjaC5wcm90b3R5cGUuc2hvd1NlYXJjaCA9IGZ1bmN0aW9uIChfLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICByZXR1cm4gU2VhcmNoO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bi9oaWRlUGxhY2Vob2xkZXInLFtcblxuXSwgZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIaWRlUGxhY2Vob2xkZXIgKGRlY29yYXRlZCwgJGVsZW1lbnQsIG9wdGlvbnMsIGRhdGFBZGFwdGVyKSB7XG4gICAgdGhpcy5wbGFjZWhvbGRlciA9IHRoaXMubm9ybWFsaXplUGxhY2Vob2xkZXIob3B0aW9ucy5nZXQoJ3BsYWNlaG9sZGVyJykpO1xuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMsIGRhdGFBZGFwdGVyKTtcbiAgfVxuXG4gIEhpZGVQbGFjZWhvbGRlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0cyA9IHRoaXMucmVtb3ZlUGxhY2Vob2xkZXIoZGF0YS5yZXN1bHRzKTtcblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGRhdGEpO1xuICB9O1xuXG4gIEhpZGVQbGFjZWhvbGRlci5wcm90b3R5cGUubm9ybWFsaXplUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoXywgcGxhY2Vob2xkZXIpIHtcbiAgICBpZiAodHlwZW9mIHBsYWNlaG9sZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgcGxhY2Vob2xkZXIgPSB7XG4gICAgICAgIGlkOiAnJyxcbiAgICAgICAgdGV4dDogcGxhY2Vob2xkZXJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICB9O1xuXG4gIEhpZGVQbGFjZWhvbGRlci5wcm90b3R5cGUucmVtb3ZlUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoXywgZGF0YSkge1xuICAgIHZhciBtb2RpZmllZERhdGEgPSBkYXRhLnNsaWNlKDApO1xuXG4gICAgZm9yICh2YXIgZCA9IGRhdGEubGVuZ3RoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgIHZhciBpdGVtID0gZGF0YVtkXTtcblxuICAgICAgaWYgKHRoaXMucGxhY2Vob2xkZXIuaWQgPT09IGl0ZW0uaWQpIHtcbiAgICAgICAgbW9kaWZpZWREYXRhLnNwbGljZShkLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW9kaWZpZWREYXRhO1xuICB9O1xuXG4gIHJldHVybiBIaWRlUGxhY2Vob2xkZXI7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2Ryb3Bkb3duL2luZmluaXRlU2Nyb2xsJyxbXG4gICdqcXVlcnknXG5dLCBmdW5jdGlvbiAoJCkge1xuICBmdW5jdGlvbiBJbmZpbml0ZVNjcm9sbCAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucywgZGF0YUFkYXB0ZXIpIHtcbiAgICB0aGlzLmxhc3RQYXJhbXMgPSB7fTtcblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zLCBkYXRhQWRhcHRlcik7XG5cbiAgICB0aGlzLiRsb2FkaW5nTW9yZSA9IHRoaXMuY3JlYXRlTG9hZGluZ01vcmUoKTtcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBkYXRhKSB7XG4gICAgdGhpcy4kbG9hZGluZ01vcmUucmVtb3ZlKCk7XG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBkYXRhKTtcblxuICAgIGlmICh0aGlzLnNob3dMb2FkaW5nTW9yZShkYXRhKSkge1xuICAgICAgdGhpcy4kcmVzdWx0cy5hcHBlbmQodGhpcy4kbG9hZGluZ01vcmUpO1xuICAgICAgdGhpcy5sb2FkTW9yZUlmTmVlZGVkKCk7XG4gICAgfVxuICB9O1xuXG4gIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcblxuICAgIGNvbnRhaW5lci5vbigncXVlcnknLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBzZWxmLmxhc3RQYXJhbXMgPSBwYXJhbXM7XG4gICAgICBzZWxmLmxvYWRpbmcgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdxdWVyeTphcHBlbmQnLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBzZWxmLmxhc3RQYXJhbXMgPSBwYXJhbXM7XG4gICAgICBzZWxmLmxvYWRpbmcgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kcmVzdWx0cy5vbignc2Nyb2xsJywgdGhpcy5sb2FkTW9yZUlmTmVlZGVkLmJpbmQodGhpcykpO1xuICB9O1xuXG4gIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5sb2FkTW9yZUlmTmVlZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpc0xvYWRNb3JlVmlzaWJsZSA9ICQuY29udGFpbnMoXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICB0aGlzLiRsb2FkaW5nTW9yZVswXVxuICAgICk7XG5cbiAgICBpZiAodGhpcy5sb2FkaW5nIHx8ICFpc0xvYWRNb3JlVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gdGhpcy4kcmVzdWx0cy5vZmZzZXQoKS50b3AgK1xuICAgICAgdGhpcy4kcmVzdWx0cy5vdXRlckhlaWdodChmYWxzZSk7XG4gICAgdmFyIGxvYWRpbmdNb3JlT2Zmc2V0ID0gdGhpcy4kbG9hZGluZ01vcmUub2Zmc2V0KCkudG9wICtcbiAgICAgIHRoaXMuJGxvYWRpbmdNb3JlLm91dGVySGVpZ2h0KGZhbHNlKTtcblxuICAgIGlmIChjdXJyZW50T2Zmc2V0ICsgNTAgPj0gbG9hZGluZ01vcmVPZmZzZXQpIHtcbiAgICAgIHRoaXMubG9hZE1vcmUoKTtcbiAgICB9XG4gIH07XG5cbiAgSW5maW5pdGVTY3JvbGwucHJvdG90eXBlLmxvYWRNb3JlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG5cbiAgICB2YXIgcGFyYW1zID0gJC5leHRlbmQoe30sIHtwYWdlOiAxfSwgdGhpcy5sYXN0UGFyYW1zKTtcblxuICAgIHBhcmFtcy5wYWdlKys7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3F1ZXJ5OmFwcGVuZCcsIHBhcmFtcyk7XG4gIH07XG5cbiAgSW5maW5pdGVTY3JvbGwucHJvdG90eXBlLnNob3dMb2FkaW5nTW9yZSA9IGZ1bmN0aW9uIChfLCBkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEucGFnaW5hdGlvbiAmJiBkYXRhLnBhZ2luYXRpb24ubW9yZTtcbiAgfTtcblxuICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUuY3JlYXRlTG9hZGluZ01vcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRvcHRpb24gPSAkKFxuICAgICAgJzxsaSAnICtcbiAgICAgICdjbGFzcz1cInNlbGVjdDItcmVzdWx0c19fb3B0aW9uIHNlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1sb2FkLW1vcmVcIicgK1xuICAgICAgJ3JvbGU9XCJvcHRpb25cIiBhcmlhLWRpc2FibGVkPVwidHJ1ZVwiPjwvbGk+J1xuICAgICk7XG5cbiAgICB2YXIgbWVzc2FnZSA9IHRoaXMub3B0aW9ucy5nZXQoJ3RyYW5zbGF0aW9ucycpLmdldCgnbG9hZGluZ01vcmUnKTtcblxuICAgICRvcHRpb24uaHRtbChtZXNzYWdlKHRoaXMubGFzdFBhcmFtcykpO1xuXG4gICAgcmV0dXJuICRvcHRpb247XG4gIH07XG5cbiAgcmV0dXJuIEluZmluaXRlU2Nyb2xsO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bi9hdHRhY2hCb2R5JyxbXG4gICdqcXVlcnknLFxuICAnLi4vdXRpbHMnXG5dLCBmdW5jdGlvbiAoJCwgVXRpbHMpIHtcbiAgZnVuY3Rpb24gQXR0YWNoQm9keSAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGRyb3Bkb3duUGFyZW50ID0gJChvcHRpb25zLmdldCgnZHJvcGRvd25QYXJlbnQnKSB8fCBkb2N1bWVudC5ib2R5KTtcblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zKTtcbiAgfVxuXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIsICRjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBjb250YWluZXIsICRjb250YWluZXIpO1xuXG4gICAgY29udGFpbmVyLm9uKCdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fc2hvd0Ryb3Bkb3duKCk7XG4gICAgICBzZWxmLl9hdHRhY2hQb3NpdGlvbmluZ0hhbmRsZXIoY29udGFpbmVyKTtcblxuICAgICAgLy8gTXVzdCBiaW5kIGFmdGVyIHRoZSByZXN1bHRzIGhhbmRsZXJzIHRvIGVuc3VyZSBjb3JyZWN0IHNpemluZ1xuICAgICAgc2VsZi5fYmluZENvbnRhaW5lclJlc3VsdEhhbmRsZXJzKGNvbnRhaW5lcik7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5faGlkZURyb3Bkb3duKCk7XG4gICAgICBzZWxmLl9kZXRhY2hQb3NpdGlvbmluZ0hhbmRsZXIoY29udGFpbmVyKTtcbiAgICB9KTtcblxuICAgIHRoaXMuJGRyb3Bkb3duQ29udGFpbmVyLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQpIHtcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuJGRyb3Bkb3duQ29udGFpbmVyLnJlbW92ZSgpO1xuICB9O1xuXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgJGRyb3Bkb3duLCAkY29udGFpbmVyKSB7XG4gICAgLy8gQ2xvbmUgYWxsIG9mIHRoZSBjb250YWluZXIgY2xhc3Nlc1xuICAgICRkcm9wZG93bi5hdHRyKCdjbGFzcycsICRjb250YWluZXIuYXR0cignY2xhc3MnKSk7XG5cbiAgICAkZHJvcGRvd25bMF0uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0MicpO1xuICAgICRkcm9wZG93blswXS5jbGFzc0xpc3QuYWRkKCdzZWxlY3QyLWNvbnRhaW5lci0tb3BlbicpO1xuXG4gICAgJGRyb3Bkb3duLmNzcyh7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHRvcDogLTk5OTk5OVxuICAgIH0pO1xuXG4gICAgdGhpcy4kY29udGFpbmVyID0gJGNvbnRhaW5lcjtcbiAgfTtcblxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XG4gICAgdmFyICRjb250YWluZXIgPSAkKCc8c3Bhbj48L3NwYW4+Jyk7XG5cbiAgICB2YXIgJGRyb3Bkb3duID0gZGVjb3JhdGVkLmNhbGwodGhpcyk7XG4gICAgJGNvbnRhaW5lci5hcHBlbmQoJGRyb3Bkb3duKTtcblxuICAgIHRoaXMuJGRyb3Bkb3duQ29udGFpbmVyID0gJGNvbnRhaW5lcjtcblxuICAgIHJldHVybiAkY29udGFpbmVyO1xuICB9O1xuXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLl9oaWRlRHJvcGRvd24gPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XG4gICAgdGhpcy4kZHJvcGRvd25Db250YWluZXIuZGV0YWNoKCk7XG4gIH07XG5cbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuX2JpbmRDb250YWluZXJSZXN1bHRIYW5kbGVycyA9XG4gICAgICBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIpIHtcblxuICAgIC8vIFRoZXNlIHNob3VsZCBvbmx5IGJlIGJvdW5kIG9uY2VcbiAgICBpZiAodGhpcy5fY29udGFpbmVyUmVzdWx0c0hhbmRsZXJzQm91bmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6YWxsJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fcG9zaXRpb25Ecm9wZG93bigpO1xuICAgICAgc2VsZi5fcmVzaXplRHJvcGRvd24oKTtcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czphcHBlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICBzZWxmLl9yZXNpemVEcm9wZG93bigpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOm1lc3NhZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICBzZWxmLl9yZXNpemVEcm9wZG93bigpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCdzZWxlY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICBzZWxmLl9yZXNpemVEcm9wZG93bigpO1xuICAgIH0pO1xuXG4gICAgY29udGFpbmVyLm9uKCd1bnNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX3Bvc2l0aW9uRHJvcGRvd24oKTtcbiAgICAgIHNlbGYuX3Jlc2l6ZURyb3Bkb3duKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9jb250YWluZXJSZXN1bHRzSGFuZGxlcnNCb3VuZCA9IHRydWU7XG4gIH07XG5cbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuX2F0dGFjaFBvc2l0aW9uaW5nSGFuZGxlciA9XG4gICAgICBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgc2Nyb2xsRXZlbnQgPSAnc2Nyb2xsLnNlbGVjdDIuJyArIGNvbnRhaW5lci5pZDtcbiAgICB2YXIgcmVzaXplRXZlbnQgPSAncmVzaXplLnNlbGVjdDIuJyArIGNvbnRhaW5lci5pZDtcbiAgICB2YXIgb3JpZW50YXRpb25FdmVudCA9ICdvcmllbnRhdGlvbmNoYW5nZS5zZWxlY3QyLicgKyBjb250YWluZXIuaWQ7XG5cbiAgICB2YXIgJHdhdGNoZXJzID0gdGhpcy4kY29udGFpbmVyLnBhcmVudHMoKS5maWx0ZXIoVXRpbHMuaGFzU2Nyb2xsKTtcbiAgICAkd2F0Y2hlcnMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBVdGlscy5TdG9yZURhdGEodGhpcywgJ3NlbGVjdDItc2Nyb2xsLXBvc2l0aW9uJywge1xuICAgICAgICB4OiAkKHRoaXMpLnNjcm9sbExlZnQoKSxcbiAgICAgICAgeTogJCh0aGlzKS5zY3JvbGxUb3AoKVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAkd2F0Y2hlcnMub24oc2Nyb2xsRXZlbnQsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHBvc2l0aW9uID0gVXRpbHMuR2V0RGF0YSh0aGlzLCAnc2VsZWN0Mi1zY3JvbGwtcG9zaXRpb24nKTtcbiAgICAgICQodGhpcykuc2Nyb2xsVG9wKHBvc2l0aW9uLnkpO1xuICAgIH0pO1xuXG4gICAgJCh3aW5kb3cpLm9uKHNjcm9sbEV2ZW50ICsgJyAnICsgcmVzaXplRXZlbnQgKyAnICcgKyBvcmllbnRhdGlvbkV2ZW50LFxuICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHNlbGYuX3Bvc2l0aW9uRHJvcGRvd24oKTtcbiAgICAgIHNlbGYuX3Jlc2l6ZURyb3Bkb3duKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuX2RldGFjaFBvc2l0aW9uaW5nSGFuZGxlciA9XG4gICAgICBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIpIHtcbiAgICB2YXIgc2Nyb2xsRXZlbnQgPSAnc2Nyb2xsLnNlbGVjdDIuJyArIGNvbnRhaW5lci5pZDtcbiAgICB2YXIgcmVzaXplRXZlbnQgPSAncmVzaXplLnNlbGVjdDIuJyArIGNvbnRhaW5lci5pZDtcbiAgICB2YXIgb3JpZW50YXRpb25FdmVudCA9ICdvcmllbnRhdGlvbmNoYW5nZS5zZWxlY3QyLicgKyBjb250YWluZXIuaWQ7XG5cbiAgICB2YXIgJHdhdGNoZXJzID0gdGhpcy4kY29udGFpbmVyLnBhcmVudHMoKS5maWx0ZXIoVXRpbHMuaGFzU2Nyb2xsKTtcbiAgICAkd2F0Y2hlcnMub2ZmKHNjcm9sbEV2ZW50KTtcblxuICAgICQod2luZG93KS5vZmYoc2Nyb2xsRXZlbnQgKyAnICcgKyByZXNpemVFdmVudCArICcgJyArIG9yaWVudGF0aW9uRXZlbnQpO1xuICB9O1xuXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLl9wb3NpdGlvbkRyb3Bkb3duID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkd2luZG93ID0gJCh3aW5kb3cpO1xuXG4gICAgdmFyIGlzQ3VycmVudGx5QWJvdmUgPSB0aGlzLiRkcm9wZG93blswXS5jbGFzc0xpc3RcbiAgICAgIC5jb250YWlucygnc2VsZWN0Mi1kcm9wZG93bi0tYWJvdmUnKTtcbiAgICB2YXIgaXNDdXJyZW50bHlCZWxvdyA9IHRoaXMuJGRyb3Bkb3duWzBdLmNsYXNzTGlzdFxuICAgICAgLmNvbnRhaW5zKCdzZWxlY3QyLWRyb3Bkb3duLS1iZWxvdycpO1xuXG4gICAgdmFyIG5ld0RpcmVjdGlvbiA9IG51bGw7XG5cbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy4kY29udGFpbmVyLm9mZnNldCgpO1xuXG4gICAgb2Zmc2V0LmJvdHRvbSA9IG9mZnNldC50b3AgKyB0aGlzLiRjb250YWluZXIub3V0ZXJIZWlnaHQoZmFsc2UpO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IHtcbiAgICAgIGhlaWdodDogdGhpcy4kY29udGFpbmVyLm91dGVySGVpZ2h0KGZhbHNlKVxuICAgIH07XG5cbiAgICBjb250YWluZXIudG9wID0gb2Zmc2V0LnRvcDtcbiAgICBjb250YWluZXIuYm90dG9tID0gb2Zmc2V0LnRvcCArIGNvbnRhaW5lci5oZWlnaHQ7XG5cbiAgICB2YXIgZHJvcGRvd24gPSB7XG4gICAgICBoZWlnaHQ6IHRoaXMuJGRyb3Bkb3duLm91dGVySGVpZ2h0KGZhbHNlKVxuICAgIH07XG5cbiAgICB2YXIgdmlld3BvcnQgPSB7XG4gICAgICB0b3A6ICR3aW5kb3cuc2Nyb2xsVG9wKCksXG4gICAgICBib3R0b206ICR3aW5kb3cuc2Nyb2xsVG9wKCkgKyAkd2luZG93LmhlaWdodCgpXG4gICAgfTtcblxuICAgIHZhciBlbm91Z2hSb29tQWJvdmUgPSB2aWV3cG9ydC50b3AgPCAob2Zmc2V0LnRvcCAtIGRyb3Bkb3duLmhlaWdodCk7XG4gICAgdmFyIGVub3VnaFJvb21CZWxvdyA9IHZpZXdwb3J0LmJvdHRvbSA+IChvZmZzZXQuYm90dG9tICsgZHJvcGRvd24uaGVpZ2h0KTtcblxuICAgIHZhciBjc3MgPSB7XG4gICAgICBsZWZ0OiBvZmZzZXQubGVmdCxcbiAgICAgIHRvcDogY29udGFpbmVyLmJvdHRvbVxuICAgIH07XG5cbiAgICAvLyBEZXRlcm1pbmUgd2hhdCB0aGUgcGFyZW50IGVsZW1lbnQgaXMgdG8gdXNlIGZvciBjYWxjdWxhdGluZyB0aGUgb2Zmc2V0XG4gICAgdmFyICRvZmZzZXRQYXJlbnQgPSB0aGlzLiRkcm9wZG93blBhcmVudDtcblxuICAgIC8vIEZvciBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudHMsIHdlIG5lZWQgdG8gZ2V0IHRoZSBlbGVtZW50XG4gICAgLy8gdGhhdCBpcyBkZXRlcm1pbmluZyB0aGUgb2Zmc2V0XG4gICAgaWYgKCRvZmZzZXRQYXJlbnQuY3NzKCdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgJG9mZnNldFBhcmVudCA9ICRvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50KCk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudE9mZnNldCA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9O1xuXG4gICAgaWYgKFxuICAgICAgJC5jb250YWlucyhkb2N1bWVudC5ib2R5LCAkb2Zmc2V0UGFyZW50WzBdKSB8fFxuICAgICAgJG9mZnNldFBhcmVudFswXS5pc0Nvbm5lY3RlZFxuICAgICAgKSB7XG4gICAgICBwYXJlbnRPZmZzZXQgPSAkb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuICAgIH1cblxuICAgIGNzcy50b3AgLT0gcGFyZW50T2Zmc2V0LnRvcDtcbiAgICBjc3MubGVmdCAtPSBwYXJlbnRPZmZzZXQubGVmdDtcblxuICAgIGlmICghaXNDdXJyZW50bHlBYm92ZSAmJiAhaXNDdXJyZW50bHlCZWxvdykge1xuICAgICAgbmV3RGlyZWN0aW9uID0gJ2JlbG93JztcbiAgICB9XG5cbiAgICBpZiAoIWVub3VnaFJvb21CZWxvdyAmJiBlbm91Z2hSb29tQWJvdmUgJiYgIWlzQ3VycmVudGx5QWJvdmUpIHtcbiAgICAgIG5ld0RpcmVjdGlvbiA9ICdhYm92ZSc7XG4gICAgfSBlbHNlIGlmICghZW5vdWdoUm9vbUFib3ZlICYmIGVub3VnaFJvb21CZWxvdyAmJiBpc0N1cnJlbnRseUFib3ZlKSB7XG4gICAgICBuZXdEaXJlY3Rpb24gPSAnYmVsb3cnO1xuICAgIH1cblxuICAgIGlmIChuZXdEaXJlY3Rpb24gPT0gJ2Fib3ZlJyB8fFxuICAgICAgKGlzQ3VycmVudGx5QWJvdmUgJiYgbmV3RGlyZWN0aW9uICE9PSAnYmVsb3cnKSkge1xuICAgICAgY3NzLnRvcCA9IGNvbnRhaW5lci50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0gZHJvcGRvd24uaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChuZXdEaXJlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgdGhpcy4kZHJvcGRvd25bMF0uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0Mi1kcm9wZG93bi0tYmVsb3cnKTtcbiAgICAgIHRoaXMuJGRyb3Bkb3duWzBdLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdDItZHJvcGRvd24tLWFib3ZlJyk7XG4gICAgICB0aGlzLiRkcm9wZG93blswXS5jbGFzc0xpc3QuYWRkKCdzZWxlY3QyLWRyb3Bkb3duLS0nICsgbmV3RGlyZWN0aW9uKTtcblxuICAgICAgdGhpcy4kY29udGFpbmVyWzBdLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdDItY29udGFpbmVyLS1iZWxvdycpO1xuICAgICAgdGhpcy4kY29udGFpbmVyWzBdLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdDItY29udGFpbmVyLS1hYm92ZScpO1xuICAgICAgdGhpcy4kY29udGFpbmVyWzBdLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdDItY29udGFpbmVyLS0nICsgbmV3RGlyZWN0aW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLiRkcm9wZG93bkNvbnRhaW5lci5jc3MoY3NzKTtcbiAgfTtcblxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5fcmVzaXplRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNzcyA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLiRjb250YWluZXIub3V0ZXJXaWR0aChmYWxzZSkgKyAncHgnXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2V0KCdkcm9wZG93bkF1dG9XaWR0aCcpKSB7XG4gICAgICBjc3MubWluV2lkdGggPSBjc3Mud2lkdGg7XG4gICAgICBjc3MucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgY3NzLndpZHRoID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIHRoaXMuJGRyb3Bkb3duLmNzcyhjc3MpO1xuICB9O1xuXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLl9zaG93RHJvcGRvd24gPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XG4gICAgdGhpcy4kZHJvcGRvd25Db250YWluZXIuYXBwZW5kVG8odGhpcy4kZHJvcGRvd25QYXJlbnQpO1xuXG4gICAgdGhpcy5fcG9zaXRpb25Ecm9wZG93bigpO1xuICAgIHRoaXMuX3Jlc2l6ZURyb3Bkb3duKCk7XG4gIH07XG5cbiAgcmV0dXJuIEF0dGFjaEJvZHk7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2Ryb3Bkb3duL21pbmltdW1SZXN1bHRzRm9yU2VhcmNoJyxbXG5cbl0sIGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gY291bnRSZXN1bHRzIChkYXRhKSB7XG4gICAgdmFyIGNvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGF0YS5sZW5ndGg7IGQrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhW2RdO1xuXG4gICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICBjb3VudCArPSBjb3VudFJlc3VsdHMoaXRlbS5jaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIE1pbmltdW1SZXN1bHRzRm9yU2VhcmNoIChkZWNvcmF0ZWQsICRlbGVtZW50LCBvcHRpb25zLCBkYXRhQWRhcHRlcikge1xuICAgIHRoaXMubWluaW11bVJlc3VsdHNGb3JTZWFyY2ggPSBvcHRpb25zLmdldCgnbWluaW11bVJlc3VsdHNGb3JTZWFyY2gnKTtcblxuICAgIGlmICh0aGlzLm1pbmltdW1SZXN1bHRzRm9yU2VhcmNoIDwgMCkge1xuICAgICAgdGhpcy5taW5pbXVtUmVzdWx0c0ZvclNlYXJjaCA9IEluZmluaXR5O1xuICAgIH1cblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zLCBkYXRhQWRhcHRlcik7XG4gIH1cblxuICBNaW5pbXVtUmVzdWx0c0ZvclNlYXJjaC5wcm90b3R5cGUuc2hvd1NlYXJjaCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcykge1xuICAgIGlmIChjb3VudFJlc3VsdHMocGFyYW1zLmRhdGEucmVzdWx0cykgPCB0aGlzLm1pbmltdW1SZXN1bHRzRm9yU2VhcmNoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY29yYXRlZC5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gIH07XG5cbiAgcmV0dXJuIE1pbmltdW1SZXN1bHRzRm9yU2VhcmNoO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bi9zZWxlY3RPbkNsb3NlJyxbXG4gICcuLi91dGlscydcbl0sIGZ1bmN0aW9uIChVdGlscykge1xuICBmdW5jdGlvbiBTZWxlY3RPbkNsb3NlICgpIHsgfVxuXG4gIFNlbGVjdE9uQ2xvc2UucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIsICRjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBjb250YWluZXIsICRjb250YWluZXIpO1xuXG4gICAgY29udGFpbmVyLm9uKCdjbG9zZScsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIHNlbGYuX2hhbmRsZVNlbGVjdE9uQ2xvc2UocGFyYW1zKTtcbiAgICB9KTtcbiAgfTtcblxuICBTZWxlY3RPbkNsb3NlLnByb3RvdHlwZS5faGFuZGxlU2VsZWN0T25DbG9zZSA9IGZ1bmN0aW9uIChfLCBwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5vcmlnaW5hbFNlbGVjdDJFdmVudCAhPSBudWxsKSB7XG4gICAgICB2YXIgZXZlbnQgPSBwYXJhbXMub3JpZ2luYWxTZWxlY3QyRXZlbnQ7XG5cbiAgICAgIC8vIERvbid0IHNlbGVjdCBhbiBpdGVtIGlmIHRoZSBjbG9zZSBldmVudCB3YXMgdHJpZ2dlcmVkIGZyb20gYSBzZWxlY3Qgb3JcbiAgICAgIC8vIHVuc2VsZWN0IGV2ZW50XG4gICAgICBpZiAoZXZlbnQuX3R5cGUgPT09ICdzZWxlY3QnIHx8IGV2ZW50Ll90eXBlID09PSAndW5zZWxlY3QnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgJGhpZ2hsaWdodGVkUmVzdWx0cyA9IHRoaXMuZ2V0SGlnaGxpZ2h0ZWRSZXN1bHRzKCk7XG5cbiAgICAvLyBPbmx5IHNlbGVjdCBoaWdobGlnaHRlZCByZXN1bHRzXG4gICAgaWYgKCRoaWdobGlnaHRlZFJlc3VsdHMubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gVXRpbHMuR2V0RGF0YSgkaGlnaGxpZ2h0ZWRSZXN1bHRzWzBdLCAnZGF0YScpO1xuXG4gICAgLy8gRG9uJ3QgcmUtc2VsZWN0IGFscmVhZHkgc2VsZWN0ZWQgcmVzdWx0ZVxuICAgIGlmIChcbiAgICAgIChkYXRhLmVsZW1lbnQgIT0gbnVsbCAmJiBkYXRhLmVsZW1lbnQuc2VsZWN0ZWQpIHx8XG4gICAgICAoZGF0YS5lbGVtZW50ID09IG51bGwgJiYgZGF0YS5zZWxlY3RlZClcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdCcsIHtcbiAgICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTZWxlY3RPbkNsb3NlO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bi9jbG9zZU9uU2VsZWN0JyxbXG5cbl0sIGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2xvc2VPblNlbGVjdCAoKSB7IH1cblxuICBDbG9zZU9uU2VsZWN0LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcblxuICAgIGNvbnRhaW5lci5vbignc2VsZWN0JywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi5fc2VsZWN0VHJpZ2dlcmVkKGV2dCk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIub24oJ3Vuc2VsZWN0JywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi5fc2VsZWN0VHJpZ2dlcmVkKGV2dCk7XG4gICAgfSk7XG4gIH07XG5cbiAgQ2xvc2VPblNlbGVjdC5wcm90b3R5cGUuX3NlbGVjdFRyaWdnZXJlZCA9IGZ1bmN0aW9uIChfLCBldnQpIHtcbiAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGV2dC5vcmlnaW5hbEV2ZW50O1xuXG4gICAgLy8gRG9uJ3QgY2xvc2UgaWYgdGhlIGNvbnRyb2wga2V5IGlzIGJlaW5nIGhlbGRcbiAgICBpZiAob3JpZ2luYWxFdmVudCAmJiAob3JpZ2luYWxFdmVudC5jdHJsS2V5IHx8IG9yaWdpbmFsRXZlbnQubWV0YUtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2Nsb3NlJywge1xuICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudCxcbiAgICAgIG9yaWdpbmFsU2VsZWN0MkV2ZW50OiBldnRcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ2xvc2VPblNlbGVjdDtcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZHJvcGRvd24vZHJvcGRvd25Dc3MnLFtcbiAgJy4uL3V0aWxzJ1xuXSwgZnVuY3Rpb24gKFV0aWxzKSB7XG4gIGZ1bmN0aW9uIERyb3Bkb3duQ1NTICgpIHsgfVxuXG4gIERyb3Bkb3duQ1NTLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XG4gICAgdmFyICRkcm9wZG93biA9IGRlY29yYXRlZC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIGRyb3Bkb3duQ3NzQ2xhc3MgPSB0aGlzLm9wdGlvbnMuZ2V0KCdkcm9wZG93bkNzc0NsYXNzJykgfHwgJyc7XG5cbiAgICBpZiAoZHJvcGRvd25Dc3NDbGFzcy5pbmRleE9mKCc6YWxsOicpICE9PSAtMSkge1xuICAgICAgZHJvcGRvd25Dc3NDbGFzcyA9IGRyb3Bkb3duQ3NzQ2xhc3MucmVwbGFjZSgnOmFsbDonLCAnJyk7XG5cbiAgICAgIFV0aWxzLmNvcHlOb25JbnRlcm5hbENzc0NsYXNzZXMoJGRyb3Bkb3duWzBdLCB0aGlzLiRlbGVtZW50WzBdKTtcbiAgICB9XG5cbiAgICAkZHJvcGRvd24uYWRkQ2xhc3MoZHJvcGRvd25Dc3NDbGFzcyk7XG5cbiAgICByZXR1cm4gJGRyb3Bkb3duO1xuICB9O1xuXG4gIHJldHVybiBEcm9wZG93bkNTUztcbn0pO1xuXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZHJvcGRvd24vdGFnc1NlYXJjaEhpZ2hsaWdodCcsW1xuICAnLi4vdXRpbHMnXG5dLCBmdW5jdGlvbiAoVXRpbHMpIHtcbiAgZnVuY3Rpb24gVGFnc1NlYXJjaEhpZ2hsaWdodCAoKSB7IH1cblxuICBUYWdzU2VhcmNoSGlnaGxpZ2h0LnByb3RvdHlwZS5oaWdobGlnaHRGaXJzdEl0ZW0gPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XG4gICAgdmFyICRvcHRpb25zID0gdGhpcy4kcmVzdWx0c1xuICAgIC5maW5kKFxuICAgICAgJy5zZWxlY3QyLXJlc3VsdHNfX29wdGlvbi0tc2VsZWN0YWJsZScgK1xuICAgICAgJzpub3QoLnNlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1zZWxlY3RlZCknXG4gICAgKTtcblxuICAgIGlmICgkb3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgJGZpcnN0T3B0aW9uID0gJG9wdGlvbnMuZmlyc3QoKTtcbiAgICAgIHZhciBkYXRhID0gVXRpbHMuR2V0RGF0YSgkZmlyc3RPcHRpb25bMF0sICdkYXRhJyk7XG4gICAgICB2YXIgZmlyc3RFbGVtZW50ID0gZGF0YS5lbGVtZW50O1xuXG4gICAgICBpZiAoZmlyc3RFbGVtZW50ICYmIGZpcnN0RWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGZpcnN0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2VsZWN0Mi10YWcnKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgJGZpcnN0T3B0aW9uLnRyaWdnZXIoJ21vdXNlZW50ZXInKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBUYWdzU2VhcmNoSGlnaGxpZ2h0O1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9pMThuL2VuJyxbXSxmdW5jdGlvbiAoKSB7XG4gIC8vIEVuZ2xpc2hcbiAgcmV0dXJuIHtcbiAgICBlcnJvckxvYWRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnVGhlIHJlc3VsdHMgY291bGQgbm90IGJlIGxvYWRlZC4nO1xuICAgIH0sXG4gICAgaW5wdXRUb29Mb25nOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgdmFyIG92ZXJDaGFycyA9IGFyZ3MuaW5wdXQubGVuZ3RoIC0gYXJncy5tYXhpbXVtO1xuXG4gICAgICB2YXIgbWVzc2FnZSA9ICdQbGVhc2UgZGVsZXRlICcgKyBvdmVyQ2hhcnMgKyAnIGNoYXJhY3Rlcic7XG5cbiAgICAgIGlmIChvdmVyQ2hhcnMgIT0gMSkge1xuICAgICAgICBtZXNzYWdlICs9ICdzJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBpbnB1dFRvb1Nob3J0OiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgdmFyIHJlbWFpbmluZ0NoYXJzID0gYXJncy5taW5pbXVtIC0gYXJncy5pbnB1dC5sZW5ndGg7XG5cbiAgICAgIHZhciBtZXNzYWdlID0gJ1BsZWFzZSBlbnRlciAnICsgcmVtYWluaW5nQ2hhcnMgKyAnIG9yIG1vcmUgY2hhcmFjdGVycyc7XG5cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgbG9hZGluZ01vcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnTG9hZGluZyBtb3JlIHJlc3VsdHPigKYnO1xuICAgIH0sXG4gICAgbWF4aW11bVNlbGVjdGVkOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnWW91IGNhbiBvbmx5IHNlbGVjdCAnICsgYXJncy5tYXhpbXVtICsgJyBpdGVtJztcblxuICAgICAgaWYgKGFyZ3MubWF4aW11bSAhPSAxKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gJ3MnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIG5vUmVzdWx0czogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICdObyByZXN1bHRzIGZvdW5kJztcbiAgICB9LFxuICAgIHNlYXJjaGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICdTZWFyY2hpbmfigKYnO1xuICAgIH0sXG4gICAgcmVtb3ZlQWxsSXRlbXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnUmVtb3ZlIGFsbCBpdGVtcyc7XG4gICAgfSxcbiAgICByZW1vdmVJdGVtOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJ1JlbW92ZSBpdGVtJztcbiAgICB9LFxuICAgIHNlYXJjaDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ1NlYXJjaCc7XG4gICAgfVxuICB9O1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9kZWZhdWx0cycsW1xuICAnanF1ZXJ5JyxcblxuICAnLi9yZXN1bHRzJyxcblxuICAnLi9zZWxlY3Rpb24vc2luZ2xlJyxcbiAgJy4vc2VsZWN0aW9uL211bHRpcGxlJyxcbiAgJy4vc2VsZWN0aW9uL3BsYWNlaG9sZGVyJyxcbiAgJy4vc2VsZWN0aW9uL2FsbG93Q2xlYXInLFxuICAnLi9zZWxlY3Rpb24vc2VhcmNoJyxcbiAgJy4vc2VsZWN0aW9uL3NlbGVjdGlvbkNzcycsXG4gICcuL3NlbGVjdGlvbi9ldmVudFJlbGF5JyxcblxuICAnLi91dGlscycsXG4gICcuL3RyYW5zbGF0aW9uJyxcbiAgJy4vZGlhY3JpdGljcycsXG5cbiAgJy4vZGF0YS9zZWxlY3QnLFxuICAnLi9kYXRhL2FycmF5JyxcbiAgJy4vZGF0YS9hamF4JyxcbiAgJy4vZGF0YS90YWdzJyxcbiAgJy4vZGF0YS90b2tlbml6ZXInLFxuICAnLi9kYXRhL21pbmltdW1JbnB1dExlbmd0aCcsXG4gICcuL2RhdGEvbWF4aW11bUlucHV0TGVuZ3RoJyxcbiAgJy4vZGF0YS9tYXhpbXVtU2VsZWN0aW9uTGVuZ3RoJyxcblxuICAnLi9kcm9wZG93bicsXG4gICcuL2Ryb3Bkb3duL3NlYXJjaCcsXG4gICcuL2Ryb3Bkb3duL2hpZGVQbGFjZWhvbGRlcicsXG4gICcuL2Ryb3Bkb3duL2luZmluaXRlU2Nyb2xsJyxcbiAgJy4vZHJvcGRvd24vYXR0YWNoQm9keScsXG4gICcuL2Ryb3Bkb3duL21pbmltdW1SZXN1bHRzRm9yU2VhcmNoJyxcbiAgJy4vZHJvcGRvd24vc2VsZWN0T25DbG9zZScsXG4gICcuL2Ryb3Bkb3duL2Nsb3NlT25TZWxlY3QnLFxuICAnLi9kcm9wZG93bi9kcm9wZG93bkNzcycsXG4gICcuL2Ryb3Bkb3duL3RhZ3NTZWFyY2hIaWdobGlnaHQnLFxuXG4gICcuL2kxOG4vZW4nXG5dLCBmdW5jdGlvbiAoJCxcblxuICAgICAgICAgICAgIFJlc3VsdHNMaXN0LFxuXG4gICAgICAgICAgICAgU2luZ2xlU2VsZWN0aW9uLCBNdWx0aXBsZVNlbGVjdGlvbiwgUGxhY2Vob2xkZXIsIEFsbG93Q2xlYXIsXG4gICAgICAgICAgICAgU2VsZWN0aW9uU2VhcmNoLCBTZWxlY3Rpb25DU1MsIEV2ZW50UmVsYXksXG5cbiAgICAgICAgICAgICBVdGlscywgVHJhbnNsYXRpb24sIERJQUNSSVRJQ1MsXG5cbiAgICAgICAgICAgICBTZWxlY3REYXRhLCBBcnJheURhdGEsIEFqYXhEYXRhLCBUYWdzLCBUb2tlbml6ZXIsXG4gICAgICAgICAgICAgTWluaW11bUlucHV0TGVuZ3RoLCBNYXhpbXVtSW5wdXRMZW5ndGgsIE1heGltdW1TZWxlY3Rpb25MZW5ndGgsXG5cbiAgICAgICAgICAgICBEcm9wZG93biwgRHJvcGRvd25TZWFyY2gsIEhpZGVQbGFjZWhvbGRlciwgSW5maW5pdGVTY3JvbGwsXG4gICAgICAgICAgICAgQXR0YWNoQm9keSwgTWluaW11bVJlc3VsdHNGb3JTZWFyY2gsIFNlbGVjdE9uQ2xvc2UsIENsb3NlT25TZWxlY3QsXG4gICAgICAgICAgICAgRHJvcGRvd25DU1MsIFRhZ3NTZWFyY2hIaWdobGlnaHQsXG5cbiAgICAgICAgICAgICBFbmdsaXNoVHJhbnNsYXRpb24pIHtcbiAgZnVuY3Rpb24gRGVmYXVsdHMgKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIERlZmF1bHRzLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLmRhdGFBZGFwdGVyID09IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLmFqYXggIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gQWpheERhdGE7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIgPSBBcnJheURhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gU2VsZWN0RGF0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMubWluaW11bUlucHV0TGVuZ3RoID4gMCkge1xuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXG4gICAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlcixcbiAgICAgICAgICBNaW5pbXVtSW5wdXRMZW5ndGhcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMubWF4aW11bUlucHV0TGVuZ3RoID4gMCkge1xuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXG4gICAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlcixcbiAgICAgICAgICBNYXhpbXVtSW5wdXRMZW5ndGhcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMubWF4aW11bVNlbGVjdGlvbkxlbmd0aCA+IDApIHtcbiAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxuICAgICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIsXG4gICAgICAgICAgTWF4aW11bVNlbGVjdGlvbkxlbmd0aFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50YWdzKSB7XG4gICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShvcHRpb25zLmRhdGFBZGFwdGVyLCBUYWdzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudG9rZW5TZXBhcmF0b3JzICE9IG51bGwgfHwgb3B0aW9ucy50b2tlbml6ZXIgIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXG4gICAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlcixcbiAgICAgICAgICBUb2tlbml6ZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yZXN1bHRzQWRhcHRlciA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zLnJlc3VsdHNBZGFwdGVyID0gUmVzdWx0c0xpc3Q7XG5cbiAgICAgIGlmIChvcHRpb25zLmFqYXggIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLnJlc3VsdHNBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXG4gICAgICAgICAgb3B0aW9ucy5yZXN1bHRzQWRhcHRlcixcbiAgICAgICAgICBJbmZpbml0ZVNjcm9sbFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5wbGFjZWhvbGRlciAhPSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMucmVzdWx0c0FkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgICBvcHRpb25zLnJlc3VsdHNBZGFwdGVyLFxuICAgICAgICAgIEhpZGVQbGFjZWhvbGRlclxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5zZWxlY3RPbkNsb3NlKSB7XG4gICAgICAgIG9wdGlvbnMucmVzdWx0c0FkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgICBvcHRpb25zLnJlc3VsdHNBZGFwdGVyLFxuICAgICAgICAgIFNlbGVjdE9uQ2xvc2VcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudGFncykge1xuICAgICAgICBvcHRpb25zLnJlc3VsdHNBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXG4gICAgICAgICAgb3B0aW9ucy5yZXN1bHRzQWRhcHRlcixcbiAgICAgICAgICBUYWdzU2VhcmNoSGlnaGxpZ2h0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyID09IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLm11bHRpcGxlKSB7XG4gICAgICAgIG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyID0gRHJvcGRvd247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgU2VhcmNoYWJsZURyb3Bkb3duID0gVXRpbHMuRGVjb3JhdGUoRHJvcGRvd24sIERyb3Bkb3duU2VhcmNoKTtcblxuICAgICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlciA9IFNlYXJjaGFibGVEcm9wZG93bjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMubWluaW11bVJlc3VsdHNGb3JTZWFyY2ggIT09IDApIHtcbiAgICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlcixcbiAgICAgICAgICBNaW5pbXVtUmVzdWx0c0ZvclNlYXJjaFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jbG9zZU9uU2VsZWN0KSB7XG4gICAgICAgIG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXG4gICAgICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIsXG4gICAgICAgICAgQ2xvc2VPblNlbGVjdFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kcm9wZG93bkNzc0NsYXNzICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlcixcbiAgICAgICAgICBEcm9wZG93bkNTU1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxuICAgICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlcixcbiAgICAgICAgQXR0YWNoQm9keVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyID09IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLm11bHRpcGxlKSB7XG4gICAgICAgIG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlciA9IE11bHRpcGxlU2VsZWN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyID0gU2luZ2xlU2VsZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIHBsYWNlaG9sZGVyIG1peGluIGlmIGEgcGxhY2Vob2xkZXIgd2FzIHNwZWNpZmllZFxuICAgICAgaWYgKG9wdGlvbnMucGxhY2Vob2xkZXIgIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIsXG4gICAgICAgICAgUGxhY2Vob2xkZXJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYWxsb3dDbGVhcikge1xuICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIsXG4gICAgICAgICAgQWxsb3dDbGVhclxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5tdWx0aXBsZSkge1xuICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIsXG4gICAgICAgICAgU2VsZWN0aW9uU2VhcmNoXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnNlbGVjdGlvbkNzc0NsYXNzICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXG4gICAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyLFxuICAgICAgICAgIFNlbGVjdGlvbkNTU1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcbiAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyLFxuICAgICAgICBFdmVudFJlbGF5XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBkZWZhdWx0cyB3ZXJlIG5vdCBwcmV2aW91c2x5IGFwcGxpZWQgZnJvbSBhbiBlbGVtZW50LCBpdCBpc1xuICAgIC8vIHBvc3NpYmxlIGZvciB0aGUgbGFuZ3VhZ2Ugb3B0aW9uIHRvIGhhdmUgbm90IGJlZW4gcmVzb2x2ZWRcbiAgICBvcHRpb25zLmxhbmd1YWdlID0gdGhpcy5fcmVzb2x2ZUxhbmd1YWdlKG9wdGlvbnMubGFuZ3VhZ2UpO1xuXG4gICAgLy8gQWx3YXlzIGZhbGwgYmFjayB0byBFbmdsaXNoIHNpbmNlIGl0IHdpbGwgYWx3YXlzIGJlIGNvbXBsZXRlXG4gICAgb3B0aW9ucy5sYW5ndWFnZS5wdXNoKCdlbicpO1xuXG4gICAgdmFyIHVuaXF1ZUxhbmd1YWdlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgbCA9IDA7IGwgPCBvcHRpb25zLmxhbmd1YWdlLmxlbmd0aDsgbCsrKSB7XG4gICAgICB2YXIgbGFuZ3VhZ2UgPSBvcHRpb25zLmxhbmd1YWdlW2xdO1xuXG4gICAgICBpZiAodW5pcXVlTGFuZ3VhZ2VzLmluZGV4T2YobGFuZ3VhZ2UpID09PSAtMSkge1xuICAgICAgICB1bmlxdWVMYW5ndWFnZXMucHVzaChsYW5ndWFnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW9ucy5sYW5ndWFnZSA9IHVuaXF1ZUxhbmd1YWdlcztcblxuICAgIG9wdGlvbnMudHJhbnNsYXRpb25zID0gdGhpcy5fcHJvY2Vzc1RyYW5zbGF0aW9ucyhcbiAgICAgIG9wdGlvbnMubGFuZ3VhZ2UsXG4gICAgICBvcHRpb25zLmRlYnVnXG4gICAgKTtcblxuICAgIHJldHVybiBvcHRpb25zO1xuICB9O1xuXG4gIERlZmF1bHRzLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBzdHJpcERpYWNyaXRpY3MgKHRleHQpIHtcbiAgICAgIC8vIFVzZWQgJ3VuaSByYW5nZSArIG5hbWVkIGZ1bmN0aW9uJyBmcm9tIGh0dHA6Ly9qc3BlcmYuY29tL2RpYWNyaXRpY3MvMThcbiAgICAgIGZ1bmN0aW9uIG1hdGNoKGEpIHtcbiAgICAgICAgcmV0dXJuIERJQUNSSVRJQ1NbYV0gfHwgYTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvW15cXHUwMDAwLVxcdTAwN0VdL2csIG1hdGNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaGVyIChwYXJhbXMsIGRhdGEpIHtcbiAgICAgIC8vIEFsd2F5cyByZXR1cm4gdGhlIG9iamVjdCBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGNvbXBhcmVcbiAgICAgIGlmIChwYXJhbXMudGVybSA9PSBudWxsIHx8IHBhcmFtcy50ZXJtLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG5cbiAgICAgIC8vIERvIGEgcmVjdXJzaXZlIGNoZWNrIGZvciBvcHRpb25zIHdpdGggY2hpbGRyZW5cbiAgICAgIGlmIChkYXRhLmNoaWxkcmVuICYmIGRhdGEuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBDbG9uZSB0aGUgZGF0YSBvYmplY3QgaWYgdGhlcmUgYXJlIGNoaWxkcmVuXG4gICAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgYXMgd2UgbW9kaWZ5IHRoZSBvYmplY3QgdG8gcmVtb3ZlIGFueSBub24tbWF0Y2hlc1xuICAgICAgICB2YXIgbWF0Y2ggPSAkLmV4dGVuZCh0cnVlLCB7fSwgZGF0YSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZWFjaCBjaGlsZCBvZiB0aGUgb3B0aW9uXG4gICAgICAgIGZvciAodmFyIGMgPSBkYXRhLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGMgPj0gMDsgYy0tKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gZGF0YS5jaGlsZHJlbltjXTtcblxuICAgICAgICAgIHZhciBtYXRjaGVzID0gbWF0Y2hlcihwYXJhbXMsIGNoaWxkKTtcblxuICAgICAgICAgIC8vIElmIHRoZXJlIHdhc24ndCBhIG1hdGNoLCByZW1vdmUgdGhlIG9iamVjdCBpbiB0aGUgYXJyYXlcbiAgICAgICAgICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXRjaC5jaGlsZHJlbi5zcGxpY2UoYywgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYW55IGNoaWxkcmVuIG1hdGNoZWQsIHJldHVybiB0aGUgbmV3IG9iamVjdFxuICAgICAgICBpZiAobWF0Y2guY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIHdlcmUgbm8gbWF0Y2hpbmcgY2hpbGRyZW4sIGNoZWNrIGp1c3QgdGhlIHBsYWluIG9iamVjdFxuICAgICAgICByZXR1cm4gbWF0Y2hlcihwYXJhbXMsIG1hdGNoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9yaWdpbmFsID0gc3RyaXBEaWFjcml0aWNzKGRhdGEudGV4dCkudG9VcHBlckNhc2UoKTtcbiAgICAgIHZhciB0ZXJtID0gc3RyaXBEaWFjcml0aWNzKHBhcmFtcy50ZXJtKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgdGV4dCBjb250YWlucyB0aGUgdGVybVxuICAgICAgaWYgKG9yaWdpbmFsLmluZGV4T2YodGVybSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgZG9lc24ndCBjb250YWluIHRoZSB0ZXJtLCBkb24ndCByZXR1cm4gYW55dGhpbmdcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICBhbWRMYW5ndWFnZUJhc2U6ICcuL2kxOG4vJyxcbiAgICAgIGF1dG9jb21wbGV0ZTogJ29mZicsXG4gICAgICBjbG9zZU9uU2VsZWN0OiB0cnVlLFxuICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgZHJvcGRvd25BdXRvV2lkdGg6IGZhbHNlLFxuICAgICAgZXNjYXBlTWFya3VwOiBVdGlscy5lc2NhcGVNYXJrdXAsXG4gICAgICBsYW5ndWFnZToge30sXG4gICAgICBtYXRjaGVyOiBtYXRjaGVyLFxuICAgICAgbWluaW11bUlucHV0TGVuZ3RoOiAwLFxuICAgICAgbWF4aW11bUlucHV0TGVuZ3RoOiAwLFxuICAgICAgbWF4aW11bVNlbGVjdGlvbkxlbmd0aDogMCxcbiAgICAgIG1pbmltdW1SZXN1bHRzRm9yU2VhcmNoOiAwLFxuICAgICAgc2VsZWN0T25DbG9zZTogZmFsc2UsXG4gICAgICBzY3JvbGxBZnRlclNlbGVjdDogZmFsc2UsXG4gICAgICBzb3J0ZXI6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSxcbiAgICAgIHRlbXBsYXRlUmVzdWx0OiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudGV4dDtcbiAgICAgIH0sXG4gICAgICB0ZW1wbGF0ZVNlbGVjdGlvbjogZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uLnRleHQ7XG4gICAgICB9LFxuICAgICAgdGhlbWU6ICdkZWZhdWx0JyxcbiAgICAgIHdpZHRoOiAncmVzb2x2ZSdcbiAgICB9O1xuICB9O1xuXG4gIERlZmF1bHRzLnByb3RvdHlwZS5hcHBseUZyb21FbGVtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMsICRlbGVtZW50KSB7XG4gICAgdmFyIG9wdGlvbkxhbmd1YWdlID0gb3B0aW9ucy5sYW5ndWFnZTtcbiAgICB2YXIgZGVmYXVsdExhbmd1YWdlID0gdGhpcy5kZWZhdWx0cy5sYW5ndWFnZTtcbiAgICB2YXIgZWxlbWVudExhbmd1YWdlID0gJGVsZW1lbnQucHJvcCgnbGFuZycpO1xuICAgIHZhciBwYXJlbnRMYW5ndWFnZSA9ICRlbGVtZW50LmNsb3Nlc3QoJ1tsYW5nXScpLnByb3AoJ2xhbmcnKTtcblxuICAgIHZhciBsYW5ndWFnZXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmNhbGwoXG4gICAgICB0aGlzLl9yZXNvbHZlTGFuZ3VhZ2UoZWxlbWVudExhbmd1YWdlKSxcbiAgICAgIHRoaXMuX3Jlc29sdmVMYW5ndWFnZShvcHRpb25MYW5ndWFnZSksXG4gICAgICB0aGlzLl9yZXNvbHZlTGFuZ3VhZ2UoZGVmYXVsdExhbmd1YWdlKSxcbiAgICAgIHRoaXMuX3Jlc29sdmVMYW5ndWFnZShwYXJlbnRMYW5ndWFnZSlcbiAgICApO1xuXG4gICAgb3B0aW9ucy5sYW5ndWFnZSA9IGxhbmd1YWdlcztcblxuICAgIHJldHVybiBvcHRpb25zO1xuICB9O1xuXG4gIERlZmF1bHRzLnByb3RvdHlwZS5fcmVzb2x2ZUxhbmd1YWdlID0gZnVuY3Rpb24gKGxhbmd1YWdlKSB7XG4gICAgaWYgKCFsYW5ndWFnZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICgkLmlzRW1wdHlPYmplY3QobGFuZ3VhZ2UpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKCQuaXNQbGFpbk9iamVjdChsYW5ndWFnZSkpIHtcbiAgICAgIHJldHVybiBbbGFuZ3VhZ2VdO1xuICAgIH1cblxuICAgIHZhciBsYW5ndWFnZXM7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobGFuZ3VhZ2UpKSB7XG4gICAgICBsYW5ndWFnZXMgPSBbbGFuZ3VhZ2VdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYW5ndWFnZXMgPSBsYW5ndWFnZTtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZWRMYW5ndWFnZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGFuZ3VhZ2VzLmxlbmd0aDsgbCsrKSB7XG4gICAgICByZXNvbHZlZExhbmd1YWdlcy5wdXNoKGxhbmd1YWdlc1tsXSk7XG5cbiAgICAgIGlmICh0eXBlb2YgbGFuZ3VhZ2VzW2xdID09PSAnc3RyaW5nJyAmJiBsYW5ndWFnZXNbbF0uaW5kZXhPZignLScpID4gMCkge1xuICAgICAgICAvLyBFeHRyYWN0IHRoZSByZWdpb24gaW5mb3JtYXRpb24gaWYgaXQgaXMgaW5jbHVkZWRcbiAgICAgICAgdmFyIGxhbmd1YWdlUGFydHMgPSBsYW5ndWFnZXNbbF0uc3BsaXQoJy0nKTtcbiAgICAgICAgdmFyIGJhc2VMYW5ndWFnZSA9IGxhbmd1YWdlUGFydHNbMF07XG5cbiAgICAgICAgcmVzb2x2ZWRMYW5ndWFnZXMucHVzaChiYXNlTGFuZ3VhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXNvbHZlZExhbmd1YWdlcztcbiAgfTtcblxuICBEZWZhdWx0cy5wcm90b3R5cGUuX3Byb2Nlc3NUcmFuc2xhdGlvbnMgPSBmdW5jdGlvbiAobGFuZ3VhZ2VzLCBkZWJ1Zykge1xuICAgIHZhciB0cmFuc2xhdGlvbnMgPSBuZXcgVHJhbnNsYXRpb24oKTtcblxuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGFuZ3VhZ2VzLmxlbmd0aDsgbCsrKSB7XG4gICAgICB2YXIgbGFuZ3VhZ2VEYXRhID0gbmV3IFRyYW5zbGF0aW9uKCk7XG5cbiAgICAgIHZhciBsYW5ndWFnZSA9IGxhbmd1YWdlc1tsXTtcblxuICAgICAgaWYgKHR5cGVvZiBsYW5ndWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUcnkgdG8gbG9hZCBpdCB3aXRoIHRoZSBvcmlnaW5hbCBuYW1lXG4gICAgICAgICAgbGFuZ3VhZ2VEYXRhID0gVHJhbnNsYXRpb24ubG9hZFBhdGgobGFuZ3VhZ2UpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGxvYWQgaXQsIGNoZWNrIGlmIGl0IHdhc24ndCB0aGUgZnVsbCBwYXRoXG4gICAgICAgICAgICBsYW5ndWFnZSA9IHRoaXMuZGVmYXVsdHMuYW1kTGFuZ3VhZ2VCYXNlICsgbGFuZ3VhZ2U7XG4gICAgICAgICAgICBsYW5ndWFnZURhdGEgPSBUcmFuc2xhdGlvbi5sb2FkUGF0aChsYW5ndWFnZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIC8vIFRoZSB0cmFuc2xhdGlvbiBjb3VsZCBub3QgYmUgbG9hZGVkIGF0IGFsbC4gU29tZXRpbWVzIHRoaXMgaXNcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugb2YgYSBjb25maWd1cmF0aW9uIHByb2JsZW0sIG90aGVyIHRpbWVzIHRoaXMgY2FuIGJlXG4gICAgICAgICAgICAvLyBiZWNhdXNlIG9mIGhvdyBTZWxlY3QyIGhlbHBzIGxvYWQgYWxsIHBvc3NpYmxlIHRyYW5zbGF0aW9uIGZpbGVzXG4gICAgICAgICAgICBpZiAoZGVidWcgJiYgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAnU2VsZWN0MjogVGhlIGxhbmd1YWdlIGZpbGUgZm9yIFwiJyArIGxhbmd1YWdlICsgJ1wiIGNvdWxkICcgK1xuICAgICAgICAgICAgICAgICdub3QgYmUgYXV0b21hdGljYWxseSBsb2FkZWQuIEEgZmFsbGJhY2sgd2lsbCBiZSB1c2VkIGluc3RlYWQuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgkLmlzUGxhaW5PYmplY3QobGFuZ3VhZ2UpKSB7XG4gICAgICAgIGxhbmd1YWdlRGF0YSA9IG5ldyBUcmFuc2xhdGlvbihsYW5ndWFnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYW5ndWFnZURhdGEgPSBsYW5ndWFnZTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNsYXRpb25zLmV4dGVuZChsYW5ndWFnZURhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2xhdGlvbnM7XG4gIH07XG5cbiAgRGVmYXVsdHMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGNhbWVsS2V5ID0gJC5jYW1lbENhc2Uoa2V5KTtcblxuICAgIHZhciBkYXRhID0ge307XG4gICAgZGF0YVtjYW1lbEtleV0gPSB2YWx1ZTtcblxuICAgIHZhciBjb252ZXJ0ZWREYXRhID0gVXRpbHMuX2NvbnZlcnREYXRhKGRhdGEpO1xuXG4gICAgJC5leHRlbmQodHJ1ZSwgdGhpcy5kZWZhdWx0cywgY29udmVydGVkRGF0YSk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRzID0gbmV3IERlZmF1bHRzKCk7XG5cbiAgcmV0dXJuIGRlZmF1bHRzO1xufSk7XG5cblMyLmRlZmluZSgnc2VsZWN0Mi9vcHRpb25zJyxbXG4gICdqcXVlcnknLFxuICAnLi9kZWZhdWx0cycsXG4gICcuL3V0aWxzJ1xuXSwgZnVuY3Rpb24gKCQsIERlZmF1bHRzLCBVdGlscykge1xuICBmdW5jdGlvbiBPcHRpb25zIChvcHRpb25zLCAkZWxlbWVudCkge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICBpZiAoJGVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5mcm9tRWxlbWVudCgkZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKCRlbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IERlZmF1bHRzLmFwcGx5RnJvbUVsZW1lbnQodGhpcy5vcHRpb25zLCAkZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gRGVmYXVsdHMuYXBwbHkodGhpcy5vcHRpb25zKTtcbiAgfVxuXG4gIE9wdGlvbnMucHJvdG90eXBlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24gKCRlKSB7XG4gICAgdmFyIGV4Y2x1ZGVkRGF0YSA9IFsnc2VsZWN0MiddO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5tdWx0aXBsZSA9PSBudWxsKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubXVsdGlwbGUgPSAkZS5wcm9wKCdtdWx0aXBsZScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5vcHRpb25zLmRpc2FibGVkID0gJGUucHJvcCgnZGlzYWJsZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9jb21wbGV0ZSA9PSBudWxsICYmICRlLnByb3AoJ2F1dG9jb21wbGV0ZScpKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuYXV0b2NvbXBsZXRlID0gJGUucHJvcCgnYXV0b2NvbXBsZXRlJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXIgPT0gbnVsbCkge1xuICAgICAgaWYgKCRlLnByb3AoJ2RpcicpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5kaXIgPSAkZS5wcm9wKCdkaXInKTtcbiAgICAgIH0gZWxzZSBpZiAoJGUuY2xvc2VzdCgnW2Rpcl0nKS5wcm9wKCdkaXInKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZGlyID0gJGUuY2xvc2VzdCgnW2Rpcl0nKS5wcm9wKCdkaXInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5kaXIgPSAnbHRyJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkZS5wcm9wKCdkaXNhYmxlZCcsIHRoaXMub3B0aW9ucy5kaXNhYmxlZCk7XG4gICAgJGUucHJvcCgnbXVsdGlwbGUnLCB0aGlzLm9wdGlvbnMubXVsdGlwbGUpO1xuXG4gICAgaWYgKFV0aWxzLkdldERhdGEoJGVbMF0sICdzZWxlY3QyVGFncycpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1NlbGVjdDI6IFRoZSBgZGF0YS1zZWxlY3QyLXRhZ3NgIGF0dHJpYnV0ZSBoYXMgYmVlbiBjaGFuZ2VkIHRvICcgK1xuICAgICAgICAgICd1c2UgdGhlIGBkYXRhLWRhdGFgIGFuZCBgZGF0YS10YWdzPVwidHJ1ZVwiYCBhdHRyaWJ1dGVzIGFuZCB3aWxsIGJlICcgK1xuICAgICAgICAgICdyZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBTZWxlY3QyLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgVXRpbHMuU3RvcmVEYXRhKCRlWzBdLCAnZGF0YScsIFV0aWxzLkdldERhdGEoJGVbMF0sICdzZWxlY3QyVGFncycpKTtcbiAgICAgIFV0aWxzLlN0b3JlRGF0YSgkZVswXSwgJ3RhZ3MnLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbHMuR2V0RGF0YSgkZVswXSwgJ2FqYXhVcmwnKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdTZWxlY3QyOiBUaGUgYGRhdGEtYWpheC11cmxgIGF0dHJpYnV0ZSBoYXMgYmVlbiBjaGFuZ2VkIHRvICcgK1xuICAgICAgICAgICdgZGF0YS1hamF4LS11cmxgIGFuZCBzdXBwb3J0IGZvciB0aGUgb2xkIGF0dHJpYnV0ZSB3aWxsIGJlIHJlbW92ZWQnICtcbiAgICAgICAgICAnIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBTZWxlY3QyLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgJGUuYXR0cignYWpheC0tdXJsJywgVXRpbHMuR2V0RGF0YSgkZVswXSwgJ2FqYXhVcmwnKSk7XG4gICAgICBVdGlscy5TdG9yZURhdGEoJGVbMF0sICdhamF4LVVybCcsIFV0aWxzLkdldERhdGEoJGVbMF0sICdhamF4VXJsJykpO1xuICAgIH1cblxuICAgIHZhciBkYXRhc2V0ID0ge307XG5cbiAgICBmdW5jdGlvbiB1cHBlckNhc2VMZXR0ZXIoXywgbGV0dGVyKSB7XG4gICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gUHJlLWxvYWQgYWxsIG9mIHRoZSBhdHRyaWJ1dGVzIHdoaWNoIGFyZSBwcmVmaXhlZCB3aXRoIGBkYXRhLWBcbiAgICBmb3IgKHZhciBhdHRyID0gMDsgYXR0ciA8ICRlWzBdLmF0dHJpYnV0ZXMubGVuZ3RoOyBhdHRyKyspIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gJGVbMF0uYXR0cmlidXRlc1thdHRyXS5uYW1lO1xuICAgICAgdmFyIHByZWZpeCA9ICdkYXRhLSc7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVOYW1lLnN1YnN0cigwLCBwcmVmaXgubGVuZ3RoKSA9PSBwcmVmaXgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBjb250ZW50cyBvZiB0aGUgYXR0cmlidXRlIGFmdGVyIGBkYXRhLWBcbiAgICAgICAgdmFyIGRhdGFOYW1lID0gYXR0cmlidXRlTmFtZS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBkYXRhIGNvbnRlbnRzIGZyb20gdGhlIGNvbnNpc3RlbnQgc291cmNlXG4gICAgICAgIC8vIFRoaXMgaXMgbW9yZSB0aGFuIGxpa2VseSB0aGUgalF1ZXJ5IGRhdGEgaGVscGVyXG4gICAgICAgIHZhciBkYXRhVmFsdWUgPSBVdGlscy5HZXREYXRhKCRlWzBdLCBkYXRhTmFtZSk7XG5cbiAgICAgICAgLy8gY2FtZWxDYXNlIHRoZSBhdHRyaWJ1dGUgbmFtZSB0byBtYXRjaCB0aGUgc3BlY1xuICAgICAgICB2YXIgY2FtZWxEYXRhTmFtZSA9IGRhdGFOYW1lLnJlcGxhY2UoLy0oW2Etel0pL2csIHVwcGVyQ2FzZUxldHRlcik7XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIGRhdGEgYXR0cmlidXRlIGNvbnRlbnRzIGludG8gdGhlIGRhdGFzZXQgc2luY2VcbiAgICAgICAgZGF0YXNldFtjYW1lbERhdGFOYW1lXSA9IGRhdGFWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcmVmZXIgdGhlIGVsZW1lbnQncyBgZGF0YXNldGAgYXR0cmlidXRlIGlmIGl0IGV4aXN0c1xuICAgIC8vIGpRdWVyeSAxLnggZG9lcyBub3QgY29ycmVjdGx5IGhhbmRsZSBkYXRhIGF0dHJpYnV0ZXMgd2l0aCBtdWx0aXBsZSBkYXNoZXNcbiAgICBpZiAoJC5mbi5qcXVlcnkgJiYgJC5mbi5qcXVlcnkuc3Vic3RyKDAsIDIpID09ICcxLicgJiYgJGVbMF0uZGF0YXNldCkge1xuICAgICAgZGF0YXNldCA9ICQuZXh0ZW5kKHRydWUsIHt9LCAkZVswXS5kYXRhc2V0LCBkYXRhc2V0KTtcbiAgICB9XG5cbiAgICAvLyBQcmVmZXIgb3VyIGludGVybmFsIGRhdGEgY2FjaGUgaWYgaXQgZXhpc3RzXG4gICAgdmFyIGRhdGEgPSAkLmV4dGVuZCh0cnVlLCB7fSwgVXRpbHMuR2V0RGF0YSgkZVswXSksIGRhdGFzZXQpO1xuXG4gICAgZGF0YSA9IFV0aWxzLl9jb252ZXJ0RGF0YShkYXRhKTtcblxuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBpZiAoZXhjbHVkZWREYXRhLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KHRoaXMub3B0aW9uc1trZXldKSkge1xuICAgICAgICAkLmV4dGVuZCh0aGlzLm9wdGlvbnNba2V5XSwgZGF0YVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gZGF0YVtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIE9wdGlvbnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zW2tleV07XG4gIH07XG5cbiAgT3B0aW9ucy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWw7XG4gIH07XG5cbiAgcmV0dXJuIE9wdGlvbnM7XG59KTtcblxuUzIuZGVmaW5lKCdzZWxlY3QyL2NvcmUnLFtcbiAgJ2pxdWVyeScsXG4gICcuL29wdGlvbnMnLFxuICAnLi91dGlscycsXG4gICcuL2tleXMnXG5dLCBmdW5jdGlvbiAoJCwgT3B0aW9ucywgVXRpbHMsIEtFWVMpIHtcbiAgdmFyIFNlbGVjdDIgPSBmdW5jdGlvbiAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAoVXRpbHMuR2V0RGF0YSgkZWxlbWVudFswXSwgJ3NlbGVjdDInKSAhPSBudWxsKSB7XG4gICAgICBVdGlscy5HZXREYXRhKCRlbGVtZW50WzBdLCAnc2VsZWN0MicpLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XG5cbiAgICB0aGlzLmlkID0gdGhpcy5fZ2VuZXJhdGVJZCgkZWxlbWVudCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG5ldyBPcHRpb25zKG9wdGlvbnMsICRlbGVtZW50KTtcblxuICAgIFNlbGVjdDIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG5cbiAgICAvLyBTZXQgdXAgdGhlIHRhYmluZGV4XG5cbiAgICB2YXIgdGFiaW5kZXggPSAkZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpIHx8IDA7XG4gICAgVXRpbHMuU3RvcmVEYXRhKCRlbGVtZW50WzBdLCAnb2xkLXRhYmluZGV4JywgdGFiaW5kZXgpO1xuICAgICRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgJy0xJyk7XG5cbiAgICAvLyBTZXQgdXAgY29udGFpbmVycyBhbmQgYWRhcHRlcnNcblxuICAgIHZhciBEYXRhQWRhcHRlciA9IHRoaXMub3B0aW9ucy5nZXQoJ2RhdGFBZGFwdGVyJyk7XG4gICAgdGhpcy5kYXRhQWRhcHRlciA9IG5ldyBEYXRhQWRhcHRlcigkZWxlbWVudCwgdGhpcy5vcHRpb25zKTtcblxuICAgIHZhciAkY29udGFpbmVyID0gdGhpcy5yZW5kZXIoKTtcblxuICAgIHRoaXMuX3BsYWNlQ29udGFpbmVyKCRjb250YWluZXIpO1xuXG4gICAgdmFyIFNlbGVjdGlvbkFkYXB0ZXIgPSB0aGlzLm9wdGlvbnMuZ2V0KCdzZWxlY3Rpb25BZGFwdGVyJyk7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uQWRhcHRlcigkZWxlbWVudCwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLiRzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbi5yZW5kZXIoKTtcblxuICAgIHRoaXMuc2VsZWN0aW9uLnBvc2l0aW9uKHRoaXMuJHNlbGVjdGlvbiwgJGNvbnRhaW5lcik7XG5cbiAgICB2YXIgRHJvcGRvd25BZGFwdGVyID0gdGhpcy5vcHRpb25zLmdldCgnZHJvcGRvd25BZGFwdGVyJyk7XG4gICAgdGhpcy5kcm9wZG93biA9IG5ldyBEcm9wZG93bkFkYXB0ZXIoJGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy4kZHJvcGRvd24gPSB0aGlzLmRyb3Bkb3duLnJlbmRlcigpO1xuXG4gICAgdGhpcy5kcm9wZG93bi5wb3NpdGlvbih0aGlzLiRkcm9wZG93biwgJGNvbnRhaW5lcik7XG5cbiAgICB2YXIgUmVzdWx0c0FkYXB0ZXIgPSB0aGlzLm9wdGlvbnMuZ2V0KCdyZXN1bHRzQWRhcHRlcicpO1xuICAgIHRoaXMucmVzdWx0cyA9IG5ldyBSZXN1bHRzQWRhcHRlcigkZWxlbWVudCwgdGhpcy5vcHRpb25zLCB0aGlzLmRhdGFBZGFwdGVyKTtcbiAgICB0aGlzLiRyZXN1bHRzID0gdGhpcy5yZXN1bHRzLnJlbmRlcigpO1xuXG4gICAgdGhpcy5yZXN1bHRzLnBvc2l0aW9uKHRoaXMuJHJlc3VsdHMsIHRoaXMuJGRyb3Bkb3duKTtcblxuICAgIC8vIEJpbmQgZXZlbnRzXG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBCaW5kIHRoZSBjb250YWluZXIgdG8gYWxsIG9mIHRoZSBhZGFwdGVyc1xuICAgIHRoaXMuX2JpbmRBZGFwdGVycygpO1xuXG4gICAgLy8gUmVnaXN0ZXIgYW55IERPTSBldmVudCBoYW5kbGVyc1xuICAgIHRoaXMuX3JlZ2lzdGVyRG9tRXZlbnRzKCk7XG5cbiAgICAvLyBSZWdpc3RlciBhbnkgaW50ZXJuYWwgZXZlbnQgaGFuZGxlcnNcbiAgICB0aGlzLl9yZWdpc3RlckRhdGFFdmVudHMoKTtcbiAgICB0aGlzLl9yZWdpc3RlclNlbGVjdGlvbkV2ZW50cygpO1xuICAgIHRoaXMuX3JlZ2lzdGVyRHJvcGRvd25FdmVudHMoKTtcbiAgICB0aGlzLl9yZWdpc3RlclJlc3VsdHNFdmVudHMoKTtcbiAgICB0aGlzLl9yZWdpc3RlckV2ZW50cygpO1xuXG4gICAgLy8gU2V0IHRoZSBpbml0aWFsIHN0YXRlXG4gICAgdGhpcy5kYXRhQWRhcHRlci5jdXJyZW50KGZ1bmN0aW9uIChpbml0aWFsRGF0YSkge1xuICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3Rpb246dXBkYXRlJywge1xuICAgICAgICBkYXRhOiBpbml0aWFsRGF0YVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBIaWRlIHRoZSBvcmlnaW5hbCBzZWxlY3RcbiAgICAkZWxlbWVudFswXS5jbGFzc0xpc3QuYWRkKCdzZWxlY3QyLWhpZGRlbi1hY2Nlc3NpYmxlJyk7XG4gICAgJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgLy8gU3luY2hyb25pemUgYW55IG1vbml0b3JlZCBhdHRyaWJ1dGVzXG4gICAgdGhpcy5fc3luY0F0dHJpYnV0ZXMoKTtcblxuICAgIFV0aWxzLlN0b3JlRGF0YSgkZWxlbWVudFswXSwgJ3NlbGVjdDInLCB0aGlzKTtcblxuICAgIC8vIEVuc3VyZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoICRlbGVtZW50LmRhdGEoJ3NlbGVjdDInKS5cbiAgICAkZWxlbWVudC5kYXRhKCdzZWxlY3QyJywgdGhpcyk7XG4gIH07XG5cbiAgVXRpbHMuRXh0ZW5kKFNlbGVjdDIsIFV0aWxzLk9ic2VydmFibGUpO1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLl9nZW5lcmF0ZUlkID0gZnVuY3Rpb24gKCRlbGVtZW50KSB7XG4gICAgdmFyIGlkID0gJyc7XG5cbiAgICBpZiAoJGVsZW1lbnQuYXR0cignaWQnKSAhPSBudWxsKSB7XG4gICAgICBpZCA9ICRlbGVtZW50LmF0dHIoJ2lkJyk7XG4gICAgfSBlbHNlIGlmICgkZWxlbWVudC5hdHRyKCduYW1lJykgIT0gbnVsbCkge1xuICAgICAgaWQgPSAkZWxlbWVudC5hdHRyKCduYW1lJykgKyAnLScgKyBVdGlscy5nZW5lcmF0ZUNoYXJzKDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IFV0aWxzLmdlbmVyYXRlQ2hhcnMoNCk7XG4gICAgfVxuXG4gICAgaWQgPSBpZC5yZXBsYWNlKC8oOnxcXC58XFxbfFxcXXwsKS9nLCAnJyk7XG4gICAgaWQgPSAnc2VsZWN0Mi0nICsgaWQ7XG5cbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUuX3BsYWNlQ29udGFpbmVyID0gZnVuY3Rpb24gKCRjb250YWluZXIpIHtcbiAgICAkY29udGFpbmVyLmluc2VydEFmdGVyKHRoaXMuJGVsZW1lbnQpO1xuXG4gICAgdmFyIHdpZHRoID0gdGhpcy5fcmVzb2x2ZVdpZHRoKHRoaXMuJGVsZW1lbnQsIHRoaXMub3B0aW9ucy5nZXQoJ3dpZHRoJykpO1xuXG4gICAgaWYgKHdpZHRoICE9IG51bGwpIHtcbiAgICAgICRjb250YWluZXIuY3NzKCd3aWR0aCcsIHdpZHRoKTtcbiAgICB9XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUuX3Jlc29sdmVXaWR0aCA9IGZ1bmN0aW9uICgkZWxlbWVudCwgbWV0aG9kKSB7XG4gICAgdmFyIFdJRFRIID0gL153aWR0aDooKFstK10/KFswLTldKlxcLik/WzAtOV0rKShweHxlbXxleHwlfGlufGNtfG1tfHB0fHBjKSkvaTtcblxuICAgIGlmIChtZXRob2QgPT0gJ3Jlc29sdmUnKSB7XG4gICAgICB2YXIgc3R5bGVXaWR0aCA9IHRoaXMuX3Jlc29sdmVXaWR0aCgkZWxlbWVudCwgJ3N0eWxlJyk7XG5cbiAgICAgIGlmIChzdHlsZVdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlV2lkdGgoJGVsZW1lbnQsICdlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCA9PSAnZWxlbWVudCcpIHtcbiAgICAgIHZhciBlbGVtZW50V2lkdGggPSAkZWxlbWVudC5vdXRlcldpZHRoKGZhbHNlKTtcblxuICAgICAgaWYgKGVsZW1lbnRXaWR0aCA8PSAwKSB7XG4gICAgICAgIHJldHVybiAnYXV0byc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50V2lkdGggKyAncHgnO1xuICAgIH1cblxuICAgIGlmIChtZXRob2QgPT0gJ3N0eWxlJykge1xuICAgICAgdmFyIHN0eWxlID0gJGVsZW1lbnQuYXR0cignc3R5bGUnKTtcblxuICAgICAgaWYgKHR5cGVvZihzdHlsZSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cnMgPSBzdHlsZS5zcGxpdCgnOycpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkgPSBpICsgMSkge1xuICAgICAgICB2YXIgYXR0ciA9IGF0dHJzW2ldLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgIHZhciBtYXRjaGVzID0gYXR0ci5tYXRjaChXSURUSCk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwgJiYgbWF0Y2hlcy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgIHJldHVybiBtYXRjaGVzWzFdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChtZXRob2QgPT0gJ2NvbXB1dGVkc3R5bGUnKSB7XG4gICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCRlbGVtZW50WzBdKTtcblxuICAgICAgcmV0dXJuIGNvbXB1dGVkU3R5bGUud2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5fYmluZEFkYXB0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGF0YUFkYXB0ZXIuYmluZCh0aGlzLCB0aGlzLiRjb250YWluZXIpO1xuICAgIHRoaXMuc2VsZWN0aW9uLmJpbmQodGhpcywgdGhpcy4kY29udGFpbmVyKTtcblxuICAgIHRoaXMuZHJvcGRvd24uYmluZCh0aGlzLCB0aGlzLiRjb250YWluZXIpO1xuICAgIHRoaXMucmVzdWx0cy5iaW5kKHRoaXMsIHRoaXMuJGNvbnRhaW5lcik7XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUuX3JlZ2lzdGVyRG9tRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuJGVsZW1lbnQub24oJ2NoYW5nZS5zZWxlY3QyJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5kYXRhQWRhcHRlci5jdXJyZW50KGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0aW9uOnVwZGF0ZScsIHtcbiAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRlbGVtZW50Lm9uKCdmb2N1cy5zZWxlY3QyJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgc2VsZi50cmlnZ2VyKCdmb2N1cycsIGV2dCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zeW5jQSA9IFV0aWxzLmJpbmQodGhpcy5fc3luY0F0dHJpYnV0ZXMsIHRoaXMpO1xuICAgIHRoaXMuX3N5bmNTID0gVXRpbHMuYmluZCh0aGlzLl9zeW5jU3VidHJlZSwgdGhpcyk7XG5cbiAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgICBzZWxmLl9zeW5jQSgpO1xuICAgICAgc2VsZi5fc3luY1MobXV0YXRpb25zKTtcbiAgICB9KTtcbiAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuJGVsZW1lbnRbMF0sIHtcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICBzdWJ0cmVlOiBmYWxzZVxuICAgIH0pO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLl9yZWdpc3RlckRhdGFFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5kYXRhQWRhcHRlci5vbignKicsIGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMpIHtcbiAgICAgIHNlbGYudHJpZ2dlcihuYW1lLCBwYXJhbXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLl9yZWdpc3RlclNlbGVjdGlvbkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG5vblJlbGF5RXZlbnRzID0gWyd0b2dnbGUnLCAnZm9jdXMnXTtcblxuICAgIHRoaXMuc2VsZWN0aW9uLm9uKCd0b2dnbGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnRvZ2dsZURyb3Bkb3duKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNlbGVjdGlvbi5vbignZm9jdXMnLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBzZWxmLmZvY3VzKHBhcmFtcyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNlbGVjdGlvbi5vbignKicsIGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMpIHtcbiAgICAgIGlmIChub25SZWxheUV2ZW50cy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYudHJpZ2dlcihuYW1lLCBwYXJhbXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLl9yZWdpc3RlckRyb3Bkb3duRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuZHJvcGRvd24ub24oJyonLCBmdW5jdGlvbiAobmFtZSwgcGFyYW1zKSB7XG4gICAgICBzZWxmLnRyaWdnZXIobmFtZSwgcGFyYW1zKTtcbiAgICB9KTtcbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5fcmVnaXN0ZXJSZXN1bHRzRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucmVzdWx0cy5vbignKicsIGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMpIHtcbiAgICAgIHNlbGYudHJpZ2dlcihuYW1lLCBwYXJhbXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLl9yZWdpc3RlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLm9uKCdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi4kY29udGFpbmVyWzBdLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdDItY29udGFpbmVyLS1vcGVuJyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuJGNvbnRhaW5lclswXS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3QyLWNvbnRhaW5lci0tb3BlbicpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignZW5hYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi4kY29udGFpbmVyWzBdLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdDItY29udGFpbmVyLS1kaXNhYmxlZCcpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignZGlzYWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuJGNvbnRhaW5lclswXS5jbGFzc0xpc3QuYWRkKCdzZWxlY3QyLWNvbnRhaW5lci0tZGlzYWJsZWQnKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLiRjb250YWluZXJbMF0uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0Mi1jb250YWluZXItLWZvY3VzJyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdxdWVyeScsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIGlmICghc2VsZi5pc09wZW4oKSkge1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ29wZW4nLCB7fSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YUFkYXB0ZXIucXVlcnkocGFyYW1zLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ3Jlc3VsdHM6YWxsJywge1xuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgcXVlcnk6IHBhcmFtc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbigncXVlcnk6YXBwZW5kJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgdGhpcy5kYXRhQWRhcHRlci5xdWVyeShwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czphcHBlbmQnLCB7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBxdWVyeTogcGFyYW1zXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdrZXlwcmVzcycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIHZhciBrZXkgPSBldnQud2hpY2g7XG5cbiAgICAgIGlmIChzZWxmLmlzT3BlbigpKSB7XG4gICAgICAgIGlmIChrZXkgPT09IEtFWVMuRVNDIHx8IChrZXkgPT09IEtFWVMuVVAgJiYgZXZ0LmFsdEtleSkpIHtcbiAgICAgICAgICBzZWxmLmNsb3NlKGV2dCk7XG5cbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IEtFWVMuRU5URVIgfHwga2V5ID09PSBLRVlTLlRBQikge1xuICAgICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czpzZWxlY3QnLCB7fSk7XG5cbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmICgoa2V5ID09PSBLRVlTLlNQQUNFICYmIGV2dC5jdHJsS2V5KSkge1xuICAgICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czp0b2dnbGUnLCB7fSk7XG5cbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IEtFWVMuVVApIHtcbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3Jlc3VsdHM6cHJldmlvdXMnLCB7fSk7XG5cbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IEtFWVMuRE9XTikge1xuICAgICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czpuZXh0Jywge30pO1xuXG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXkgPT09IEtFWVMuRU5URVIgfHwga2V5ID09PSBLRVlTLlNQQUNFIHx8XG4gICAgICAgICAgICAoa2V5ID09PSBLRVlTLkRPV04gJiYgZXZ0LmFsdEtleSkpIHtcbiAgICAgICAgICBzZWxmLm9wZW4oKTtcblxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUuX3N5bmNBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub3B0aW9ucy5zZXQoJ2Rpc2FibGVkJywgdGhpcy4kZWxlbWVudC5wcm9wKCdkaXNhYmxlZCcpKTtcblxuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQoKSkge1xuICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyaWdnZXIoJ2Rpc2FibGUnLCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZW5hYmxlJywge30pO1xuICAgIH1cbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5faXNDaGFuZ2VNdXRhdGlvbiA9IGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAobXV0YXRpb25zLmFkZGVkTm9kZXMgJiYgbXV0YXRpb25zLmFkZGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBtdXRhdGlvbnMuYWRkZWROb2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgbm9kZSA9IG11dGF0aW9ucy5hZGRlZE5vZGVzW25dO1xuXG4gICAgICAgIGlmIChub2RlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG11dGF0aW9ucy5yZW1vdmVkTm9kZXMgJiYgbXV0YXRpb25zLnJlbW92ZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobXV0YXRpb25zKSkge1xuICAgICAgcmV0dXJuIG11dGF0aW9ucy5zb21lKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gc2VsZi5faXNDaGFuZ2VNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUuX3N5bmNTdWJ0cmVlID0gZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5faXNDaGFuZ2VNdXRhdGlvbihtdXRhdGlvbnMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIE9ubHkgcmUtcHVsbCB0aGUgZGF0YSBpZiB3ZSB0aGluayB0aGVyZSBpcyBhIGNoYW5nZVxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmRhdGFBZGFwdGVyLmN1cnJlbnQoZnVuY3Rpb24gKGN1cnJlbnREYXRhKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0aW9uOnVwZGF0ZScsIHtcbiAgICAgICAgICBkYXRhOiBjdXJyZW50RGF0YVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHRyaWdnZXIgbWV0aG9kIHRvIGF1dG9tYXRpY2FsbHkgdHJpZ2dlciBwcmUtZXZlbnRzIHdoZW5cbiAgICogdGhlcmUgYXJlIGV2ZW50cyB0aGF0IGNhbiBiZSBwcmV2ZW50ZWQuXG4gICAqL1xuICBTZWxlY3QyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICB2YXIgYWN0dWFsVHJpZ2dlciA9IFNlbGVjdDIuX19zdXBlcl9fLnRyaWdnZXI7XG4gICAgdmFyIHByZVRyaWdnZXJNYXAgPSB7XG4gICAgICAnb3Blbic6ICdvcGVuaW5nJyxcbiAgICAgICdjbG9zZSc6ICdjbG9zaW5nJyxcbiAgICAgICdzZWxlY3QnOiAnc2VsZWN0aW5nJyxcbiAgICAgICd1bnNlbGVjdCc6ICd1bnNlbGVjdGluZycsXG4gICAgICAnY2xlYXInOiAnY2xlYXJpbmcnXG4gICAgfTtcblxuICAgIGlmIChhcmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFyZ3MgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSBpbiBwcmVUcmlnZ2VyTWFwKSB7XG4gICAgICB2YXIgcHJlVHJpZ2dlck5hbWUgPSBwcmVUcmlnZ2VyTWFwW25hbWVdO1xuICAgICAgdmFyIHByZVRyaWdnZXJBcmdzID0ge1xuICAgICAgICBwcmV2ZW50ZWQ6IGZhbHNlLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgICB9O1xuXG4gICAgICBhY3R1YWxUcmlnZ2VyLmNhbGwodGhpcywgcHJlVHJpZ2dlck5hbWUsIHByZVRyaWdnZXJBcmdzKTtcblxuICAgICAgaWYgKHByZVRyaWdnZXJBcmdzLnByZXZlbnRlZCkge1xuICAgICAgICBhcmdzLnByZXZlbnRlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFjdHVhbFRyaWdnZXIuY2FsbCh0aGlzLCBuYW1lLCBhcmdzKTtcbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS50b2dnbGVEcm9wZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc0Rpc2FibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcigncXVlcnknLCB7fSk7XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmlzT3BlbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyKCdjbG9zZScsIHsgb3JpZ2luYWxFdmVudCA6IGV2dCB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBhYnN0cmFjdCB0aGUgXCJlbmFibGVkXCIgKG5vdCBcImRpc2FibGVkXCIpIHN0YXRlIG9mIHRoaXNcbiAgICogb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHt0cnVlfSBpZiB0aGUgaW5zdGFuY2UgaXMgbm90IGRpc2FibGVkLlxuICAgKiBAcmV0dXJuIHtmYWxzZX0gaWYgdGhlIGluc3RhbmNlIGlzIGRpc2FibGVkLlxuICAgKi9cbiAgU2VsZWN0Mi5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhdGhpcy5pc0Rpc2FibGVkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gYWJzdHJhY3QgdGhlIFwiZGlzYWJsZWRcIiBzdGF0ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7dHJ1ZX0gaWYgdGhlIGRpc2FibGVkIG9wdGlvbiBpcyB0cnVlLlxuICAgKiBAcmV0dXJuIHtmYWxzZX0gaWYgdGhlIGRpc2FibGVkIG9wdGlvbiBpcyBmYWxzZS5cbiAgICovXG4gIFNlbGVjdDIucHJvdG90eXBlLmlzRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5nZXQoJ2Rpc2FibGVkJyk7XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUuaXNPcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLiRjb250YWluZXJbMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3QyLWNvbnRhaW5lci0tb3BlbicpO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLmhhc0ZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLiRjb250YWluZXJbMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3QyLWNvbnRhaW5lci0tZm9jdXMnKTtcbiAgfTtcblxuICBTZWxlY3QyLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgLy8gTm8gbmVlZCB0byByZS10cmlnZ2VyIGZvY3VzIGV2ZW50cyBpZiB3ZSBhcmUgYWxyZWFkeSBmb2N1c2VkXG4gICAgaWYgKHRoaXMuaGFzRm9jdXMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuJGNvbnRhaW5lclswXS5jbGFzc0xpc3QuYWRkKCdzZWxlY3QyLWNvbnRhaW5lci0tZm9jdXMnKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2ZvY3VzJywge30pO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5nZXQoJ2RlYnVnJykgJiYgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdTZWxlY3QyOiBUaGUgYHNlbGVjdDIoXCJlbmFibGVcIilgIG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsJyArXG4gICAgICAgICcgYmUgcmVtb3ZlZCBpbiBsYXRlciBTZWxlY3QyIHZlcnNpb25zLiBVc2UgJGVsZW1lbnQucHJvcChcImRpc2FibGVkXCIpJyArXG4gICAgICAgICcgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChhcmdzID09IG51bGwgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIGFyZ3MgPSBbdHJ1ZV07XG4gICAgfVxuXG4gICAgdmFyIGRpc2FibGVkID0gIWFyZ3NbMF07XG5cbiAgICB0aGlzLiRlbGVtZW50LnByb3AoJ2Rpc2FibGVkJywgZGlzYWJsZWQpO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5nZXQoJ2RlYnVnJykgJiZcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdTZWxlY3QyOiBEYXRhIGNhbiBubyBsb25nZXIgYmUgc2V0IHVzaW5nIGBzZWxlY3QyKFwiZGF0YVwiKWAuIFlvdSAnICtcbiAgICAgICAgJ3Nob3VsZCBjb25zaWRlciBzZXR0aW5nIHRoZSB2YWx1ZSBpbnN0ZWFkIHVzaW5nIGAkZWxlbWVudC52YWwoKWAuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IFtdO1xuXG4gICAgdGhpcy5kYXRhQWRhcHRlci5jdXJyZW50KGZ1bmN0aW9uIChjdXJyZW50RGF0YSkge1xuICAgICAgZGF0YSA9IGN1cnJlbnREYXRhO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgU2VsZWN0Mi5wcm90b3R5cGUudmFsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmdldCgnZGVidWcnKSAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1NlbGVjdDI6IFRoZSBgc2VsZWN0MihcInZhbFwiKWAgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUnICtcbiAgICAgICAgJyByZW1vdmVkIGluIGxhdGVyIFNlbGVjdDIgdmVyc2lvbnMuIFVzZSAkZWxlbWVudC52YWwoKSBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MgPT0gbnVsbCB8fCBhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQudmFsKCk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1ZhbCA9IGFyZ3NbMF07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXdWYWwpKSB7XG4gICAgICBuZXdWYWwgPSBuZXdWYWwubWFwKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC52YWwobmV3VmFsKS50cmlnZ2VyKCdpbnB1dCcpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgVXRpbHMuUmVtb3ZlRGF0YSh0aGlzLiRjb250YWluZXJbMF0pO1xuICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmUoKTtcblxuICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG5cbiAgICB0aGlzLl9zeW5jQSA9IG51bGw7XG4gICAgdGhpcy5fc3luY1MgPSBudWxsO1xuXG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJy5zZWxlY3QyJyk7XG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsXG4gICAgVXRpbHMuR2V0RGF0YSh0aGlzLiRlbGVtZW50WzBdLCAnb2xkLXRhYmluZGV4JykpO1xuXG4gICAgdGhpcy4kZWxlbWVudFswXS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3QyLWhpZGRlbi1hY2Nlc3NpYmxlJyk7XG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuICAgIFV0aWxzLlJlbW92ZURhdGEodGhpcy4kZWxlbWVudFswXSk7XG4gICAgdGhpcy4kZWxlbWVudC5yZW1vdmVEYXRhKCdzZWxlY3QyJyk7XG5cbiAgICB0aGlzLmRhdGFBZGFwdGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgdGhpcy5kcm9wZG93bi5kZXN0cm95KCk7XG4gICAgdGhpcy5yZXN1bHRzLmRlc3Ryb3koKTtcblxuICAgIHRoaXMuZGF0YUFkYXB0ZXIgPSBudWxsO1xuICAgIHRoaXMuc2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmRyb3Bkb3duID0gbnVsbDtcbiAgICB0aGlzLnJlc3VsdHMgPSBudWxsO1xuICB9O1xuXG4gIFNlbGVjdDIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGNvbnRhaW5lciA9ICQoXG4gICAgICAnPHNwYW4gY2xhc3M9XCJzZWxlY3QyIHNlbGVjdDItY29udGFpbmVyXCI+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cInNlbGVjdGlvblwiPjwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiZHJvcGRvd24td3JhcHBlclwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj4nICtcbiAgICAgICc8L3NwYW4+J1xuICAgICk7XG5cbiAgICAkY29udGFpbmVyLmF0dHIoJ2RpcicsIHRoaXMub3B0aW9ucy5nZXQoJ2RpcicpKTtcblxuICAgIHRoaXMuJGNvbnRhaW5lciA9ICRjb250YWluZXI7XG5cbiAgICB0aGlzLiRjb250YWluZXJbMF0uY2xhc3NMaXN0XG4gICAgICAuYWRkKCdzZWxlY3QyLWNvbnRhaW5lci0tJyArIHRoaXMub3B0aW9ucy5nZXQoJ3RoZW1lJykpO1xuXG4gICAgVXRpbHMuU3RvcmVEYXRhKCRjb250YWluZXJbMF0sICdlbGVtZW50JywgdGhpcy4kZWxlbWVudCk7XG5cbiAgICByZXR1cm4gJGNvbnRhaW5lcjtcbiAgfTtcblxuICByZXR1cm4gU2VsZWN0Mjtcbn0pO1xuXG5TMi5kZWZpbmUoJ2pxdWVyeS1tb3VzZXdoZWVsJyxbXG4gICdqcXVlcnknXG5dLCBmdW5jdGlvbiAoJCkge1xuICAvLyBVc2VkIHRvIHNoaW0galF1ZXJ5Lm1vdXNld2hlZWwgZm9yIG5vbi1mdWxsIGJ1aWxkcy5cbiAgcmV0dXJuICQ7XG59KTtcblxuUzIuZGVmaW5lKCdqcXVlcnkuc2VsZWN0MicsW1xuICAnanF1ZXJ5JyxcbiAgJ2pxdWVyeS1tb3VzZXdoZWVsJyxcblxuICAnLi9zZWxlY3QyL2NvcmUnLFxuICAnLi9zZWxlY3QyL2RlZmF1bHRzJyxcbiAgJy4vc2VsZWN0Mi91dGlscydcbl0sIGZ1bmN0aW9uICgkLCBfLCBTZWxlY3QyLCBEZWZhdWx0cywgVXRpbHMpIHtcbiAgaWYgKCQuZm4uc2VsZWN0MiA9PSBudWxsKSB7XG4gICAgLy8gQWxsIG1ldGhvZHMgdGhhdCBzaG91bGQgcmV0dXJuIHRoZSBlbGVtZW50XG4gICAgdmFyIHRoaXNNZXRob2RzID0gWydvcGVuJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knXTtcblxuICAgICQuZm4uc2VsZWN0MiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZU9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgU2VsZWN0MigkKHRoaXMpLCBpbnN0YW5jZU9wdGlvbnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IFV0aWxzLkdldERhdGEodGhpcywgJ3NlbGVjdDInKTtcblxuICAgICAgICAgIGlmIChpbnN0YW5jZSA9PSBudWxsICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdUaGUgc2VsZWN0MihcXCcnICsgb3B0aW9ucyArICdcXCcpIG1ldGhvZCB3YXMgY2FsbGVkIG9uIGFuICcgK1xuICAgICAgICAgICAgICAnZWxlbWVudCB0aGF0IGlzIG5vdCB1c2luZyBTZWxlY3QyLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0ID0gaW5zdGFuY2Vbb3B0aW9uc10uYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgYmUgcmV0dXJuaW5nIGB0aGlzYFxuICAgICAgICBpZiAodGhpc01ldGhvZHMuaW5kZXhPZihvcHRpb25zKSA+IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBmb3IgU2VsZWN0MjogJyArIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAoJC5mbi5zZWxlY3QyLmRlZmF1bHRzID09IG51bGwpIHtcbiAgICAkLmZuLnNlbGVjdDIuZGVmYXVsdHMgPSBEZWZhdWx0cztcbiAgfVxuXG4gIHJldHVybiBTZWxlY3QyO1xufSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBBTUQgbG9hZGVyIGNvbmZpZ3VyYXRpb24gc28gaXQgY2FuIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGlzIGZpbGVcbiAgcmV0dXJuIHtcbiAgICBkZWZpbmU6IFMyLmRlZmluZSxcbiAgICByZXF1aXJlOiBTMi5yZXF1aXJlXG4gIH07XG59KCkpO1xuXG4gIC8vIEF1dG9sb2FkIHRoZSBqUXVlcnkgYmluZGluZ3NcbiAgLy8gV2Uga25vdyB0aGF0IGFsbCBvZiB0aGUgbW9kdWxlcyBleGlzdCBhYm92ZSB0aGlzLCBzbyB3ZSdyZSBzYWZlXG4gIHZhciBzZWxlY3QyID0gUzIucmVxdWlyZSgnanF1ZXJ5LnNlbGVjdDInKTtcblxuICAvLyBIb2xkIHRoZSBBTUQgbW9kdWxlIHJlZmVyZW5jZXMgb24gdGhlIGpRdWVyeSBmdW5jdGlvbiB0aGF0IHdhcyBqdXN0IGxvYWRlZFxuICAvLyBUaGlzIGFsbG93cyBTZWxlY3QyIHRvIHVzZSB0aGUgaW50ZXJuYWwgbG9hZGVyIG91dHNpZGUgb2YgdGhpcyBmaWxlLCBzdWNoXG4gIC8vIGFzIGluIHRoZSBsYW5ndWFnZSBmaWxlcy5cbiAgalF1ZXJ5LmZuLnNlbGVjdDIuYW1kID0gUzI7XG5cbiAgLy8gUmV0dXJuIHRoZSBTZWxlY3QyIGluc3RhbmNlIGZvciBhbnlvbmUgd2hvIGlzIGltcG9ydGluZyBpdC5cbiAgcmV0dXJuIHNlbGVjdDI7XG59KSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHRyeVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RyeS10by1zdHJpbmcnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNvbnN0cnVjdG9yJyk7XG52YXIgdHJ5VG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZycpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkgaXMgdHJ1ZWBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudCA9PSAnb2JqZWN0JyB8fCBpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArICRTdHJpbmcoYXJndW1lbnQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBQcm90b3R5cGUpIHtcbiAgaWYgKGlzUHJvdG90eXBlT2YoUHJvdG90eXBlLCBpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBUeXBlKGFyZ3VtZW50KSBpcyBPYmplY3RgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNPYmplY3QoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yKCRTdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICAgIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24nKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzdcbiAgcmV0dXJuIFY4X1ZFUlNJT04gPj0gNTEgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBhcnJheS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgIGNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZm9vOiAxIH07XG4gICAgfTtcbiAgICByZXR1cm4gYXJyYXlbTUVUSE9EX05BTUVdKEJvb2xlYW4pLmZvbyAhPT0gMTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuY3VycnlUaGlzKFtdLnNsaWNlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgaXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jb25zdHJ1Y3RvcicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xudmFyICRBcnJheSA9IEFycmF5O1xuXG4vLyBhIHBhcnQgb2YgYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWxBcnJheSkpIHtcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmIChpc0NvbnN0cnVjdG9yKEMpICYmIChDID09PSAkQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGVsc2UgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gJEFycmF5IDogQztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG4vLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoYXJyYXlTcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWxBcnJheSkpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1mcm9tLCBuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IHJldHVybiBmYWxzZTsgfSAvLyB3b3JrYXJvdW5kIG9mIG9sZCBXZWJLaXQgKyBgZXZhbGAgYnVnXG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhlYyhvYmplY3QpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKHt9LnRvU3RyaW5nKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHN0cmluZ1NsaWNlKHRvU3RyaW5nKGl0KSwgOCwgLTEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGNsYXNzb2ZSYXcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSAkT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vd24ta2V5cycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgZXhjZXB0aW9ucykge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkgJiYgIShleGNlcHRpb25zICYmIGhhc093bihleGNlcHRpb25zLCBrZXkpKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5Jyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgbWFrZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWFrZS1idWlsdC1pbicpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gIGlmIChkZXNjcmlwdG9yLmdldCkgbWFrZUJ1aWx0SW4oZGVzY3JpcHRvci5nZXQsIG5hbWUsIHsgZ2V0dGVyOiB0cnVlIH0pO1xuICBpZiAoZGVzY3JpcHRvci5zZXQpIG1ha2VCdWlsdEluKGRlc2NyaXB0b3Iuc2V0LCBuYW1lLCB7IHNldHRlcjogdHJ1ZSB9KTtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5LmYodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBtYWtlQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9tYWtlLWJ1aWx0LWluJyk7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucy5lbnVtZXJhYmxlO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xuICBpZiAoaXNDYWxsYWJsZSh2YWx1ZSkpIG1ha2VCdWlsdEluKHZhbHVlLCBuYW1lLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVHbG9iYWxQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6ICFvcHRpb25zLm5vbkNvbmZpZ3VyYWJsZSxcbiAgICAgIHdyaXRhYmxlOiAhb3B0aW9ucy5ub25Xcml0YWJsZVxuICAgIH0pO1xuICB9IHJldHVybiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbFtrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9PSA3O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZG9jdW1lbnRBbGwgPSB0eXBlb2YgZG9jdW1lbnQgPT0gJ29iamVjdCcgJiYgZG9jdW1lbnQuYWxsO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLUlzSFRNTEREQS1pbnRlcm5hbC1zbG90XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby10eXBlb2YtdW5kZWZpbmVkIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgSVNfSFRNTEREQSA9IHR5cGVvZiBkb2N1bWVudEFsbCA9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudEFsbCAhPT0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWxsOiBkb2N1bWVudEFsbCxcbiAgSVNfSFRNTEREQTogSVNfSFRNTEREQVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID4gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgJFR5cGVFcnJvcignTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgSVNfREVOTyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtaXMtZGVubycpO1xudmFyIElTX05PREUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLW5vZGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhSVNfREVOTyAmJiAhSVNfTk9ERVxuICAmJiB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnXG4gICYmIHR5cGVvZiBkb2N1bWVudCA9PSAnb2JqZWN0JztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBEZW5vIC0tIERlbm8gY2FzZSAqL1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgRGVubyA9PSAnb2JqZWN0JyAmJiBEZW5vICYmIHR5cGVvZiBEZW5vLnZlcnNpb24gPT0gJ29iamVjdCc7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gL2lwYWR8aXBob25lfGlwb2QvaS50ZXN0KHVzZXJBZ2VudCkgJiYgdHlwZW9mIFBlYmJsZSAhPSAndW5kZWZpbmVkJztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZG9zL25vLXZ1bG5lcmFibGUgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSAvKD86aXBhZHxpcGhvbmV8aXBvZCkuKmFwcGxld2Via2l0L2kudGVzdCh1c2VyQWdlbnQpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3NvZihnbG9iYWwucHJvY2VzcykgPT09ICdwcm9jZXNzJztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAvd2ViMHMoPyEuKmNocm9tZSkvaS50ZXN0KHVzZXJBZ2VudCk7XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gJ3VuZGVmaW5lZCcgJiYgU3RyaW5nKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8ICcnO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQnKTtcblxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBEZW5vID0gZ2xvYmFsLkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnMgfHwgRGVubyAmJiBEZW5vLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcnNpb247XG4iLCIndXNlIHN0cmljdCc7XG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHknKTtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcycpO1xudmFyIGlzRm9yY2VkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWZvcmNlZCcpO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgICAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLmRvbnRDYWxsR2V0U2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuICBvcHRpb25zLm5hbWUgICAgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMuZG9udENhbGxHZXRTZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmaW5lQnVpbHRJbih0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBOQVRJVkVfQklORCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZScpO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYXBwbHkgPSBGdW5jdGlvblByb3RvdHlwZS5hcHBseTtcbnZhciBjYWxsID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXJlZmxlY3QgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgUmVmbGVjdCA9PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmFwcGx5IHx8IChOQVRJVkVfQklORCA/IGNhbGwuYmluZChhcHBseSkgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsLmFwcGx5KGFwcGx5LCBhcmd1bWVudHMpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLWNsYXVzZScpO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG52YXIgTkFUSVZFX0JJTkQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUnKTtcblxudmFyIGJpbmQgPSB1bmN1cnJ5VGhpcyh1bmN1cnJ5VGhpcy5iaW5kKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCkge1xuICBhQ2FsbGFibGUoZm4pO1xuICByZXR1cm4gdGhhdCA9PT0gdW5kZWZpbmVkID8gZm4gOiBOQVRJVkVfQklORCA/IGJpbmQoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gc2FmZVxuICB2YXIgdGVzdCA9IChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pLmJpbmQoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiB0eXBlb2YgdGVzdCAhPSAnZnVuY3Rpb24nIHx8IHRlc3QuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTkFUSVZFX0JJTkQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUnKTtcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IGNhbGwuYmluZChjYWxsKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwuYXBwbHkoY2FsbCwgYXJndW1lbnRzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciBFWElTVFMgPSBoYXNPd24oRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJyk7XG4vLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIChmdW5jdGlvbiBzb21ldGhpbmcoKSB7IC8qIGVtcHR5ICovIH0pLm5hbWUgPT09ICdzb21ldGhpbmcnO1xudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTIHx8IChERVNDUklQVE9SUyAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRVhJU1RTOiBFWElTVFMsXG4gIFBST1BFUjogUFJPUEVSLFxuICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgbWV0aG9kKSB7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuICAgIHJldHVybiB1bmN1cnJ5VGhpcyhhQ2FsbGFibGUoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIGtleSlbbWV0aG9kXSkpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNsYXNzb2ZSYXcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgLy8gTmFzaG9ybiBidWc6XG4gIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzExMjhcbiAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTEzMFxuICBpZiAoY2xhc3NvZlJhdyhmbikgPT09ICdGdW5jdGlvbicpIHJldHVybiB1bmN1cnJ5VGhpcyhmbik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBjYWxsID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcbnZhciB1bmN1cnJ5VGhpc1dpdGhCaW5kID0gTkFUSVZFX0JJTkQgJiYgRnVuY3Rpb25Qcm90b3R5cGUuYmluZC5iaW5kKGNhbGwsIGNhbGwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gdW5jdXJyeVRoaXNXaXRoQmluZCA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKGdsb2JhbFtuYW1lc3BhY2VdKSA6IGdsb2JhbFtuYW1lc3BhY2VdICYmIGdsb2JhbFtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIGdldE1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtbWV0aG9kJyk7XG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc051bGxPclVuZGVmaW5lZChpdCkpIHJldHVybiBnZXRNZXRob2QoaXQsIElURVJBVE9SKVxuICAgIHx8IGdldE1ldGhvZChpdCwgJ0BAaXRlcmF0b3InKVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdHJ5VG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZycpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50LCB1c2luZ0l0ZXJhdG9yKSB7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZ2V0SXRlcmF0b3JNZXRob2QoYXJndW1lbnQpIDogdXNpbmdJdGVyYXRvcjtcbiAgaWYgKGFDYWxsYWJsZShpdGVyYXRvck1ldGhvZCkpIHJldHVybiBhbk9iamVjdChjYWxsKGl0ZXJhdG9yTWV0aG9kLCBhcmd1bWVudCkpO1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkJyk7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQoZnVuYykgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUoZnVuYyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbm1vZHVsZS5leHBvcnRzID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcbiAgY2hlY2sodHlwZW9mIHRoaXMgPT0gJ29iamVjdCcgJiYgdGhpcykgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QoaXQpLCBrZXkpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0ge307XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGUgLS0gc2FmZVxuICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBjb25zb2xlLmVycm9yKGEpIDogY29uc29sZS5lcnJvcihhLCBiKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG5cbi8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPT0gNztcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzKCcnLnNwbGl0KTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3Ncbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gISRPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mKGl0KSA9PT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogJE9iamVjdChpdCk7XG59IDogJE9iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgc3RvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMoRnVuY3Rpb24udG9TdHJpbmcpO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUoc3RvcmUuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZS5pbnNwZWN0U291cmNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWFrLW1hcC1iYXNpYy1kZXRlY3Rpb24nKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtYXNzaWduIC0tIHByb3RvdHlwZSBtZXRob2RzIHByb3RlY3Rpb24gKi9cbiAgc3RvcmUuZ2V0ID0gc3RvcmUuZ2V0O1xuICBzdG9yZS5oYXMgPSBzdG9yZS5oYXM7XG4gIHN0b3JlLnNldCA9IHN0b3JlLnNldDtcbiAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWFzc2lnbiAtLSBwcm90b3R5cGUgbWV0aG9kcyBwcm90ZWN0aW9uICovXG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoc3RvcmUuaGFzKGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgc3RvcmUuc2V0KGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gc3RvcmUuZ2V0KGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHN0b3JlLmhhcyhpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24oaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24oaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZVtJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xuXG4vLyBgSXNBcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1pc2FycmF5IC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZ3VtZW50KSB7XG4gIHJldHVybiBjbGFzc29mKGFyZ3VtZW50KSA9PT0gJ0FycmF5Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRvY3VtZW50QWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWFsbCcpO1xuXG52YXIgZG9jdW1lbnRBbGwgPSAkZG9jdW1lbnRBbGwuYWxsO1xuXG4vLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbm1vZHVsZS5leHBvcnRzID0gJGRvY3VtZW50QWxsLklTX0hUTUxEREEgPyBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50ID09PSBkb2N1bWVudEFsbDtcbn0gOiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgZW1wdHkgPSBbXTtcbnZhciBjb25zdHJ1Y3QgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIGNvbnN0cnVjdG9yUmVnRXhwID0gL15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLztcbnZhciBleGVjID0gdW5jdXJyeVRoaXMoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC50ZXN0KG5vb3ApO1xuXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0cnVjdChub29wLCBlbXB0eSwgYXJndW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGlzQ29uc3RydWN0b3JMZWdhY3kgPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChjbGFzc29mKGFyZ3VtZW50KSkge1xuICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZShhcmd1bWVudCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5pc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlO1xuXG4vLyBgSXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3Jcbm1vZHVsZS5leHBvcnRzID0gIWNvbnN0cnVjdCB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsZWQ7XG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihPYmplY3QpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlOyB9KVxuICAgIHx8IGNhbGxlZDtcbn0pID8gaXNDb25zdHJ1Y3RvckxlZ2FjeSA6IGlzQ29uc3RydWN0b3JNb2Rlcm47XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT09IE5BVElWRSA/IGZhbHNlXG4gICAgOiBpc0NhbGxhYmxlKGRldGVjdGlvbikgPyBmYWlscyhkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZC5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZC5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZC5QT0xZRklMTCA9ICdQJztcblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZvcmNlZDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIHdlIGNhbid0IHVzZSBqdXN0IGBpdCA9PSBudWxsYCBzaW5jZSBvZiBgZG9jdW1lbnQuYWxsYCBzcGVjaWFsIGNhc2Vcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtSXNIVE1MRERBLWludGVybmFsLXNsb3QtYWVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IG51bGwgfHwgaXQgPT09IHVuZGVmaW5lZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyICRkb2N1bWVudEFsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1hbGwnKTtcblxudmFyIGRvY3VtZW50QWxsID0gJGRvY3VtZW50QWxsLmFsbDtcblxubW9kdWxlLmV4cG9ydHMgPSAkZG9jdW1lbnRBbGwuSVNfSFRNTEREQSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlKGl0KSB8fCBpdCA9PT0gZG9jdW1lbnRBbGw7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUoaXQpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaXNQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mJyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQnKTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbm1vZHVsZS5leHBvcnRzID0gVVNFX1NZTUJPTF9BU19VSUQgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluKCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZigkU3ltYm9sLnByb3RvdHlwZSwgJE9iamVjdChpdCkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRyeVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RyeS10by1zdHJpbmcnKTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UnKTtcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciBnZXRJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3InKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1jbG9zZScpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcbiAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG52YXIgUmVzdWx0UHJvdG90eXBlID0gUmVzdWx0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIHVuYm91bmRGdW5jdGlvbiwgb3B0aW9ucykge1xuICB2YXIgdGhhdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aGF0O1xuICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcbiAgdmFyIElTX1JFQ09SRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19SRUNPUkQpO1xuICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xuICB2YXIgZm4gPSBiaW5kKHVuYm91bmRGdW5jdGlvbiwgdGhhdCk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgY29uZGl0aW9uKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QodmFsdWUpO1xuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgfSByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZSwgc3RvcCkgOiBmbih2YWx1ZSk7XG4gIH07XG5cbiAgaWYgKElTX1JFQ09SRCkge1xuICAgIGl0ZXJhdG9yID0gaXRlcmFibGUuaXRlcmF0b3I7XG4gIH0gZWxzZSBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICBpZiAoIWl0ZXJGbikgdGhyb3cgbmV3ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKGl0ZXJhYmxlKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEZuKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgaXNQcm90b3R5cGVPZihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbiAgICB9XG4gICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihpdGVyYWJsZSwgaXRlckZuKTtcbiAgfVxuXG4gIG5leHQgPSBJU19SRUNPUkQgPyBpdGVyYWJsZS5uZXh0IDogaXRlcmF0b3IubmV4dDtcbiAgd2hpbGUgKCEoc3RlcCA9IGNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGNhbGxGbihzdGVwLnZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgaXNQcm90b3R5cGVPZihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBnZXRNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LW1ldGhvZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwga2luZCwgdmFsdWUpIHtcbiAgdmFyIGlubmVyUmVzdWx0LCBpbm5lckVycm9yO1xuICBhbk9iamVjdChpdGVyYXRvcik7XG4gIHRyeSB7XG4gICAgaW5uZXJSZXN1bHQgPSBnZXRNZXRob2QoaXRlcmF0b3IsICdyZXR1cm4nKTtcbiAgICBpZiAoIWlubmVyUmVzdWx0KSB7XG4gICAgICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlubmVyUmVzdWx0ID0gY2FsbChpbm5lclJlc3VsdCwgaXRlcmF0b3IpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlubmVyRXJyb3IgPSB0cnVlO1xuICAgIGlubmVyUmVzdWx0ID0gZXJyb3I7XG4gIH1cbiAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICBpZiAoaW5uZXJFcnJvcikgdGhyb3cgaW5uZXJSZXN1bHQ7XG4gIGFuT2JqZWN0KGlubmVyUmVzdWx0KTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0ge307XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZScpLkNPTkZJR1VSQUJMRTtcbnZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xuXG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyICRTdHJpbmcgPSBTdHJpbmc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG52YXIgam9pbiA9IHVuY3VycnlUaGlzKFtdLmpvaW4pO1xuXG52YXIgQ09ORklHVVJBQkxFX0xFTkdUSCA9IERFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdsZW5ndGgnLCB7IHZhbHVlOiA4IH0pLmxlbmd0aCAhPT0gODtcbn0pO1xuXG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbnZhciBtYWtlQnVpbHRJbiA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChzdHJpbmdTbGljZSgkU3RyaW5nKG5hbWUpLCAwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIHJlcGxhY2UoJFN0cmluZyhuYW1lKSwgL15TeW1ib2xcXCgoW14pXSopXFwpLywgJyQxJykgKyAnXSc7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nZXR0ZXIpIG5hbWUgPSAnZ2V0ICcgKyBuYW1lO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9ICdzZXQgJyArIG5hbWU7XG4gIGlmICghaGFzT3duKHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSkge1xuICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkodmFsdWUsICduYW1lJywgeyB2YWx1ZTogbmFtZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIGVsc2UgdmFsdWUubmFtZSA9IG5hbWU7XG4gIH1cbiAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgJ2FyaXR5JykgJiYgdmFsdWUubGVuZ3RoICE9PSBvcHRpb25zLmFyaXR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkodmFsdWUsICdwcm90b3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAvLyBpbiBWOCB+IENocm9tZSA1MywgcHJvdG90eXBlcyBvZiBzb21lIG1ldGhvZHMsIGxpa2UgYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgLCBhcmUgbm9uLXdyaXRhYmxlXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gIGlmICghaGFzT3duKHN0YXRlLCAnc291cmNlJykpIHtcbiAgICBzdGF0ZS5zb3VyY2UgPSBqb2luKFRFTVBMQVRFLCB0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0ZW5kLW5hdGl2ZSAtLSByZXF1aXJlZFxuRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gbWFrZUJ1aWx0SW4oZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IGluc3BlY3RTb3VyY2UodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuLy8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tbWF0aC10cnVuYyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gdHJ1bmMoeCkge1xuICB2YXIgbiA9ICt4O1xuICByZXR1cm4gKG4gPiAwID8gZmxvb3IgOiBjZWlsKShuKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90YXNrJykuc2V0O1xudmFyIFF1ZXVlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3F1ZXVlJyk7XG52YXIgSVNfSU9TID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1pb3MnKTtcbnZhciBJU19JT1NfUEVCQkxFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1pb3MtcGViYmxlJyk7XG52YXIgSVNfV0VCT1NfV0VCS0lUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy13ZWJvcy13ZWJraXQnKTtcbnZhciBJU19OT0RFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1ub2RlJyk7XG5cbnZhciBNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbi8vIE5vZGUuanMgMTEgc2hvd3MgRXhwZXJpbWVudGFsV2FybmluZyBvbiBnZXR0aW5nIGBxdWV1ZU1pY3JvdGFza2BcbnZhciBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsLCAncXVldWVNaWNyb3Rhc2snKTtcbnZhciBtaWNyb3Rhc2sgPSBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgJiYgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yLnZhbHVlO1xudmFyIG5vdGlmeSwgdG9nZ2xlLCBub2RlLCBwcm9taXNlLCB0aGVuO1xuXG4vLyBtb2Rlcm4gZW5naW5lcyBoYXZlIHF1ZXVlTWljcm90YXNrIG1ldGhvZFxuaWYgKCFtaWNyb3Rhc2spIHtcbiAgdmFyIHF1ZXVlID0gbmV3IFF1ZXVlKCk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChJU19OT0RFICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGZuID0gcXVldWUuZ2V0KCkpIHRyeSB7XG4gICAgICBmbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAocXVldWUuaGVhZCkgbm90aWZ5KCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICAvLyBhbHNvIGV4Y2VwdCBXZWJPUyBXZWJraXQgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg5OFxuICBpZiAoIUlTX0lPUyAmJiAhSVNfTk9ERSAmJiAhSVNfV0VCT1NfV0VCS0lUICYmIE11dGF0aW9uT2JzZXJ2ZXIgJiYgZG9jdW1lbnQpIHtcbiAgICB0b2dnbGUgPSB0cnVlO1xuICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmICghSVNfSU9TX1BFQkJMRSAmJiBQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIC8vIHdvcmthcm91bmQgb2YgV2ViS2l0IH4gaU9TIFNhZmFyaSAxMC4xIGJ1Z1xuICAgIHByb21pc2UuY29uc3RydWN0b3IgPSBQcm9taXNlO1xuICAgIHRoZW4gPSBiaW5kKHByb21pc2UudGhlbiwgcHJvbWlzZSk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gTm9kZS5qcyB3aXRob3V0IHByb21pc2VzXG4gIH0gZWxzZSBpZiAoSVNfTk9ERSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ2VcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgLy8gYHdlYnBhY2tgIGRldiBzZXJ2ZXIgYnVnIG9uIElFIGdsb2JhbCBtZXRob2RzIC0gdXNlIGJpbmQoZm4sIGdsb2JhbClcbiAgICBtYWNyb3Rhc2sgPSBiaW5kKG1hY3JvdGFzaywgZ2xvYmFsKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtYWNyb3Rhc2soZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICBtaWNyb3Rhc2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAoIXF1ZXVlLmhlYWQpIG5vdGlmeSgpO1xuICAgIHF1ZXVlLmFkZChmbik7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWljcm90YXNrO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IG5ldyAkVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhQ2FsbGFibGUocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUNhbGxhYmxlKHJlamVjdCk7XG59O1xuXG4vLyBgTmV3UHJvbWlzZUNhcGFiaWxpdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1uZXdwcm9taXNlY2FwYWJpbGl0eVxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1ZycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5Jyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVOVU1FUkFCTEUgPSAnZW51bWVyYWJsZSc7XG52YXIgQ09ORklHVVJBQkxFID0gJ2NvbmZpZ3VyYWJsZSc7XG52YXIgV1JJVEFCTEUgPSAnd3JpdGFibGUnO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/IFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XG4gICAgdmFyIGN1cnJlbnQgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnRbV1JJVEFCTEVdKSB7XG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogQ09ORklHVVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0NPTkZJR1VSQUJMRV0gOiBjdXJyZW50W0NPTkZJR1VSQUJMRV0sXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9IHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG59IDogJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBuZXcgJFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXknKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXNPd24oTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoIWNhbGwocHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiwgTywgUCksIE9bUF0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG5cbnZhciBoaWRkZW5LZXlzID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmN1cnJ5VGhpcyh7fS5pc1Byb3RvdHlwZU9mKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093bihoaWRkZW5LZXlzLCBrZXkpICYmIGhhc093bihPLCBrZXkpICYmIHB1c2gocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxuZXhwb3J0cy5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAtLSBzYWZlICovXG52YXIgdW5jdXJyeVRoaXNBY2Nlc3NvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtYWNjZXNzb3InKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LXNldHByb3RvdHlwZW9mIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgc2V0dGVyID0gdW5jdXJyeVRoaXNBY2Nlc3NvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJywgJ3NldCcpO1xuICAgIHNldHRlcih0ZXN0LCBbXSk7XG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgYW5PYmplY3QoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoaXNDYWxsYWJsZShmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlLCB2YWx1ZTogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIHZhbHVlOiBlcnJvciB9O1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcHJvbWlzZS1uYXRpdmUtY29uc3RydWN0b3InKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIElTX0JST1dTRVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLWJyb3dzZXInKTtcbnZhciBJU19ERU5PID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1kZW5vJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbicpO1xuXG52YXIgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciBTVUJDTEFTU0lORyA9IGZhbHNlO1xudmFyIE5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCA9IGlzQ2FsbGFibGUoZ2xvYmFsLlByb21pc2VSZWplY3Rpb25FdmVudCk7XG5cbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiA9IGlzRm9yY2VkKCdQcm9taXNlJywgZnVuY3Rpb24gKCkge1xuICB2YXIgUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgPSBpbnNwZWN0U291cmNlKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvcik7XG4gIHZhciBHTE9CQUxfQ09SRV9KU19QUk9NSVNFID0gUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgIT09IFN0cmluZyhOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IpO1xuICAvLyBWOCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAvLyBXZSBjYW4ndCBkZXRlY3QgaXQgc3luY2hyb25vdXNseSwgc28ganVzdCBjaGVjayB2ZXJzaW9uc1xuICBpZiAoIUdMT0JBTF9DT1JFX0pTX1BST01JU0UgJiYgVjhfVkVSU0lPTiA9PT0gNjYpIHJldHVybiB0cnVlO1xuICAvLyBXZSBuZWVkIFByb21pc2UjeyBjYXRjaCwgZmluYWxseSB9IGluIHRoZSBwdXJlIHZlcnNpb24gZm9yIHByZXZlbnRpbmcgcHJvdG90eXBlIHBvbGx1dGlvblxuICBpZiAoSVNfUFVSRSAmJiAhKE5hdGl2ZVByb21pc2VQcm90b3R5cGVbJ2NhdGNoJ10gJiYgTmF0aXZlUHJvbWlzZVByb3RvdHlwZVsnZmluYWxseSddKSkgcmV0dXJuIHRydWU7XG4gIC8vIFdlIGNhbid0IHVzZSBAQHNwZWNpZXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG4gIGlmICghVjhfVkVSU0lPTiB8fCBWOF9WRVJTSU9OIDwgNTEgfHwgIS9uYXRpdmUgY29kZS8udGVzdChQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSkpIHtcbiAgICAvLyBEZXRlY3QgY29ycmVjdG5lc3Mgb2Ygc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gbmV3IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKDEpOyB9KTtcbiAgICB2YXIgRmFrZVByb21pc2UgPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG4gICAgfTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yID0ge307XG4gICAgY29uc3RydWN0b3JbU1BFQ0lFU10gPSBGYWtlUHJvbWlzZTtcbiAgICBTVUJDTEFTU0lORyA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gICAgaWYgKCFTVUJDTEFTU0lORykgcmV0dXJuIHRydWU7XG4gIC8vIFVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgfSByZXR1cm4gIUdMT0JBTF9DT1JFX0pTX1BST01JU0UgJiYgKElTX0JST1dTRVIgfHwgSVNfREVOTykgJiYgIU5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ09OU1RSVUNUT1I6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SLFxuICBSRUpFQ1RJT05fRVZFTlQ6IE5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCxcbiAgU1VCQ0xBU1NJTkc6IFNVQkNMQVNTSU5HXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuUHJvbWlzZTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2UtbmF0aXZlLWNvbnN0cnVjdG9yJyk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbicpO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2UtY29uc3RydWN0b3ItZGV0ZWN0aW9uJykuQ09OU1RSVUNUT1I7XG5cbm1vZHVsZS5leHBvcnRzID0gRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yLmFsbChpdGVyYWJsZSkudGhlbih1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgdGhpcy50YWlsID0gbnVsbDtcbn07XG5cblF1ZXVlLnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBlbnRyeSA9IHsgaXRlbTogaXRlbSwgbmV4dDogbnVsbCB9O1xuICAgIHZhciB0YWlsID0gdGhpcy50YWlsO1xuICAgIGlmICh0YWlsKSB0YWlsLm5leHQgPSBlbnRyeTtcbiAgICBlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmhlYWQ7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaGVhZCA9IGVudHJ5Lm5leHQ7XG4gICAgICBpZiAobmV4dCA9PT0gbnVsbCkgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHJldHVybiBlbnRyeS5pdGVtO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoaXQpKSB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi1hY2Nlc3NvcicpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUpIHtcbiAgdmFyIENvbnN0cnVjdG9yID0gZ2V0QnVpbHRJbihDT05TVFJVQ1RPUl9OQU1FKTtcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgQ29uc3RydWN0b3IgJiYgIUNvbnN0cnVjdG9yW1NQRUNJRVNdKSB7XG4gICAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKENvbnN0cnVjdG9yLCBTUEVDSUVTLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB9KTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBUQUcsIFNUQVRJQykge1xuICBpZiAodGFyZ2V0ICYmICFTVEFUSUMpIHRhcmdldCA9IHRhcmdldC5wcm90b3R5cGU7XG4gIGlmICh0YXJnZXQgJiYgIWhhc093bih0YXJnZXQsIFRPX1NUUklOR19UQUcpKSB7XG4gICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xuXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eScpO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShTSEFSRUQsIHt9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjM0LjAnLFxuICBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMyBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjM0LjAvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgYUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY29uc3RydWN0b3InKTtcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG4vLyBgU3BlY2llc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgaXNOdWxsT3JVbmRlZmluZWQoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFDb25zdHJ1Y3RvcihTKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBWOF9WRVJTSU9OID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbnZhciAkU3RyaW5nID0gZ2xvYmFsLlN0cmluZztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3Rpbmdcbm1vZHVsZS5leHBvcnRzID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woJ3N5bWJvbCBkZXRlY3Rpb24nKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICAvLyBuYjogRG8gbm90IGNhbGwgYFN0cmluZ2AgZGlyZWN0bHkgdG8gYXZvaWQgdGhpcyBiZWluZyBvcHRpbWl6ZWQgb3V0IHRvIGBzeW1ib2wrJydgIHdoaWNoIHdpbGwsXG4gIC8vIG9mIGNvdXJzZSwgZmFpbC5cbiAgcmV0dXJuICEkU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OICYmIFY4X1ZFUlNJT04gPCA0MTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBhcHBseSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1hcHBseScpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBhcnJheVNsaWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNsaWNlJyk7XG52YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3ZhbGlkYXRlLWFyZ3VtZW50cy1sZW5ndGgnKTtcbnZhciBJU19JT1MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLWlvcycpO1xudmFyIElTX05PREUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLW5vZGUnKTtcblxudmFyIHNldCA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXIgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIEZ1bmN0aW9uID0gZ2xvYmFsLkZ1bmN0aW9uO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIFN0cmluZyA9IGdsb2JhbC5TdHJpbmc7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciAkbG9jYXRpb24sIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xuXG5mYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIERlbm8gdGhyb3dzIGEgUmVmZXJlbmNlRXJyb3Igb24gYGxvY2F0aW9uYCBhY2Nlc3Mgd2l0aG91dCBgLS1sb2NhdGlvbmAgZmxhZ1xuICAkbG9jYXRpb24gPSBnbG9iYWwubG9jYXRpb247XG59KTtcblxudmFyIHJ1biA9IGZ1bmN0aW9uIChpZCkge1xuICBpZiAoaGFzT3duKHF1ZXVlLCBpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xuXG52YXIgcnVubmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcnVuKGlkKTtcbiAgfTtcbn07XG5cbnZhciBldmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bihldmVudC5kYXRhKTtcbn07XG5cbnZhciBnbG9iYWxQb3N0TWVzc2FnZURlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gIC8vIG9sZCBlbmdpbmVzIGhhdmUgbm90IGxvY2F0aW9uLm9yaWdpblxuICBnbG9iYWwucG9zdE1lc3NhZ2UoU3RyaW5nKGlkKSwgJGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArICRsb2NhdGlvbi5ob3N0KTtcbn07XG5cbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0IHx8ICFjbGVhcikge1xuICBzZXQgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoaGFuZGxlcikge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBmbiA9IGlzQ2FsbGFibGUoaGFuZGxlcikgPyBoYW5kbGVyIDogRnVuY3Rpb24oaGFuZGxlcik7XG4gICAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwcGx5KGZuLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKElTX05PREUpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhydW5uZXIoaWQpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgLy8gZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82MjRcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCAmJiAhSVNfSU9TKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZXZlbnRMaXN0ZW5lcjtcbiAgICBkZWZlciA9IGJpbmQocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKFxuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmXG4gICAgaXNDYWxsYWJsZShnbG9iYWwucG9zdE1lc3NhZ2UpICYmXG4gICAgIWdsb2JhbC5pbXBvcnRTY3JpcHRzICYmXG4gICAgJGxvY2F0aW9uICYmICRsb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJlxuICAgICFmYWlscyhnbG9iYWxQb3N0TWVzc2FnZURlZmVyKVxuICApIHtcbiAgICBkZWZlciA9IGdsb2JhbFBvc3RNZXNzYWdlRGVmZXI7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChydW5uZXIoaWQpLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldCxcbiAgY2xlYXI6IGNsZWFyXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXJPckluZmluaXR5KGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0cnVuYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9tYXRoLXRydW5jJyk7XG5cbi8vIGBUb0ludGVnZXJPckluZmluaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2Vyb3JpbmZpbml0eVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIG51bWJlciA9ICthcmd1bWVudDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiB0cnVuYyhudW1iZXIpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHknKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcbnZhciBnZXRNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LW1ldGhvZCcpO1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIGlmICghaXNPYmplY3QoaW5wdXQpIHx8IGlzU3ltYm9sKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kKGlucHV0LCBUT19QUklNSVRJVkUpO1xuICB2YXIgcmVzdWx0O1xuICBpZiAoZXhvdGljVG9QcmltKSB7XG4gICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICByZXN1bHQgPSBjYWxsKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QocmVzdWx0KSB8fCBpc1N5bWJvbChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiAkU3RyaW5nKGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG52YXIgdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcygxLjAudG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZygrK2lkICsgcG9zdGZpeCwgMzYpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9TWU1CT0xcbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9PSA0Mjtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhc3NlZCwgcmVxdWlyZWQpIHtcbiAgaWYgKHBhc3NlZCA8IHJlcXVpcmVkKSB0aHJvdyBuZXcgJFR5cGVFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgcmV0dXJuIHBhc3NlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0NhbGxhYmxlKFdlYWtNYXApICYmIC9uYXRpdmUgY29kZS8udGVzdChTdHJpbmcoV2Vha01hcCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uJyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQnKTtcblxudmFyIFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbFsnZm9yJ10gfHwgU3ltYm9sIDogU3ltYm9sICYmIFN5bWJvbC53aXRob3V0U2V0dGVyIHx8IHVpZDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhc093bihXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpKSB7XG4gICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gTkFUSVZFX1NZTUJPTCAmJiBoYXNPd24oU3ltYm9sLCBuYW1lKVxuICAgICAgPyBTeW1ib2xbbmFtZV1cbiAgICAgIDogY3JlYXRlV2VsbEtub3duU3ltYm9sKCdTeW1ib2wuJyArIG5hbWUpO1xuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UnKTtcbnZhciBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9lcy1ub3QtZXhjZWVkLXNhZmUtaW50ZWdlcicpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBWOF9WRVJTSU9OID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uJyk7XG5cbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRSA9IHdlbGxLbm93blN5bWJvbCgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG5cbi8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUID0gVjhfVkVSU0lPTiA+PSA1MSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgYXJyYXlbSVNfQ09OQ0FUX1NQUkVBREFCTEVdID0gZmFsc2U7XG4gIHJldHVybiBhcnJheS5jb25jYXQoKVswXSAhPT0gYXJyYXk7XG59KTtcblxudmFyIGlzQ29uY2F0U3ByZWFkYWJsZSA9IGZ1bmN0aW9uIChPKSB7XG4gIGlmICghaXNPYmplY3QoTykpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNwcmVhZGFibGUgPSBPW0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgcmV0dXJuIHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkoTyk7XG59O1xuXG52YXIgRk9SQ0VEID0gIUlTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgfHwgIWFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2NvbmNhdCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5jb25jYXRcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBpc0NvbmNhdFNwcmVhZGFibGUgYW5kIEBAc3BlY2llc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGFyaXR5OiAxLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIGNvbmNhdDogZnVuY3Rpb24gY29uY2F0KGFyZykge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgdmFyIG4gPSAwO1xuICAgIHZhciBpLCBrLCBsZW5ndGgsIGxlbiwgRTtcbiAgICBmb3IgKGkgPSAtMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBFID0gaSA9PT0gLTEgPyBPIDogYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKGlzQ29uY2F0U3ByZWFkYWJsZShFKSkge1xuICAgICAgICBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZShFKTtcbiAgICAgICAgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyKG4gKyBsZW4pO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyssIG4rKykgaWYgKGsgaW4gRSkgY3JlYXRlUHJvcGVydHkoQSwgbiwgRVtrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIobiArIDEpO1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShBLCBuKyssIEUpO1xuICAgICAgfVxuICAgIH1cbiAgICBBLmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQnKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcnKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAoIVRPX1NUUklOR19UQUdfU1VQUE9SVCkge1xuICBkZWZpbmVCdWlsdEluKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIHRvU3RyaW5nLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGVyZm9ybScpO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0ZScpO1xudmFyIFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2Utc3RhdGljcy1pbmNvcnJlY3QtaXRlcmF0aW9uJyk7XG5cbi8vIGBQcm9taXNlLmFsbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UuYWxsXG4kKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04gfSwge1xuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUoQy5yZXNvbHZlKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgY2FsbCgkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm9taXNlLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpLkNPTlNUUlVDVE9SO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm9taXNlLW5hdGl2ZS1jb25zdHJ1Y3RvcicpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG5cbnZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbi8vIGBQcm9taXNlLnByb3RvdHlwZS5jYXRjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmNhdGNoXG4kKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SLCByZWFsOiB0cnVlIH0sIHtcbiAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gIH1cbn0pO1xuXG4vLyBtYWtlcyBzdXJlIHRoYXQgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJcyBgUHJvbWlzZSNjYXRjaGAgcHJvcGVybHkgd29ya3Mgd2l0aCBwYXRjaGVkIGBQcm9taXNlI3RoZW5gXG5pZiAoIUlTX1BVUkUgJiYgaXNDYWxsYWJsZShOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IpKSB7XG4gIHZhciBtZXRob2QgPSBnZXRCdWlsdEluKCdQcm9taXNlJykucHJvdG90eXBlWydjYXRjaCddO1xuICBpZiAoTmF0aXZlUHJvbWlzZVByb3RvdHlwZVsnY2F0Y2gnXSAhPT0gbWV0aG9kKSB7XG4gICAgZGVmaW5lQnVpbHRJbihOYXRpdmVQcm9taXNlUHJvdG90eXBlLCAnY2F0Y2gnLCBtZXRob2QsIHsgdW5zYWZlOiB0cnVlIH0pO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBJU19OT0RFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS1pcy1ub2RlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXMnKTtcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21pY3JvdGFzaycpO1xudmFyIGhvc3RSZXBvcnRFcnJvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaG9zdC1yZXBvcnQtZXJyb3JzJyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wZXJmb3JtJyk7XG52YXIgUXVldWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcXVldWUnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2UtbmF0aXZlLWNvbnN0cnVjdG9yJyk7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2UtY29uc3RydWN0b3ItZGV0ZWN0aW9uJyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uUkVKRUNUSU9OX0VWRU5UO1xudmFyIE5BVElWRV9QUk9NSVNFX1NVQkNMQVNTSU5HID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlNVQkNMQVNTSU5HO1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgJiYgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbnZhciBQcm9taXNlQ29uc3RydWN0b3IgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3I7XG52YXIgUHJvbWlzZVByb3RvdHlwZSA9IE5hdGl2ZVByb21pc2VQcm90b3R5cGU7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xudmFyIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5O1xuXG52YXIgRElTUEFUQ0hfRVZFTlQgPSAhIShkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFdmVudCAmJiBnbG9iYWwuZGlzcGF0Y2hFdmVudCk7XG52YXIgVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xudmFyIFJFSkVDVElPTl9IQU5ETEVEID0gJ3JlamVjdGlvbmhhbmRsZWQnO1xudmFyIFBFTkRJTkcgPSAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xudmFyIEhBTkRMRUQgPSAxO1xudmFyIFVOSEFORExFRCA9IDI7XG5cbnZhciBJbnRlcm5hbCwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFByb21pc2VXcmFwcGVyLCBuYXRpdmVUaGVuO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiBpc0NhbGxhYmxlKHRoZW4gPSBpdC50aGVuKSA/IHRoZW4gOiBmYWxzZTtcbn07XG5cbnZhciBjYWxsUmVhY3Rpb24gPSBmdW5jdGlvbiAocmVhY3Rpb24sIHN0YXRlKSB7XG4gIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICB2YXIgb2sgPSBzdGF0ZS5zdGF0ZSA9PT0gRlVMRklMTEVEO1xuICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgdHJ5IHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaWYgKCFvaykge1xuICAgICAgICBpZiAoc3RhdGUucmVqZWN0aW9uID09PSBVTkhBTkRMRUQpIG9uSGFuZGxlVW5oYW5kbGVkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUucmVqZWN0aW9uID0gSEFORExFRDtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIGNhbiB0aHJvd1xuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgIGNhbGwodGhlbiwgcmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgfVxufTtcblxudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChzdGF0ZSwgaXNSZWplY3QpIHtcbiAgaWYgKHN0YXRlLm5vdGlmaWVkKSByZXR1cm47XG4gIHN0YXRlLm5vdGlmaWVkID0gdHJ1ZTtcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVhY3Rpb25zID0gc3RhdGUucmVhY3Rpb25zO1xuICAgIHZhciByZWFjdGlvbjtcbiAgICB3aGlsZSAocmVhY3Rpb24gPSByZWFjdGlvbnMuZ2V0KCkpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5ub3RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhc3RhdGUucmVqZWN0aW9uKSBvblVuaGFuZGxlZChzdGF0ZSk7XG4gIH0pO1xufTtcblxudmFyIGRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgcHJvbWlzZSwgcmVhc29uKSB7XG4gIHZhciBldmVudCwgaGFuZGxlcjtcbiAgaWYgKERJU1BBVENIX0VWRU5UKSB7XG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5wcm9taXNlID0gcHJvbWlzZTtcbiAgICBldmVudC5yZWFzb24gPSByZWFzb247XG4gICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsIGZhbHNlLCB0cnVlKTtcbiAgICBnbG9iYWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gZWxzZSBldmVudCA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiByZWFzb24gfTtcbiAgaWYgKCFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgJiYgKGhhbmRsZXIgPSBnbG9iYWxbJ29uJyArIG5hbWVdKSkgaGFuZGxlcihldmVudCk7XG4gIGVsc2UgaWYgKG5hbWUgPT09IFVOSEFORExFRF9SRUpFQ1RJT04pIGhvc3RSZXBvcnRFcnJvcnMoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHJlYXNvbik7XG59O1xuXG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgY2FsbCh0YXNrLCBnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHN0YXRlLmZhY2FkZTtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKElTX1VOSEFORExFRCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChJU19OT0RFKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFVOSEFORExFRF9SRUpFQ1RJT04sIHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHN0YXRlLnJlamVjdGlvbiA9IElTX05PREUgfHwgaXNVbmhhbmRsZWQoc3RhdGUpID8gVU5IQU5ETEVEIDogSEFORExFRDtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRocm93IHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5yZWplY3Rpb24gIT09IEhBTkRMRUQgJiYgIXN0YXRlLnBhcmVudDtcbn07XG5cbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBjYWxsKHRhc2ssIGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gc3RhdGUuZmFjYWRlO1xuICAgIGlmIChJU19OT0RFKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChSRUpFQ1RJT05fSEFORExFRCwgcHJvbWlzZSwgc3RhdGUudmFsdWUpO1xuICB9KTtcbn07XG5cbnZhciBiaW5kID0gZnVuY3Rpb24gKGZuLCBzdGF0ZSwgdW53cmFwKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBmbihzdGF0ZSwgdmFsdWUsIHVud3JhcCk7XG4gIH07XG59O1xuXG52YXIgaW50ZXJuYWxSZWplY3QgPSBmdW5jdGlvbiAoc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIGlmICh1bndyYXApIHN0YXRlID0gdW53cmFwO1xuICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICBzdGF0ZS5zdGF0ZSA9IFJFSkVDVEVEO1xuICBub3RpZnkoc3RhdGUsIHRydWUpO1xufTtcblxudmFyIGludGVybmFsUmVzb2x2ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHRyeSB7XG4gICAgaWYgKHN0YXRlLmZhY2FkZSA9PT0gdmFsdWUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICB2YXIgdGhlbiA9IGlzVGhlbmFibGUodmFsdWUpO1xuICAgIGlmICh0aGVuKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsKHRoZW4sIHZhbHVlLFxuICAgICAgICAgICAgYmluZChpbnRlcm5hbFJlc29sdmUsIHdyYXBwZXIsIHN0YXRlKSxcbiAgICAgICAgICAgIGJpbmQoaW50ZXJuYWxSZWplY3QsIHdyYXBwZXIsIHN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW50ZXJuYWxSZWplY3Qod3JhcHBlciwgZXJyb3IsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gICAgICBzdGF0ZS5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgICAgIG5vdGlmeShzdGF0ZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbnRlcm5hbFJlamVjdCh7IGRvbmU6IGZhbHNlIH0sIGVycm9yLCBzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUHJvbWlzZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgUHJvbWlzZVByb3RvdHlwZSk7XG4gICAgYUNhbGxhYmxlKGV4ZWN1dG9yKTtcbiAgICBjYWxsKEludGVybmFsLCB0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoYmluZChpbnRlcm5hbFJlc29sdmUsIHN0YXRlKSwgYmluZChpbnRlcm5hbFJlamVjdCwgc3RhdGUpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaW50ZXJuYWxSZWplY3Qoc3RhdGUsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgUHJvbWlzZVByb3RvdHlwZSA9IFByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICB0eXBlOiBQUk9NSVNFLFxuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBub3RpZmllZDogZmFsc2UsXG4gICAgICBwYXJlbnQ6IGZhbHNlLFxuICAgICAgcmVhY3Rpb25zOiBuZXcgUXVldWUoKSxcbiAgICAgIHJlamVjdGlvbjogZmFsc2UsXG4gICAgICBzdGF0ZTogUEVORElORyxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfTtcblxuICAvLyBgUHJvbWlzZS5wcm90b3R5cGUudGhlbmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUudGhlblxuICBJbnRlcm5hbC5wcm90b3R5cGUgPSBkZWZpbmVCdWlsdEluKFByb21pc2VQcm90b3R5cGUsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IpKTtcbiAgICBzdGF0ZS5wYXJlbnQgPSB0cnVlO1xuICAgIHJlYWN0aW9uLm9rID0gaXNDYWxsYWJsZShvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgcmVhY3Rpb24uZmFpbCA9IGlzQ2FsbGFibGUob25SZWplY3RlZCkgJiYgb25SZWplY3RlZDtcbiAgICByZWFjdGlvbi5kb21haW4gPSBJU19OT0RFID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHN0YXRlLnN0YXRlID09PSBQRU5ESU5HKSBzdGF0ZS5yZWFjdGlvbnMuYWRkKHJlYWN0aW9uKTtcbiAgICBlbHNlIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsUmVhY3Rpb24ocmVhY3Rpb24sIHN0YXRlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgfSk7XG5cbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZShwcm9taXNlKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGJpbmQoaW50ZXJuYWxSZXNvbHZlLCBzdGF0ZSk7XG4gICAgdGhpcy5yZWplY3QgPSBiaW5kKGludGVybmFsUmVqZWN0LCBzdGF0ZSk7XG4gIH07XG5cbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gUHJvbWlzZUNvbnN0cnVjdG9yIHx8IEMgPT09IFByb21pc2VXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG5cbiAgaWYgKCFJU19QVVJFICYmIGlzQ2FsbGFibGUoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yKSAmJiBOYXRpdmVQcm9taXNlUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgbmF0aXZlVGhlbiA9IE5hdGl2ZVByb21pc2VQcm90b3R5cGUudGhlbjtcblxuICAgIGlmICghTkFUSVZFX1BST01JU0VfU1VCQ0xBU1NJTkcpIHtcbiAgICAgIC8vIG1ha2UgYFByb21pc2UjdGhlbmAgcmV0dXJuIGEgcG9seWZpbGxlZCBgUHJvbWlzZWAgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICAgIGRlZmluZUJ1aWx0SW4oTmF0aXZlUHJvbWlzZVByb3RvdHlwZSwgJ3RoZW4nLCBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGNhbGwobmF0aXZlVGhlbiwgdGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjQwXG4gICAgICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGAuY29uc3RydWN0b3IgPT09IFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICB0cnkge1xuICAgICAgZGVsZXRlIE5hdGl2ZVByb21pc2VQcm90b3R5cGUuY29uc3RydWN0b3I7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG4gICAgLy8gbWFrZSBgaW5zdGFuY2VvZiBQcm9taXNlYCB3b3JrIGZvciBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzXG4gICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICBzZXRQcm90b3R5cGVPZihOYXRpdmVQcm9taXNlUHJvdG90eXBlLCBQcm9taXNlUHJvdG90eXBlKTtcbiAgICB9XG4gIH1cbn1cblxuJCh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgfSwge1xuICBQcm9taXNlOiBQcm9taXNlQ29uc3RydWN0b3Jcbn0pO1xuXG5zZXRUb1N0cmluZ1RhZyhQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UsIGZhbHNlLCB0cnVlKTtcbnNldFNwZWNpZXMoUFJPTUlTRSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBtb2R1bGUgZnJvbSBgY29yZS1qc0A0YCBzaW5jZSBpdCdzIHNwbGl0IHRvIG1vZHVsZXMgbGlzdGVkIGJlbG93XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnByb21pc2UuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMucHJvbWlzZS5hbGwnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMucHJvbWlzZS5jYXRjaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5wcm9taXNlLnJhY2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMucHJvbWlzZS5yZWplY3QnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMucHJvbWlzZS5yZXNvbHZlJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BlcmZvcm0nKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdGUnKTtcbnZhciBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm9taXNlLXN0YXRpY3MtaW5jb3JyZWN0LWl0ZXJhdGlvbicpO1xuXG4vLyBgUHJvbWlzZS5yYWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yYWNlXG4kKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04gfSwge1xuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZihDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFDYWxsYWJsZShDLnJlc29sdmUpO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgY2FsbCgkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcHJvbWlzZS1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24nKS5DT05TVFJVQ1RPUjtcblxuLy8gYFByb21pc2UucmVqZWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZWplY3RcbiQoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiB9LCB7XG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYodGhpcyk7XG4gICAgY2FsbChjYXBhYmlsaXR5LnJlamVjdCwgdW5kZWZpbmVkLCByKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Byb21pc2UtbmF0aXZlLWNvbnN0cnVjdG9yJyk7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcHJvbWlzZS1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24nKS5DT05TVFJVQ1RPUjtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm9taXNlLXJlc29sdmUnKTtcblxudmFyIFByb21pc2VDb25zdHJ1Y3RvcldyYXBwZXIgPSBnZXRCdWlsdEluKCdQcm9taXNlJyk7XG52YXIgQ0hFQ0tfV1JBUFBFUiA9IElTX1BVUkUgJiYgIUZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SO1xuXG4vLyBgUHJvbWlzZS5yZXNvbHZlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZXNvbHZlXG4kKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogSVNfUFVSRSB8fCBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiB9LCB7XG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDSEVDS19XUkFQUEVSICYmIHRoaXMgPT09IFByb21pc2VDb25zdHJ1Y3RvcldyYXBwZXIgPyBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG4iLCIvKiFcbiogVFcgRWxlbWVudHMgMS4xLjBcbiogXG4qIFRXIEVsZW1lbnRzIGlzIGFuIG9wZW4tc291cmNlIFVJIGtpdCBvZiBhZHZhbmNlZCBjb21wb25lbnRzIGZvciBUYWlsd2luZENTUy5cbiogQ29weXJpZ2h0IMKpIDIwMjMgTURCb290c3RyYXAuY29tXG4qIFxuKiBVbmxlc3MgYSBjdXN0b20sIGluZGl2aWR1YWxseSBhc3NpZ25lZCBsaWNlbnNlIGhhcyBiZWVuIGdyYW50ZWQsIHRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuKiBJbiBhZGRpdGlvbiwgYSBjdXN0b20gbGljZW5zZSBtYXkgYmUgYXZhaWxhYmxlIHVwb24gcmVxdWVzdCwgc3ViamVjdCB0byB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdGhhdCBsaWNlbnNlLiBQbGVhc2UgY29udGFjdCB0YWlsd2luZEBtZGJvb3RzdHJhcC5jb20gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gb2J0YWluaW5nIGEgY3VzdG9tIGxpY2Vuc2UuXG4qIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4qIFxuKiBJZiB5b3Ugd291bGQgbGlrZSB0byBwdXJjaGFzZSBhIENPTU1FUkNJQUwsIG5vbi1BR1BMIGxpY2Vuc2UgZm9yIFRXRSwgcGxlYXNlIGNoZWNrIG91dCBvdXIgcHJpY2luZzogaHR0cHM6Ly90dy1lbGVtZW50cy5jb20vcHJvL1xuKi9cbnZhciBoZCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBkZCA9IChzLCB0LCBlKSA9PiB0IGluIHMgPyBoZChzLCB0LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBlIH0pIDogc1t0XSA9IGU7XG52YXIgd3QgPSAocywgdCwgZSkgPT4gKGRkKHMsIHR5cGVvZiB0ICE9IFwic3ltYm9sXCIgPyB0ICsgXCJcIiA6IHQsIGUpLCBlKTtcbmNvbnN0IEluID0gKCgpID0+IHtcbiAgY29uc3QgcyA9IHt9O1xuICBsZXQgdCA9IDE7XG4gIHJldHVybiB7XG4gICAgc2V0KGUsIGksIG4pIHtcbiAgICAgIHR5cGVvZiBlW2ldID4gXCJ1XCIgJiYgKGVbaV0gPSB7XG4gICAgICAgIGtleTogaSxcbiAgICAgICAgaWQ6IHRcbiAgICAgIH0sIHQrKyksIHNbZVtpXS5pZF0gPSBuO1xuICAgIH0sXG4gICAgZ2V0KGUsIGkpIHtcbiAgICAgIGlmICghZSB8fCB0eXBlb2YgZVtpXSA+IFwidVwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IG4gPSBlW2ldO1xuICAgICAgcmV0dXJuIG4ua2V5ID09PSBpID8gc1tuLmlkXSA6IG51bGw7XG4gICAgfSxcbiAgICBkZWxldGUoZSwgaSkge1xuICAgICAgaWYgKHR5cGVvZiBlW2ldID4gXCJ1XCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG4gPSBlW2ldO1xuICAgICAgbi5rZXkgPT09IGkgJiYgKGRlbGV0ZSBzW24uaWRdLCBkZWxldGUgZVtpXSk7XG4gICAgfVxuICB9O1xufSkoKSwgQSA9IHtcbiAgc2V0RGF0YShzLCB0LCBlKSB7XG4gICAgSW4uc2V0KHMsIHQsIGUpO1xuICB9LFxuICBnZXREYXRhKHMsIHQpIHtcbiAgICByZXR1cm4gSW4uZ2V0KHMsIHQpO1xuICB9LFxuICByZW1vdmVEYXRhKHMsIHQpIHtcbiAgICBJbi5kZWxldGUocywgdCk7XG4gIH1cbn0sIHVkID0gMWU2LCBwZCA9IDFlMywgSG8gPSBcInRyYW5zaXRpb25lbmRcIiwgX2QgPSAocykgPT4gcyA9PSBudWxsID8gYCR7c31gIDoge30udG9TdHJpbmcuY2FsbChzKS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKSwgZXQgPSAocykgPT4ge1xuICBkb1xuICAgIHMgKz0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdWQpO1xuICB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocykpO1xuICByZXR1cm4gcztcbn0sIHBjID0gKHMpID0+IHtcbiAgbGV0IHQgPSBzLmdldEF0dHJpYnV0ZShcImRhdGEtdGUtdGFyZ2V0XCIpO1xuICBpZiAoIXQgfHwgdCA9PT0gXCIjXCIpIHtcbiAgICBsZXQgZSA9IHMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICBpZiAoIWUgfHwgIWUuaW5jbHVkZXMoXCIjXCIpICYmICFlLnN0YXJ0c1dpdGgoXCIuXCIpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZS5pbmNsdWRlcyhcIiNcIikgJiYgIWUuc3RhcnRzV2l0aChcIiNcIikgJiYgKGUgPSBgIyR7ZS5zcGxpdChcIiNcIilbMV19YCksIHQgPSBlICYmIGUgIT09IFwiI1wiID8gZS50cmltKCkgOiBudWxsO1xuICB9XG4gIHJldHVybiB0O1xufSwgbHIgPSAocykgPT4ge1xuICBjb25zdCB0ID0gcGMocyk7XG4gIHJldHVybiB0ICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkgPyB0IDogbnVsbDtcbn0sIHRlID0gKHMpID0+IHtcbiAgY29uc3QgdCA9IHBjKHMpO1xuICByZXR1cm4gdCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkgOiBudWxsO1xufSwgY24gPSAocykgPT4ge1xuICBpZiAoIXMpXG4gICAgcmV0dXJuIDA7XG4gIGxldCB7IHRyYW5zaXRpb25EdXJhdGlvbjogdCwgdHJhbnNpdGlvbkRlbGF5OiBlIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzKTtcbiAgY29uc3QgaSA9IE51bWJlci5wYXJzZUZsb2F0KHQpLCBuID0gTnVtYmVyLnBhcnNlRmxvYXQoZSk7XG4gIHJldHVybiAhaSAmJiAhbiA/IDAgOiAodCA9IHQuc3BsaXQoXCIsXCIpWzBdLCBlID0gZS5zcGxpdChcIixcIilbMF0sIChOdW1iZXIucGFyc2VGbG9hdCh0KSArIE51bWJlci5wYXJzZUZsb2F0KGUpKSAqIHBkKTtcbn0sIF9jID0gKHMpID0+IHtcbiAgcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChIbykpO1xufSwgWGUgPSAocykgPT4gIXMgfHwgdHlwZW9mIHMgIT0gXCJvYmplY3RcIiA/ICExIDogKHR5cGVvZiBzLmpxdWVyeSA8IFwidVwiICYmIChzID0gc1swXSksIHR5cGVvZiBzLm5vZGVUeXBlIDwgXCJ1XCIpLCBlZSA9IChzKSA9PiBYZShzKSA/IHMuanF1ZXJ5ID8gc1swXSA6IHMgOiB0eXBlb2YgcyA9PSBcInN0cmluZ1wiICYmIHMubGVuZ3RoID4gMCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocykgOiBudWxsLCBJID0gKHMsIHQsIGUpID0+IHtcbiAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGNvbnN0IG4gPSBlW2ldLCBvID0gdFtpXSwgciA9IG8gJiYgWGUobykgPyBcImVsZW1lbnRcIiA6IF9kKG8pO1xuICAgIGlmICghbmV3IFJlZ0V4cChuKS50ZXN0KHIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtzLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCIke2l9XCIgcHJvdmlkZWQgdHlwZSBcIiR7cn1cIiBidXQgZXhwZWN0ZWQgdHlwZSBcIiR7bn1cIi5gXG4gICAgICApO1xuICB9KTtcbn0sIE10ID0gKHMpID0+IHtcbiAgaWYgKCFzIHx8IHMuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuICExO1xuICBpZiAocy5zdHlsZSAmJiBzLnBhcmVudE5vZGUgJiYgcy5wYXJlbnROb2RlLnN0eWxlKSB7XG4gICAgY29uc3QgdCA9IGdldENvbXB1dGVkU3R5bGUocyksIGUgPSBnZXRDb21wdXRlZFN0eWxlKHMucGFyZW50Tm9kZSk7XG4gICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocykuZ2V0UHJvcGVydHlWYWx1ZShcInZpc2liaWxpdHlcIikgPT09IFwidmlzaWJsZVwiIHx8IHQuZGlzcGxheSAhPT0gXCJub25lXCIgJiYgZS5kaXNwbGF5ICE9PSBcIm5vbmVcIiAmJiB0LnZpc2liaWxpdHkgIT09IFwiaGlkZGVuXCI7XG4gIH1cbiAgcmV0dXJuICExO1xufSwgYmUgPSAocykgPT4gIXMgfHwgcy5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgfHwgcy5jbGFzc0xpc3QuY29udGFpbnMoXCJkaXNhYmxlZFwiKSA/ICEwIDogdHlwZW9mIHMuZGlzYWJsZWQgPCBcInVcIiA/IHMuZGlzYWJsZWQgOiBzLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpICYmIHMuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgIT09IFwiZmFsc2VcIiwgZmMgPSAocykgPT4ge1xuICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICh0eXBlb2Ygcy5nZXRSb290Tm9kZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCB0ID0gcy5nZXRSb290Tm9kZSgpO1xuICAgIHJldHVybiB0IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHQgOiBudWxsO1xuICB9XG4gIHJldHVybiBzIGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHMgOiBzLnBhcmVudE5vZGUgPyBmYyhzLnBhcmVudE5vZGUpIDogbnVsbDtcbn0sIGhuID0gKCkgPT4gZnVuY3Rpb24oKSB7XG59LCBzaSA9IChzKSA9PiB7XG4gIHMub2Zmc2V0SGVpZ2h0O1xufSwgbWMgPSAoKSA9PiB7XG4gIGNvbnN0IHsgalF1ZXJ5OiBzIH0gPSB3aW5kb3c7XG4gIHJldHVybiBzICYmICFkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZShcImRhdGEtdGUtbm8tanF1ZXJ5XCIpID8gcyA6IG51bGw7XG59LCBEbiA9IFtdLCBnYyA9IChzKSA9PiB7XG4gIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwibG9hZGluZ1wiID8gKERuLmxlbmd0aCB8fCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gICAgRG4uZm9yRWFjaCgodCkgPT4gdCgpKTtcbiAgfSksIERuLnB1c2gocykpIDogcygpO1xufSwgVyA9ICgpID0+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgPT09IFwicnRsXCIsIGZkID0gKHMpID0+IEFycmF5LmZyb20ocyksICQgPSAocykgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChzKSwgZ2UgPSAocykgPT4ge1xuICB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIgJiYgcygpO1xufSwgYmMgPSAocywgdCwgZSA9ICEwKSA9PiB7XG4gIGlmICghZSkge1xuICAgIGdlKHMpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpID0gNSwgbiA9IGNuKHQpICsgaTtcbiAgbGV0IG8gPSAhMTtcbiAgY29uc3QgciA9ICh7IHRhcmdldDogYSB9KSA9PiB7XG4gICAgYSA9PT0gdCAmJiAobyA9ICEwLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoSG8sIHIpLCBnZShzKSk7XG4gIH07XG4gIHQuYWRkRXZlbnRMaXN0ZW5lcihIbywgciksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIG8gfHwgX2ModCk7XG4gIH0sIG4pO1xufSwgdmMgPSAocywgdCwgZSwgaSkgPT4ge1xuICBsZXQgbiA9IHMuaW5kZXhPZih0KTtcbiAgaWYgKG4gPT09IC0xKVxuICAgIHJldHVybiBzWyFlICYmIGkgPyBzLmxlbmd0aCAtIDEgOiAwXTtcbiAgY29uc3QgbyA9IHMubGVuZ3RoO1xuICByZXR1cm4gbiArPSBlID8gMSA6IC0xLCBpICYmIChuID0gKG4gKyBvKSAlIG8pLCBzW01hdGgubWF4KDAsIE1hdGgubWluKG4sIG8gLSAxKSldO1xufSwgbWQgPSAvW14uXSooPz1cXC4uKilcXC58LiovLCBnZCA9IC9cXC4uKi8sIGJkID0gLzo6XFxkKyQvLCAkbiA9IHt9O1xubGV0IEhyID0gMTtcbmNvbnN0IHZkID0ge1xuICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJcbn0sIFRkID0gL14obW91c2VlbnRlcnxtb3VzZWxlYXZlKS9pLCBUYyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJjbGlja1wiLFxuICBcImRibGNsaWNrXCIsXG4gIFwibW91c2V1cFwiLFxuICBcIm1vdXNlZG93blwiLFxuICBcImNvbnRleHRtZW51XCIsXG4gIFwibW91c2V3aGVlbFwiLFxuICBcIkRPTU1vdXNlU2Nyb2xsXCIsXG4gIFwibW91c2VvdmVyXCIsXG4gIFwibW91c2VvdXRcIixcbiAgXCJtb3VzZW1vdmVcIixcbiAgXCJzZWxlY3RzdGFydFwiLFxuICBcInNlbGVjdGVuZFwiLFxuICBcImtleWRvd25cIixcbiAgXCJrZXlwcmVzc1wiLFxuICBcImtleXVwXCIsXG4gIFwib3JpZW50YXRpb25jaGFuZ2VcIixcbiAgXCJ0b3VjaHN0YXJ0XCIsXG4gIFwidG91Y2htb3ZlXCIsXG4gIFwidG91Y2hlbmRcIixcbiAgXCJ0b3VjaGNhbmNlbFwiLFxuICBcInBvaW50ZXJkb3duXCIsXG4gIFwicG9pbnRlcm1vdmVcIixcbiAgXCJwb2ludGVydXBcIixcbiAgXCJwb2ludGVybGVhdmVcIixcbiAgXCJwb2ludGVyY2FuY2VsXCIsXG4gIFwiZ2VzdHVyZXN0YXJ0XCIsXG4gIFwiZ2VzdHVyZWNoYW5nZVwiLFxuICBcImdlc3R1cmVlbmRcIixcbiAgXCJmb2N1c1wiLFxuICBcImJsdXJcIixcbiAgXCJjaGFuZ2VcIixcbiAgXCJyZXNldFwiLFxuICBcInNlbGVjdFwiLFxuICBcInN1Ym1pdFwiLFxuICBcImZvY3VzaW5cIixcbiAgXCJmb2N1c291dFwiLFxuICBcImxvYWRcIixcbiAgXCJ1bmxvYWRcIixcbiAgXCJiZWZvcmV1bmxvYWRcIixcbiAgXCJyZXNpemVcIixcbiAgXCJtb3ZlXCIsXG4gIFwiRE9NQ29udGVudExvYWRlZFwiLFxuICBcInJlYWR5c3RhdGVjaGFuZ2VcIixcbiAgXCJlcnJvclwiLFxuICBcImFib3J0XCIsXG4gIFwic2Nyb2xsXCJcbl0pO1xuZnVuY3Rpb24gRWMocywgdCkge1xuICByZXR1cm4gdCAmJiBgJHt0fTo6JHtIcisrfWAgfHwgcy51aWRFdmVudCB8fCBIcisrO1xufVxuZnVuY3Rpb24gQ2Mocykge1xuICBjb25zdCB0ID0gRWMocyk7XG4gIHJldHVybiBzLnVpZEV2ZW50ID0gdCwgJG5bdF0gPSAkblt0XSB8fCB7fSwgJG5bdF07XG59XG5mdW5jdGlvbiBFZChzLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBlKGkpIHtcbiAgICByZXR1cm4gaS5kZWxlZ2F0ZVRhcmdldCA9IHMsIGUub25lT2ZmICYmIGMub2ZmKHMsIGkudHlwZSwgdCksIHQuYXBwbHkocywgW2ldKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIENkKHMsIHQsIGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGkobikge1xuICAgIGNvbnN0IG8gPSBzLnF1ZXJ5U2VsZWN0b3JBbGwodCk7XG4gICAgZm9yIChsZXQgeyB0YXJnZXQ6IHIgfSA9IG47IHIgJiYgciAhPT0gdGhpczsgciA9IHIucGFyZW50Tm9kZSlcbiAgICAgIGZvciAobGV0IGEgPSBvLmxlbmd0aDsgYS0tOyBcIlwiKVxuICAgICAgICBpZiAob1thXSA9PT0gcilcbiAgICAgICAgICByZXR1cm4gbi5kZWxlZ2F0ZVRhcmdldCA9IHIsIGkub25lT2ZmICYmIGMub2ZmKHMsIG4udHlwZSwgZSksIGUuYXBwbHkociwgW25dKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cbmZ1bmN0aW9uIEFjKHMsIHQsIGUgPSBudWxsKSB7XG4gIGNvbnN0IGkgPSBPYmplY3Qua2V5cyhzKTtcbiAgZm9yIChsZXQgbiA9IDAsIG8gPSBpLmxlbmd0aDsgbiA8IG87IG4rKykge1xuICAgIGNvbnN0IHIgPSBzW2lbbl1dO1xuICAgIGlmIChyLm9yaWdpbmFsSGFuZGxlciA9PT0gdCAmJiByLmRlbGVnYXRpb25TZWxlY3RvciA9PT0gZSlcbiAgICAgIHJldHVybiByO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24geWMocywgdCwgZSkge1xuICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiwgbiA9IGkgPyBlIDogdDtcbiAgbGV0IG8gPSB3YyhzKTtcbiAgcmV0dXJuIFRjLmhhcyhvKSB8fCAobyA9IHMpLCBbaSwgbiwgb107XG59XG5mdW5jdGlvbiBWcihzLCB0LCBlLCBpLCBuKSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFzKVxuICAgIHJldHVybjtcbiAgaWYgKGUgfHwgKGUgPSBpLCBpID0gbnVsbCksIFRkLnRlc3QodCkpIHtcbiAgICBjb25zdCBnID0gKG0pID0+IGZ1bmN0aW9uKGIpIHtcbiAgICAgIGlmICghYi5yZWxhdGVkVGFyZ2V0IHx8IGIucmVsYXRlZFRhcmdldCAhPT0gYi5kZWxlZ2F0ZVRhcmdldCAmJiAhYi5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhiLnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICByZXR1cm4gbS5jYWxsKHRoaXMsIGIpO1xuICAgIH07XG4gICAgaSA/IGkgPSBnKGkpIDogZSA9IGcoZSk7XG4gIH1cbiAgY29uc3QgW28sIHIsIGFdID0geWMoXG4gICAgdCxcbiAgICBlLFxuICAgIGlcbiAgKSwgbCA9IENjKHMpLCBwID0gbFthXSB8fCAobFthXSA9IHt9KSwgdSA9IEFjKFxuICAgIHAsXG4gICAgcixcbiAgICBvID8gZSA6IG51bGxcbiAgKTtcbiAgaWYgKHUpIHtcbiAgICB1Lm9uZU9mZiA9IHUub25lT2ZmICYmIG47XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IF8gPSBFYyhcbiAgICByLFxuICAgIHQucmVwbGFjZShtZCwgXCJcIilcbiAgKSwgZiA9IG8gPyBDZChzLCBlLCBpKSA6IEVkKHMsIGUpO1xuICBmLmRlbGVnYXRpb25TZWxlY3RvciA9IG8gPyBlIDogbnVsbCwgZi5vcmlnaW5hbEhhbmRsZXIgPSByLCBmLm9uZU9mZiA9IG4sIGYudWlkRXZlbnQgPSBfLCBwW19dID0gZiwgcy5hZGRFdmVudExpc3RlbmVyKGEsIGYsIG8pO1xufVxuZnVuY3Rpb24gVm8ocywgdCwgZSwgaSwgbikge1xuICBjb25zdCBvID0gQWModFtlXSwgaSwgbik7XG4gIG8gJiYgKHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBvLCAhIW4pLCBkZWxldGUgdFtlXVtvLnVpZEV2ZW50XSk7XG59XG5mdW5jdGlvbiBBZChzLCB0LCBlLCBpKSB7XG4gIGNvbnN0IG4gPSB0W2VdIHx8IHt9O1xuICBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgaWYgKG8uaW5jbHVkZXMoaSkpIHtcbiAgICAgIGNvbnN0IHIgPSBuW29dO1xuICAgICAgVm8oXG4gICAgICAgIHMsXG4gICAgICAgIHQsXG4gICAgICAgIGUsXG4gICAgICAgIHIub3JpZ2luYWxIYW5kbGVyLFxuICAgICAgICByLmRlbGVnYXRpb25TZWxlY3RvclxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gd2Mocykge1xuICByZXR1cm4gcyA9IHMucmVwbGFjZShnZCwgXCJcIiksIHZkW3NdIHx8IHM7XG59XG5jb25zdCBjID0ge1xuICBvbihzLCB0LCBlLCBpKSB7XG4gICAgVnIocywgdCwgZSwgaSwgITEpO1xuICB9LFxuICBvbmUocywgdCwgZSwgaSkge1xuICAgIFZyKHMsIHQsIGUsIGksICEwKTtcbiAgfSxcbiAgb2ZmKHMsIHQsIGUsIGkpIHtcbiAgICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIiB8fCAhcylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbbiwgbywgcl0gPSB5YyhcbiAgICAgIHQsXG4gICAgICBlLFxuICAgICAgaVxuICAgICksIGEgPSByICE9PSB0LCBsID0gQ2MocyksIHAgPSB0LnN0YXJ0c1dpdGgoXCIuXCIpO1xuICAgIGlmICh0eXBlb2YgbyA8IFwidVwiKSB7XG4gICAgICBpZiAoIWwgfHwgIWxbcl0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIFZvKFxuICAgICAgICBzLFxuICAgICAgICBsLFxuICAgICAgICByLFxuICAgICAgICBvLFxuICAgICAgICBuID8gZSA6IG51bGxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHAgJiYgT2JqZWN0LmtleXMobCkuZm9yRWFjaCgoXykgPT4ge1xuICAgICAgQWQoXG4gICAgICAgIHMsXG4gICAgICAgIGwsXG4gICAgICAgIF8sXG4gICAgICAgIHQuc2xpY2UoMSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgY29uc3QgdSA9IGxbcl0gfHwge307XG4gICAgT2JqZWN0LmtleXModSkuZm9yRWFjaCgoXykgPT4ge1xuICAgICAgY29uc3QgZiA9IF8ucmVwbGFjZShiZCwgXCJcIik7XG4gICAgICBpZiAoIWEgfHwgdC5pbmNsdWRlcyhmKSkge1xuICAgICAgICBjb25zdCBnID0gdVtfXTtcbiAgICAgICAgVm8oXG4gICAgICAgICAgcyxcbiAgICAgICAgICBsLFxuICAgICAgICAgIHIsXG4gICAgICAgICAgZy5vcmlnaW5hbEhhbmRsZXIsXG4gICAgICAgICAgZy5kZWxlZ2F0aW9uU2VsZWN0b3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgdHJpZ2dlcihzLCB0LCBlKSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIgfHwgIXMpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBpID0gbWMoKSwgbiA9IHdjKHQpLCBvID0gdCAhPT0gbiwgciA9IFRjLmhhcyhuKTtcbiAgICBsZXQgYSwgbCA9ICEwLCBwID0gITAsIHUgPSAhMSwgXyA9IG51bGw7XG4gICAgcmV0dXJuIG8gJiYgaSAmJiAoYSA9IGkuRXZlbnQodCwgZSksIGkocykudHJpZ2dlcihhKSwgbCA9ICFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCksIHAgPSAhYS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpLCB1ID0gYS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSksIHIgPyAoXyA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKSwgXy5pbml0RXZlbnQobiwgbCwgITApKSA6IF8gPSBuZXcgQ3VzdG9tRXZlbnQodCwge1xuICAgICAgYnViYmxlczogbCxcbiAgICAgIGNhbmNlbGFibGU6ICEwXG4gICAgfSksIHR5cGVvZiBlIDwgXCJ1XCIgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIGYsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBlW2ZdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSwgdSAmJiBfLnByZXZlbnREZWZhdWx0KCksIHAgJiYgcy5kaXNwYXRjaEV2ZW50KF8pLCBfLmRlZmF1bHRQcmV2ZW50ZWQgJiYgdHlwZW9mIGEgPCBcInVcIiAmJiBhLnByZXZlbnREZWZhdWx0KCksIF87XG4gIH1cbn0sIEsgPSB7XG4gIG9uKHMsIHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gdC5zcGxpdChcIiBcIik7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBuLmxlbmd0aDsgbysrKVxuICAgICAgYy5vbihzLCBuW29dLCBlLCBpKTtcbiAgfSxcbiAgb2ZmKHMsIHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gdC5zcGxpdChcIiBcIik7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBuLmxlbmd0aDsgbysrKVxuICAgICAgYy5vZmYocywgbltvXSwgZSwgaSk7XG4gIH1cbn0sIHlkID0gXCI1LjEuM1wiO1xuY2xhc3MgZnQge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdCA9IGVlKHQpLCB0ICYmICh0aGlzLl9lbGVtZW50ID0gdCwgQS5zZXREYXRhKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIEEucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0aGlzW3RdID0gbnVsbDtcbiAgICB9KTtcbiAgfVxuICBfcXVldWVDYWxsYmFjayh0LCBlLCBpID0gITApIHtcbiAgICBiYyh0LCBlLCBpKTtcbiAgfVxuICAvKiogU3RhdGljICovXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEEuZ2V0RGF0YShlZSh0KSwgdGhpcy5EQVRBX0tFWSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIHlkO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnWW91IGhhdmUgdG8gaW1wbGVtZW50IHRoZSBzdGF0aWMgbWV0aG9kIFwiTkFNRVwiLCBmb3IgZWFjaCBjb21wb25lbnQhJ1xuICAgICk7XG4gIH1cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gYHRlLiR7dGhpcy5OQU1FfWA7XG4gIH1cbiAgc3RhdGljIGdldCBFVkVOVF9LRVkoKSB7XG4gICAgcmV0dXJuIGAuJHt0aGlzLkRBVEFfS0VZfWA7XG4gIH1cbn1cbmNvbnN0IHdkID0gXCJidXR0b25cIiwga2QgPSBcImFjdGl2ZVwiO1xuY2xhc3Mga2MgZXh0ZW5kcyBmdCB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiB3ZDtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLXByZXNzZWRcIixcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShrZClcbiAgICApO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IGtjLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICB0ID09PSBcInRvZ2dsZVwiICYmIGVbdF0oKTtcbiAgICB9KTtcbiAgfVxufVxudmFyIHN0ID0gXCJ0b3BcIiwgdXQgPSBcImJvdHRvbVwiLCBwdCA9IFwicmlnaHRcIiwgbnQgPSBcImxlZnRcIiwgamkgPSBcImF1dG9cIiwgbmkgPSBbc3QsIHV0LCBwdCwgbnRdLCBBZSA9IFwic3RhcnRcIiwgR2UgPSBcImVuZFwiLCB4YyA9IFwiY2xpcHBpbmdQYXJlbnRzXCIsIGNyID0gXCJ2aWV3cG9ydFwiLCBCZSA9IFwicG9wcGVyXCIsIE9jID0gXCJyZWZlcmVuY2VcIiwgV28gPSAvKiBAX19QVVJFX18gKi8gbmkucmVkdWNlKGZ1bmN0aW9uKHMsIHQpIHtcbiAgcmV0dXJuIHMuY29uY2F0KFt0ICsgXCItXCIgKyBBZSwgdCArIFwiLVwiICsgR2VdKTtcbn0sIFtdKSwgaHIgPSAvKiBAX19QVVJFX18gKi8gW10uY29uY2F0KG5pLCBbamldKS5yZWR1Y2UoZnVuY3Rpb24ocywgdCkge1xuICByZXR1cm4gcy5jb25jYXQoW3QsIHQgKyBcIi1cIiArIEFlLCB0ICsgXCItXCIgKyBHZV0pO1xufSwgW10pLCBTYyA9IFwiYmVmb3JlUmVhZFwiLCBJYyA9IFwicmVhZFwiLCBEYyA9IFwiYWZ0ZXJSZWFkXCIsICRjID0gXCJiZWZvcmVNYWluXCIsIExjID0gXCJtYWluXCIsIE5jID0gXCJhZnRlck1haW5cIiwgTWMgPSBcImJlZm9yZVdyaXRlXCIsIFJjID0gXCJ3cml0ZVwiLCBQYyA9IFwiYWZ0ZXJXcml0ZVwiLCBkbiA9IFtTYywgSWMsIERjLCAkYywgTGMsIE5jLCBNYywgUmMsIFBjXTtcbmZ1bmN0aW9uIFJ0KHMpIHtcbiAgcmV0dXJuIHMgPyAocy5ub2RlTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIF90KHMpIHtcbiAgaWYgKHMgPT0gbnVsbClcbiAgICByZXR1cm4gd2luZG93O1xuICBpZiAocy50b1N0cmluZygpICE9PSBcIltvYmplY3QgV2luZG93XVwiKSB7XG4gICAgdmFyIHQgPSBzLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIHQgJiYgdC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiB5ZShzKSB7XG4gIHZhciB0ID0gX3QocykuRWxlbWVudDtcbiAgcmV0dXJuIHMgaW5zdGFuY2VvZiB0IHx8IHMgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuZnVuY3Rpb24gZHQocykge1xuICB2YXIgdCA9IF90KHMpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gcyBpbnN0YW5jZW9mIHQgfHwgcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gZHIocykge1xuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPiBcInVcIilcbiAgICByZXR1cm4gITE7XG4gIHZhciB0ID0gX3QocykuU2hhZG93Um9vdDtcbiAgcmV0dXJuIHMgaW5zdGFuY2VvZiB0IHx8IHMgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuZnVuY3Rpb24geGQocykge1xuICB2YXIgdCA9IHMuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHQuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgIHZhciBpID0gdC5zdHlsZXNbZV0gfHwge30sIG4gPSB0LmF0dHJpYnV0ZXNbZV0gfHwge30sIG8gPSB0LmVsZW1lbnRzW2VdO1xuICAgICFkdChvKSB8fCAhUnQobykgfHwgKE9iamVjdC5hc3NpZ24oby5zdHlsZSwgaSksIE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgdmFyIGEgPSBuW3JdO1xuICAgICAgYSA9PT0gITEgPyBvLnJlbW92ZUF0dHJpYnV0ZShyKSA6IG8uc2V0QXR0cmlidXRlKHIsIGEgPT09ICEwID8gXCJcIiA6IGEpO1xuICAgIH0pKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBPZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiB0Lm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiBcIjBcIixcbiAgICAgIHRvcDogXCIwXCIsXG4gICAgICBtYXJnaW46IFwiMFwiXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgZS5wb3BwZXIpLCB0LnN0eWxlcyA9IGUsIHQuZWxlbWVudHMuYXJyb3cgJiYgT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLmFycm93LnN0eWxlLCBlLmFycm93KSwgZnVuY3Rpb24oKSB7XG4gICAgT2JqZWN0LmtleXModC5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgbiA9IHQuZWxlbWVudHNbaV0sIG8gPSB0LmF0dHJpYnV0ZXNbaV0gfHwge30sIHIgPSBPYmplY3Qua2V5cyh0LnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShpKSA/IHQuc3R5bGVzW2ldIDogZVtpXSksIGEgPSByLnJlZHVjZShmdW5jdGlvbihsLCBwKSB7XG4gICAgICAgIHJldHVybiBsW3BdID0gXCJcIiwgbDtcbiAgICAgIH0sIHt9KTtcbiAgICAgICFkdChuKSB8fCAhUnQobikgfHwgKE9iamVjdC5hc3NpZ24obi5zdHlsZSwgYSksIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24obCkge1xuICAgICAgICBuLnJlbW92ZUF0dHJpYnV0ZShsKTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfTtcbn1cbmNvbnN0IHVyID0ge1xuICBuYW1lOiBcImFwcGx5U3R5bGVzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJ3cml0ZVwiLFxuICBmbjogeGQsXG4gIGVmZmVjdDogT2QsXG4gIHJlcXVpcmVzOiBbXCJjb21wdXRlU3R5bGVzXCJdXG59O1xuZnVuY3Rpb24gRXQocykge1xuICByZXR1cm4gcy5zcGxpdChcIi1cIilbMF07XG59XG52YXIgdmUgPSBNYXRoLm1heCwgdW4gPSBNYXRoLm1pbiwgcWUgPSBNYXRoLnJvdW5kO1xuZnVuY3Rpb24gRm8oKSB7XG4gIHZhciBzID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIHJldHVybiBzICE9IG51bGwgJiYgcy5icmFuZHMgJiYgQXJyYXkuaXNBcnJheShzLmJyYW5kcykgPyBzLmJyYW5kcy5tYXAoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0LmJyYW5kICsgXCIvXCIgKyB0LnZlcnNpb247XG4gIH0pLmpvaW4oXCIgXCIpIDogbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cbmZ1bmN0aW9uIEJjKCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoRm8oKSk7XG59XG5mdW5jdGlvbiBaZShzLCB0LCBlKSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9ICExKSwgZSA9PT0gdm9pZCAwICYmIChlID0gITEpO1xuICB2YXIgaSA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG4gPSAxLCBvID0gMTtcbiAgdCAmJiBkdChzKSAmJiAobiA9IHMub2Zmc2V0V2lkdGggPiAwICYmIHFlKGkud2lkdGgpIC8gcy5vZmZzZXRXaWR0aCB8fCAxLCBvID0gcy5vZmZzZXRIZWlnaHQgPiAwICYmIHFlKGkuaGVpZ2h0KSAvIHMub2Zmc2V0SGVpZ2h0IHx8IDEpO1xuICB2YXIgciA9IHllKHMpID8gX3QocykgOiB3aW5kb3csIGEgPSByLnZpc3VhbFZpZXdwb3J0LCBsID0gIUJjKCkgJiYgZSwgcCA9IChpLmxlZnQgKyAobCAmJiBhID8gYS5vZmZzZXRMZWZ0IDogMCkpIC8gbiwgdSA9IChpLnRvcCArIChsICYmIGEgPyBhLm9mZnNldFRvcCA6IDApKSAvIG8sIF8gPSBpLndpZHRoIC8gbiwgZiA9IGkuaGVpZ2h0IC8gbztcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogXyxcbiAgICBoZWlnaHQ6IGYsXG4gICAgdG9wOiB1LFxuICAgIHJpZ2h0OiBwICsgXyxcbiAgICBib3R0b206IHUgKyBmLFxuICAgIGxlZnQ6IHAsXG4gICAgeDogcCxcbiAgICB5OiB1XG4gIH07XG59XG5mdW5jdGlvbiBwcihzKSB7XG4gIHZhciB0ID0gWmUocyksIGUgPSBzLm9mZnNldFdpZHRoLCBpID0gcy5vZmZzZXRIZWlnaHQ7XG4gIHJldHVybiBNYXRoLmFicyh0LndpZHRoIC0gZSkgPD0gMSAmJiAoZSA9IHQud2lkdGgpLCBNYXRoLmFicyh0LmhlaWdodCAtIGkpIDw9IDEgJiYgKGkgPSB0LmhlaWdodCksIHtcbiAgICB4OiBzLm9mZnNldExlZnQsXG4gICAgeTogcy5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IGUsXG4gICAgaGVpZ2h0OiBpXG4gIH07XG59XG5mdW5jdGlvbiBIYyhzLCB0KSB7XG4gIHZhciBlID0gdC5nZXRSb290Tm9kZSAmJiB0LmdldFJvb3ROb2RlKCk7XG4gIGlmIChzLmNvbnRhaW5zKHQpKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKGUgJiYgZHIoZSkpIHtcbiAgICB2YXIgaSA9IHQ7XG4gICAgZG8ge1xuICAgICAgaWYgKGkgJiYgcy5pc1NhbWVOb2RlKGkpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpID0gaS5wYXJlbnROb2RlIHx8IGkuaG9zdDtcbiAgICB9IHdoaWxlIChpKTtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBBdChzKSB7XG4gIHJldHVybiBfdChzKS5nZXRDb21wdXRlZFN0eWxlKHMpO1xufVxuZnVuY3Rpb24gU2Qocykge1xuICByZXR1cm4gW1widGFibGVcIiwgXCJ0ZFwiLCBcInRoXCJdLmluZGV4T2YoUnQocykpID49IDA7XG59XG5mdW5jdGlvbiBpZShzKSB7XG4gIHJldHVybiAoKHllKHMpID8gcy5vd25lckRvY3VtZW50IDogKFxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHMuZG9jdW1lbnRcbiAgKSkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBtbihzKSB7XG4gIHJldHVybiBSdChzKSA9PT0gXCJodG1sXCIgPyBzIDogKFxuICAgIC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHMuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgcy5wYXJlbnROb2RlIHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgKGRyKHMpID8gcy5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBpZShzKVxuICApO1xufVxuZnVuY3Rpb24gV3Iocykge1xuICByZXR1cm4gIWR0KHMpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIEF0KHMpLnBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBudWxsIDogcy5vZmZzZXRQYXJlbnQ7XG59XG5mdW5jdGlvbiBJZChzKSB7XG4gIHZhciB0ID0gL2ZpcmVmb3gvaS50ZXN0KEZvKCkpLCBlID0gL1RyaWRlbnQvaS50ZXN0KEZvKCkpO1xuICBpZiAoZSAmJiBkdChzKSkge1xuICAgIHZhciBpID0gQXQocyk7XG4gICAgaWYgKGkucG9zaXRpb24gPT09IFwiZml4ZWRcIilcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBuID0gbW4ocyk7XG4gIGZvciAoZHIobikgJiYgKG4gPSBuLmhvc3QpOyBkdChuKSAmJiBbXCJodG1sXCIsIFwiYm9keVwiXS5pbmRleE9mKFJ0KG4pKSA8IDA7ICkge1xuICAgIHZhciBvID0gQXQobik7XG4gICAgaWYgKG8udHJhbnNmb3JtICE9PSBcIm5vbmVcIiB8fCBvLnBlcnNwZWN0aXZlICE9PSBcIm5vbmVcIiB8fCBvLmNvbnRhaW4gPT09IFwicGFpbnRcIiB8fCBbXCJ0cmFuc2Zvcm1cIiwgXCJwZXJzcGVjdGl2ZVwiXS5pbmRleE9mKG8ud2lsbENoYW5nZSkgIT09IC0xIHx8IHQgJiYgby53aWxsQ2hhbmdlID09PSBcImZpbHRlclwiIHx8IHQgJiYgby5maWx0ZXIgJiYgby5maWx0ZXIgIT09IFwibm9uZVwiKVxuICAgICAgcmV0dXJuIG47XG4gICAgbiA9IG4ucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIEtpKHMpIHtcbiAgZm9yICh2YXIgdCA9IF90KHMpLCBlID0gV3Iocyk7IGUgJiYgU2QoZSkgJiYgQXQoZSkucG9zaXRpb24gPT09IFwic3RhdGljXCI7IClcbiAgICBlID0gV3IoZSk7XG4gIHJldHVybiBlICYmIChSdChlKSA9PT0gXCJodG1sXCIgfHwgUnQoZSkgPT09IFwiYm9keVwiICYmIEF0KGUpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiKSA/IHQgOiBlIHx8IElkKHMpIHx8IHQ7XG59XG5mdW5jdGlvbiBfcihzKSB7XG4gIHJldHVybiBbXCJ0b3BcIiwgXCJib3R0b21cIl0uaW5kZXhPZihzKSA+PSAwID8gXCJ4XCIgOiBcInlcIjtcbn1cbmZ1bmN0aW9uIE1pKHMsIHQsIGUpIHtcbiAgcmV0dXJuIHZlKHMsIHVuKHQsIGUpKTtcbn1cbmZ1bmN0aW9uIERkKHMsIHQsIGUpIHtcbiAgdmFyIGkgPSBNaShzLCB0LCBlKTtcbiAgcmV0dXJuIGkgPiBlID8gZSA6IGk7XG59XG5mdW5jdGlvbiBWYygpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIFdjKHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIFZjKCksIHMpO1xufVxuZnVuY3Rpb24gRmMocywgdCkge1xuICByZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24oZSwgaSkge1xuICAgIHJldHVybiBlW2ldID0gcywgZTtcbiAgfSwge30pO1xufVxudmFyICRkID0gZnVuY3Rpb24odCwgZSkge1xuICByZXR1cm4gdCA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQoT2JqZWN0LmFzc2lnbih7fSwgZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogZS5wbGFjZW1lbnRcbiAgfSkpIDogdCwgV2ModHlwZW9mIHQgIT0gXCJudW1iZXJcIiA/IHQgOiBGYyh0LCBuaSkpO1xufTtcbmZ1bmN0aW9uIExkKHMpIHtcbiAgdmFyIHQsIGUgPSBzLnN0YXRlLCBpID0gcy5uYW1lLCBuID0gcy5vcHRpb25zLCBvID0gZS5lbGVtZW50cy5hcnJvdywgciA9IGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLCBhID0gRXQoZS5wbGFjZW1lbnQpLCBsID0gX3IoYSksIHAgPSBbbnQsIHB0XS5pbmRleE9mKGEpID49IDAsIHUgPSBwID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgaWYgKCEoIW8gfHwgIXIpKSB7XG4gICAgdmFyIF8gPSAkZChuLnBhZGRpbmcsIGUpLCBmID0gcHIobyksIGcgPSBsID09PSBcInlcIiA/IHN0IDogbnQsIG0gPSBsID09PSBcInlcIiA/IHV0IDogcHQsIGIgPSBlLnJlY3RzLnJlZmVyZW5jZVt1XSArIGUucmVjdHMucmVmZXJlbmNlW2xdIC0gcltsXSAtIGUucmVjdHMucG9wcGVyW3VdLCB2ID0gcltsXSAtIGUucmVjdHMucmVmZXJlbmNlW2xdLCBUID0gS2kobyksIHkgPSBUID8gbCA9PT0gXCJ5XCIgPyBULmNsaWVudEhlaWdodCB8fCAwIDogVC5jbGllbnRXaWR0aCB8fCAwIDogMCwgQyA9IGIgLyAyIC0gdiAvIDIsIEUgPSBfW2ddLCB3ID0geSAtIGZbdV0gLSBfW21dLCBrID0geSAvIDIgLSBmW3VdIC8gMiArIEMsIEQgPSBNaShFLCBrLCB3KSwgTyA9IGw7XG4gICAgZS5tb2RpZmllcnNEYXRhW2ldID0gKHQgPSB7fSwgdFtPXSA9IEQsIHQuY2VudGVyT2Zmc2V0ID0gRCAtIGssIHQpO1xuICB9XG59XG5mdW5jdGlvbiBOZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IGUuZWxlbWVudCwgbiA9IGkgPT09IHZvaWQgMCA/IFwiW2RhdGEtcG9wcGVyLWFycm93XVwiIDogaTtcbiAgaWYgKG4gIT0gbnVsbCAmJiAhKHR5cGVvZiBuID09IFwic3RyaW5nXCIgJiYgKG4gPSB0LmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKG4pLCAhbikpKSB7XG4gICAgaWYgKHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoZHQobikgfHwgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCAobm90IGFuIFNWR0VsZW1lbnQpLicsIFwiVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhc1wiLCBcInRoZSBhcnJvdy5cIl0uam9pbihcIiBcIikpKSwgIUhjKHQuZWxlbWVudHMucG9wcGVyLCBuKSkge1xuICAgICAgKHt9KS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIG1vZGlmaWVyXFwncyBgZWxlbWVudGAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBwb3BwZXInLCBcImVsZW1lbnQuXCJdLmpvaW4oXCIgXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdC5lbGVtZW50cy5hcnJvdyA9IG47XG4gIH1cbn1cbmNvbnN0IFljID0ge1xuICBuYW1lOiBcImFycm93XCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIGZuOiBMZCxcbiAgZWZmZWN0OiBOZCxcbiAgcmVxdWlyZXM6IFtcInBvcHBlck9mZnNldHNcIl0sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcInByZXZlbnRPdmVyZmxvd1wiXVxufTtcbmZ1bmN0aW9uIFFlKHMpIHtcbiAgcmV0dXJuIHMuc3BsaXQoXCItXCIpWzFdO1xufVxudmFyIE1kID0ge1xuICB0b3A6IFwiYXV0b1wiLFxuICByaWdodDogXCJhdXRvXCIsXG4gIGJvdHRvbTogXCJhdXRvXCIsXG4gIGxlZnQ6IFwiYXV0b1wiXG59O1xuZnVuY3Rpb24gUmQocywgdCkge1xuICB2YXIgZSA9IHMueCwgaSA9IHMueSwgbiA9IHQuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHFlKGUgKiBuKSAvIG4gfHwgMCxcbiAgICB5OiBxZShpICogbikgLyBuIHx8IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIEZyKHMpIHtcbiAgdmFyIHQsIGUgPSBzLnBvcHBlciwgaSA9IHMucG9wcGVyUmVjdCwgbiA9IHMucGxhY2VtZW50LCBvID0gcy52YXJpYXRpb24sIHIgPSBzLm9mZnNldHMsIGEgPSBzLnBvc2l0aW9uLCBsID0gcy5ncHVBY2NlbGVyYXRpb24sIHAgPSBzLmFkYXB0aXZlLCB1ID0gcy5yb3VuZE9mZnNldHMsIF8gPSBzLmlzRml4ZWQsIGYgPSByLngsIGcgPSBmID09PSB2b2lkIDAgPyAwIDogZiwgbSA9IHIueSwgYiA9IG0gPT09IHZvaWQgMCA/IDAgOiBtLCB2ID0gdHlwZW9mIHUgPT0gXCJmdW5jdGlvblwiID8gdSh7XG4gICAgeDogZyxcbiAgICB5OiBiXG4gIH0pIDoge1xuICAgIHg6IGcsXG4gICAgeTogYlxuICB9O1xuICBnID0gdi54LCBiID0gdi55O1xuICB2YXIgVCA9IHIuaGFzT3duUHJvcGVydHkoXCJ4XCIpLCB5ID0gci5oYXNPd25Qcm9wZXJ0eShcInlcIiksIEMgPSBudCwgRSA9IHN0LCB3ID0gd2luZG93O1xuICBpZiAocCkge1xuICAgIHZhciBrID0gS2koZSksIEQgPSBcImNsaWVudEhlaWdodFwiLCBPID0gXCJjbGllbnRXaWR0aFwiO1xuICAgIGlmIChrID09PSBfdChlKSAmJiAoayA9IGllKGUpLCBBdChrKS5wb3NpdGlvbiAhPT0gXCJzdGF0aWNcIiAmJiBhID09PSBcImFic29sdXRlXCIgJiYgKEQgPSBcInNjcm9sbEhlaWdodFwiLCBPID0gXCJzY3JvbGxXaWR0aFwiKSksIGsgPSBrLCBuID09PSBzdCB8fCAobiA9PT0gbnQgfHwgbiA9PT0gcHQpICYmIG8gPT09IEdlKSB7XG4gICAgICBFID0gdXQ7XG4gICAgICB2YXIgeCA9IF8gJiYgayA9PT0gdyAmJiB3LnZpc3VhbFZpZXdwb3J0ID8gdy52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAoXG4gICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICBrW0RdXG4gICAgICApO1xuICAgICAgYiAtPSB4IC0gaS5oZWlnaHQsIGIgKj0gbCA/IDEgOiAtMTtcbiAgICB9XG4gICAgaWYgKG4gPT09IG50IHx8IChuID09PSBzdCB8fCBuID09PSB1dCkgJiYgbyA9PT0gR2UpIHtcbiAgICAgIEMgPSBwdDtcbiAgICAgIHZhciBMID0gXyAmJiBrID09PSB3ICYmIHcudmlzdWFsVmlld3BvcnQgPyB3LnZpc3VhbFZpZXdwb3J0LndpZHRoIDogKFxuICAgICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAga1tPXVxuICAgICAgKTtcbiAgICAgIGcgLT0gTCAtIGkud2lkdGgsIGcgKj0gbCA/IDEgOiAtMTtcbiAgICB9XG4gIH1cbiAgdmFyIFMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogYVxuICB9LCBwICYmIE1kKSwgTiA9IHUgPT09ICEwID8gUmQoe1xuICAgIHg6IGcsXG4gICAgeTogYlxuICB9LCBfdChlKSkgOiB7XG4gICAgeDogZyxcbiAgICB5OiBiXG4gIH07XG4gIGlmIChnID0gTi54LCBiID0gTi55LCBsKSB7XG4gICAgdmFyIFA7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIFMsIChQID0ge30sIFBbRV0gPSB5ID8gXCIwXCIgOiBcIlwiLCBQW0NdID0gVCA/IFwiMFwiIDogXCJcIiwgUC50cmFuc2Zvcm0gPSAody5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIGcgKyBcInB4LCBcIiArIGIgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIGcgKyBcInB4LCBcIiArIGIgKyBcInB4LCAwKVwiLCBQKSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIFMsICh0ID0ge30sIHRbRV0gPSB5ID8gYiArIFwicHhcIiA6IFwiXCIsIHRbQ10gPSBUID8gZyArIFwicHhcIiA6IFwiXCIsIHQudHJhbnNmb3JtID0gXCJcIiwgdCkpO1xufVxuZnVuY3Rpb24gUGQocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBlLmdwdUFjY2VsZXJhdGlvbiwgbiA9IGkgPT09IHZvaWQgMCA/ICEwIDogaSwgbyA9IGUuYWRhcHRpdmUsIHIgPSBvID09PSB2b2lkIDAgPyAhMCA6IG8sIGEgPSBlLnJvdW5kT2Zmc2V0cywgbCA9IGEgPT09IHZvaWQgMCA/ICEwIDogYTtcbiAgaWYgKHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciBwID0gQXQodC5lbGVtZW50cy5wb3BwZXIpLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCBcIlwiO1xuICAgIHIgJiYgW1widHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdLnNvbWUoZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIHAuaW5kZXhPZihfKSA+PSAwO1xuICAgIH0pICYmIGNvbnNvbGUud2FybihbXCJQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZ1wiLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgYFxuXG5gLCAnRGlzYWJsZSB0aGUgXCJjb21wdXRlU3R5bGVzXCIgbW9kaWZpZXJcXCdzIGBhZGFwdGl2ZWAgb3B0aW9uIHRvIGFsbG93JywgXCJmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1NcIiwgXCJ0cmFuc2l0aW9uIGRlY2xhcmF0aW9uIG9uIHRoZSBwb3BwZXIgZWxlbWVudCBpZiBvbmx5IHRyYW5zaXRpb25pbmdcIiwgXCJvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuXCIsIGBcblxuYCwgXCJXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXJcIiwgXCJlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuXCJdLmpvaW4oXCIgXCIpKTtcbiAgfVxuICB2YXIgdSA9IHtcbiAgICBwbGFjZW1lbnQ6IEV0KHQucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IFFlKHQucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHQuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHQucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogbixcbiAgICBpc0ZpeGVkOiB0Lm9wdGlvbnMuc3RyYXRlZ3kgPT09IFwiZml4ZWRcIlxuICB9O1xuICB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsICYmICh0LnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCB0LnN0eWxlcy5wb3BwZXIsIEZyKE9iamVjdC5hc3NpZ24oe30sIHUsIHtcbiAgICBvZmZzZXRzOiB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICBwb3NpdGlvbjogdC5vcHRpb25zLnN0cmF0ZWd5LFxuICAgIGFkYXB0aXZlOiByLFxuICAgIHJvdW5kT2Zmc2V0czogbFxuICB9KSkpKSwgdC5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwgJiYgKHQuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgdC5zdHlsZXMuYXJyb3csIEZyKE9iamVjdC5hc3NpZ24oe30sIHUsIHtcbiAgICBvZmZzZXRzOiB0Lm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICBhZGFwdGl2ZTogITEsXG4gICAgcm91bmRPZmZzZXRzOiBsXG4gIH0pKSkpLCB0LmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdC5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgIFwiZGF0YS1wb3BwZXItcGxhY2VtZW50XCI6IHQucGxhY2VtZW50XG4gIH0pO1xufVxuY29uc3QgZnIgPSB7XG4gIG5hbWU6IFwiY29tcHV0ZVN0eWxlc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwiYmVmb3JlV3JpdGVcIixcbiAgZm46IFBkLFxuICBkYXRhOiB7fVxufTtcbnZhciBucyA9IHtcbiAgcGFzc2l2ZTogITBcbn07XG5mdW5jdGlvbiBCZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMuaW5zdGFuY2UsIGkgPSBzLm9wdGlvbnMsIG4gPSBpLnNjcm9sbCwgbyA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgciA9IGkucmVzaXplLCBhID0gciA9PT0gdm9pZCAwID8gITAgOiByLCBsID0gX3QodC5lbGVtZW50cy5wb3BwZXIpLCBwID0gW10uY29uY2F0KHQuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHQuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuICByZXR1cm4gbyAmJiBwLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgIHUuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBlLnVwZGF0ZSwgbnMpO1xuICB9KSwgYSAmJiBsLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZS51cGRhdGUsIG5zKSwgZnVuY3Rpb24oKSB7XG4gICAgbyAmJiBwLmZvckVhY2goZnVuY3Rpb24odSkge1xuICAgICAgdS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGUudXBkYXRlLCBucyk7XG4gICAgfSksIGEgJiYgbC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGUudXBkYXRlLCBucyk7XG4gIH07XG59XG5jb25zdCBtciA9IHtcbiAgbmFtZTogXCJldmVudExpc3RlbmVyc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwid3JpdGVcIixcbiAgZm46IGZ1bmN0aW9uKCkge1xuICB9LFxuICBlZmZlY3Q6IEJkLFxuICBkYXRhOiB7fVxufTtcbnZhciBIZCA9IHtcbiAgbGVmdDogXCJyaWdodFwiLFxuICByaWdodDogXCJsZWZ0XCIsXG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgdG9wOiBcImJvdHRvbVwiXG59O1xuZnVuY3Rpb24gV3Mocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBIZFt0XTtcbiAgfSk7XG59XG52YXIgVmQgPSB7XG4gIHN0YXJ0OiBcImVuZFwiLFxuICBlbmQ6IFwic3RhcnRcIlxufTtcbmZ1bmN0aW9uIFlyKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gVmRbdF07XG4gIH0pO1xufVxuZnVuY3Rpb24gZ3Iocykge1xuICB2YXIgdCA9IF90KHMpLCBlID0gdC5wYWdlWE9mZnNldCwgaSA9IHQucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZSxcbiAgICBzY3JvbGxUb3A6IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIGJyKHMpIHtcbiAgcmV0dXJuIFplKGllKHMpKS5sZWZ0ICsgZ3Iocykuc2Nyb2xsTGVmdDtcbn1cbmZ1bmN0aW9uIFdkKHMsIHQpIHtcbiAgdmFyIGUgPSBfdChzKSwgaSA9IGllKHMpLCBuID0gZS52aXN1YWxWaWV3cG9ydCwgbyA9IGkuY2xpZW50V2lkdGgsIHIgPSBpLmNsaWVudEhlaWdodCwgYSA9IDAsIGwgPSAwO1xuICBpZiAobikge1xuICAgIG8gPSBuLndpZHRoLCByID0gbi5oZWlnaHQ7XG4gICAgdmFyIHAgPSBCYygpO1xuICAgIChwIHx8ICFwICYmIHQgPT09IFwiZml4ZWRcIikgJiYgKGEgPSBuLm9mZnNldExlZnQsIGwgPSBuLm9mZnNldFRvcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogbyxcbiAgICBoZWlnaHQ6IHIsXG4gICAgeDogYSArIGJyKHMpLFxuICAgIHk6IGxcbiAgfTtcbn1cbmZ1bmN0aW9uIEZkKHMpIHtcbiAgdmFyIHQsIGUgPSBpZShzKSwgaSA9IGdyKHMpLCBuID0gKHQgPSBzLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiB0LmJvZHksIG8gPSB2ZShlLnNjcm9sbFdpZHRoLCBlLmNsaWVudFdpZHRoLCBuID8gbi5zY3JvbGxXaWR0aCA6IDAsIG4gPyBuLmNsaWVudFdpZHRoIDogMCksIHIgPSB2ZShlLnNjcm9sbEhlaWdodCwgZS5jbGllbnRIZWlnaHQsIG4gPyBuLnNjcm9sbEhlaWdodCA6IDAsIG4gPyBuLmNsaWVudEhlaWdodCA6IDApLCBhID0gLWkuc2Nyb2xsTGVmdCArIGJyKHMpLCBsID0gLWkuc2Nyb2xsVG9wO1xuICByZXR1cm4gQXQobiB8fCBlKS5kaXJlY3Rpb24gPT09IFwicnRsXCIgJiYgKGEgKz0gdmUoZS5jbGllbnRXaWR0aCwgbiA/IG4uY2xpZW50V2lkdGggOiAwKSAtIG8pLCB7XG4gICAgd2lkdGg6IG8sXG4gICAgaGVpZ2h0OiByLFxuICAgIHg6IGEsXG4gICAgeTogbFxuICB9O1xufVxuZnVuY3Rpb24gdnIocykge1xuICB2YXIgdCA9IEF0KHMpLCBlID0gdC5vdmVyZmxvdywgaSA9IHQub3ZlcmZsb3dYLCBuID0gdC5vdmVyZmxvd1k7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3QoZSArIG4gKyBpKTtcbn1cbmZ1bmN0aW9uIGpjKHMpIHtcbiAgcmV0dXJuIFtcImh0bWxcIiwgXCJib2R5XCIsIFwiI2RvY3VtZW50XCJdLmluZGV4T2YoUnQocykpID49IDAgPyBzLm93bmVyRG9jdW1lbnQuYm9keSA6IGR0KHMpICYmIHZyKHMpID8gcyA6IGpjKG1uKHMpKTtcbn1cbmZ1bmN0aW9uIFJpKHMsIHQpIHtcbiAgdmFyIGU7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IFtdKTtcbiAgdmFyIGkgPSBqYyhzKSwgbiA9IGkgPT09ICgoZSA9IHMub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGUuYm9keSksIG8gPSBfdChpKSwgciA9IG4gPyBbb10uY29uY2F0KG8udmlzdWFsVmlld3BvcnQgfHwgW10sIHZyKGkpID8gaSA6IFtdKSA6IGksIGEgPSB0LmNvbmNhdChyKTtcbiAgcmV0dXJuIG4gPyBhIDogKFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICAgIGEuY29uY2F0KFJpKG1uKHIpKSlcbiAgKTtcbn1cbmZ1bmN0aW9uIFlvKHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHMsIHtcbiAgICBsZWZ0OiBzLngsXG4gICAgdG9wOiBzLnksXG4gICAgcmlnaHQ6IHMueCArIHMud2lkdGgsXG4gICAgYm90dG9tOiBzLnkgKyBzLmhlaWdodFxuICB9KTtcbn1cbmZ1bmN0aW9uIFlkKHMsIHQpIHtcbiAgdmFyIGUgPSBaZShzLCAhMSwgdCA9PT0gXCJmaXhlZFwiKTtcbiAgcmV0dXJuIGUudG9wID0gZS50b3AgKyBzLmNsaWVudFRvcCwgZS5sZWZ0ID0gZS5sZWZ0ICsgcy5jbGllbnRMZWZ0LCBlLmJvdHRvbSA9IGUudG9wICsgcy5jbGllbnRIZWlnaHQsIGUucmlnaHQgPSBlLmxlZnQgKyBzLmNsaWVudFdpZHRoLCBlLndpZHRoID0gcy5jbGllbnRXaWR0aCwgZS5oZWlnaHQgPSBzLmNsaWVudEhlaWdodCwgZS54ID0gZS5sZWZ0LCBlLnkgPSBlLnRvcCwgZTtcbn1cbmZ1bmN0aW9uIGpyKHMsIHQsIGUpIHtcbiAgcmV0dXJuIHQgPT09IGNyID8gWW8oV2QocywgZSkpIDogeWUodCkgPyBZZCh0LCBlKSA6IFlvKEZkKGllKHMpKSk7XG59XG5mdW5jdGlvbiBqZChzKSB7XG4gIHZhciB0ID0gUmkobW4ocykpLCBlID0gW1wiYWJzb2x1dGVcIiwgXCJmaXhlZFwiXS5pbmRleE9mKEF0KHMpLnBvc2l0aW9uKSA+PSAwLCBpID0gZSAmJiBkdChzKSA/IEtpKHMpIDogcztcbiAgcmV0dXJuIHllKGkpID8gdC5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgIHJldHVybiB5ZShuKSAmJiBIYyhuLCBpKSAmJiBSdChuKSAhPT0gXCJib2R5XCI7XG4gIH0pIDogW107XG59XG5mdW5jdGlvbiBLZChzLCB0LCBlLCBpKSB7XG4gIHZhciBuID0gdCA9PT0gXCJjbGlwcGluZ1BhcmVudHNcIiA/IGpkKHMpIDogW10uY29uY2F0KHQpLCBvID0gW10uY29uY2F0KG4sIFtlXSksIHIgPSBvWzBdLCBhID0gby5yZWR1Y2UoZnVuY3Rpb24obCwgcCkge1xuICAgIHZhciB1ID0ganIocywgcCwgaSk7XG4gICAgcmV0dXJuIGwudG9wID0gdmUodS50b3AsIGwudG9wKSwgbC5yaWdodCA9IHVuKHUucmlnaHQsIGwucmlnaHQpLCBsLmJvdHRvbSA9IHVuKHUuYm90dG9tLCBsLmJvdHRvbSksIGwubGVmdCA9IHZlKHUubGVmdCwgbC5sZWZ0KSwgbDtcbiAgfSwganIocywgciwgaSkpO1xuICByZXR1cm4gYS53aWR0aCA9IGEucmlnaHQgLSBhLmxlZnQsIGEuaGVpZ2h0ID0gYS5ib3R0b20gLSBhLnRvcCwgYS54ID0gYS5sZWZ0LCBhLnkgPSBhLnRvcCwgYTtcbn1cbmZ1bmN0aW9uIEtjKHMpIHtcbiAgdmFyIHQgPSBzLnJlZmVyZW5jZSwgZSA9IHMuZWxlbWVudCwgaSA9IHMucGxhY2VtZW50LCBuID0gaSA/IEV0KGkpIDogbnVsbCwgbyA9IGkgPyBRZShpKSA6IG51bGwsIHIgPSB0LnggKyB0LndpZHRoIC8gMiAtIGUud2lkdGggLyAyLCBhID0gdC55ICsgdC5oZWlnaHQgLyAyIC0gZS5oZWlnaHQgLyAyLCBsO1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIHN0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogcixcbiAgICAgICAgeTogdC55IC0gZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIHV0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogcixcbiAgICAgICAgeTogdC55ICsgdC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIHB0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54ICsgdC53aWR0aCxcbiAgICAgICAgeTogYVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgbnQ6XG4gICAgICBsID0ge1xuICAgICAgICB4OiB0LnggLSBlLndpZHRoLFxuICAgICAgICB5OiBhXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGwgPSB7XG4gICAgICAgIHg6IHQueCxcbiAgICAgICAgeTogdC55XG4gICAgICB9O1xuICB9XG4gIHZhciBwID0gbiA/IF9yKG4pIDogbnVsbDtcbiAgaWYgKHAgIT0gbnVsbCkge1xuICAgIHZhciB1ID0gcCA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICAgIHN3aXRjaCAobykge1xuICAgICAgY2FzZSBBZTpcbiAgICAgICAgbFtwXSA9IGxbcF0gLSAodFt1XSAvIDIgLSBlW3VdIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZTpcbiAgICAgICAgbFtwXSA9IGxbcF0gKyAodFt1XSAvIDIgLSBlW3VdIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbDtcbn1cbmZ1bmN0aW9uIEplKHMsIHQpIHtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0ge30pO1xuICB2YXIgZSA9IHQsIGkgPSBlLnBsYWNlbWVudCwgbiA9IGkgPT09IHZvaWQgMCA/IHMucGxhY2VtZW50IDogaSwgbyA9IGUuc3RyYXRlZ3ksIHIgPSBvID09PSB2b2lkIDAgPyBzLnN0cmF0ZWd5IDogbywgYSA9IGUuYm91bmRhcnksIGwgPSBhID09PSB2b2lkIDAgPyB4YyA6IGEsIHAgPSBlLnJvb3RCb3VuZGFyeSwgdSA9IHAgPT09IHZvaWQgMCA/IGNyIDogcCwgXyA9IGUuZWxlbWVudENvbnRleHQsIGYgPSBfID09PSB2b2lkIDAgPyBCZSA6IF8sIGcgPSBlLmFsdEJvdW5kYXJ5LCBtID0gZyA9PT0gdm9pZCAwID8gITEgOiBnLCBiID0gZS5wYWRkaW5nLCB2ID0gYiA9PT0gdm9pZCAwID8gMCA6IGIsIFQgPSBXYyh0eXBlb2YgdiAhPSBcIm51bWJlclwiID8gdiA6IEZjKHYsIG5pKSksIHkgPSBmID09PSBCZSA/IE9jIDogQmUsIEMgPSBzLnJlY3RzLnBvcHBlciwgRSA9IHMuZWxlbWVudHNbbSA/IHkgOiBmXSwgdyA9IEtkKHllKEUpID8gRSA6IEUuY29udGV4dEVsZW1lbnQgfHwgaWUocy5lbGVtZW50cy5wb3BwZXIpLCBsLCB1LCByKSwgayA9IFplKHMuZWxlbWVudHMucmVmZXJlbmNlKSwgRCA9IEtjKHtcbiAgICByZWZlcmVuY2U6IGssXG4gICAgZWxlbWVudDogQyxcbiAgICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiLFxuICAgIHBsYWNlbWVudDogblxuICB9KSwgTyA9IFlvKE9iamVjdC5hc3NpZ24oe30sIEMsIEQpKSwgeCA9IGYgPT09IEJlID8gTyA6IGssIEwgPSB7XG4gICAgdG9wOiB3LnRvcCAtIHgudG9wICsgVC50b3AsXG4gICAgYm90dG9tOiB4LmJvdHRvbSAtIHcuYm90dG9tICsgVC5ib3R0b20sXG4gICAgbGVmdDogdy5sZWZ0IC0geC5sZWZ0ICsgVC5sZWZ0LFxuICAgIHJpZ2h0OiB4LnJpZ2h0IC0gdy5yaWdodCArIFQucmlnaHRcbiAgfSwgUyA9IHMubW9kaWZpZXJzRGF0YS5vZmZzZXQ7XG4gIGlmIChmID09PSBCZSAmJiBTKSB7XG4gICAgdmFyIE4gPSBTW25dO1xuICAgIE9iamVjdC5rZXlzKEwpLmZvckVhY2goZnVuY3Rpb24oUCkge1xuICAgICAgdmFyIG90ID0gW3B0LCB1dF0uaW5kZXhPZihQKSA+PSAwID8gMSA6IC0xLCBydCA9IFtzdCwgdXRdLmluZGV4T2YoUCkgPj0gMCA/IFwieVwiIDogXCJ4XCI7XG4gICAgICBMW1BdICs9IE5bcnRdICogb3Q7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIEw7XG59XG5mdW5jdGlvbiB6ZChzLCB0KSB7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IHt9KTtcbiAgdmFyIGUgPSB0LCBpID0gZS5wbGFjZW1lbnQsIG4gPSBlLmJvdW5kYXJ5LCBvID0gZS5yb290Qm91bmRhcnksIHIgPSBlLnBhZGRpbmcsIGEgPSBlLmZsaXBWYXJpYXRpb25zLCBsID0gZS5hbGxvd2VkQXV0b1BsYWNlbWVudHMsIHAgPSBsID09PSB2b2lkIDAgPyBociA6IGwsIHUgPSBRZShpKSwgXyA9IHUgPyBhID8gV28gOiBXby5maWx0ZXIoZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBRZShtKSA9PT0gdTtcbiAgfSkgOiBuaSwgZiA9IF8uZmlsdGVyKGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gcC5pbmRleE9mKG0pID49IDA7XG4gIH0pO1xuICBmLmxlbmd0aCA9PT0gMCAmJiAoZiA9IF8sIHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFtcIlBvcHBlcjogVGhlIGBhbGxvd2VkQXV0b1BsYWNlbWVudHNgIG9wdGlvbiBkaWQgbm90IGFsbG93IGFueVwiLCBcInBsYWNlbWVudHMuIEVuc3VyZSB0aGUgYHBsYWNlbWVudGAgb3B0aW9uIG1hdGNoZXMgdGhlIHZhcmlhdGlvblwiLCBcIm9mIHRoZSBhbGxvd2VkIHBsYWNlbWVudHMuXCIsICdGb3IgZXhhbXBsZSwgXCJhdXRvXCIgY2Fubm90IGJlIHVzZWQgdG8gYWxsb3cgXCJib3R0b20tc3RhcnRcIi4nLCAnVXNlIFwiYXV0by1zdGFydFwiIGluc3RlYWQuJ10uam9pbihcIiBcIikpKTtcbiAgdmFyIGcgPSBmLnJlZHVjZShmdW5jdGlvbihtLCBiKSB7XG4gICAgcmV0dXJuIG1bYl0gPSBKZShzLCB7XG4gICAgICBwbGFjZW1lbnQ6IGIsXG4gICAgICBib3VuZGFyeTogbixcbiAgICAgIHJvb3RCb3VuZGFyeTogbyxcbiAgICAgIHBhZGRpbmc6IHJcbiAgICB9KVtFdChiKV0sIG07XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGcpLnNvcnQoZnVuY3Rpb24obSwgYikge1xuICAgIHJldHVybiBnW21dIC0gZ1tiXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBVZChzKSB7XG4gIGlmIChFdChzKSA9PT0gamkpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgdCA9IFdzKHMpO1xuICByZXR1cm4gW1lyKHMpLCB0LCBZcih0KV07XG59XG5mdW5jdGlvbiBYZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IHMubmFtZTtcbiAgaWYgKCF0Lm1vZGlmaWVyc0RhdGFbaV0uX3NraXApIHtcbiAgICBmb3IgKHZhciBuID0gZS5tYWluQXhpcywgbyA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgciA9IGUuYWx0QXhpcywgYSA9IHIgPT09IHZvaWQgMCA/ICEwIDogciwgbCA9IGUuZmFsbGJhY2tQbGFjZW1lbnRzLCBwID0gZS5wYWRkaW5nLCB1ID0gZS5ib3VuZGFyeSwgXyA9IGUucm9vdEJvdW5kYXJ5LCBmID0gZS5hbHRCb3VuZGFyeSwgZyA9IGUuZmxpcFZhcmlhdGlvbnMsIG0gPSBnID09PSB2b2lkIDAgPyAhMCA6IGcsIGIgPSBlLmFsbG93ZWRBdXRvUGxhY2VtZW50cywgdiA9IHQub3B0aW9ucy5wbGFjZW1lbnQsIFQgPSBFdCh2KSwgeSA9IFQgPT09IHYsIEMgPSBsIHx8ICh5IHx8ICFtID8gW1dzKHYpXSA6IFVkKHYpKSwgRSA9IFt2XS5jb25jYXQoQykucmVkdWNlKGZ1bmN0aW9uKE9lLCBWdCkge1xuICAgICAgcmV0dXJuIE9lLmNvbmNhdChFdChWdCkgPT09IGppID8gemQodCwge1xuICAgICAgICBwbGFjZW1lbnQ6IFZ0LFxuICAgICAgICBib3VuZGFyeTogdSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiBfLFxuICAgICAgICBwYWRkaW5nOiBwLFxuICAgICAgICBmbGlwVmFyaWF0aW9uczogbSxcbiAgICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBiXG4gICAgICB9KSA6IFZ0KTtcbiAgICB9LCBbXSksIHcgPSB0LnJlY3RzLnJlZmVyZW5jZSwgayA9IHQucmVjdHMucG9wcGVyLCBEID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgTyA9ICEwLCB4ID0gRVswXSwgTCA9IDA7IEwgPCBFLmxlbmd0aDsgTCsrKSB7XG4gICAgICB2YXIgUyA9IEVbTF0sIE4gPSBFdChTKSwgUCA9IFFlKFMpID09PSBBZSwgb3QgPSBbc3QsIHV0XS5pbmRleE9mKE4pID49IDAsIHJ0ID0gb3QgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLCBHID0gSmUodCwge1xuICAgICAgICBwbGFjZW1lbnQ6IFMsXG4gICAgICAgIGJvdW5kYXJ5OiB1LFxuICAgICAgICByb290Qm91bmRhcnk6IF8sXG4gICAgICAgIGFsdEJvdW5kYXJ5OiBmLFxuICAgICAgICBwYWRkaW5nOiBwXG4gICAgICB9KSwgdnQgPSBvdCA/IFAgPyBwdCA6IG50IDogUCA/IHV0IDogc3Q7XG4gICAgICB3W3J0XSA+IGtbcnRdICYmICh2dCA9IFdzKHZ0KSk7XG4gICAgICB2YXIgSmkgPSBXcyh2dCksIG9lID0gW107XG4gICAgICBpZiAobyAmJiBvZS5wdXNoKEdbTl0gPD0gMCksIGEgJiYgb2UucHVzaChHW3Z0XSA8PSAwLCBHW0ppXSA8PSAwKSwgb2UuZXZlcnkoZnVuY3Rpb24oT2UpIHtcbiAgICAgICAgcmV0dXJuIE9lO1xuICAgICAgfSkpIHtcbiAgICAgICAgeCA9IFMsIE8gPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBELnNldChTLCBvZSk7XG4gICAgfVxuICAgIGlmIChPKVxuICAgICAgZm9yICh2YXIgdHMgPSBtID8gMyA6IDEsIGtuID0gZnVuY3Rpb24oVnQpIHtcbiAgICAgICAgdmFyIGRpID0gRS5maW5kKGZ1bmN0aW9uKGlzKSB7XG4gICAgICAgICAgdmFyIHJlID0gRC5nZXQoaXMpO1xuICAgICAgICAgIGlmIChyZSlcbiAgICAgICAgICAgIHJldHVybiByZS5zbGljZSgwLCBWdCkuZXZlcnkoZnVuY3Rpb24oeG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHhuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGkpXG4gICAgICAgICAgcmV0dXJuIHggPSBkaSwgXCJicmVha1wiO1xuICAgICAgfSwgaGkgPSB0czsgaGkgPiAwOyBoaS0tKSB7XG4gICAgICAgIHZhciBlcyA9IGtuKGhpKTtcbiAgICAgICAgaWYgKGVzID09PSBcImJyZWFrXCIpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgdC5wbGFjZW1lbnQgIT09IHggJiYgKHQubW9kaWZpZXJzRGF0YVtpXS5fc2tpcCA9ICEwLCB0LnBsYWNlbWVudCA9IHgsIHQucmVzZXQgPSAhMCk7XG4gIH1cbn1cbmNvbnN0IHpjID0ge1xuICBuYW1lOiBcImZsaXBcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgZm46IFhkLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJvZmZzZXRcIl0sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogITFcbiAgfVxufTtcbmZ1bmN0aW9uIEtyKHMsIHQsIGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSksIHtcbiAgICB0b3A6IHMudG9wIC0gdC5oZWlnaHQgLSBlLnksXG4gICAgcmlnaHQ6IHMucmlnaHQgLSB0LndpZHRoICsgZS54LFxuICAgIGJvdHRvbTogcy5ib3R0b20gLSB0LmhlaWdodCArIGUueSxcbiAgICBsZWZ0OiBzLmxlZnQgLSB0LndpZHRoIC0gZS54XG4gIH07XG59XG5mdW5jdGlvbiB6cihzKSB7XG4gIHJldHVybiBbc3QsIHB0LCB1dCwgbnRdLnNvbWUoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBzW3RdID49IDA7XG4gIH0pO1xufVxuZnVuY3Rpb24gR2Qocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm5hbWUsIGkgPSB0LnJlY3RzLnJlZmVyZW5jZSwgbiA9IHQucmVjdHMucG9wcGVyLCBvID0gdC5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdywgciA9IEplKHQsIHtcbiAgICBlbGVtZW50Q29udGV4dDogXCJyZWZlcmVuY2VcIlxuICB9KSwgYSA9IEplKHQsIHtcbiAgICBhbHRCb3VuZGFyeTogITBcbiAgfSksIGwgPSBLcihyLCBpKSwgcCA9IEtyKGEsIG4sIG8pLCB1ID0genIobCksIF8gPSB6cihwKTtcbiAgdC5tb2RpZmllcnNEYXRhW2VdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogbCxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiB1LFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IF9cbiAgfSwgdC5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHQuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICBcImRhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW5cIjogdSxcbiAgICBcImRhdGEtcG9wcGVyLWVzY2FwZWRcIjogX1xuICB9KTtcbn1cbmNvbnN0IFVjID0ge1xuICBuYW1lOiBcImhpZGVcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgcmVxdWlyZXNJZkV4aXN0czogW1wicHJldmVudE92ZXJmbG93XCJdLFxuICBmbjogR2Rcbn07XG5mdW5jdGlvbiBxZChzLCB0LCBlKSB7XG4gIHZhciBpID0gRXQocyksIG4gPSBbbnQsIHN0XS5pbmRleE9mKGkpID49IDAgPyAtMSA6IDEsIG8gPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlKE9iamVjdC5hc3NpZ24oe30sIHQsIHtcbiAgICBwbGFjZW1lbnQ6IHNcbiAgfSkpIDogZSwgciA9IG9bMF0sIGEgPSBvWzFdO1xuICByZXR1cm4gciA9IHIgfHwgMCwgYSA9IChhIHx8IDApICogbiwgW250LCBwdF0uaW5kZXhPZihpKSA+PSAwID8ge1xuICAgIHg6IGEsXG4gICAgeTogclxuICB9IDoge1xuICAgIHg6IHIsXG4gICAgeTogYVxuICB9O1xufVxuZnVuY3Rpb24gWmQocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBzLm5hbWUsIG4gPSBlLm9mZnNldCwgbyA9IG4gPT09IHZvaWQgMCA/IFswLCAwXSA6IG4sIHIgPSBoci5yZWR1Y2UoZnVuY3Rpb24odSwgXykge1xuICAgIHJldHVybiB1W19dID0gcWQoXywgdC5yZWN0cywgbyksIHU7XG4gIH0sIHt9KSwgYSA9IHJbdC5wbGFjZW1lbnRdLCBsID0gYS54LCBwID0gYS55O1xuICB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsICYmICh0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IGwsIHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0gcCksIHQubW9kaWZpZXJzRGF0YVtpXSA9IHI7XG59XG5jb25zdCBYYyA9IHtcbiAgbmFtZTogXCJvZmZzZXRcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgcmVxdWlyZXM6IFtcInBvcHBlck9mZnNldHNcIl0sXG4gIGZuOiBaZFxufTtcbmZ1bmN0aW9uIFFkKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5uYW1lO1xuICB0Lm1vZGlmaWVyc0RhdGFbZV0gPSBLYyh7XG4gICAgcmVmZXJlbmNlOiB0LnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiB0LnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiLFxuICAgIHBsYWNlbWVudDogdC5wbGFjZW1lbnRcbiAgfSk7XG59XG5jb25zdCBUciA9IHtcbiAgbmFtZTogXCJwb3BwZXJPZmZzZXRzXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJyZWFkXCIsXG4gIGZuOiBRZCxcbiAgZGF0YToge31cbn07XG5mdW5jdGlvbiBKZChzKSB7XG4gIHJldHVybiBzID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7XG59XG5mdW5jdGlvbiB0dShzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IHMubmFtZSwgbiA9IGUubWFpbkF4aXMsIG8gPSBuID09PSB2b2lkIDAgPyAhMCA6IG4sIHIgPSBlLmFsdEF4aXMsIGEgPSByID09PSB2b2lkIDAgPyAhMSA6IHIsIGwgPSBlLmJvdW5kYXJ5LCBwID0gZS5yb290Qm91bmRhcnksIHUgPSBlLmFsdEJvdW5kYXJ5LCBfID0gZS5wYWRkaW5nLCBmID0gZS50ZXRoZXIsIGcgPSBmID09PSB2b2lkIDAgPyAhMCA6IGYsIG0gPSBlLnRldGhlck9mZnNldCwgYiA9IG0gPT09IHZvaWQgMCA/IDAgOiBtLCB2ID0gSmUodCwge1xuICAgIGJvdW5kYXJ5OiBsLFxuICAgIHJvb3RCb3VuZGFyeTogcCxcbiAgICBwYWRkaW5nOiBfLFxuICAgIGFsdEJvdW5kYXJ5OiB1XG4gIH0pLCBUID0gRXQodC5wbGFjZW1lbnQpLCB5ID0gUWUodC5wbGFjZW1lbnQpLCBDID0gIXksIEUgPSBfcihUKSwgdyA9IEpkKEUpLCBrID0gdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsIEQgPSB0LnJlY3RzLnJlZmVyZW5jZSwgTyA9IHQucmVjdHMucG9wcGVyLCB4ID0gdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiID8gYihPYmplY3QuYXNzaWduKHt9LCB0LnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiB0LnBsYWNlbWVudFxuICB9KSkgOiBiLCBMID0gdHlwZW9mIHggPT0gXCJudW1iZXJcIiA/IHtcbiAgICBtYWluQXhpczogeCxcbiAgICBhbHRBeGlzOiB4XG4gIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICBtYWluQXhpczogMCxcbiAgICBhbHRBeGlzOiAwXG4gIH0sIHgpLCBTID0gdC5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHQubW9kaWZpZXJzRGF0YS5vZmZzZXRbdC5wbGFjZW1lbnRdIDogbnVsbCwgTiA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgaWYgKGspIHtcbiAgICBpZiAobykge1xuICAgICAgdmFyIFAsIG90ID0gRSA9PT0gXCJ5XCIgPyBzdCA6IG50LCBydCA9IEUgPT09IFwieVwiID8gdXQgOiBwdCwgRyA9IEUgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgdnQgPSBrW0VdLCBKaSA9IHZ0ICsgdltvdF0sIG9lID0gdnQgLSB2W3J0XSwgdHMgPSBnID8gLU9bR10gLyAyIDogMCwga24gPSB5ID09PSBBZSA/IERbR10gOiBPW0ddLCBoaSA9IHkgPT09IEFlID8gLU9bR10gOiAtRFtHXSwgZXMgPSB0LmVsZW1lbnRzLmFycm93LCBPZSA9IGcgJiYgZXMgPyBwcihlcykgOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sIFZ0ID0gdC5tb2RpZmllcnNEYXRhW1wiYXJyb3cjcGVyc2lzdGVudFwiXSA/IHQubW9kaWZpZXJzRGF0YVtcImFycm93I3BlcnNpc3RlbnRcIl0ucGFkZGluZyA6IFZjKCksIGRpID0gVnRbb3RdLCBpcyA9IFZ0W3J0XSwgcmUgPSBNaSgwLCBEW0ddLCBPZVtHXSksIHhuID0gQyA/IERbR10gLyAyIC0gdHMgLSByZSAtIGRpIC0gTC5tYWluQXhpcyA6IGtuIC0gcmUgLSBkaSAtIEwubWFpbkF4aXMsIG5kID0gQyA/IC1EW0ddIC8gMiArIHRzICsgcmUgKyBpcyArIEwubWFpbkF4aXMgOiBoaSArIHJlICsgaXMgKyBMLm1haW5BeGlzLCBPbiA9IHQuZWxlbWVudHMuYXJyb3cgJiYgS2kodC5lbGVtZW50cy5hcnJvdyksIG9kID0gT24gPyBFID09PSBcInlcIiA/IE9uLmNsaWVudFRvcCB8fCAwIDogT24uY2xpZW50TGVmdCB8fCAwIDogMCwgSXIgPSAoUCA9IFMgPT0gbnVsbCA/IHZvaWQgMCA6IFNbRV0pICE9IG51bGwgPyBQIDogMCwgcmQgPSB2dCArIHhuIC0gSXIgLSBvZCwgYWQgPSB2dCArIG5kIC0gSXIsIERyID0gTWkoZyA/IHVuKEppLCByZCkgOiBKaSwgdnQsIGcgPyB2ZShvZSwgYWQpIDogb2UpO1xuICAgICAga1tFXSA9IERyLCBOW0VdID0gRHIgLSB2dDtcbiAgICB9XG4gICAgaWYgKGEpIHtcbiAgICAgIHZhciAkciwgbGQgPSBFID09PSBcInhcIiA/IHN0IDogbnQsIGNkID0gRSA9PT0gXCJ4XCIgPyB1dCA6IHB0LCBhZSA9IGtbd10sIHNzID0gdyA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLCBMciA9IGFlICsgdltsZF0sIE5yID0gYWUgLSB2W2NkXSwgU24gPSBbc3QsIG50XS5pbmRleE9mKFQpICE9PSAtMSwgTXIgPSAoJHIgPSBTID09IG51bGwgPyB2b2lkIDAgOiBTW3ddKSAhPSBudWxsID8gJHIgOiAwLCBSciA9IFNuID8gTHIgOiBhZSAtIERbc3NdIC0gT1tzc10gLSBNciArIEwuYWx0QXhpcywgUHIgPSBTbiA/IGFlICsgRFtzc10gKyBPW3NzXSAtIE1yIC0gTC5hbHRBeGlzIDogTnIsIEJyID0gZyAmJiBTbiA/IERkKFJyLCBhZSwgUHIpIDogTWkoZyA/IFJyIDogTHIsIGFlLCBnID8gUHIgOiBOcik7XG4gICAgICBrW3ddID0gQnIsIE5bd10gPSBCciAtIGFlO1xuICAgIH1cbiAgICB0Lm1vZGlmaWVyc0RhdGFbaV0gPSBOO1xuICB9XG59XG5jb25zdCBHYyA9IHtcbiAgbmFtZTogXCJwcmV2ZW50T3ZlcmZsb3dcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIm1haW5cIixcbiAgZm46IHR1LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJvZmZzZXRcIl1cbn07XG5mdW5jdGlvbiBldShzKSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogcy5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogcy5zY3JvbGxUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIGl1KHMpIHtcbiAgcmV0dXJuIHMgPT09IF90KHMpIHx8ICFkdChzKSA/IGdyKHMpIDogZXUocyk7XG59XG5mdW5jdGlvbiBzdShzKSB7XG4gIHZhciB0ID0gcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZSA9IHFlKHQud2lkdGgpIC8gcy5vZmZzZXRXaWR0aCB8fCAxLCBpID0gcWUodC5oZWlnaHQpIC8gcy5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIGUgIT09IDEgfHwgaSAhPT0gMTtcbn1cbmZ1bmN0aW9uIG51KHMsIHQsIGUpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gITEpO1xuICB2YXIgaSA9IGR0KHQpLCBuID0gZHQodCkgJiYgc3UodCksIG8gPSBpZSh0KSwgciA9IFplKHMsIG4sIGUpLCBhID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH0sIGwgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIHJldHVybiAoaSB8fCAhaSAmJiAhZSkgJiYgKChSdCh0KSAhPT0gXCJib2R5XCIgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gIHZyKG8pKSAmJiAoYSA9IGl1KHQpKSwgZHQodCkgPyAobCA9IFplKHQsICEwKSwgbC54ICs9IHQuY2xpZW50TGVmdCwgbC55ICs9IHQuY2xpZW50VG9wKSA6IG8gJiYgKGwueCA9IGJyKG8pKSksIHtcbiAgICB4OiByLmxlZnQgKyBhLnNjcm9sbExlZnQgLSBsLngsXG4gICAgeTogci50b3AgKyBhLnNjcm9sbFRvcCAtIGwueSxcbiAgICB3aWR0aDogci53aWR0aCxcbiAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBvdShzKSB7XG4gIHZhciB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIGkgPSBbXTtcbiAgcy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICB0LnNldChvLm5hbWUsIG8pO1xuICB9KTtcbiAgZnVuY3Rpb24gbihvKSB7XG4gICAgZS5hZGQoby5uYW1lKTtcbiAgICB2YXIgciA9IFtdLmNvbmNhdChvLnJlcXVpcmVzIHx8IFtdLCBvLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHIuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICBpZiAoIWUuaGFzKGEpKSB7XG4gICAgICAgIHZhciBsID0gdC5nZXQoYSk7XG4gICAgICAgIGwgJiYgbihsKTtcbiAgICAgIH1cbiAgICB9KSwgaS5wdXNoKG8pO1xuICB9XG4gIHJldHVybiBzLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgIGUuaGFzKG8ubmFtZSkgfHwgbihvKTtcbiAgfSksIGk7XG59XG5mdW5jdGlvbiBydShzKSB7XG4gIHZhciB0ID0gb3Uocyk7XG4gIHJldHVybiBkbi5yZWR1Y2UoZnVuY3Rpb24oZSwgaSkge1xuICAgIHJldHVybiBlLmNvbmNhdCh0LmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gbi5waGFzZSA9PT0gaTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIGF1KHMpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdCB8fCAodCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKGUpIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHQgPSB2b2lkIDAsIGUocygpKTtcbiAgICAgIH0pO1xuICAgIH0pKSwgdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIFd0KHMpIHtcbiAgZm9yICh2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGgsIGUgPSBuZXcgQXJyYXkodCA+IDEgPyB0IC0gMSA6IDApLCBpID0gMTsgaSA8IHQ7IGkrKylcbiAgICBlW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgcmV0dXJuIFtdLmNvbmNhdChlKS5yZWR1Y2UoZnVuY3Rpb24obiwgbykge1xuICAgIHJldHVybiBuLnJlcGxhY2UoLyVzLywgbyk7XG4gIH0sIHMpO1xufVxudmFyIGxlID0gJ1BvcHBlcjogbW9kaWZpZXIgXCIlc1wiIHByb3ZpZGVkIGFuIGludmFsaWQgJXMgcHJvcGVydHksIGV4cGVjdGVkICVzIGJ1dCBnb3QgJXMnLCBsdSA9ICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiByZXF1aXJlcyBcIiVzXCIsIGJ1dCBcIiVzXCIgbW9kaWZpZXIgaXMgbm90IGF2YWlsYWJsZScsIFVyID0gW1wibmFtZVwiLCBcImVuYWJsZWRcIiwgXCJwaGFzZVwiLCBcImZuXCIsIFwiZWZmZWN0XCIsIFwicmVxdWlyZXNcIiwgXCJvcHRpb25zXCJdO1xuZnVuY3Rpb24gY3Uocykge1xuICBzLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgIFtdLmNvbmNhdChPYmplY3Qua2V5cyh0KSwgVXIpLmZpbHRlcihmdW5jdGlvbihlLCBpLCBuKSB7XG4gICAgICByZXR1cm4gbi5pbmRleE9mKGUpID09PSBpO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgdHlwZW9mIHQubmFtZSAhPSBcInN0cmluZ1wiICYmIGNvbnNvbGUuZXJyb3IoV3QobGUsIFN0cmluZyh0Lm5hbWUpLCAnXCJuYW1lXCInLCAnXCJzdHJpbmdcIicsICdcIicgKyBTdHJpbmcodC5uYW1lKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVuYWJsZWRcIjpcbiAgICAgICAgICB0eXBlb2YgdC5lbmFibGVkICE9IFwiYm9vbGVhblwiICYmIGNvbnNvbGUuZXJyb3IoV3QobGUsIHQubmFtZSwgJ1wiZW5hYmxlZFwiJywgJ1wiYm9vbGVhblwiJywgJ1wiJyArIFN0cmluZyh0LmVuYWJsZWQpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicGhhc2VcIjpcbiAgICAgICAgICBkbi5pbmRleE9mKHQucGhhc2UpIDwgMCAmJiBjb25zb2xlLmVycm9yKFd0KGxlLCB0Lm5hbWUsICdcInBoYXNlXCInLCBcImVpdGhlciBcIiArIGRuLmpvaW4oXCIsIFwiKSwgJ1wiJyArIFN0cmluZyh0LnBoYXNlKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImZuXCI6XG4gICAgICAgICAgdHlwZW9mIHQuZm4gIT0gXCJmdW5jdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoV3QobGUsIHQubmFtZSwgJ1wiZm5cIicsICdcImZ1bmN0aW9uXCInLCAnXCInICsgU3RyaW5nKHQuZm4pICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZWZmZWN0XCI6XG4gICAgICAgICAgdC5lZmZlY3QgIT0gbnVsbCAmJiB0eXBlb2YgdC5lZmZlY3QgIT0gXCJmdW5jdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoV3QobGUsIHQubmFtZSwgJ1wiZWZmZWN0XCInLCAnXCJmdW5jdGlvblwiJywgJ1wiJyArIFN0cmluZyh0LmZuKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlcXVpcmVzXCI6XG4gICAgICAgICAgdC5yZXF1aXJlcyAhPSBudWxsICYmICFBcnJheS5pc0FycmF5KHQucmVxdWlyZXMpICYmIGNvbnNvbGUuZXJyb3IoV3QobGUsIHQubmFtZSwgJ1wicmVxdWlyZXNcIicsICdcImFycmF5XCInLCAnXCInICsgU3RyaW5nKHQucmVxdWlyZXMpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVxdWlyZXNJZkV4aXN0c1wiOlxuICAgICAgICAgIEFycmF5LmlzQXJyYXkodC5yZXF1aXJlc0lmRXhpc3RzKSB8fCBjb25zb2xlLmVycm9yKFd0KGxlLCB0Lm5hbWUsICdcInJlcXVpcmVzSWZFeGlzdHNcIicsICdcImFycmF5XCInLCAnXCInICsgU3RyaW5nKHQucmVxdWlyZXNJZkV4aXN0cykgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvcHRpb25zXCI6XG4gICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUG9wcGVySlM6IGFuIGludmFsaWQgcHJvcGVydHkgaGFzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIFwiJyArIHQubmFtZSArICdcIiBtb2RpZmllciwgdmFsaWQgcHJvcGVydGllcyBhcmUgJyArIFVyLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1wiJyArIGkgKyAnXCInO1xuICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKSArICc7IGJ1dCBcIicgKyBlICsgJ1wiIHdhcyBwcm92aWRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHQucmVxdWlyZXMgJiYgdC5yZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcy5maW5kKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi5uYW1lID09PSBpO1xuICAgICAgICB9KSA9PSBudWxsICYmIGNvbnNvbGUuZXJyb3IoV3QobHUsIFN0cmluZyh0Lm5hbWUpLCBpLCBpKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBodShzLCB0KSB7XG4gIHZhciBlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcmV0dXJuIHMuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgbiA9IHQoaSk7XG4gICAgaWYgKCFlLmhhcyhuKSlcbiAgICAgIHJldHVybiBlLmFkZChuKSwgITA7XG4gIH0pO1xufVxuZnVuY3Rpb24gZHUocykge1xuICB2YXIgdCA9IHMucmVkdWNlKGZ1bmN0aW9uKGUsIGkpIHtcbiAgICB2YXIgbiA9IGVbaS5uYW1lXTtcbiAgICByZXR1cm4gZVtpLm5hbWVdID0gbiA/IE9iamVjdC5hc3NpZ24oe30sIG4sIGksIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIG4ub3B0aW9ucywgaS5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIG4uZGF0YSwgaS5kYXRhKVxuICAgIH0pIDogaSwgZTtcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXModCkubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdFtlXTtcbiAgfSk7XG59XG52YXIgWHIgPSBcIlBvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50LlwiLCB1dSA9IFwiUG9wcGVyOiBBbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtb2RpZmllcnMgY3ljbGUgaGFzIGJlZW4gZGV0ZWN0ZWQhIFRoZSBjeWNsZSBoYXMgYmVlbiBpbnRlcnJ1cHRlZCB0byBwcmV2ZW50IGEgYnJvd3NlciBjcmFzaC5cIiwgR3IgPSB7XG4gIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIlxufTtcbmZ1bmN0aW9uIHFyKCkge1xuICBmb3IgKHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShzKSwgZSA9IDA7IGUgPCBzOyBlKyspXG4gICAgdFtlXSA9IGFyZ3VtZW50c1tlXTtcbiAgcmV0dXJuICF0LnNvbWUoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiAhKGkgJiYgdHlwZW9mIGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09IFwiZnVuY3Rpb25cIik7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ24ocykge1xuICBzID09PSB2b2lkIDAgJiYgKHMgPSB7fSk7XG4gIHZhciB0ID0gcywgZSA9IHQuZGVmYXVsdE1vZGlmaWVycywgaSA9IGUgPT09IHZvaWQgMCA/IFtdIDogZSwgbiA9IHQuZGVmYXVsdE9wdGlvbnMsIG8gPSBuID09PSB2b2lkIDAgPyBHciA6IG47XG4gIHJldHVybiBmdW5jdGlvbihhLCBsLCBwKSB7XG4gICAgcCA9PT0gdm9pZCAwICYmIChwID0gbyk7XG4gICAgdmFyIHUgPSB7XG4gICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIEdyLCBvKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiBhLFxuICAgICAgICBwb3BwZXI6IGxcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9LCBfID0gW10sIGYgPSAhMSwgZyA9IHtcbiAgICAgIHN0YXRlOiB1LFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24oVCkge1xuICAgICAgICB2YXIgeSA9IHR5cGVvZiBUID09IFwiZnVuY3Rpb25cIiA/IFQodS5vcHRpb25zKSA6IFQ7XG4gICAgICAgIGIoKSwgdS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgbywgdS5vcHRpb25zLCB5KSwgdS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogeWUoYSkgPyBSaShhKSA6IGEuY29udGV4dEVsZW1lbnQgPyBSaShhLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogUmkobClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIEMgPSBydShkdShbXS5jb25jYXQoaSwgdS5vcHRpb25zLm1vZGlmaWVycykpKTtcbiAgICAgICAgaWYgKHUub3JkZXJlZE1vZGlmaWVycyA9IEMuZmlsdGVyKGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgICByZXR1cm4gUy5lbmFibGVkO1xuICAgICAgICB9KSwge30uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgdmFyIEUgPSBodShbXS5jb25jYXQoQywgdS5vcHRpb25zLm1vZGlmaWVycyksIGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgICAgIHZhciBOID0gUy5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIE47XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGN1KEUpLCBFdCh1Lm9wdGlvbnMucGxhY2VtZW50KSA9PT0gamkpIHtcbiAgICAgICAgICAgIHZhciB3ID0gdS5vcmRlcmVkTW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24oUykge1xuICAgICAgICAgICAgICB2YXIgTiA9IFMubmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuIE4gPT09IFwiZmxpcFwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3IHx8IGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXV0b1wiIHBsYWNlbWVudHMgcmVxdWlyZSB0aGUgXCJmbGlwXCIgbW9kaWZpZXIgYmUnLCBcInByZXNlbnQgYW5kIGVuYWJsZWQgdG8gd29yay5cIl0uam9pbihcIiBcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgayA9IEF0KGwpLCBEID0gay5tYXJnaW5Ub3AsIE8gPSBrLm1hcmdpblJpZ2h0LCB4ID0gay5tYXJnaW5Cb3R0b20sIEwgPSBrLm1hcmdpbkxlZnQ7XG4gICAgICAgICAgW0QsIE8sIHgsIExdLnNvbWUoZnVuY3Rpb24oUykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoUyk7XG4gICAgICAgICAgfSkgJiYgY29uc29sZS53YXJuKFsnUG9wcGVyOiBDU1MgXCJtYXJnaW5cIiBzdHlsZXMgY2Fubm90IGJlIHVzZWQgdG8gYXBwbHkgcGFkZGluZycsIFwiYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgb3IgYm91bmRhcnkuXCIsIFwiVG8gcmVwbGljYXRlIG1hcmdpbiwgdXNlIHRoZSBgb2Zmc2V0YCBtb2RpZmllciwgYXMgd2VsbCBhc1wiLCBcInRoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgXCIsIFwibW9kaWZpZXJzLlwiXS5qb2luKFwiIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0oKSwgZy51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghZikge1xuICAgICAgICAgIHZhciBUID0gdS5lbGVtZW50cywgeSA9IFQucmVmZXJlbmNlLCBDID0gVC5wb3BwZXI7XG4gICAgICAgICAgaWYgKCFxcih5LCBDKSkge1xuICAgICAgICAgICAgKHt9KS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihYcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHUucmVjdHMgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2U6IG51KHksIEtpKEMpLCB1Lm9wdGlvbnMuc3RyYXRlZ3kgPT09IFwiZml4ZWRcIiksXG4gICAgICAgICAgICBwb3BwZXI6IHByKEMpXG4gICAgICAgICAgfSwgdS5yZXNldCA9ICExLCB1LnBsYWNlbWVudCA9IHUub3B0aW9ucy5wbGFjZW1lbnQsIHUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKFMpIHtcbiAgICAgICAgICAgIHJldHVybiB1Lm1vZGlmaWVyc0RhdGFbUy5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIFMuZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yICh2YXIgRSA9IDAsIHcgPSAwOyB3IDwgdS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgICBpZiAoe30uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChFICs9IDEsIEUgPiAxMDApKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodXUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1LnJlc2V0ID09PSAhMCkge1xuICAgICAgICAgICAgICB1LnJlc2V0ID0gITEsIHcgPSAtMTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgayA9IHUub3JkZXJlZE1vZGlmaWVyc1t3XSwgRCA9IGsuZm4sIE8gPSBrLm9wdGlvbnMsIHggPSBPID09PSB2b2lkIDAgPyB7fSA6IE8sIEwgPSBrLm5hbWU7XG4gICAgICAgICAgICB0eXBlb2YgRCA9PSBcImZ1bmN0aW9uXCIgJiYgKHUgPSBEKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHgsXG4gICAgICAgICAgICAgIG5hbWU6IEwsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBnXG4gICAgICAgICAgICB9KSB8fCB1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBhdShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBnLmZvcmNlVXBkYXRlKCksIHYodSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgYigpLCBmID0gITA7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIXFyKGEsIGwpKVxuICAgICAgcmV0dXJuIHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFhyKSwgZztcbiAgICBnLnNldE9wdGlvbnMocCkudGhlbihmdW5jdGlvbih2KSB7XG4gICAgICAhZiAmJiBwLm9uRmlyc3RVcGRhdGUgJiYgcC5vbkZpcnN0VXBkYXRlKHYpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIG0oKSB7XG4gICAgICB1Lm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciBUID0gdi5uYW1lLCB5ID0gdi5vcHRpb25zLCBDID0geSA9PT0gdm9pZCAwID8ge30gOiB5LCBFID0gdi5lZmZlY3Q7XG4gICAgICAgIGlmICh0eXBlb2YgRSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB2YXIgdyA9IEUoe1xuICAgICAgICAgICAgc3RhdGU6IHUsXG4gICAgICAgICAgICBuYW1lOiBULFxuICAgICAgICAgICAgaW5zdGFuY2U6IGcsXG4gICAgICAgICAgICBvcHRpb25zOiBDXG4gICAgICAgICAgfSksIGsgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB9O1xuICAgICAgICAgIF8ucHVzaCh3IHx8IGspO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYigpIHtcbiAgICAgIF8uZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2KCk7XG4gICAgICB9KSwgXyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gZztcbiAgfTtcbn1cbnZhciBwdSA9IC8qIEBfX1BVUkVfXyAqLyBnbigpLCBfdSA9IFttciwgVHIsIGZyLCB1cl0sIGZ1ID0gLyogQF9fUFVSRV9fICovIGduKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogX3Vcbn0pLCBtdSA9IFttciwgVHIsIGZyLCB1ciwgWGMsIHpjLCBHYywgWWMsIFVjXSwgc2UgPSAvKiBAX19QVVJFX18gKi8gZ24oe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBtdVxufSk7XG5jb25zdCBxYyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFmdGVyTWFpbjogTmMsXG4gIGFmdGVyUmVhZDogRGMsXG4gIGFmdGVyV3JpdGU6IFBjLFxuICBhcHBseVN0eWxlczogdXIsXG4gIGFycm93OiBZYyxcbiAgYXV0bzogamksXG4gIGJhc2VQbGFjZW1lbnRzOiBuaSxcbiAgYmVmb3JlTWFpbjogJGMsXG4gIGJlZm9yZVJlYWQ6IFNjLFxuICBiZWZvcmVXcml0ZTogTWMsXG4gIGJvdHRvbTogdXQsXG4gIGNsaXBwaW5nUGFyZW50czogeGMsXG4gIGNvbXB1dGVTdHlsZXM6IGZyLFxuICBjcmVhdGVQb3BwZXI6IHNlLFxuICBjcmVhdGVQb3BwZXJCYXNlOiBwdSxcbiAgY3JlYXRlUG9wcGVyTGl0ZTogZnUsXG4gIGRldGVjdE92ZXJmbG93OiBKZSxcbiAgZW5kOiBHZSxcbiAgZXZlbnRMaXN0ZW5lcnM6IG1yLFxuICBmbGlwOiB6YyxcbiAgaGlkZTogVWMsXG4gIGxlZnQ6IG50LFxuICBtYWluOiBMYyxcbiAgbW9kaWZpZXJQaGFzZXM6IGRuLFxuICBvZmZzZXQ6IFhjLFxuICBwbGFjZW1lbnRzOiBocixcbiAgcG9wcGVyOiBCZSxcbiAgcG9wcGVyR2VuZXJhdG9yOiBnbixcbiAgcG9wcGVyT2Zmc2V0czogVHIsXG4gIHByZXZlbnRPdmVyZmxvdzogR2MsXG4gIHJlYWQ6IEljLFxuICByZWZlcmVuY2U6IE9jLFxuICByaWdodDogcHQsXG4gIHN0YXJ0OiBBZSxcbiAgdG9wOiBzdCxcbiAgdmFyaWF0aW9uUGxhY2VtZW50czogV28sXG4gIHZpZXdwb3J0OiBjcixcbiAgd3JpdGU6IFJjXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xuZnVuY3Rpb24gTG4ocykge1xuICByZXR1cm4gcyA9PT0gXCJ0cnVlXCIgPyAhMCA6IHMgPT09IFwiZmFsc2VcIiA/ICExIDogcyA9PT0gTnVtYmVyKHMpLnRvU3RyaW5nKCkgPyBOdW1iZXIocykgOiBzID09PSBcIlwiIHx8IHMgPT09IFwibnVsbFwiID8gbnVsbCA6IHM7XG59XG5mdW5jdGlvbiBObihzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1tBLVpdL2csICh0KSA9PiBgLSR7dC50b0xvd2VyQ2FzZSgpfWApO1xufVxuY29uc3QgaCA9IHtcbiAgc2V0RGF0YUF0dHJpYnV0ZShzLCB0LCBlKSB7XG4gICAgcy5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtJHtObih0KX1gLCBlKTtcbiAgfSxcbiAgcmVtb3ZlRGF0YUF0dHJpYnV0ZShzLCB0KSB7XG4gICAgcy5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtdGUtJHtObih0KX1gKTtcbiAgfSxcbiAgZ2V0RGF0YUF0dHJpYnV0ZXMocykge1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB0ID0ge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHMuZGF0YXNldCkuZmlsdGVyKChlKSA9PiBlLnN0YXJ0c1dpdGgoXCJ0ZVwiKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaWYgKGUuc3RhcnRzV2l0aChcInRlQ2xhc3NcIikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBpID0gZS5yZXBsYWNlKC9edGUvLCBcIlwiKTtcbiAgICAgIGkgPSBpLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgaS5zbGljZSgxLCBpLmxlbmd0aCksIHRbaV0gPSBMbihzLmRhdGFzZXRbZV0pO1xuICAgIH0pLCB0O1xuICB9LFxuICBnZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHMpIHtcbiAgICBpZiAoIXMpXG4gICAgICByZXR1cm4ge307XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLnMuZGF0YXNldFxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLmZpbHRlcigoZSkgPT4gZS5zdGFydHNXaXRoKFwidGVDbGFzc1wiKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgbGV0IGkgPSBlLnJlcGxhY2UoL150ZUNsYXNzLywgXCJcIik7XG4gICAgICBpID0gaS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIGkuc2xpY2UoMSwgaS5sZW5ndGgpLCB0W2ldID0gTG4odFtlXSk7XG4gICAgfSksIHQ7XG4gIH0sXG4gIGdldERhdGFBdHRyaWJ1dGUocywgdCkge1xuICAgIHJldHVybiBMbihcbiAgICAgIHMuZ2V0QXR0cmlidXRlKGBkYXRhLXRlLSR7Tm4odCl9YClcbiAgICApO1xuICB9LFxuICBvZmZzZXQocykge1xuICAgIGNvbnN0IHQgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHQudG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICBsZWZ0OiB0LmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnRcbiAgICB9O1xuICB9LFxuICBwb3NpdGlvbihzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcy5vZmZzZXRUb3AsXG4gICAgICBsZWZ0OiBzLm9mZnNldExlZnRcbiAgICB9O1xuICB9LFxuICBzdHlsZShzLCB0KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzLnN0eWxlLCB0KTtcbiAgfSxcbiAgdG9nZ2xlQ2xhc3MocywgdCkge1xuICAgIHMgJiYgTW4odCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgcy5jbGFzc0xpc3QuY29udGFpbnMoZSkgPyBzLmNsYXNzTGlzdC5yZW1vdmUoZSkgOiBzLmNsYXNzTGlzdC5hZGQoZSk7XG4gICAgfSk7XG4gIH0sXG4gIGFkZENsYXNzKHMsIHQpIHtcbiAgICBNbih0KS5mb3JFYWNoKFxuICAgICAgKGUpID0+ICFzLmNsYXNzTGlzdC5jb250YWlucyhlKSAmJiBzLmNsYXNzTGlzdC5hZGQoZSlcbiAgICApO1xuICB9LFxuICBhZGRTdHlsZShzLCB0KSB7XG4gICAgT2JqZWN0LmtleXModCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgcy5zdHlsZVtlXSA9IHRbZV07XG4gICAgfSk7XG4gIH0sXG4gIHJlbW92ZUNsYXNzKHMsIHQpIHtcbiAgICBNbih0KS5mb3JFYWNoKFxuICAgICAgKGUpID0+IHMuY2xhc3NMaXN0LmNvbnRhaW5zKGUpICYmIHMuY2xhc3NMaXN0LnJlbW92ZShlKVxuICAgICk7XG4gIH0sXG4gIGhhc0NsYXNzKHMsIHQpIHtcbiAgICByZXR1cm4gcy5jbGFzc0xpc3QuY29udGFpbnModCk7XG4gIH0sXG4gIG1heE9mZnNldChzKSB7XG4gICAgY29uc3QgdCA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdC50b3AgKyBNYXRoLm1heChcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICAgIHdpbmRvdy5zY3JvbGxZXG4gICAgICApLFxuICAgICAgbGVmdDogdC5sZWZ0ICsgTWF0aC5tYXgoXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICAgIHdpbmRvdy5zY3JvbGxYXG4gICAgICApXG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIE1uKHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBzLnNwbGl0KFwiIFwiKSA6IEFycmF5LmlzQXJyYXkocykgPyBzIDogITE7XG59XG5jb25zdCBndSA9IDMsIGQgPSB7XG4gIGNsb3Nlc3QocywgdCkge1xuICAgIHJldHVybiBzLmNsb3Nlc3QodCk7XG4gIH0sXG4gIG1hdGNoZXMocywgdCkge1xuICAgIHJldHVybiBzLm1hdGNoZXModCk7XG4gIH0sXG4gIGZpbmQocywgdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAuLi5FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLmNhbGwodCwgcylcbiAgICApO1xuICB9LFxuICBmaW5kT25lKHMsIHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvci5jYWxsKHQsIHMpO1xuICB9LFxuICBjaGlsZHJlbihzLCB0KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5zLmNoaWxkcmVuKS5maWx0ZXIoKGkpID0+IGkubWF0Y2hlcyh0KSk7XG4gIH0sXG4gIHBhcmVudHMocywgdCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICBsZXQgaSA9IHMucGFyZW50Tm9kZTtcbiAgICBmb3IgKDsgaSAmJiBpLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBpLm5vZGVUeXBlICE9PSBndTsgKVxuICAgICAgdGhpcy5tYXRjaGVzKGksIHQpICYmIGUucHVzaChpKSwgaSA9IGkucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gZTtcbiAgfSxcbiAgcHJldihzLCB0KSB7XG4gICAgbGV0IGUgPSBzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgZm9yICg7IGU7ICkge1xuICAgICAgaWYgKGUubWF0Y2hlcyh0KSlcbiAgICAgICAgcmV0dXJuIFtlXTtcbiAgICAgIGUgPSBlLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgbmV4dChzLCB0KSB7XG4gICAgbGV0IGUgPSBzLm5leHRFbGVtZW50U2libGluZztcbiAgICBmb3IgKDsgZTsgKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaGVzKGUsIHQpKVxuICAgICAgICByZXR1cm4gW2VdO1xuICAgICAgZSA9IGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH0sXG4gIGZvY3VzYWJsZUNoaWxkcmVuKHMpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgXCJhXCIsXG4gICAgICBcImJ1dHRvblwiLFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgXCJ0ZXh0YXJlYVwiLFxuICAgICAgXCJzZWxlY3RcIixcbiAgICAgIFwiZGV0YWlsc1wiLFxuICAgICAgXCJbdGFiaW5kZXhdXCIsXG4gICAgICAnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nXG4gICAgXS5tYXAoKGUpID0+IGAke2V9Om5vdChbdGFiaW5kZXhePVwiLVwiXSlgKS5qb2luKFwiLCBcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluZCh0LCBzKS5maWx0ZXIoXG4gICAgICAoZSkgPT4gIWJlKGUpICYmIE10KGUpXG4gICAgKTtcbiAgfVxufSwgUm4gPSBcImRyb3Bkb3duXCIsIGJ1ID0gXCJ0ZS5kcm9wZG93blwiLCB4ZSA9IGAuJHtidX1gLCBFciA9IFwiLmRhdGEtYXBpXCIsIEZzID0gXCJFc2NhcGVcIiwgWnIgPSBcIlNwYWNlXCIsIFFyID0gXCJUYWJcIiwgam8gPSBcIkFycm93VXBcIiwgWXMgPSBcIkFycm93RG93blwiLCB2dSA9IDIsIFR1ID0gbmV3IFJlZ0V4cChcbiAgYCR7am99fCR7WXN9fCR7RnN9YFxuKSwgRXUgPSBgaGlkZSR7eGV9YCwgQ3UgPSBgaGlkZGVuJHt4ZX1gLCBBdSA9IGBzaG93JHt4ZX1gLCB5dSA9IGBzaG93biR7eGV9YCwgd3UgPSBgY2xpY2ske3hlfSR7RXJ9YCwgSnIgPSBga2V5ZG93biR7eGV9JHtFcn1gLCBrdSA9IGBrZXl1cCR7eGV9JHtFcn1gLCBGdCA9IFwic2hvd1wiLCB4dSA9IFwiZHJvcHVwXCIsIE91ID0gXCJkcm9wZW5kXCIsIFN1ID0gXCJkcm9wc3RhcnRcIiwgSXUgPSBcIltkYXRhLXRlLW5hdmJhci1yZWZdXCIsIG9zID0gXCJbZGF0YS10ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBQbiA9IFwiW2RhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZdXCIsIER1ID0gXCJbZGF0YS10ZS1uYXZiYXItbmF2LXJlZl1cIiwgJHUgPSBcIltkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXSBbZGF0YS10ZS1kcm9wZG93bi1pdGVtLXJlZl06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZClcIiwgTHUgPSBXKCkgPyBcInRvcC1lbmRcIiA6IFwidG9wLXN0YXJ0XCIsIE51ID0gVygpID8gXCJ0b3Atc3RhcnRcIiA6IFwidG9wLWVuZFwiLCBNdSA9IFcoKSA/IFwiYm90dG9tLWVuZFwiIDogXCJib3R0b20tc3RhcnRcIiwgUnUgPSBXKCkgPyBcImJvdHRvbS1zdGFydFwiIDogXCJib3R0b20tZW5kXCIsIFB1ID0gVygpID8gXCJsZWZ0LXN0YXJ0XCIgOiBcInJpZ2h0LXN0YXJ0XCIsIEJ1ID0gVygpID8gXCJyaWdodC1zdGFydFwiIDogXCJsZWZ0LXN0YXJ0XCIsIEh1ID0gW3sgb3BhY2l0eTogXCIwXCIgfSwgeyBvcGFjaXR5OiBcIjFcIiB9XSwgVnUgPSBbeyBvcGFjaXR5OiBcIjFcIiB9LCB7IG9wYWNpdHk6IFwiMFwiIH1dLCB0YSA9IHtcbiAgaXRlcmF0aW9uczogMSxcbiAgZWFzaW5nOiBcImVhc2VcIixcbiAgZmlsbDogXCJib3RoXCJcbn0sIFd1ID0ge1xuICBvZmZzZXQ6IFswLCAyXSxcbiAgYm91bmRhcnk6IFwiY2xpcHBpbmdQYXJlbnRzXCIsXG4gIHJlZmVyZW5jZTogXCJ0b2dnbGVcIixcbiAgZGlzcGxheTogXCJkeW5hbWljXCIsXG4gIHBvcHBlckNvbmZpZzogbnVsbCxcbiAgYXV0b0Nsb3NlOiAhMCxcbiAgZHJvcGRvd25BbmltYXRpb246IFwib25cIixcbiAgYW5pbWF0aW9uRHVyYXRpb246IDU1MFxufSwgRnUgPSB7XG4gIG9mZnNldDogXCIoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBib3VuZGFyeTogXCIoc3RyaW5nfGVsZW1lbnQpXCIsXG4gIHJlZmVyZW5jZTogXCIoc3RyaW5nfGVsZW1lbnR8b2JqZWN0KVwiLFxuICBkaXNwbGF5OiBcInN0cmluZ1wiLFxuICBwb3BwZXJDb25maWc6IFwiKG51bGx8b2JqZWN0fGZ1bmN0aW9uKVwiLFxuICBhdXRvQ2xvc2U6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBkcm9wZG93bkFuaW1hdGlvbjogXCJzdHJpbmdcIixcbiAgYW5pbWF0aW9uRHVyYXRpb246IFwibnVtYmVyXCJcbn07XG5jbGFzcyAkdCBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpLCB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpLCB0aGlzLl9mYWRlT3V0QW5pbWF0ZSA9IG51bGw7XG4gICAgY29uc3QgaSA9IHdpbmRvdy5tYXRjaE1lZGlhKFxuICAgICAgXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiXG4gICAgKS5tYXRjaGVzO1xuICAgIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgPSB0aGlzLl9jb25maWcuZHJvcGRvd25BbmltYXRpb24gPT09IFwib25cIiAmJiAhaSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIFd1O1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIEZ1O1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gUm47XG4gIH1cbiAgLy8gUHVibGljXG4gIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmIChiZSh0aGlzLl9lbGVtZW50KSB8fCB0aGlzLl9pc1Nob3duKHRoaXMuX21lbnUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfTtcbiAgICBpZiAoYy50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIEF1LFxuICAgICAgdFxuICAgICkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gJHQuZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgdGhpcy5faW5OYXZiYXIgPyBoLnNldERhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgXCJwb3BwZXJcIiwgXCJub25lXCIpIDogdGhpcy5fY3JlYXRlUG9wcGVyKGkpLCBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhaS5jbG9zZXN0KER1KSAmJiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgobikgPT4gYy5vbihuLCBcIm1vdXNlb3ZlclwiLCBobikpLCB0aGlzLl9lbGVtZW50LmZvY3VzKCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCAhMCksIHRoaXMuX21lbnUuc2V0QXR0cmlidXRlKGBkYXRhLXRlLWRyb3Bkb3duLSR7RnR9YCwgXCJcIiksIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgJiYgdGhpcy5fbWVudS5hbmltYXRlKEh1LCB7XG4gICAgICAuLi50YSxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLl9jb25maWcuYW5pbWF0aW9uRHVyYXRpb25cbiAgICB9KSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtZHJvcGRvd24tJHtGdH1gLCBcIlwiKSwgc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHl1LCB0KTtcbiAgICAgIH0sXG4gICAgICB0aGlzLl9hbmltYXRpb25DYW5QbGF5ID8gdGhpcy5fY29uZmlnLmFuaW1hdGlvbkR1cmF0aW9uIDogMFxuICAgICk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoYmUodGhpcy5fZWxlbWVudCkgfHwgIXRoaXMuX2lzU2hvd24odGhpcy5fbWVudSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9O1xuICAgIHRoaXMuX2NvbXBsZXRlSGlkZSh0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCksIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8IChjLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBKcixcbiAgICAgIG9zLFxuICAgICAgJHQuZGF0YUFwaUtleWRvd25IYW5kbGVyXG4gICAgKSwgYy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgSnIsXG4gICAgICBQbixcbiAgICAgICR0LmRhdGFBcGlLZXlkb3duSGFuZGxlclxuICAgICksIGMub24oZG9jdW1lbnQsIHd1LCAkdC5jbGVhck1lbnVzKSwgYy5vbihkb2N1bWVudCwga3UsICR0LmNsZWFyTWVudXMpLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9jb21wbGV0ZUhpZGUodCkge1xuICAgIHRoaXMuX2ZhZGVPdXRBbmltYXRlICYmIHRoaXMuX2ZhZGVPdXRBbmltYXRlLnBsYXlTdGF0ZSA9PT0gXCJydW5uaW5nXCIgfHwgYy50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIEV1LFxuICAgICAgdFxuICAgICkuZGVmYXVsdFByZXZlbnRlZCB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKGkpID0+IGMub2ZmKGksIFwibW91c2VvdmVyXCIsIGhuKSksIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgJiYgKHRoaXMuX2ZhZGVPdXRBbmltYXRlID0gdGhpcy5fbWVudS5hbmltYXRlKFZ1LCB7XG4gICAgICAuLi50YSxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLl9jb25maWcuYW5pbWF0aW9uRHVyYXRpb25cbiAgICB9KSksIHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9tZW51LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS1kcm9wZG93bi0ke0Z0fWApLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS1kcm9wZG93bi0ke0Z0fWApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKSwgaC5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsIFwicG9wcGVyXCIpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgQ3UsIHQpO1xuICAgICAgfSxcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgPyB0aGlzLl9jb25maWcuYW5pbWF0aW9uRHVyYXRpb24gOiAwXG4gICAgKSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgaWYgKHQgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH0sIEkoUm4sIHQsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLCB0eXBlb2YgdC5yZWZlcmVuY2UgPT0gXCJvYmplY3RcIiAmJiAhWGUodC5yZWZlcmVuY2UpICYmIHR5cGVvZiB0LnJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYCR7Um4udG9VcHBlckNhc2UoKX06IE9wdGlvbiBcInJlZmVyZW5jZVwiIHByb3ZpZGVkIHR5cGUgXCJvYmplY3RcIiB3aXRob3V0IGEgcmVxdWlyZWQgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIiBtZXRob2QuYFxuICAgICAgKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBfY3JlYXRlUG9wcGVyKHQpIHtcbiAgICBpZiAodHlwZW9mIHFjID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkJvb3RzdHJhcCdzIGRyb3Bkb3ducyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKVwiXG4gICAgICApO1xuICAgIGxldCBlID0gdGhpcy5fZWxlbWVudDtcbiAgICB0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSBcInBhcmVudFwiID8gZSA9IHQgOiBYZSh0aGlzLl9jb25maWcucmVmZXJlbmNlKSA/IGUgPSBlZSh0aGlzLl9jb25maWcucmVmZXJlbmNlKSA6IHR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlID09IFwib2JqZWN0XCIgJiYgKGUgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlKTtcbiAgICBjb25zdCBpID0gdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCksIG4gPSBpLm1vZGlmaWVycy5maW5kKFxuICAgICAgKG8pID0+IG8ubmFtZSA9PT0gXCJhcHBseVN0eWxlc1wiICYmIG8uZW5hYmxlZCA9PT0gITFcbiAgICApO1xuICAgIHRoaXMuX3BvcHBlciA9IHNlKFxuICAgICAgZSxcbiAgICAgIHRoaXMuX21lbnUsXG4gICAgICBpXG4gICAgKSwgbiAmJiBoLnNldERhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgXCJwb3BwZXJcIiwgXCJzdGF0aWNcIik7XG4gIH1cbiAgX2lzU2hvd24odCA9IHRoaXMuX2VsZW1lbnQpIHtcbiAgICByZXR1cm4gdC5kYXRhc2V0W2B0ZURyb3Bkb3duJHtGdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIEZ0LnNsaWNlKDEpfWBdID09PSBcIlwiO1xuICB9XG4gIF9nZXRNZW51RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZC5uZXh0KHRoaXMuX2VsZW1lbnQsIFBuKVswXTtcbiAgfVxuICBfZ2V0UGxhY2VtZW50KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHQuZGF0YXNldC50ZURyb3Bkb3duUG9zaXRpb24gPT09IE91KVxuICAgICAgcmV0dXJuIFB1O1xuICAgIGlmICh0LmRhdGFzZXQudGVEcm9wZG93blBvc2l0aW9uID09PSBTdSlcbiAgICAgIHJldHVybiBCdTtcbiAgICBjb25zdCBlID0gdC5kYXRhc2V0LnRlRHJvcGRvd25BbGlnbm1lbnQgPT09IFwiZW5kXCI7XG4gICAgcmV0dXJuIHQuZGF0YXNldC50ZURyb3Bkb3duUG9zaXRpb24gPT09IHh1ID8gZSA/IE51IDogTHUgOiBlID8gUnUgOiBNdTtcbiAgfVxuICBfZGV0ZWN0TmF2YmFyKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoSXUpICE9PSBudWxsO1xuICB9XG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3QgeyBvZmZzZXQ6IHQgfSA9IHRoaXMuX2NvbmZpZztcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQuc3BsaXQoXCIsXCIpLm1hcCgoZSkgPT4gTnVtYmVyLnBhcnNlSW50KGUsIDEwKSkgOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyAoZSkgPT4gdChlLCB0aGlzLl9lbGVtZW50KSA6IHQ7XG4gIH1cbiAgX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgcGxhY2VtZW50OiB0aGlzLl9nZXRQbGFjZW1lbnQoKSxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJwcmV2ZW50T3ZlcmZsb3dcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRpc3BsYXkgPT09IFwic3RhdGljXCIgJiYgKHQubW9kaWZpZXJzID0gW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcImFwcGx5U3R5bGVzXCIsXG4gICAgICAgIGVuYWJsZWQ6ICExXG4gICAgICB9XG4gICAgXSksIHtcbiAgICAgIC4uLnQsXG4gICAgICAuLi50eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKHQpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZ1xuICAgIH07XG4gIH1cbiAgX3NlbGVjdE1lbnVJdGVtKHsga2V5OiB0LCB0YXJnZXQ6IGUgfSkge1xuICAgIGNvbnN0IGkgPSBkLmZpbmQoXG4gICAgICAkdSxcbiAgICAgIHRoaXMuX21lbnVcbiAgICApLmZpbHRlcihNdCk7XG4gICAgaS5sZW5ndGggJiYgdmMoXG4gICAgICBpLFxuICAgICAgZSxcbiAgICAgIHQgPT09IFlzLFxuICAgICAgIWkuaW5jbHVkZXMoZSlcbiAgICApLmZvY3VzKCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gJHQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGNsZWFyTWVudXModCkge1xuICAgIGlmICh0ICYmICh0LmJ1dHRvbiA9PT0gdnUgfHwgdC50eXBlID09PSBcImtleXVwXCIgJiYgdC5rZXkgIT09IFFyKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gZC5maW5kKG9zKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGUubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCBvID0gJHQuZ2V0SW5zdGFuY2UoZVtpXSk7XG4gICAgICBpZiAoIW8gfHwgby5fY29uZmlnLmF1dG9DbG9zZSA9PT0gITEgfHwgIW8uX2lzU2hvd24oKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCByID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBvLl9lbGVtZW50XG4gICAgICB9O1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgY29uc3QgYSA9IHQuY29tcG9zZWRQYXRoKCksIGwgPSBhLmluY2x1ZGVzKG8uX21lbnUpO1xuICAgICAgICBpZiAoYS5pbmNsdWRlcyhvLl9lbGVtZW50KSB8fCBvLl9jb25maWcuYXV0b0Nsb3NlID09PSBcImluc2lkZVwiICYmICFsIHx8IG8uX2NvbmZpZy5hdXRvQ2xvc2UgPT09IFwib3V0c2lkZVwiICYmIGwgfHwgby5fbWVudS5jb250YWlucyh0LnRhcmdldCkgJiYgKHQudHlwZSA9PT0gXCJrZXl1cFwiICYmIHQua2V5ID09PSBRciB8fCAvaW5wdXR8c2VsZWN0fG9wdGlvbnx0ZXh0YXJlYXxmb3JtL2kudGVzdCh0LnRhcmdldC50YWdOYW1lKSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHQudHlwZSA9PT0gXCJjbGlja1wiICYmIChyLmNsaWNrRXZlbnQgPSB0KTtcbiAgICAgIH1cbiAgICAgIG8uX2NvbXBsZXRlSGlkZShyKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldFBhcmVudEZyb21FbGVtZW50KHQpIHtcbiAgICByZXR1cm4gdGUodCkgfHwgdC5wYXJlbnROb2RlO1xuICB9XG4gIHN0YXRpYyBkYXRhQXBpS2V5ZG93bkhhbmRsZXIodCkge1xuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KHQudGFyZ2V0LnRhZ05hbWUpID8gdC5rZXkgPT09IFpyIHx8IHQua2V5ICE9PSBGcyAmJiAodC5rZXkgIT09IFlzICYmIHQua2V5ICE9PSBqbyB8fCB0LnRhcmdldC5jbG9zZXN0KFBuKSkgOiAhVHUudGVzdCh0LmtleSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuZGF0YXNldFtgdGVEcm9wZG93biR7RnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBGdC5zbGljZSgxKX1gXSA9PT0gXCJcIjtcbiAgICBpZiAoIWUgJiYgdC5rZXkgPT09IEZzIHx8ICh0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCksIGJlKHRoaXMpKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gdGhpcy5tYXRjaGVzKG9zKSA/IHRoaXMgOiBkLnByZXYodGhpcywgb3MpWzBdLCBuID0gJHQuZ2V0T3JDcmVhdGVJbnN0YW5jZShpKTtcbiAgICBpZiAodC5rZXkgPT09IEZzKSB7XG4gICAgICBuLmhpZGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHQua2V5ID09PSBqbyB8fCB0LmtleSA9PT0gWXMpIHtcbiAgICAgIGUgfHwgbi5zaG93KCksIG4uX3NlbGVjdE1lbnVJdGVtKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoIWUgfHwgdC5rZXkgPT09IFpyKSAmJiAkdC5jbGVhck1lbnVzKCk7XG4gIH1cbn1cbmNvbnN0IEJuID0gXCJjb2xsYXBzZVwiLCBaYyA9IFwidGUuY29sbGFwc2VcIiwgYm4gPSBgLiR7WmN9YCwgZWEgPSB7XG4gIHRvZ2dsZTogITAsXG4gIHBhcmVudDogbnVsbFxufSwgWXUgPSB7XG4gIHRvZ2dsZTogXCJib29sZWFuXCIsXG4gIHBhcmVudDogXCIobnVsbHxlbGVtZW50KVwiXG59LCBqdSA9IGBzaG93JHtibn1gLCBLdSA9IGBzaG93biR7Ym59YCwgenUgPSBgaGlkZSR7Ym59YCwgVXUgPSBgaGlkZGVuJHtibn1gLCBIbiA9IFwiZGF0YS10ZS1jb2xsYXBzZS1zaG93XCIsIGlhID0gXCJkYXRhLXRlLWNvbGxhcHNlLWNvbGxhcHNlZFwiLCBycyA9IFwiZGF0YS10ZS1jb2xsYXBzZS1jb2xsYXBzaW5nXCIsIFh1ID0gXCJkYXRhLXRlLWNvbGxhcHNlLWhvcml6b250YWxcIiwgV2UgPSBcImRhdGEtdGUtY29sbGFwc2UtaXRlbVwiLCBzYSA9IGA6c2NvcGUgWyR7V2V9XSBbJHtXZX1dYCwgR3UgPSBcIndpZHRoXCIsIHF1ID0gXCJoZWlnaHRcIiwgWnUgPSBcIltkYXRhLXRlLWNvbGxhcHNlLWl0ZW1dW2RhdGEtdGUtY29sbGFwc2Utc2hvd10sIFtkYXRhLXRlLWNvbGxhcHNlLWl0ZW1dW2RhdGEtdGUtY29sbGFwc2UtY29sbGFwc2luZ11cIiwgbmEgPSBcIltkYXRhLXRlLWNvbGxhcHNlLWluaXRdXCIsIFF1ID0ge1xuICB2aXNpYmxlOiBcIiF2aXNpYmxlXCIsXG4gIGhpZGRlbjogXCJoaWRkZW5cIixcbiAgYmFzZVRyYW5zaXRpb246IFwib3ZlcmZsb3ctaGlkZGVuIGR1cmF0aW9uLVszNTBtc10gZWFzZS1bY3ViaWMtYmV6aWVyKDAuMjUsMC4xLDAuMjUsMS4wKV0gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgY29sbGFwc2luZzogXCJoLTAgdHJhbnNpdGlvbi1baGVpZ2h0XSBvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBjb2xsYXBzaW5nSG9yaXpvbnRhbDogXCJ3LTAgaC1hdXRvIHRyYW5zaXRpb24tW3dpZHRoXSBvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiXG59LCBKdSA9IHtcbiAgdmlzaWJsZTogXCJzdHJpbmdcIixcbiAgaGlkZGVuOiBcInN0cmluZ1wiLFxuICBiYXNlVHJhbnNpdGlvbjogXCJzdHJpbmdcIixcbiAgY29sbGFwc2luZzogXCJzdHJpbmdcIixcbiAgY29sbGFwc2luZ0hvcml6b250YWw6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBRdCBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fdHJpZ2dlckFycmF5ID0gW107XG4gICAgY29uc3QgbiA9IGQuZmluZChuYSk7XG4gICAgZm9yIChsZXQgbyA9IDAsIHIgPSBuLmxlbmd0aDsgbyA8IHI7IG8rKykge1xuICAgICAgY29uc3QgYSA9IG5bb10sIGwgPSBscihhKSwgcCA9IGQuZmluZChsKS5maWx0ZXIoXG4gICAgICAgICh1KSA9PiB1ID09PSB0aGlzLl9lbGVtZW50XG4gICAgICApO1xuICAgICAgbCAhPT0gbnVsbCAmJiBwLmxlbmd0aCAmJiAodGhpcy5fc2VsZWN0b3IgPSBsLCB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChhKSk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxpemVDaGlsZHJlbigpLCB0aGlzLl9jb25maWcucGFyZW50IHx8IHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksIHRoaXMuX2lzU2hvd24oKSksIHRoaXMuX2NvbmZpZy50b2dnbGUgJiYgdGhpcy50b2dnbGUoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gZWE7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBCbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2lzU2hvd24oKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2lzU2hvd24oKSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgdCA9IFtdLCBlO1xuICAgIGlmICh0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICBjb25zdCB1ID0gZC5maW5kKFxuICAgICAgICBzYSxcbiAgICAgICAgdGhpcy5fY29uZmlnLnBhcmVudFxuICAgICAgKTtcbiAgICAgIHQgPSBkLmZpbmQoXG4gICAgICAgIFp1LFxuICAgICAgICB0aGlzLl9jb25maWcucGFyZW50XG4gICAgICApLmZpbHRlcigoXykgPT4gIXUuaW5jbHVkZXMoXykpO1xuICAgIH1cbiAgICBjb25zdCBpID0gZC5maW5kT25lKHRoaXMuX3NlbGVjdG9yKTtcbiAgICBpZiAodC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHUgPSB0LmZpbmQoKF8pID0+IGkgIT09IF8pO1xuICAgICAgaWYgKGUgPSB1ID8gUXQuZ2V0SW5zdGFuY2UodSkgOiBudWxsLCBlICYmIGUuX2lzVHJhbnNpdGlvbmluZylcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGp1KS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHQuZm9yRWFjaCgodSkgPT4ge1xuICAgICAgaSAhPT0gdSAmJiBRdC5nZXRPckNyZWF0ZUluc3RhbmNlKHUsIHsgdG9nZ2xlOiAhMSB9KS5oaWRlKCksIGUgfHwgQS5zZXREYXRhKHUsIFpjLCBudWxsKTtcbiAgICB9KTtcbiAgICBjb25zdCBvID0gdGhpcy5fZ2V0RGltZW5zaW9uKCksIHIgPSBvID09PSBcImhlaWdodFwiID8gdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nIDogdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nSG9yaXpvbnRhbDtcbiAgICBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMudmlzaWJsZSksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5oaWRkZW4pLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShXZSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKHJzLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zdHlsZVtvXSA9IDAsIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksICEwKSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITA7XG4gICAgY29uc3QgYSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCByKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShycyksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFdlLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoSG4sIFwiXCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlW29dID0gXCJcIiwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEt1KTtcbiAgICB9LCBwID0gYHNjcm9sbCR7b1swXS50b1VwcGVyQ2FzZSgpICsgby5zbGljZSgxKX1gO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soYSwgdGhpcy5fZWxlbWVudCwgITApLCB0aGlzLl9lbGVtZW50LnN0eWxlW29dID0gYCR7dGhpcy5fZWxlbWVudFtwXX1weGA7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkgfHwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHp1KS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXREaW1lbnNpb24oKSwgaSA9IGUgPT09IFwiaGVpZ2h0XCIgPyB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmcgOiB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmdIb3Jpem9udGFsO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZV0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2VdfXB4YCwgc2kodGhpcy5fZWxlbWVudCksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgaSksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKHJzLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoV2UpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShIbik7XG4gICAgY29uc3QgbiA9IHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGg7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBuOyByKyspIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLl90cmlnZ2VyQXJyYXlbcl0sIGwgPSB0ZShhKTtcbiAgICAgIGwgJiYgIXRoaXMuX2lzU2hvd24obCkgJiYgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFthXSwgITEpO1xuICAgIH1cbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMDtcbiAgICBjb25zdCBvID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgaSksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHJzKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoV2UsIFwiXCIpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVXUpO1xuICAgIH07XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtlXSA9IFwiXCIsIHRoaXMuX3F1ZXVlQ2FsbGJhY2sobywgdGhpcy5fZWxlbWVudCwgITApO1xuICB9XG4gIF9pc1Nob3duKHQgPSB0aGlzLl9lbGVtZW50KSB7XG4gICAgcmV0dXJuIHQuaGFzQXR0cmlidXRlKEhuKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZWEsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH0sIHQudG9nZ2xlID0gISF0LnRvZ2dsZSwgdC5wYXJlbnQgPSBlZSh0LnBhcmVudCksIEkoQm4sIHQsIFl1KSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlF1LFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKEJuLCB0LCBKdSksIHQ7XG4gIH1cbiAgX2dldERpbWVuc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoWHUpID8gR3UgOiBxdTtcbiAgfVxuICBfaW5pdGlhbGl6ZUNoaWxkcmVuKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gZC5maW5kKFxuICAgICAgc2EsXG4gICAgICB0aGlzLl9jb25maWcucGFyZW50XG4gICAgKTtcbiAgICBkLmZpbmQobmEsIHRoaXMuX2NvbmZpZy5wYXJlbnQpLmZpbHRlcigoZSkgPT4gIXQuaW5jbHVkZXMoZSkpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSB0ZShlKTtcbiAgICAgIGkgJiYgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFtlXSwgdGhpcy5faXNTaG93bihpKSk7XG4gICAgfSk7XG4gIH1cbiAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0LCBlKSB7XG4gICAgdC5sZW5ndGggJiYgdC5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBlID8gaS5yZW1vdmVBdHRyaWJ1dGUoaWEpIDogaS5zZXRBdHRyaWJ1dGUoYCR7aWF9YCwgXCJcIiksIGkuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBlKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSB7fTtcbiAgICAgIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgL3Nob3d8aGlkZS8udGVzdCh0KSAmJiAoZS50b2dnbGUgPSAhMSk7XG4gICAgICBjb25zdCBpID0gUXQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBlKTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IG9hID0gXCIuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wXCIsIHJhID0gXCIuc3RpY2t5LXRvcFwiO1xuY2xhc3MgdGkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgfVxuICBnZXRXaWR0aCgpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cuaW5uZXJXaWR0aCAtIHQpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICB0aGlzLl9kaXNhYmxlT3ZlckZsb3coKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJwYWRkaW5nUmlnaHRcIixcbiAgICAgIChlKSA9PiBlICsgdFxuICAgICksIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFxuICAgICAgb2EsXG4gICAgICBcInBhZGRpbmdSaWdodFwiLFxuICAgICAgKGUpID0+IGUgKyB0XG4gICAgKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXG4gICAgICByYSxcbiAgICAgIFwibWFyZ2luUmlnaHRcIixcbiAgICAgIChlKSA9PiBlIC0gdFxuICAgICk7XG4gIH1cbiAgX2Rpc2FibGVPdmVyRmxvdygpIHtcbiAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50LCBcIm92ZXJmbG93XCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgfVxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXModCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldFdpZHRoKCksIG8gPSAocikgPT4ge1xuICAgICAgaWYgKHIgIT09IHRoaXMuX2VsZW1lbnQgJiYgd2luZG93LmlubmVyV2lkdGggPiByLmNsaWVudFdpZHRoICsgbilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fc2F2ZUluaXRpYWxBdHRyaWJ1dGUociwgZSk7XG4gICAgICBjb25zdCBhID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocilbZV07XG4gICAgICByLnN0eWxlW2VdID0gYCR7aShcbiAgICAgICAgTnVtYmVyLnBhcnNlRmxvYXQoYSlcbiAgICAgICl9cHhgO1xuICAgIH07XG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBvKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFwib3ZlcmZsb3dcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgXCJwYWRkaW5nUmlnaHRcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMob2EsIFwicGFkZGluZ1JpZ2h0XCIpLCB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHJhLCBcIm1hcmdpblJpZ2h0XCIpO1xuICB9XG4gIF9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0LCBlKSB7XG4gICAgY29uc3QgaSA9IHQuc3R5bGVbZV07XG4gICAgaSAmJiBoLnNldERhdGFBdHRyaWJ1dGUodCwgZSwgaSk7XG4gIH1cbiAgX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModCwgZSkge1xuICAgIGNvbnN0IGkgPSAobikgPT4ge1xuICAgICAgY29uc3QgbyA9IGguZ2V0RGF0YUF0dHJpYnV0ZShuLCBlKTtcbiAgICAgIHR5cGVvZiBvID4gXCJ1XCIgPyBuLnN0eWxlLnJlbW92ZVByb3BlcnR5KGUpIDogKGgucmVtb3ZlRGF0YUF0dHJpYnV0ZShuLCBlKSwgbi5zdHlsZVtlXSA9IG8pO1xuICAgIH07XG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBpKTtcbiAgfVxuICBfYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCBlKSB7XG4gICAgWGUodCkgPyBlKHQpIDogZC5maW5kKHQsIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goZSk7XG4gIH1cbiAgaXNPdmVyZmxvd2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRXaWR0aCgpID4gMDtcbiAgfVxufVxuY29uc3QgdHAgPSB7XG4gIGlzVmlzaWJsZTogITAsXG4gIC8vIGlmIGZhbHNlLCB3ZSB1c2UgdGhlIGJhY2tkcm9wIGhlbHBlciB3aXRob3V0IGFkZGluZyBhbnkgZWxlbWVudCB0byB0aGUgZG9tXG4gIGlzQW5pbWF0ZWQ6ICExLFxuICByb290RWxlbWVudDogXCJib2R5XCIsXG4gIC8vIGdpdmUgdGhlIGNob2ljZSB0byBwbGFjZSBiYWNrZHJvcCB1bmRlciBkaWZmZXJlbnQgZWxlbWVudHNcbiAgY2xpY2tDYWxsYmFjazogbnVsbCxcbiAgYmFja2Ryb3BDbGFzc2VzOiBudWxsXG59LCBlcCA9IHtcbiAgaXNWaXNpYmxlOiBcImJvb2xlYW5cIixcbiAgaXNBbmltYXRlZDogXCJib29sZWFuXCIsXG4gIHJvb3RFbGVtZW50OiBcIihlbGVtZW50fHN0cmluZylcIixcbiAgY2xpY2tDYWxsYmFjazogXCIoZnVuY3Rpb258bnVsbClcIixcbiAgYmFja2Ryb3BDbGFzc2VzOiBcIihhcnJheXxzdHJpbmd8bnVsbClcIlxufSwgUWMgPSBcImJhY2tkcm9wXCIsIGFhID0gYG1vdXNlZG93bi50ZS4ke1FjfWA7XG5jbGFzcyBDciB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcodCksIHRoaXMuX2lzQXBwZW5kZWQgPSAhMSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgc2hvdyh0KSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICBnZSh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYXBwZW5kKCksIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkICYmIHNpKHRoaXMuX2dldEVsZW1lbnQoKSk7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NvbmZpZy5iYWNrZHJvcENsYXNzZXMgfHwgW1xuICAgICAgXCJvcGFjaXR5LTUwXCIsXG4gICAgICBcInRyYW5zaXRpb24tYWxsXCIsXG4gICAgICBcImR1cmF0aW9uLTMwMFwiLFxuICAgICAgXCJlYXNlLWluLW91dFwiLFxuICAgICAgXCJmaXhlZFwiLFxuICAgICAgXCJ0b3AtMFwiLFxuICAgICAgXCJsZWZ0LTBcIixcbiAgICAgIFwiei1bMTA0MF1cIixcbiAgICAgIFwiYmctYmxhY2tcIixcbiAgICAgIFwidy1zY3JlZW5cIixcbiAgICAgIFwiaC1zY3JlZW5cIlxuICAgIF07XG4gICAgaC5yZW1vdmVDbGFzcyh0aGlzLl9nZXRFbGVtZW50KCksIFwib3BhY2l0eS0wXCIpLCBoLmFkZENsYXNzKHRoaXMuX2dldEVsZW1lbnQoKSwgZSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1iYWNrZHJvcC1zaG93XCIsIFwiXCIpLCB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcbiAgICAgIGdlKHQpO1xuICAgIH0pO1xuICB9XG4gIGhpZGUodCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgZ2UodCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1iYWNrZHJvcC1zaG93XCIpLCB0aGlzLl9nZXRFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMFwiKSwgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTUwXCIpLCB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpLCBnZSh0KTtcbiAgICB9KTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRFbGVtZW50KCkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xuICAgICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0LmNsYXNzTmFtZSA9IHRoaXMuX2NvbmZpZy5jbGFzc05hbWUsIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkICYmIHQuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktNTBcIiksIHRoaXMuX2VsZW1lbnQgPSB0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnRwLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIHQucm9vdEVsZW1lbnQgPSBlZSh0LnJvb3RFbGVtZW50KSwgSShRYywgdCwgZXApLCB0O1xuICB9XG4gIF9hcHBlbmQoKSB7XG4gICAgdGhpcy5faXNBcHBlbmRlZCB8fCAodGhpcy5fY29uZmlnLnJvb3RFbGVtZW50LmFwcGVuZCh0aGlzLl9nZXRFbGVtZW50KCkpLCBjLm9uKHRoaXMuX2dldEVsZW1lbnQoKSwgYWEsICgpID0+IHtcbiAgICAgIGdlKHRoaXMuX2NvbmZpZy5jbGlja0NhbGxiYWNrKTtcbiAgICB9KSwgdGhpcy5faXNBcHBlbmRlZCA9ICEwKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2lzQXBwZW5kZWQgJiYgKGMub2ZmKHRoaXMuX2VsZW1lbnQsIGFhKSwgdGhpcy5fZWxlbWVudC5yZW1vdmUoKSwgdGhpcy5faXNBcHBlbmRlZCA9ICExKTtcbiAgfVxuICBfZW11bGF0ZUFuaW1hdGlvbih0KSB7XG4gICAgYmMoXG4gICAgICB0LFxuICAgICAgdGhpcy5fZ2V0RWxlbWVudCgpLFxuICAgICAgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWRcbiAgICApO1xuICB9XG59XG5jbGFzcyB6aSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl90b2dnbGVyID0gaSwgdGhpcy5fZXZlbnQgPSBlLmV2ZW50IHx8IFwiYmx1clwiLCB0aGlzLl9jb25kaXRpb24gPSBlLmNvbmRpdGlvbiB8fCAoKCkgPT4gITApLCB0aGlzLl9zZWxlY3RvciA9IGUuc2VsZWN0b3IgfHwgJ2J1dHRvbiwgYSwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIFt0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKScsIHRoaXMuX29ubHlWaXNpYmxlID0gZS5vbmx5VmlzaWJsZSB8fCAhMSwgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMgPSBbXSwgdGhpcy5fZmlyc3RFbGVtZW50ID0gbnVsbCwgdGhpcy5fbGFzdEVsZW1lbnQgPSBudWxsLCB0aGlzLmhhbmRsZXIgPSAobikgPT4ge1xuICAgICAgdGhpcy5fY29uZGl0aW9uKG4pICYmICFuLnNoaWZ0S2V5ICYmIG4udGFyZ2V0ID09PSB0aGlzLl9sYXN0RWxlbWVudCA/IChuLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2ZpcnN0RWxlbWVudC5mb2N1cygpKSA6IHRoaXMuX2NvbmRpdGlvbihuKSAmJiBuLnNoaWZ0S2V5ICYmIG4udGFyZ2V0ID09PSB0aGlzLl9maXJzdEVsZW1lbnQgJiYgKG4ucHJldmVudERlZmF1bHQoKSwgdGhpcy5fbGFzdEVsZW1lbnQuZm9jdXMoKSk7XG4gICAgfTtcbiAgfVxuICB0cmFwKCkge1xuICAgIHRoaXMuX3NldEVsZW1lbnRzKCksIHRoaXMuX2luaXQoKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKCk7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fZXZlbnQsIHRoaXMuaGFuZGxlcik7XG4gICAgfSksIHRoaXMuX3RvZ2dsZXIgJiYgdGhpcy5fdG9nZ2xlci5mb2N1cygpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9zZXRFbGVtZW50cygpLCB0aGlzLl9zZXRGb2N1c1RyYXAoKTtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gKGUpID0+IHtcbiAgICAgICF0aGlzLl9maXJzdEVsZW1lbnQgfHwgZS5rZXkgIT09IFwiVGFiXCIgfHwgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMuaW5jbHVkZXMoZS50YXJnZXQpIHx8IChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2ZpcnN0RWxlbWVudC5mb2N1cygpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdCkpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHQpO1xuICB9XG4gIF9maWx0ZXJWaXNpYmxlKHQpIHtcbiAgICByZXR1cm4gdC5maWx0ZXIoKGUpID0+IHtcbiAgICAgIGlmICghTXQoZSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGkgPSBkLnBhcmVudHMoZSwgXCIqXCIpO1xuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBpLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGNvbnN0IG8gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpW25dKTtcbiAgICAgICAgaWYgKG8gJiYgKG8uZGlzcGxheSA9PT0gXCJub25lXCIgfHwgby52aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfSk7XG4gIH1cbiAgX3NldEVsZW1lbnRzKCkge1xuICAgIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzID0gZC5mb2N1c2FibGVDaGlsZHJlbih0aGlzLl9lbGVtZW50KSwgdGhpcy5fb25seVZpc2libGUgJiYgKHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzID0gdGhpcy5fZmlsdGVyVmlzaWJsZSh0aGlzLl9mb2N1c2FibGVFbGVtZW50cykpLCB0aGlzLl9maXJzdEVsZW1lbnQgPSB0aGlzLl9mb2N1c2FibGVFbGVtZW50c1swXSwgdGhpcy5fbGFzdEVsZW1lbnQgPSB0aGlzLl9mb2N1c2FibGVFbGVtZW50c1t0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgfVxuICBfc2V0Rm9jdXNUcmFwKCkge1xuICAgIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmZvckVhY2goKHQsIGUpID0+IHtcbiAgICAgIGUgPT09IHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDEgfHwgZSA9PT0gMCA/IHQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9ldmVudCwgdGhpcy5oYW5kbGVyKSA6IHQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9ldmVudCwgdGhpcy5oYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxufVxubGV0IGxhID0gW107XG5jb25zdCB2biA9IChzLCB0ID0gXCJoaWRlXCIpID0+IHtcbiAgY29uc3QgZSA9IGBjbGljay5kaXNtaXNzJHtzLkVWRU5UX0tFWX1gLCBpID0gcy5OQU1FO1xuICBsYS5pbmNsdWRlcyhpKSB8fCAobGEucHVzaChpKSwgYy5vbihcbiAgICBkb2N1bWVudCxcbiAgICBlLFxuICAgIGBbZGF0YS10ZS0ke2l9LWRpc21pc3NdYCxcbiAgICBmdW5jdGlvbihuKSB7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBuLnByZXZlbnREZWZhdWx0KCksIGJlKHRoaXMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0gdGUodGhpcykgfHwgdGhpcy5jbG9zZXN0KGAuJHtpfWApIHx8IHRoaXMuY2xvc2VzdChgW2RhdGEtdGUtJHtpfS1pbml0XWApO1xuICAgICAgaWYgKCFvKVxuICAgICAgICByZXR1cm47XG4gICAgICBzLmdldE9yQ3JlYXRlSW5zdGFuY2UobylbdF0oKTtcbiAgICB9XG4gICkpO1xufSwgY2EgPSBcIm9mZmNhbnZhc1wiLCBpcCA9IFwidGUub2ZmY2FudmFzXCIsIG9pID0gYC4ke2lwfWAsIHNwID0gXCIuZGF0YS1hcGlcIiwgbnAgPSBgbG9hZCR7b2l9JHtzcH1gLCBvcCA9IFwiRXNjYXBlXCIsIGhhID0ge1xuICBiYWNrZHJvcDogITAsXG4gIGtleWJvYXJkOiAhMCxcbiAgc2Nyb2xsOiAhMVxufSwgcnAgPSB7XG4gIGJhY2tkcm9wOiBcImJvb2xlYW5cIixcbiAga2V5Ym9hcmQ6IFwiYm9vbGVhblwiLFxuICBzY3JvbGw6IFwiYm9vbGVhblwiXG59LCBkYSA9IFwic2hvd1wiLCBhcCA9IFwiW2RhdGEtdGUtb2ZmY2FudmFzLWluaXRdW2RhdGEtdGUtb2ZmY2FudmFzLXNob3ddXCIsIGxwID0gYHNob3cke29pfWAsIGNwID0gYHNob3duJHtvaX1gLCBocCA9IGBoaWRlJHtvaX1gLCBkcCA9IGBoaWRkZW4ke29pfWAsIHVwID0gYGtleWRvd24uZGlzbWlzcyR7b2l9YDtcbmNsYXNzIGpzIGV4dGVuZHMgZnQge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpLCB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCksIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBjYTtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIGhhO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUodCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3codCk7XG4gIH1cbiAgc2hvdyh0KSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGxwLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9pc1Nob3duID0gITAsIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiLCB0aGlzLl9iYWNrZHJvcC5zaG93KCksIHRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgbmV3IHRpKCkuaGlkZSgpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiwgITApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLXRlLW9mZmNhbnZhcy0ke2RhfWAsIFwiXCIpO1xuICAgIGNvbnN0IGkgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25maWcuc2Nyb2xsIHx8IHRoaXMuX2ZvY3VzdHJhcC50cmFwKCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBjcCwgeyByZWxhdGVkVGFyZ2V0OiB0IH0pO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhpLCB0aGlzLl9lbGVtZW50LCAhMCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGhwKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIHRoaXMuX2VsZW1lbnQuYmx1cigpLCB0aGlzLl9pc1Nob3duID0gITEsIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGBkYXRhLXRlLW9mZmNhbnZhcy0ke2RhfWApLCB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgITApLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKSwgdGhpcy5fZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgdGhpcy5fY29uZmlnLnNjcm9sbCB8fCBuZXcgdGkoKS5yZXNldCgpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZHApO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhlLCB0aGlzLl9lbGVtZW50LCAhMCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKGMub24oXG4gICAgICB3aW5kb3csXG4gICAgICBucCxcbiAgICAgICgpID0+IGQuZmluZChhcCkuZm9yRWFjaChcbiAgICAgICAgKHQpID0+IGpzLmdldE9yQ3JlYXRlSW5zdGFuY2UodCkuc2hvdygpXG4gICAgICApXG4gICAgKSwgdGhpcy5fZGlkSW5pdCA9ICEwLCB2bihqcykpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uaGEsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIEkoY2EsIHQsIHJwKSwgdDtcbiAgfVxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIHJldHVybiBuZXcgQ3Ioe1xuICAgICAgaXNWaXNpYmxlOiB0aGlzLl9jb25maWcuYmFja2Ryb3AsXG4gICAgICBpc0FuaW1hdGVkOiAhMCxcbiAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICBjbGlja0NhbGxiYWNrOiAoKSA9PiB0aGlzLmhpZGUoKVxuICAgIH0pO1xuICB9XG4gIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgIHJldHVybiBuZXcgemkodGhpcy5fZWxlbWVudCwge1xuICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgY29uZGl0aW9uOiAodCkgPT4gdC5rZXkgPT09IFwiVGFiXCJcbiAgICB9KTtcbiAgfVxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCB1cCwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiB0LmtleSA9PT0gb3AgJiYgdGhpcy5oaWRlKCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0ganMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChlW3RdID09PSB2b2lkIDAgfHwgdC5zdGFydHNXaXRoKFwiX1wiKSB8fCB0ID09PSBcImNvbnN0cnVjdG9yXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFZuID0gXCJhbGVydFwiLCBwcCA9IFwidGUuYWxlcnRcIiwgSmMgPSBgLiR7cHB9YCwgX3AgPSBgY2xvc2Uke0pjfWAsIGZwID0gYGNsb3NlZCR7SmN9YCwgdWkgPSBcImRhdGEtdGUtYWxlcnQtc2hvd1wiLCBtcCA9IHtcbiAgYW5pbWF0aW9uOiBcImJvb2xlYW5cIixcbiAgYXV0b2hpZGU6IFwiYm9vbGVhblwiLFxuICBhdXRvY2xvc2U6IFwiYm9vbGVhblwiLFxuICBkZWxheTogXCJudW1iZXJcIlxufSwgdWEgPSB7XG4gIGFuaW1hdGlvbjogITAsXG4gIGF1dG9oaWRlOiAhMCxcbiAgYXV0b2Nsb3NlOiAhMSxcbiAgZGVsYXk6IDFlM1xufSwgZ3AgPSB7XG4gIGZhZGVJbjogXCJhbmltYXRlLVtmYWRlLWluXzAuM3NfYm90aF0gcC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIixcbiAgZmFkZU91dDogXCJhbmltYXRlLVtmYWRlLW91dF8wLjNzX2JvdGhdIHAtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCJcbn0sIGJwID0ge1xuICBmYWRlSW46IFwic3RyaW5nXCIsXG4gIGZhZGVPdXQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBLbyBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBtcDtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHVhO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gVm47XG4gIH1cbiAgLy8gUHVibGljXG4gIGNsb3NlKCkge1xuICAgIGlmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgX3ApLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGUgPSAwO1xuICAgIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgKGUgPSAzMDAsIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHVpKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKFxuICAgICAgICAoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudCgpLFxuICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICB0aGlzLl9jb25maWcuYW5pbWF0aW9uXG4gICAgICApO1xuICAgIH0sIGUpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuYXV0b2hpZGUgJiYgdGhpcy5fc2V0dXBBdXRvaGlkZSgpLCAodGhpcy5fY29uZmlnLmF1dG9jbG9zZSB8fCB0aGlzLl9jb25maWcuYXV0b2Nsb3NlICYmIHRoaXMuX2NvbmZpZy5hdXRvaGlkZSkgJiYgdGhpcy5fc2V0dXBBdXRvY2xvc2UoKSwgIXRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKHVpKSAmJiAoaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcImhpZGRlblwiKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcImJsb2NrXCIpLCBNdCh0aGlzLl9lbGVtZW50KSkpIHtcbiAgICAgICAgY29uc3QgdCA9IChlKSA9PiB7XG4gICAgICAgICAgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcImhpZGRlblwiKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcImJsb2NrXCIpLCBjLm9mZihlLnRhcmdldCwgXCJhbmltYXRpb25lbmRcIiwgdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKHVpLCBcIlwiKSwgYy5vbih0aGlzLl9lbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCB0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgKGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVJbikpO1xuICAgIH1cbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50ICYmIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKHVpKSkge1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodWkpO1xuICAgICAgY29uc3QgdCA9IChlKSA9PiB7XG4gICAgICAgIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJoaWRkZW5cIiksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJibG9ja1wiKSwgdGhpcy5fdGltZW91dCAhPT0gbnVsbCAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpLCB0aGlzLl90aW1lb3V0ID0gbnVsbCksIGMub2ZmKGUudGFyZ2V0LCBcImFuaW1hdGlvbmVuZFwiLCB0KTtcbiAgICAgIH07XG4gICAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsIHQpLCBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpO1xuICAgIH1cbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKHZuKEtvLCBcImNsb3NlXCIpLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4udWEsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgSShWbiwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5ncCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgSShWbiwgdCwgYnApLCB0O1xuICB9XG4gIF9zZXR1cEF1dG9oaWRlKCkge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSk7XG4gIH1cbiAgX3NldHVwQXV0b2Nsb3NlKCkge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpO1xuICB9XG4gIF9kZXN0cm95RWxlbWVudCgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZSgpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZnApLCB0aGlzLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBLby5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGVbdF0gPT09IHZvaWQgMCB8fCB0LnN0YXJ0c1dpdGgoXCJfXCIpIHx8IHQgPT09IFwiY29uc3RydWN0b3JcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgV24gPSBcImNhcm91c2VsXCIsIHZwID0gXCJ0ZS5jYXJvdXNlbFwiLCBtdCA9IGAuJHt2cH1gLCB0aCA9IFwiLmRhdGEtYXBpXCIsIFRwID0gXCJBcnJvd0xlZnRcIiwgRXAgPSBcIkFycm93UmlnaHRcIiwgQ3AgPSA1MDAsIEFwID0gNDAsIHBhID0ge1xuICBpbnRlcnZhbDogNWUzLFxuICBrZXlib2FyZDogITAsXG4gIHJpZGU6ICExLFxuICBwYXVzZTogXCJob3ZlclwiLFxuICB3cmFwOiAhMCxcbiAgdG91Y2g6ICEwXG59LCB5cCA9IHtcbiAgaW50ZXJ2YWw6IFwiKG51bWJlcnxib29sZWFuKVwiLFxuICBrZXlib2FyZDogXCJib29sZWFuXCIsXG4gIHJpZGU6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBwYXVzZTogXCIoc3RyaW5nfGJvb2xlYW4pXCIsXG4gIHdyYXA6IFwiYm9vbGVhblwiLFxuICB0b3VjaDogXCJib29sZWFuXCJcbn0sIHdwID0ge1xuICBwb2ludGVyOiBcInRvdWNoLXBhbi15XCIsXG4gIGJsb2NrOiBcIiFibG9ja1wiLFxuICB2aXNpYmxlOiBcImRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOm9wYWNpdHktMTAwIGRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOnotWzFdXCIsXG4gIGludmlzaWJsZTogXCJkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTp6LTAgZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06b3BhY2l0eS0wIGRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOmR1cmF0aW9uLVs2MDBtc10gZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06ZGVsYXktNjAwXCIsXG4gIHNsaWRlUmlnaHQ6IFwidHJhbnNsYXRlLXgtZnVsbFwiLFxuICBzbGlkZUxlZnQ6IFwiLXRyYW5zbGF0ZS14LWZ1bGxcIlxufSwga3AgPSB7XG4gIHBvaW50ZXI6IFwic3RyaW5nXCIsXG4gIGJsb2NrOiBcInN0cmluZ1wiLFxuICB2aXNpYmxlOiBcInN0cmluZ1wiLFxuICBpbnZpc2libGU6IFwic3RyaW5nXCIsXG4gIHNsaWRlUmlnaHQ6IFwic3RyaW5nXCIsXG4gIHNsaWRlTGVmdDogXCJzdHJpbmdcIlxufSwgY2UgPSBcIm5leHRcIiwgaGUgPSBcInByZXZcIiwgZmUgPSBcImxlZnRcIiwgRWkgPSBcInJpZ2h0XCIsIHhwID0ge1xuICBbVHBdOiBFaSxcbiAgW0VwXTogZmVcbn0sIE9wID0gYHNsaWRlJHttdH1gLCBGbiA9IGBzbGlkJHttdH1gLCBTcCA9IGBrZXlkb3duJHttdH1gLCBJcCA9IGBtb3VzZWVudGVyJHttdH1gLCBEcCA9IGBtb3VzZWxlYXZlJHttdH1gLCAkcCA9IGB0b3VjaHN0YXJ0JHttdH1gLCBMcCA9IGB0b3VjaG1vdmUke210fWAsIE5wID0gYHRvdWNoZW5kJHttdH1gLCBNcCA9IGBwb2ludGVyZG93biR7bXR9YCwgUnAgPSBgcG9pbnRlcnVwJHttdH1gLCBQcCA9IGBkcmFnc3RhcnQke210fWAsIEJwID0gYGxvYWQke210fSR7dGh9YCwgSHAgPSBgY2xpY2ske210fSR7dGh9YCwgX2EgPSBcImRhdGEtdGUtY2Fyb3VzZWwtaW5pdFwiLCBkZSA9IFwiZGF0YS10ZS1jYXJvdXNlbC1hY3RpdmVcIiwgVnAgPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1lbmRcIiwgWW4gPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1zdGFydFwiLCBXcCA9IFwiZGF0YS10ZS1jYXJvdXNlbC1pdGVtLW5leHRcIiwgRnAgPSBcImRhdGEtdGUtY2Fyb3VzZWwtaXRlbS1wcmV2XCIsIFlwID0gXCJkYXRhLXRlLWNhcm91c2VsLXBvaW50ZXItZXZlbnRcIiwganAgPSBcIltkYXRhLXRlLWNhcm91c2VsLWluaXRdXCIsIGVoID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1hY3RpdmVdXCIsIEFyID0gXCJbZGF0YS10ZS1jYXJvdXNlbC1pdGVtXVwiLCBTZSA9IGAke2VofSR7QXJ9YCwgS3AgPSBgJHtBcn0gaW1nYCwgenAgPSBcIltkYXRhLXRlLWNhcm91c2VsLWl0ZW0tbmV4dF0sIFtkYXRhLXRlLWNhcm91c2VsLWl0ZW0tcHJldl1cIiwgVXAgPSBcIltkYXRhLXRlLWNhcm91c2VsLWluZGljYXRvcnNdXCIsIFhwID0gXCJbZGF0YS10ZS10YXJnZXRdXCIsIEdwID0gXCJbZGF0YS10ZS1zbGlkZV0sIFtkYXRhLXRlLXNsaWRlLXRvXVwiLCBxcCA9IFwidG91Y2hcIiwgWnAgPSBcInBlblwiO1xuY2xhc3MgWHQgZXh0ZW5kcyBmdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5faXRlbXMgPSBudWxsLCB0aGlzLl9pbnRlcnZhbCA9IG51bGwsIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsLCB0aGlzLl9pc1BhdXNlZCA9ICExLCB0aGlzLl9pc1NsaWRpbmcgPSAhMSwgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsLCB0aGlzLnRvdWNoU3RhcnRYID0gMCwgdGhpcy50b3VjaERlbHRhWCA9IDAsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gZC5maW5kT25lKFxuICAgICAgVXAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fdG91Y2hTdXBwb3J0ZWQgPSBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwLCB0aGlzLl9wb2ludGVyRXZlbnQgPSAhIXdpbmRvdy5Qb2ludGVyRXZlbnQsIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRDbGFzcygpLCB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKSwgdGhpcy5fY29uZmlnLnJpZGUgPT09IFwiY2Fyb3VzZWxcIiAmJiB0aGlzLmN5Y2xlKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHBhO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gV247XG4gIH1cbiAgLy8gUHVibGljXG4gIG5leHQoKSB7XG4gICAgdGhpcy5fc2xpZGUoY2UpO1xuICB9XG4gIG5leHRXaGVuVmlzaWJsZSgpIHtcbiAgICAhZG9jdW1lbnQuaGlkZGVuICYmIE10KHRoaXMuX2VsZW1lbnQpICYmIHRoaXMubmV4dCgpO1xuICB9XG4gIHByZXYoKSB7XG4gICAgdGhpcy5fc2xpZGUoaGUpO1xuICB9XG4gIHBhdXNlKHQpIHtcbiAgICB0IHx8ICh0aGlzLl9pc1BhdXNlZCA9ICEwKSwgZC5maW5kT25lKHpwLCB0aGlzLl9lbGVtZW50KSAmJiAoX2ModGhpcy5fZWxlbWVudCksIHRoaXMuY3ljbGUoITApKSwgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCksIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgfVxuICBjeWNsZSh0KSB7XG4gICAgdCB8fCAodGhpcy5faXNQYXVzZWQgPSAhMSksIHRoaXMuX2ludGVydmFsICYmIChjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSwgdGhpcy5faW50ZXJ2YWwgPSBudWxsKSwgdGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCAmJiAhdGhpcy5faXNQYXVzZWQgJiYgKHRoaXMuX3VwZGF0ZUludGVydmFsKCksIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoXG4gICAgICAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID8gdGhpcy5uZXh0V2hlblZpc2libGUgOiB0aGlzLm5leHQpLmJpbmQoXG4gICAgICAgIHRoaXNcbiAgICAgICksXG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICApKTtcbiAgfVxuICB0byh0KSB7XG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IGQuZmluZE9uZShcbiAgICAgIFNlLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KTtcbiAgICBpZiAodCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgfHwgdCA8IDApXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgYy5vbmUodGhpcy5fZWxlbWVudCwgRm4sICgpID0+IHRoaXMudG8odCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZSA9PT0gdCkge1xuICAgICAgdGhpcy5wYXVzZSgpLCB0aGlzLmN5Y2xlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0ID4gZSA/IGNlIDogaGU7XG4gICAgdGhpcy5fc2xpZGUoaSwgdGhpcy5faXRlbXNbdF0pO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoYy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgSHAsXG4gICAgICBHcCxcbiAgICAgIFh0LmRhdGFBcGlDbGlja0hhbmRsZXJcbiAgICApLCBjLm9uKHdpbmRvdywgQnAsICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBkLmZpbmQoanApO1xuICAgICAgZm9yIChsZXQgZSA9IDAsIGkgPSB0Lmxlbmd0aDsgZSA8IGk7IGUrKylcbiAgICAgICAgWHQuY2Fyb3VzZWxJbnRlcmZhY2UoXG4gICAgICAgICAgdFtlXSxcbiAgICAgICAgICBYdC5nZXRJbnN0YW5jZSh0W2VdKVxuICAgICAgICApO1xuICAgIH0pLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ucGEsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIEkoV24sIHQsIHlwKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLndwLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKFduLCB0LCBrcCksIHQ7XG4gIH1cbiAgX2VuYWJsZUN5Y2xlKCkge1xuICAgIGlmICh0aGlzLl9jb25maWcucmlkZSkge1xuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgICBjLm9uZSh0aGlzLl9lbGVtZW50LCBGbiwgKCkgPT4gdGhpcy5jeWNsZSgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jeWNsZSgpO1xuICAgIH1cbiAgfVxuICBfYXBwbHlJbml0aWFsQ2xhc3NlcygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgU2UsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICB0LmNsYXNzTGlzdC5hZGQoXG4gICAgICB0aGlzLl9jbGFzc2VzLmJsb2NrLFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy52aXNpYmxlLnNwbGl0KFwiIFwiKVxuICAgICksIHRoaXMuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQodCk7XG4gIH1cbiAgX2hhbmRsZVN3aXBlKCkge1xuICAgIGNvbnN0IHQgPSBNYXRoLmFicyh0aGlzLnRvdWNoRGVsdGFYKTtcbiAgICBpZiAodCA8PSBBcClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdCAvIHRoaXMudG91Y2hEZWx0YVg7XG4gICAgdGhpcy50b3VjaERlbHRhWCA9IDAsIGUgJiYgdGhpcy5fc2xpZGUoZSA+IDAgPyBFaSA6IGZlKTtcbiAgfVxuICBfc2V0QWN0aXZlRWxlbWVudENsYXNzKCkge1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBkLmZpbmRPbmUoXG4gICAgICBTZSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBoLmFkZENsYXNzKHRoaXMuX2FjdGl2ZUVsZW1lbnQsIFwiaGlkZGVuXCIpO1xuICB9XG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBTcCxcbiAgICAgICh0KSA9PiB0aGlzLl9rZXlkb3duKHQpXG4gICAgKSwgdGhpcy5fY29uZmlnLnBhdXNlID09PSBcImhvdmVyXCIgJiYgKGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgSXAsXG4gICAgICAodCkgPT4gdGhpcy5wYXVzZSh0KVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgRHAsXG4gICAgICAodCkgPT4gdGhpcy5fZW5hYmxlQ3ljbGUodClcbiAgICApKSwgdGhpcy5fY29uZmlnLnRvdWNoICYmIHRoaXMuX3RvdWNoU3VwcG9ydGVkICYmIHRoaXMuX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5fYXBwbHlJbml0aWFsQ2xhc3NlcygpO1xuICB9XG4gIF9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHQgPSAobykgPT4gdGhpcy5fcG9pbnRlckV2ZW50ICYmIChvLnBvaW50ZXJUeXBlID09PSBacCB8fCBvLnBvaW50ZXJUeXBlID09PSBxcCksIGUgPSAobykgPT4ge1xuICAgICAgdChvKSA/IHRoaXMudG91Y2hTdGFydFggPSBvLmNsaWVudFggOiB0aGlzLl9wb2ludGVyRXZlbnQgfHwgKHRoaXMudG91Y2hTdGFydFggPSBvLnRvdWNoZXNbMF0uY2xpZW50WCk7XG4gICAgfSwgaSA9IChvKSA9PiB7XG4gICAgICB0aGlzLnRvdWNoRGVsdGFYID0gby50b3VjaGVzICYmIG8udG91Y2hlcy5sZW5ndGggPiAxID8gMCA6IG8udG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0WDtcbiAgICB9LCBuID0gKG8pID0+IHtcbiAgICAgIHQobykgJiYgKHRoaXMudG91Y2hEZWx0YVggPSBvLmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYKSwgdGhpcy5faGFuZGxlU3dpcGUoKSwgdGhpcy5fY29uZmlnLnBhdXNlID09PSBcImhvdmVyXCIgJiYgKHRoaXMucGF1c2UoKSwgdGhpcy50b3VjaFRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMudG91Y2hUaW1lb3V0KSwgdGhpcy50b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAocikgPT4gdGhpcy5fZW5hYmxlQ3ljbGUociksXG4gICAgICAgIENwICsgdGhpcy5fY29uZmlnLmludGVydmFsXG4gICAgICApKTtcbiAgICB9O1xuICAgIGQuZmluZChLcCwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChcbiAgICAgIChvKSA9PiB7XG4gICAgICAgIGMub24oXG4gICAgICAgICAgbyxcbiAgICAgICAgICBQcCxcbiAgICAgICAgICAocikgPT4gci5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKSwgdGhpcy5fcG9pbnRlckV2ZW50ID8gKGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgTXAsXG4gICAgICAobykgPT4gZShvKVxuICAgICksIGMub24odGhpcy5fZWxlbWVudCwgUnAsIChvKSA9PiBuKG8pKSwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuX2NsYXNzZXMucG9pbnRlciksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGAke1lwfWAsIFwiXCIpKSA6IChjLm9uKHRoaXMuX2VsZW1lbnQsICRwLCAobykgPT4gZShvKSksIGMub24odGhpcy5fZWxlbWVudCwgTHAsIChvKSA9PiBpKG8pKSwgYy5vbih0aGlzLl9lbGVtZW50LCBOcCwgKG8pID0+IG4obykpKTtcbiAgfVxuICBfa2V5ZG93bih0KSB7XG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHhwW3Qua2V5XTtcbiAgICBlICYmICh0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX3NsaWRlKGUpKTtcbiAgfVxuICBfZ2V0SXRlbUluZGV4KHQpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMgPSB0ICYmIHQucGFyZW50Tm9kZSA/IGQuZmluZChBciwgdC5wYXJlbnROb2RlKSA6IFtdLCB0aGlzLl9pdGVtcy5pbmRleE9mKHQpO1xuICB9XG4gIF9nZXRJdGVtQnlPcmRlcih0LCBlKSB7XG4gICAgY29uc3QgaSA9IHQgPT09IGNlO1xuICAgIHJldHVybiB2YyhcbiAgICAgIHRoaXMuX2l0ZW1zLFxuICAgICAgZSxcbiAgICAgIGksXG4gICAgICB0aGlzLl9jb25maWcud3JhcFxuICAgICk7XG4gIH1cbiAgX3RyaWdnZXJTbGlkZUV2ZW50KHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fZ2V0SXRlbUluZGV4KHQpLCBuID0gdGhpcy5fZ2V0SXRlbUluZGV4KFxuICAgICAgZC5maW5kT25lKFNlLCB0aGlzLl9lbGVtZW50KVxuICAgICk7XG4gICAgcmV0dXJuIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBPcCwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdCxcbiAgICAgIGRpcmVjdGlvbjogZSxcbiAgICAgIGZyb206IG4sXG4gICAgICB0bzogaVxuICAgIH0pO1xuICB9XG4gIF9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KHQpIHtcbiAgICBpZiAodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoXG4gICAgICAgIGVoLFxuICAgICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudFxuICAgICAgKTtcbiAgICAgIGUucmVtb3ZlQXR0cmlidXRlKGRlKSwgZS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIiksIGUuY2xhc3NMaXN0LnJlbW92ZShcIiFvcGFjaXR5LTEwMFwiKTtcbiAgICAgIGNvbnN0IGkgPSBkLmZpbmQoXG4gICAgICAgIFhwLFxuICAgICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudFxuICAgICAgKTtcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgaS5sZW5ndGg7IG4rKylcbiAgICAgICAgaWYgKE51bWJlci5wYXJzZUludChcbiAgICAgICAgICBpW25dLmdldEF0dHJpYnV0ZShcImRhdGEtdGUtc2xpZGUtdG9cIiksXG4gICAgICAgICAgMTBcbiAgICAgICAgKSA9PT0gdGhpcy5fZ2V0SXRlbUluZGV4KHQpKSB7XG4gICAgICAgICAgaVtuXS5zZXRBdHRyaWJ1dGUoYCR7ZGV9YCwgXCJcIiksIGlbbl0uc2V0QXR0cmlidXRlKFwiYXJpYS1jdXJyZW50XCIsIFwidHJ1ZVwiKSwgaVtuXS5jbGFzc0xpc3QuYWRkKFwiIW9wYWNpdHktMTAwXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIF91cGRhdGVJbnRlcnZhbCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fYWN0aXZlRWxlbWVudCB8fCBkLmZpbmRPbmUoU2UsIHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gTnVtYmVyLnBhcnNlSW50KFxuICAgICAgdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLWludGVydmFsXCIpLFxuICAgICAgMTBcbiAgICApO1xuICAgIGUgPyAodGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmludGVydmFsLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBlKSA6IHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmludGVydmFsO1xuICB9XG4gIF9zbGlkZSh0LCBlKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2RpcmVjdGlvblRvT3JkZXIodCksIG4gPSBkLmZpbmRPbmUoXG4gICAgICBTZSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBvID0gdGhpcy5fZ2V0SXRlbUluZGV4KG4pLCByID0gZSB8fCB0aGlzLl9nZXRJdGVtQnlPcmRlcihpLCBuKSwgYSA9IHRoaXMuX2dldEl0ZW1JbmRleChyKSwgbCA9ICEhdGhpcy5faW50ZXJ2YWwsIHAgPSBpID09PSBjZSwgdSA9IHAgPyBZbiA6IFZwLCBfID0gcCA/IFdwIDogRnAsIGYgPSB0aGlzLl9vcmRlclRvRGlyZWN0aW9uKGkpLCBnID0gdSA9PT0gWW4gPyB0aGlzLl9jbGFzc2VzLnNsaWRlTGVmdCA6IHRoaXMuX2NsYXNzZXMuc2xpZGVSaWdodCwgbSA9IHUgIT09IFluID8gdGhpcy5fY2xhc3Nlcy5zbGlkZUxlZnQgOiB0aGlzLl9jbGFzc2VzLnNsaWRlUmlnaHQ7XG4gICAgaWYgKHIgJiYgci5oYXNBdHRyaWJ1dGUoZGUpKSB7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSAhMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZyB8fCB0aGlzLl90cmlnZ2VyU2xpZGVFdmVudChyLCBmKS5kZWZhdWx0UHJldmVudGVkIHx8ICFuIHx8ICFyKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2lzU2xpZGluZyA9ICEwLCBsICYmIHRoaXMucGF1c2UoKSwgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChyKSwgdGhpcy5fYWN0aXZlRWxlbWVudCA9IHI7XG4gICAgY29uc3QgdiA9ICgpID0+IHtcbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBGbiwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiByLFxuICAgICAgICBkaXJlY3Rpb246IGYsXG4gICAgICAgIGZyb206IG8sXG4gICAgICAgIHRvOiBhXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmICh0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShfYSkpIHtcbiAgICAgIHIuc2V0QXR0cmlidXRlKGAke199YCwgXCJcIiksIHIuY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLmJsb2NrLCBtKSwgc2kociksIG4uc2V0QXR0cmlidXRlKGAke3V9YCwgXCJcIiksIG4uY2xhc3NMaXN0LmFkZChcbiAgICAgICAgZyxcbiAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnZpc2libGUuc3BsaXQoXCIgXCIpXG4gICAgICApLCBuLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy52aXNpYmxlLnNwbGl0KFwiIFwiKSksIHIuc2V0QXR0cmlidXRlKGAke3V9YCwgXCJcIiksIHIuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLnZpc2libGUuc3BsaXQoXCIgXCIpKSwgci5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICB0aGlzLl9jbGFzc2VzLnNsaWRlUmlnaHQsXG4gICAgICAgIHRoaXMuX2NsYXNzZXMuc2xpZGVMZWZ0XG4gICAgICApO1xuICAgICAgY29uc3QgVCA9ICgpID0+IHtcbiAgICAgICAgci5yZW1vdmVBdHRyaWJ1dGUodSksIHIucmVtb3ZlQXR0cmlidXRlKF8pLCByLnNldEF0dHJpYnV0ZShgJHtkZX1gLCBcIlwiKSwgbi5yZW1vdmVBdHRyaWJ1dGUoZGUpLCBuLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgICAgZyxcbiAgICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmludmlzaWJsZS5zcGxpdChcIiBcIiksXG4gICAgICAgICAgdGhpcy5fY2xhc3Nlcy5ibG9ja1xuICAgICAgICApLCBuLnJlbW92ZUF0dHJpYnV0ZShfKSwgbi5yZW1vdmVBdHRyaWJ1dGUodSksIHRoaXMuX2lzU2xpZGluZyA9ICExLCBzZXRUaW1lb3V0KHYsIDApO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soVCwgbiwgITApO1xuICAgIH0gZWxzZVxuICAgICAgbi5yZW1vdmVBdHRyaWJ1dGUoZGUpLCBuLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3Nlcy5ibG9jayksIHIuc2V0QXR0cmlidXRlKGAke2RlfWAsIFwiXCIpLCByLmNsYXNzTGlzdC5hZGQodGhpcy5fY2xhc3Nlcy5ibG9jayksIHRoaXMuX2lzU2xpZGluZyA9ICExLCB2KCk7XG4gICAgbCAmJiB0aGlzLmN5Y2xlKCk7XG4gIH1cbiAgX2RpcmVjdGlvblRvT3JkZXIodCkge1xuICAgIHJldHVybiBbRWksIGZlXS5pbmNsdWRlcyh0KSA/IFcoKSA/IHQgPT09IGZlID8gaGUgOiBjZSA6IHQgPT09IGZlID8gY2UgOiBoZSA6IHQ7XG4gIH1cbiAgX29yZGVyVG9EaXJlY3Rpb24odCkge1xuICAgIHJldHVybiBbY2UsIGhlXS5pbmNsdWRlcyh0KSA/IFcoKSA/IHQgPT09IGhlID8gZmUgOiBFaSA6IHQgPT09IGhlID8gRWkgOiBmZSA6IHQ7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBjYXJvdXNlbEludGVyZmFjZSh0LCBlKSB7XG4gICAgY29uc3QgaSA9IFh0LmdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSk7XG4gICAgbGV0IHsgX2NvbmZpZzogbiB9ID0gaTtcbiAgICB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIChuID0ge1xuICAgICAgLi4ubixcbiAgICAgIC4uLmVcbiAgICB9KTtcbiAgICBjb25zdCBvID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUgOiBlLnNsaWRlO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICBpLnRvKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHR5cGVvZiBpW29dID4gXCJ1XCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7b31cImApO1xuICAgICAgaVtvXSgpO1xuICAgIH0gZWxzZVxuICAgICAgbi5pbnRlcnZhbCAmJiBuLnJpZGUgPT09ICEwICYmIGkucGF1c2UoKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgWHQuY2Fyb3VzZWxJbnRlcmZhY2UodGhpcywgdCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGRhdGFBcGlDbGlja0hhbmRsZXIodCkge1xuICAgIGNvbnN0IGUgPSB0ZSh0aGlzKTtcbiAgICBpZiAoIWUgfHwgIWUuaGFzQXR0cmlidXRlKF9hKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0ge1xuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyhlKSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcylcbiAgICB9LCBuID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXNsaWRlLXRvXCIpO1xuICAgIG4gJiYgKGkuaW50ZXJ2YWwgPSAhMSksIFh0LmNhcm91c2VsSW50ZXJmYWNlKGUsIGkpLCBuICYmIFh0LmdldEluc3RhbmNlKGUpLnRvKG4pLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn1cbmNvbnN0IGpuID0gXCJtb2RhbFwiLCBRcCA9IFwidGUubW9kYWxcIiwgeXQgPSBgLiR7UXB9YCwgZmEgPSBcIkVzY2FwZVwiLCBtYSA9IHtcbiAgYmFja2Ryb3A6ICEwLFxuICBrZXlib2FyZDogITAsXG4gIGZvY3VzOiAhMCxcbiAgbW9kYWxOb25JbnZhc2l2ZTogITFcbn0sIEpwID0ge1xuICBiYWNrZHJvcDogXCIoYm9vbGVhbnxzdHJpbmcpXCIsXG4gIGtleWJvYXJkOiBcImJvb2xlYW5cIixcbiAgZm9jdXM6IFwiYm9vbGVhblwiLFxuICBtb2RhbE5vbkludmFzaXZlOiBcImJvb2xlYW5cIlxufSwgdF8gPSB7XG4gIHNob3c6IFwidHJhbnNmb3JtLW5vbmVcIixcbiAgc3RhdGljOiBcInNjYWxlLVsxLjAyXVwiLFxuICBzdGF0aWNQcm9wZXJ0aWVzOiBcInRyYW5zaXRpb24tc2NhbGUgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0XCIsXG4gIGJhY2tkcm9wOiBcIm9wYWNpdHktNTAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0IGZpeGVkIHRvcC0wIGxlZnQtMCB6LVsxMDQwXSBiZy1ibGFjayB3LXNjcmVlbiBoLXNjcmVlblwiXG59LCBlXyA9IHtcbiAgc2hvdzogXCJzdHJpbmdcIixcbiAgc3RhdGljOiBcInN0cmluZ1wiLFxuICBzdGF0aWNQcm9wZXJ0aWVzOiBcInN0cmluZ1wiLFxuICBiYWNrZHJvcDogXCJzdHJpbmdcIlxufSwgaV8gPSBgaGlkZSR7eXR9YCwgc18gPSBgaGlkZVByZXZlbnRlZCR7eXR9YCwgbl8gPSBgaGlkZGVuJHt5dH1gLCBvXyA9IGBzaG93JHt5dH1gLCByXyA9IGBzaG93biR7eXR9YCwgZ2EgPSBgcmVzaXplJHt5dH1gLCBiYSA9IGBjbGljay5kaXNtaXNzJHt5dH1gLCB2YSA9IGBrZXlkb3duLmRpc21pc3Mke3l0fWAsIGFfID0gYG1vdXNldXAuZGlzbWlzcyR7eXR9YCwgVGEgPSBgbW91c2Vkb3duLmRpc21pc3Mke3l0fWAsIEVhID0gXCJkYXRhLXRlLW1vZGFsLW9wZW5cIiwgQ2EgPSBcImRhdGEtdGUtb3BlblwiLCBwaSA9IFwiW2RhdGEtdGUtbW9kYWwtZGlhbG9nLXJlZl1cIiwgbF8gPSBcIltkYXRhLXRlLW1vZGFsLWJvZHktcmVmXVwiO1xuY2xhc3Mgem8gZXh0ZW5kcyBmdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZGlhbG9nID0gZC5maW5kT25lKHBpLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9jb25maWcubW9kYWxOb25JbnZhc2l2ZSA/IG51bGwgOiB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKSwgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpLCB0aGlzLl9pc1Nob3duID0gITEsIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIHRoaXMuX3Njcm9sbEJhciA9IG5ldyB0aSgpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gbWE7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBqbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHQpO1xuICB9XG4gIHNob3codCkge1xuICAgIHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBvXywge1xuICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX2lzU2hvd24gPSAhMCwgdGhpcy5faXNBbmltYXRlZCgpICYmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMCksICF0aGlzLl9jb25maWcubW9kYWxOb25JbnZhc2l2ZSAmJiB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpLCBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShFYSwgXCJ0cnVlXCIpLCB0aGlzLl9hZGp1c3REaWFsb2coKSwgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKSwgdGhpcy5fc2V0UmVzaXplRXZlbnQoKSwgYy5vbih0aGlzLl9kaWFsb2csIFRhLCAoKSA9PiB7XG4gICAgICBjLm9uZSh0aGlzLl9lbGVtZW50LCBhXywgKGkpID0+IHtcbiAgICAgICAgaS50YXJnZXQgPT09IHRoaXMuX2VsZW1lbnQgJiYgKHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMCk7XG4gICAgICB9KTtcbiAgICB9KSwgdGhpcy5fc2hvd0VsZW1lbnQodCksICF0aGlzLl9jb25maWcubW9kYWxOb25JbnZhc2l2ZSAmJiB0aGlzLl9zaG93QmFja2Ryb3AoKSk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBpXykuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9pc1Nob3duID0gITE7XG4gICAgY29uc3QgZSA9IHRoaXMuX2lzQW5pbWF0ZWQoKTtcbiAgICBlICYmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMCksIHRoaXMuX3NldEVzY2FwZUV2ZW50KCksIHRoaXMuX3NldFJlc2l6ZUV2ZW50KCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIGQuZmluZE9uZShwaSwgdGhpcy5fZWxlbWVudCkuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jbGFzc2VzLnNob3cpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBiYSksIGMub2ZmKHRoaXMuX2RpYWxvZywgVGEpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2hpZGVNb2RhbCgpLCB0aGlzLl9lbGVtZW50LCBlKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoQ2EpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgW3dpbmRvdywgZG9jdW1lbnQsIHRoaXMuX2RpYWxvZ10uZm9yRWFjaChcbiAgICAgICh0KSA9PiBjLm9mZih0LCB5dClcbiAgICApLCB0aGlzLl9iYWNrZHJvcCAmJiB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICBoYW5kbGVVcGRhdGUoKSB7XG4gICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8ICh2bih6byksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICByZXR1cm4gbmV3IENyKHtcbiAgICAgIGlzVmlzaWJsZTogISF0aGlzLl9jb25maWcuYmFja2Ryb3AsXG4gICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWVcbiAgICAgIGlzQW5pbWF0ZWQ6IHRoaXMuX2lzQW5pbWF0ZWQoKSxcbiAgICAgIGJhY2tkcm9wQ2xhc3NlczogdGhpcy5fY2xhc3Nlcy5iYWNrZHJvcFxuICAgIH0pO1xuICB9XG4gIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgIHJldHVybiBuZXcgemkodGhpcy5fZWxlbWVudCwge1xuICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgY29uZGl0aW9uOiAodCkgPT4gdC5rZXkgPT09IFwiVGFiXCJcbiAgICB9KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLm1hLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyB0IDoge31cbiAgICB9LCBJKGpuLCB0LCBKcCksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi50XyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgSShqbiwgdCwgZV8pLCB0O1xuICB9XG4gIF9zaG93RWxlbWVudCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2lzQW5pbWF0ZWQoKSwgaSA9IGQuZmluZE9uZShsXywgdGhpcy5fZGlhbG9nKTtcbiAgICAoIXRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSB8fCB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSAmJiBkb2N1bWVudC5ib2R5LmFwcGVuZCh0aGlzLl9lbGVtZW50KSwgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiLCAhMCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImRpYWxvZ1wiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYCR7Q2F9YCwgXCJ0cnVlXCIpLCB0aGlzLl9lbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgY29uc3QgbiA9IGQuZmluZE9uZShwaSwgdGhpcy5fZWxlbWVudCk7XG4gICAgbi5jbGFzc0xpc3QuYWRkKHRoaXMuX2NsYXNzZXMuc2hvdyksIG4uY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMFwiKSwgbi5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0xMDBcIiksIGkgJiYgKGkuc2Nyb2xsVG9wID0gMCksIGUgJiYgc2kodGhpcy5fZWxlbWVudCk7XG4gICAgY29uc3QgbyA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbmZpZy5mb2N1cyAmJiB0aGlzLl9mb2N1c3RyYXAudHJhcCgpLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHJfLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhvLCB0aGlzLl9kaWFsb2csIGUpO1xuICB9XG4gIF9zZXRFc2NhcGVFdmVudCgpIHtcbiAgICB0aGlzLl9pc1Nob3duID8gYy5vbihkb2N1bWVudCwgdmEsICh0KSA9PiB7XG4gICAgICB0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgdC5rZXkgPT09IGZhID8gKHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5oaWRlKCkpIDogIXRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiB0LmtleSA9PT0gZmEgJiYgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpO1xuICAgIH0pIDogYy5vZmYodGhpcy5fZWxlbWVudCwgdmEpO1xuICB9XG4gIF9zZXRSZXNpemVFdmVudCgpIHtcbiAgICB0aGlzLl9pc1Nob3duID8gYy5vbih3aW5kb3csIGdhLCAoKSA9PiB0aGlzLl9hZGp1c3REaWFsb2coKSkgOiBjLm9mZih3aW5kb3csIGdhKTtcbiAgfVxuICBfaGlkZU1vZGFsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUocGksIHRoaXMuX2VsZW1lbnQpO1xuICAgIHQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jbGFzc2VzLnNob3cpLCB0LmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTEwMFwiKSwgdC5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0wXCIpO1xuICAgIGNvbnN0IGUgPSBjbih0KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH0sIGUpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIiksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB0aGlzLl9iYWNrZHJvcCAmJiB0aGlzLl9iYWNrZHJvcC5oaWRlKCgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKEVhKSwgdGhpcy5fcmVzZXRBZGp1c3RtZW50cygpLCAhdGhpcy5fY29uZmlnLm1vZGFsTm9uSW52YXNpdmUgJiYgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBuXyk7XG4gICAgfSk7XG4gIH1cbiAgX3Nob3dCYWNrZHJvcCh0KSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBiYSwgKGUpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCAmJiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAhMCA/IHRoaXMuaGlkZSgpIDogdGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSBcInN0YXRpY1wiICYmIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSk7XG4gICAgfSksIHRoaXMuX2JhY2tkcm9wICYmIHRoaXMuX2JhY2tkcm9wLnNob3codCk7XG4gIH1cbiAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuICEhZC5maW5kT25lKHBpLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcbiAgICBpZiAoYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHNfKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY2xhc3NMaXN0OiBlLCBzY3JvbGxIZWlnaHQ6IGksIHN0eWxlOiBuIH0gPSB0aGlzLl9lbGVtZW50LCBvID0gaSA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKCFvICYmIG4ub3ZlcmZsb3dZID09PSBcImhpZGRlblwiIHx8IGUuY29udGFpbnModGhpcy5fY2xhc3Nlcy5zdGF0aWMpKVxuICAgICAgcmV0dXJuO1xuICAgIG8gfHwgKG4ub3ZlcmZsb3dZID0gXCJoaWRkZW5cIiksIGUuYWRkKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljLnNwbGl0KFwiIFwiKSksIGUuYWRkKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljUHJvcGVydGllcy5zcGxpdChcIiBcIikpO1xuICAgIGNvbnN0IHIgPSBjbih0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGUucmVtb3ZlKHRoaXMuX2NsYXNzZXMuc3RhdGljKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGUucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljUHJvcGVydGllcy5zcGxpdChcIiBcIikpO1xuICAgICAgfSwgciksIG8gfHwgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIG4ub3ZlcmZsb3dZID0gXCJcIjtcbiAgICAgIH0sIHRoaXMuX2RpYWxvZyk7XG4gICAgfSwgdGhpcy5fZGlhbG9nKSwgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gdGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBfYWRqdXN0RGlhbG9nKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIGUgPSB0aGlzLl9zY3JvbGxCYXIuZ2V0V2lkdGgoKSwgaSA9IGUgPiAwO1xuICAgICghaSAmJiB0ICYmICFXKCkgfHwgaSAmJiAhdCAmJiBXKCkpICYmICh0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gYCR7ZX1weGApLCAoaSAmJiAhdCAmJiAhVygpIHx8ICFpICYmIHQgJiYgVygpKSAmJiAodGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtlfXB4YCk7XG4gIH1cbiAgX3Jlc2V0QWRqdXN0bWVudHMoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiXCIsIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCJcIjtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGkgPSB6by5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGNfID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImJhY2tncm91bmRcIixcbiAgXCJjaXRlXCIsXG4gIFwiaHJlZlwiLFxuICBcIml0ZW10eXBlXCIsXG4gIFwibG9uZ2Rlc2NcIixcbiAgXCJwb3N0ZXJcIixcbiAgXCJzcmNcIixcbiAgXCJ4bGluazpocmVmXCJcbl0pLCBpaCA9IC9eYXJpYS1bXFx3LV0qJC9pLCBoXyA9IC9eZGF0YS10ZS1bXFx3LV0qJC9pLCBkXyA9IC9eKD86KD86aHR0cHM/fG1haWx0b3xmdHB8dGVsfGZpbGV8c21zKTp8W14jJi86P10qKD86WyMvP118JCkpL2ksIHVfID0gL15kYXRhOig/OmltYWdlXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcLyg/Om1wZWd8bXA0fG9nZ3x3ZWJtKXxhdWRpb1xcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW1xcZCsvYS16XSs9KiQvaSwgcF8gPSAocywgdCkgPT4ge1xuICBjb25zdCBlID0gcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAodC5pbmNsdWRlcyhlKSlcbiAgICByZXR1cm4gY18uaGFzKGUpID8gISEoZF8udGVzdChzLm5vZGVWYWx1ZSkgfHwgdV8udGVzdChzLm5vZGVWYWx1ZSkpIDogITA7XG4gIGNvbnN0IGkgPSB0LmZpbHRlcihcbiAgICAobikgPT4gbiBpbnN0YW5jZW9mIFJlZ0V4cFxuICApO1xuICBmb3IgKGxldCBuID0gMCwgbyA9IGkubGVuZ3RoOyBuIDwgbzsgbisrKVxuICAgIGlmIChpW25dLnRlc3QoZSkpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn0sIHNoID0ge1xuICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxuICBcIipcIjogW1xuICAgIFwiY2xhc3NcIixcbiAgICBcImRpclwiLFxuICAgIFwiaWRcIixcbiAgICBcImxhbmdcIixcbiAgICBcInJvbGVcIixcbiAgICBpaCxcbiAgICBoX1xuICBdLFxuICBhOiBbXCJ0YXJnZXRcIiwgXCJocmVmXCIsIFwidGl0bGVcIiwgXCJyZWxcIl0sXG4gIGFyZWE6IFtdLFxuICBiOiBbXSxcbiAgYnI6IFtdLFxuICBjb2w6IFtdLFxuICBjb2RlOiBbXSxcbiAgZGl2OiBbXSxcbiAgZW06IFtdLFxuICBocjogW10sXG4gIGgxOiBbXSxcbiAgaDI6IFtdLFxuICBoMzogW10sXG4gIGg0OiBbXSxcbiAgaDU6IFtdLFxuICBoNjogW10sXG4gIGk6IFtdLFxuICBpbWc6IFtcInNyY1wiLCBcInNyY3NldFwiLCBcImFsdFwiLCBcInRpdGxlXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl0sXG4gIGxpOiBbXSxcbiAgb2w6IFtdLFxuICBwOiBbXSxcbiAgcHJlOiBbXSxcbiAgczogW10sXG4gIHNtYWxsOiBbXSxcbiAgc3BhbjogW10sXG4gIHN1YjogW10sXG4gIHN1cDogW10sXG4gIHN0cm9uZzogW10sXG4gIHU6IFtdLFxuICB1bDogW11cbn0sIF9fID0ge1xuICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxuICBcIipcIjogW1wiY2xhc3NcIiwgXCJkaXJcIiwgXCJpZFwiLCBcImxhbmdcIiwgXCJyb2xlXCIsIGloXSxcbiAgYTogW1widGFyZ2V0XCIsIFwiaHJlZlwiLCBcInRpdGxlXCIsIFwicmVsXCJdLFxuICBhcmVhOiBbXSxcbiAgYjogW10sXG4gIGJyOiBbXSxcbiAgY29sOiBbXSxcbiAgY29kZTogW10sXG4gIGRpdjogW10sXG4gIGVtOiBbXSxcbiAgaHI6IFtdLFxuICBoMTogW10sXG4gIGgyOiBbXSxcbiAgaDM6IFtdLFxuICBoNDogW10sXG4gIGg1OiBbXSxcbiAgaDY6IFtdLFxuICBpOiBbXSxcbiAgaW1nOiBbXCJzcmNcIiwgXCJzcmNzZXRcIiwgXCJhbHRcIiwgXCJ0aXRsZVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLFxuICBsaTogW10sXG4gIG9sOiBbXSxcbiAgcDogW10sXG4gIHByZTogW10sXG4gIHM6IFtdLFxuICBzbWFsbDogW10sXG4gIHNwYW46IFtdLFxuICBzdWI6IFtdLFxuICBzdXA6IFtdLFxuICBzdHJvbmc6IFtdLFxuICB1OiBbXSxcbiAgdWw6IFtdXG59O1xuZnVuY3Rpb24gcG4ocywgdCwgZSkge1xuICBpZiAoIXMubGVuZ3RoKVxuICAgIHJldHVybiBzO1xuICBpZiAoZSAmJiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIGUocyk7XG4gIGNvbnN0IG4gPSBuZXcgd2luZG93LkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzLCBcInRleHQvaHRtbFwiKSwgbyA9IFtdLmNvbmNhdCguLi5uLmJvZHkucXVlcnlTZWxlY3RvckFsbChcIipcIikpO1xuICBmb3IgKGxldCByID0gMCwgYSA9IG8ubGVuZ3RoOyByIDwgYTsgcisrKSB7XG4gICAgY29uc3QgbCA9IG9bcl0sIHAgPSBsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0KS5pbmNsdWRlcyhwKSkge1xuICAgICAgbC5yZW1vdmUoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB1ID0gW10uY29uY2F0KC4uLmwuYXR0cmlidXRlcyksIF8gPSBbXS5jb25jYXQoXG4gICAgICB0W1wiKlwiXSB8fCBbXSxcbiAgICAgIHRbcF0gfHwgW11cbiAgICApO1xuICAgIHUuZm9yRWFjaCgoZikgPT4ge1xuICAgICAgcF8oZiwgXykgfHwgbC5yZW1vdmVBdHRyaWJ1dGUoZi5ub2RlTmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG4uYm9keS5pbm5lckhUTUw7XG59XG5jb25zdCBBYSA9IFwidG9vbHRpcFwiLCBmXyA9IFwidGUudG9vbHRpcFwiLCBrdCA9IGAuJHtmX31gLCBtXyA9IFwidGUtdG9vbHRpcFwiLCBnXyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInNhbml0aXplXCIsIFwiYWxsb3dMaXN0XCIsIFwic2FuaXRpemVGblwiXSksIGJfID0ge1xuICBhbmltYXRpb246IFwiYm9vbGVhblwiLFxuICB0ZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgdGl0bGU6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiLFxuICB0cmlnZ2VyOiBcInN0cmluZ1wiLFxuICBkZWxheTogXCIobnVtYmVyfG9iamVjdClcIixcbiAgaHRtbDogXCJib29sZWFuXCIsXG4gIHNlbGVjdG9yOiBcIihzdHJpbmd8Ym9vbGVhbilcIixcbiAgcGxhY2VtZW50OiBcIihzdHJpbmd8ZnVuY3Rpb24pXCIsXG4gIG9mZnNldDogXCIoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBjb250YWluZXI6IFwiKHN0cmluZ3xlbGVtZW50fGJvb2xlYW4pXCIsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogXCJhcnJheVwiLFxuICBib3VuZGFyeTogXCIoc3RyaW5nfGVsZW1lbnQpXCIsXG4gIGN1c3RvbUNsYXNzOiBcIihzdHJpbmd8ZnVuY3Rpb24pXCIsXG4gIHNhbml0aXplOiBcImJvb2xlYW5cIixcbiAgc2FuaXRpemVGbjogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgYWxsb3dMaXN0OiBcIm9iamVjdFwiLFxuICBwb3BwZXJDb25maWc6IFwiKG51bGx8b2JqZWN0fGZ1bmN0aW9uKVwiXG59LCB2XyA9IHtcbiAgQVVUTzogXCJhdXRvXCIsXG4gIFRPUDogXCJ0b3BcIixcbiAgUklHSFQ6IFcoKSA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICBCT1RUT006IFwiYm90dG9tXCIsXG4gIExFRlQ6IFcoKSA/IFwicmlnaHRcIiA6IFwibGVmdFwiXG59LCBUXyA9IHtcbiAgYW5pbWF0aW9uOiAhMCxcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwib3BhY2l0eS0wIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi0zMDAgZWFzZS1pbi1vdXQgYWJzb2x1dGUgei1bMTA4MF0gYmxvY2sgbS0wIHRleHQtc20gbm90LWl0YWxpYyBmb250LW5vcm1hbCB0ZXh0LWxlZnQgbm8tdW5kZXJsaW5lIHVuZGVybGluZS1vZmZzZXQtYXV0byBub3JtYWwtY2FzZSBsZWFkaW5nLTYgdHJhY2tpbmctbm9ybWFsIGJyZWFrLW5vcm1hbCB3aGl0ZXNwYWNlLW5vcm1hbFwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBkYXRhLXRlLXRvb2x0aXAtaW5uZXItcmVmIGNsYXNzPVwidG9vbHRpcC1pbm5lciBtYXgtdy1bMjAwcHhdIHRleHQtc20gcHktMS41IHB4LTQgdGV4dC13aGl0ZSB0ZXh0LWNlbnRlciBiZy1bIzZkNmQ2ZF0gcm91bmRlZFwiPjwvZGl2PjwvZGl2PicsXG4gIHRyaWdnZXI6IFwiaG92ZXIgZm9jdXNcIixcbiAgdGl0bGU6IFwiXCIsXG4gIGRlbGF5OiAwLFxuICBodG1sOiAhMSxcbiAgc2VsZWN0b3I6ICExLFxuICBwbGFjZW1lbnQ6IFwidG9wXCIsXG4gIG9mZnNldDogWzAsIDBdLFxuICBjb250YWluZXI6ICExLFxuICBmYWxsYmFja1BsYWNlbWVudHM6IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXSxcbiAgYm91bmRhcnk6IFwiY2xpcHBpbmdQYXJlbnRzXCIsXG4gIGN1c3RvbUNsYXNzOiBcIlwiLFxuICBzYW5pdGl6ZTogITAsXG4gIHNhbml0aXplRm46IG51bGwsXG4gIGFsbG93TGlzdDogX18sXG4gIHBvcHBlckNvbmZpZzogeyBoaWRlOiAhMCB9XG59LCBFXyA9IHtcbiAgSElERTogYGhpZGUke2t0fWAsXG4gIEhJRERFTjogYGhpZGRlbiR7a3R9YCxcbiAgU0hPVzogYHNob3cke2t0fWAsXG4gIFNIT1dOOiBgc2hvd24ke2t0fWAsXG4gIElOU0VSVEVEOiBgaW5zZXJ0ZWQke2t0fWAsXG4gIENMSUNLOiBgY2xpY2ske2t0fWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHtrdH1gLFxuICBGT0NVU09VVDogYGZvY3Vzb3V0JHtrdH1gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7a3R9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke2t0fWBcbn0sIENfID0gXCJmYWRlXCIsIEFfID0gXCJtb2RhbFwiLCBLbiA9IFwic2hvd1wiLCBfaSA9IFwic2hvd1wiLCB6biA9IFwib3V0XCIsIHlhID0gXCIudG9vbHRpcC1pbm5lclwiLCB3YSA9IGAuJHtBX31gLCBrYSA9IFwiaGlkZS50ZS5tb2RhbFwiLCBmaSA9IFwiaG92ZXJcIiwgVW4gPSBcImZvY3VzXCIsIHlfID0gXCJjbGlja1wiLCB3XyA9IFwibWFudWFsXCI7XG5jbGFzcyByaSBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIGlmICh0eXBlb2YgcWMgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiQm9vdHN0cmFwJ3MgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZylcIlxuICAgICAgKTtcbiAgICBzdXBlcih0KSwgdGhpcy5faXNFbmFibGVkID0gITAsIHRoaXMuX3RpbWVvdXQgPSAwLCB0aGlzLl9ob3ZlclN0YXRlID0gXCJcIiwgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IHt9LCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMudGlwID0gbnVsbCwgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIFRfO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gQWE7XG4gIH1cbiAgc3RhdGljIGdldCBFdmVudCgpIHtcbiAgICByZXR1cm4gRV87XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gYl87XG4gIH1cbiAgLy8gUHVibGljXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSAhMDtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICExO1xuICB9XG4gIHRvZ2dsZUVuYWJsZWQoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcbiAgfVxuICB0b2dnbGUodCkge1xuICAgIGlmICh0aGlzLl9pc0VuYWJsZWQpXG4gICAgICBpZiAodCkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQpO1xuICAgICAgICBlLl9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIWUuX2FjdGl2ZVRyaWdnZXIuY2xpY2ssIGUuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSA/IGUuX2VudGVyKG51bGwsIGUpIDogZS5fbGVhdmUobnVsbCwgZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKEtuKSkge1xuICAgICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbnRlcihudWxsLCB0aGlzKTtcbiAgICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSwgYy5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LmNsb3Nlc3Qod2EpLFxuICAgICAga2EsXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyXG4gICAgKSwgdGhpcy50aXAgJiYgdGhpcy50aXAucmVtb3ZlKCksIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50c1wiKTtcbiAgICBpZiAoISh0aGlzLmlzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBjLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XXG4gICAgKSwgZSA9IGZjKHRoaXMuX2VsZW1lbnQpLCBpID0gZSA9PT0gbnVsbCA/IHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy5fZWxlbWVudCkgOiBlLmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICh0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5OQU1FID09PSBcInRvb2x0aXBcIiAmJiB0aGlzLnRpcCAmJiB0aGlzLmdldFRpdGxlKCkgIT09IHRoaXMudGlwLnF1ZXJ5U2VsZWN0b3IoeWEpLmlubmVySFRNTCAmJiAodGhpcy5fZGlzcG9zZVBvcHBlcigpLCB0aGlzLnRpcC5yZW1vdmUoKSwgdGhpcy50aXAgPSBudWxsKTtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIG8gPSBldCh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpO1xuICAgIG4uc2V0QXR0cmlidXRlKFwiaWRcIiwgbyksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCBvKSwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudGlwLmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTEwMFwiKSwgdGhpcy50aXAuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMFwiKTtcbiAgICB9LCAxMDApO1xuICAgIGNvbnN0IHIgPSB0eXBlb2YgdGhpcy5fY29uZmlnLnBsYWNlbWVudCA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgbiwgdGhpcy5fZWxlbWVudCkgOiB0aGlzLl9jb25maWcucGxhY2VtZW50LCBhID0gdGhpcy5fZ2V0QXR0YWNobWVudChyKTtcbiAgICB0aGlzLl9hZGRBdHRhY2htZW50Q2xhc3MoYSk7XG4gICAgY29uc3QgeyBjb250YWluZXI6IGwgfSA9IHRoaXMuX2NvbmZpZztcbiAgICBpZiAoQS5zZXREYXRhKG4sIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpLCB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMudGlwKSB8fCAobC5hcHBlbmQobiksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKSksIHRoaXMuX3BvcHBlciA/IHRoaXMuX3BvcHBlci51cGRhdGUoKSA6IHRoaXMuX3BvcHBlciA9IHNlKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9nZXRQb3BwZXJDb25maWcoYSlcbiAgICApLCBuLmdldEF0dHJpYnV0ZShcImlkXCIpLmluY2x1ZGVzKFwidG9vbHRpcFwiKSlcbiAgICAgIHN3aXRjaCAocikge1xuICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHktWzAuNHJlbV1cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHgtWzAuNHJlbV1cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB4LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB5LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNvbnN0IHUgPSB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MpO1xuICAgIHUgJiYgbi5jbGFzc0xpc3QuYWRkKC4uLnUuc3BsaXQoXCIgXCIpKSwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKGcpID0+IHtcbiAgICAgIGMub24oZywgXCJtb3VzZW92ZXJcIiwgaG4pO1xuICAgIH0pO1xuICAgIGNvbnN0IF8gPSAoKSA9PiB7XG4gICAgICBjb25zdCBnID0gdGhpcy5faG92ZXJTdGF0ZTtcbiAgICAgIHRoaXMuX2hvdmVyU3RhdGUgPSBudWxsLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTiksIGcgPT09IHpuICYmIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xuICAgIH0sIGYgPSB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0cmFuc2l0aW9uLW9wYWNpdHlcIik7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhfLCB0aGlzLnRpcCwgZik7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX3BvcHBlcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkgfHwgKHRoaXMuX2hvdmVyU3RhdGUgIT09IF9pICYmIHQucmVtb3ZlKCksIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURERU4pLCB0aGlzLl9kaXNwb3NlUG9wcGVyKCkpO1xuICAgIH07XG4gICAgaWYgKGMudHJpZ2dlcihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJREVcbiAgICApLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdC5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0wXCIpLCB0LmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTEwMFwiKSwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goKG8pID0+IGMub2ZmKG8sIFwibW91c2VvdmVyXCIsIGhuKSksIHRoaXMuX2FjdGl2ZVRyaWdnZXJbeV9dID0gITEsIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVW5dID0gITEsIHRoaXMuX2FjdGl2ZVRyaWdnZXJbZmldID0gITE7XG4gICAgY29uc3QgbiA9IHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhcIm9wYWNpdHktMFwiKTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMudGlwLCBuKSwgdGhpcy5faG92ZXJTdGF0ZSA9IFwiXCI7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX3BvcHBlciAhPT0gbnVsbCAmJiB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gIH1cbiAgLy8gUHJvdGVjdGVkXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRUaXRsZSgpO1xuICB9XG4gIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMudGlwKVxuICAgICAgcmV0dXJuIHRoaXMudGlwO1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHQuaW5uZXJIVE1MID0gdGhpcy5fY29uZmlnLnRlbXBsYXRlO1xuICAgIGNvbnN0IGUgPSB0LmNoaWxkcmVuWzBdO1xuICAgIHJldHVybiB0aGlzLnNldENvbnRlbnQoZSksIGUuY2xhc3NMaXN0LnJlbW92ZShDXywgS24pLCB0aGlzLnRpcCA9IGUsIHRoaXMudGlwO1xuICB9XG4gIHNldENvbnRlbnQodCkge1xuICAgIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLmdldFRpdGxlKCksIHlhKTtcbiAgfVxuICBfc2FuaXRpemVBbmRTZXRDb250ZW50KHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gZC5maW5kT25lKGksIHQpO1xuICAgIGlmICghZSAmJiBuKSB7XG4gICAgICBuLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KG4sIGUpO1xuICB9XG4gIHNldEVsZW1lbnRDb250ZW50KHQsIGUpIHtcbiAgICBpZiAodCAhPT0gbnVsbCkge1xuICAgICAgaWYgKFhlKGUpKSB7XG4gICAgICAgIGUgPSBlZShlKSwgdGhpcy5fY29uZmlnLmh0bWwgPyBlLnBhcmVudE5vZGUgIT09IHQgJiYgKHQuaW5uZXJIVE1MID0gXCJcIiwgdC5hcHBlbmQoZSkpIDogdC50ZXh0Q29udGVudCA9IGUudGV4dENvbnRlbnQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbmZpZy5odG1sID8gKHRoaXMuX2NvbmZpZy5zYW5pdGl6ZSAmJiAoZSA9IHBuKFxuICAgICAgICBlLFxuICAgICAgICB0aGlzLl9jb25maWcuYWxsb3dMaXN0LFxuICAgICAgICB0aGlzLl9jb25maWcuc2FuaXRpemVGblxuICAgICAgKSksIHQuaW5uZXJIVE1MID0gZSkgOiB0LnRleHRDb250ZW50ID0gZTtcbiAgICB9XG4gIH1cbiAgZ2V0VGl0bGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZS1vcmlnaW5hbC10aXRsZVwiKSB8fCB0aGlzLl9jb25maWcudGl0bGU7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHQpO1xuICB9XG4gIHVwZGF0ZUF0dGFjaG1lbnQodCkge1xuICAgIHJldHVybiB0ID09PSBcInJpZ2h0XCIgPyBcImVuZFwiIDogdCA9PT0gXCJsZWZ0XCIgPyBcInN0YXJ0XCIgOiB0O1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSB7XG4gICAgcmV0dXJuIGUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5nZXRPckNyZWF0ZUluc3RhbmNlKFxuICAgICAgdC5kZWxlZ2F0ZVRhcmdldCxcbiAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcbiAgICApO1xuICB9XG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3QgeyBvZmZzZXQ6IHQgfSA9IHRoaXMuX2NvbmZpZztcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQuc3BsaXQoXCIsXCIpLm1hcCgoZSkgPT4gTnVtYmVyLnBhcnNlSW50KGUsIDEwKSkgOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyAoZSkgPT4gdChlLCB0aGlzLl9lbGVtZW50KSA6IHQ7XG4gIH1cbiAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdC5jYWxsKHRoaXMuX2VsZW1lbnQpIDogdDtcbiAgfVxuICBfZ2V0UG9wcGVyQ29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgcGxhY2VtZW50OiB0LFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImZsaXBcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHRoaXMuX2NvbmZpZy5mYWxsYmFja1BsYWNlbWVudHNcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImFycm93XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZWxlbWVudDogYC4ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXJyb3dgXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvbkNoYW5nZVwiLFxuICAgICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICAgIHBoYXNlOiBcImFmdGVyV3JpdGVcIixcbiAgICAgICAgICBmbjogKGkpID0+IHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShpKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb25GaXJzdFVwZGF0ZTogKGkpID0+IHtcbiAgICAgICAgaS5vcHRpb25zLnBsYWNlbWVudCAhPT0gaS5wbGFjZW1lbnQgJiYgdGhpcy5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGkpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmUsXG4gICAgICAuLi50eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGUpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZ1xuICAgIH07XG4gIH1cbiAgX2FkZEF0dGFjaG1lbnRDbGFzcyh0KSB7XG4gICAgdGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChcbiAgICAgIGAke3RoaXMuX2dldEJhc2ljQ2xhc3NQcmVmaXgoKX0tJHt0aGlzLnVwZGF0ZUF0dGFjaG1lbnQodCl9YFxuICAgICk7XG4gIH1cbiAgX2dldEF0dGFjaG1lbnQodCkge1xuICAgIHJldHVybiB2X1t0LnRvVXBwZXJDYXNlKCldO1xuICB9XG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fY29uZmlnLnRyaWdnZXIuc3BsaXQoXCIgXCIpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGlmIChlID09PSBcImNsaWNrXCIpXG4gICAgICAgIGMub24oXG4gICAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLFxuICAgICAgICAgIHRoaXMuX2NvbmZpZy5zZWxlY3RvcixcbiAgICAgICAgICAoaSkgPT4gdGhpcy50b2dnbGUoaSlcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgaWYgKGUgIT09IHdfKSB7XG4gICAgICAgIGNvbnN0IGkgPSBlID09PSBmaSA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUiA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTiwgbiA9IGUgPT09IGZpID8gdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFIDogdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU09VVDtcbiAgICAgICAgYy5vbihcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgIGksXG4gICAgICAgICAgdGhpcy5fY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgIChvKSA9PiB0aGlzLl9lbnRlcihvKVxuICAgICAgICApLCBjLm9uKFxuICAgICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgbixcbiAgICAgICAgICB0aGlzLl9jb25maWcuc2VsZWN0b3IsXG4gICAgICAgICAgKG8pID0+IHRoaXMuX2xlYXZlKG8pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSksIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50ICYmIHRoaXMuaGlkZSgpO1xuICAgIH0sIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LmNsb3Nlc3Qod2EpLFxuICAgICAga2EsXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyXG4gICAgKSwgdGhpcy5fY29uZmlnLnNlbGVjdG9yID8gdGhpcy5fY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5fY29uZmlnLFxuICAgICAgdHJpZ2dlcjogXCJtYW51YWxcIixcbiAgICAgIHNlbGVjdG9yOiBcIlwiXG4gICAgfSA6IHRoaXMuX2ZpeFRpdGxlKCk7XG4gIH1cbiAgX2ZpeFRpdGxlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcInRpdGxlXCIpLCBlID0gdHlwZW9mIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFxuICAgICAgXCJkYXRhLXRlLW9yaWdpbmFsLXRpdGxlXCJcbiAgICApO1xuICAgICh0IHx8IGUgIT09IFwic3RyaW5nXCIpICYmICh0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtb3JpZ2luYWwtdGl0bGVcIiwgdCB8fCBcIlwiKSwgdCAmJiAhdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpICYmICF0aGlzLl9lbGVtZW50LnRleHRDb250ZW50ICYmIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0KSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBcIlwiKSk7XG4gIH1cbiAgX2VudGVyKHQsIGUpIHtcbiAgICBpZiAoZSA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSwgdCAmJiAoZS5fYWN0aXZlVHJpZ2dlclt0LnR5cGUgPT09IFwiZm9jdXNpblwiID8gVW4gOiBmaV0gPSAhMCksIGUuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhLbikgfHwgZS5faG92ZXJTdGF0ZSA9PT0gX2kpIHtcbiAgICAgIGUuX2hvdmVyU3RhdGUgPSBfaTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNsZWFyVGltZW91dChlLl90aW1lb3V0KSwgZS5faG92ZXJTdGF0ZSA9IF9pLCAhZS5fY29uZmlnLmRlbGF5IHx8ICFlLl9jb25maWcuZGVsYXkuc2hvdykge1xuICAgICAgZS5zaG93KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGUuX2hvdmVyU3RhdGUgPT09IF9pICYmIGUuc2hvdygpO1xuICAgIH0sIGUuX2NvbmZpZy5kZWxheS5zaG93KTtcbiAgfVxuICBfbGVhdmUodCwgZSkge1xuICAgIGlmIChlID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQsIGUpLCB0ICYmIChlLl9hY3RpdmVUcmlnZ2VyW3QudHlwZSA9PT0gXCJmb2N1c291dFwiID8gVW4gOiBmaV0gPSBlLl9lbGVtZW50LmNvbnRhaW5zKHQucmVsYXRlZFRhcmdldCkpLCAhZS5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICBpZiAoY2xlYXJUaW1lb3V0KGUuX3RpbWVvdXQpLCBlLl9ob3ZlclN0YXRlID0gem4sICFlLl9jb25maWcuZGVsYXkgfHwgIWUuX2NvbmZpZy5kZWxheS5oaWRlKSB7XG4gICAgICAgIGUuaGlkZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGUuX2hvdmVyU3RhdGUgPT09IHpuICYmIGUuaGlkZSgpO1xuICAgICAgfSwgZS5fY29uZmlnLmRlbGF5LmhpZGUpO1xuICAgIH1cbiAgfVxuICBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdGhpcy5fYWN0aXZlVHJpZ2dlcilcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUcmlnZ2VyW3RdKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBnXy5oYXMoaSkgJiYgZGVsZXRlIGVbaV07XG4gICAgfSksIHQgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi5lLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgdC5jb250YWluZXIgPSB0LmNvbnRhaW5lciA9PT0gITEgPyBkb2N1bWVudC5ib2R5IDogZWUodC5jb250YWluZXIpLCB0eXBlb2YgdC5kZWxheSA9PSBcIm51bWJlclwiICYmICh0LmRlbGF5ID0ge1xuICAgICAgc2hvdzogdC5kZWxheSxcbiAgICAgIGhpZGU6IHQuZGVsYXlcbiAgICB9KSwgdHlwZW9mIHQudGl0bGUgPT0gXCJudW1iZXJcIiAmJiAodC50aXRsZSA9IHQudGl0bGUudG9TdHJpbmcoKSksIHR5cGVvZiB0LmNvbnRlbnQgPT0gXCJudW1iZXJcIiAmJiAodC5jb250ZW50ID0gdC5jb250ZW50LnRvU3RyaW5nKCkpLCBJKEFhLCB0LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSwgdC5zYW5pdGl6ZSAmJiAodC50ZW1wbGF0ZSA9IHBuKFxuICAgICAgdC50ZW1wbGF0ZSxcbiAgICAgIHQuYWxsb3dMaXN0LFxuICAgICAgdC5zYW5pdGl6ZUZuXG4gICAgKSksIHQ7XG4gIH1cbiAgX2dldERlbGVnYXRlQ29uZmlnKCkge1xuICAgIGNvbnN0IHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5fY29uZmlnKVxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VdICE9PSB0aGlzLl9jb25maWdbZV0gJiYgKHRbZV0gPSB0aGlzLl9jb25maWdbZV0pO1xuICAgIHJldHVybiB0O1xuICB9XG4gIF9jbGVhblRpcENsYXNzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFRpcEVsZW1lbnQoKSwgZSA9IG5ldyBSZWdFeHAoXG4gICAgICBgKF58XFxcXHMpJHt0aGlzLl9nZXRCYXNpY0NsYXNzUHJlZml4KCl9XFxcXFMrYCxcbiAgICAgIFwiZ1wiXG4gICAgKSwgaSA9IHQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikubWF0Y2goZSk7XG4gICAgaSAhPT0gbnVsbCAmJiBpLmxlbmd0aCA+IDAgJiYgaS5tYXAoKG4pID0+IG4udHJpbSgpKS5mb3JFYWNoKChuKSA9PiB0LmNsYXNzTGlzdC5yZW1vdmUobikpO1xuICB9XG4gIF9nZXRCYXNpY0NsYXNzUHJlZml4KCkge1xuICAgIHJldHVybiBtXztcbiAgfVxuICBfaGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHQpIHtcbiAgICBjb25zdCB7IHN0YXRlOiBlIH0gPSB0O1xuICAgIGUgJiYgKHRoaXMudGlwID0gZS5lbGVtZW50cy5wb3BwZXIsIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKSwgdGhpcy5fYWRkQXR0YWNobWVudENsYXNzKHRoaXMuX2dldEF0dGFjaG1lbnQoZS5wbGFjZW1lbnQpKSk7XG4gIH1cbiAgX2Rpc3Bvc2VQb3BwZXIoKSB7XG4gICAgdGhpcy5fcG9wcGVyICYmICh0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9wb3BwZXIgPSBudWxsKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSByaS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3Qga18gPSBcInBvcG92ZXJcIiwgeF8gPSBcInRlLnBvcG92ZXJcIiwgeHQgPSBgLiR7eF99YCwgT18gPSBcInRlLXBvcG92ZXJcIiwgU18gPSB7XG4gIC4uLnJpLkRlZmF1bHQsXG4gIHBsYWNlbWVudDogXCJyaWdodFwiLFxuICBvZmZzZXQ6IFswLCA4XSxcbiAgdHJpZ2dlcjogXCJjbGlja1wiLFxuICBjb250ZW50OiBcIlwiLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJvcGFjaXR5LTAgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBhYnNvbHV0ZSB0b3AtMCBsZWZ0LTAgei1bMTA3MF0gYmxvY2sgbWF4LXctWzI2N3B4XSBicmVhay13b3JkcyBiZy13aGl0ZSBiZy1jbGlwLXBhZGRpbmcgYm9yZGVyIGJvcmRlci1uZXV0cmFsLTEwMCByb3VuZGVkLWxnIHNoYWRvdy1bMF8wcHhfM3B4XzBfcmdiYSgwLDAsMCwwLjA3KSwwXzJweF8ycHhfMF9yZ2JhKDAsMCwwLDAuMDQpXSB0ZXh0LXNtIG5vdC1pdGFsaWMgZm9udC1ub3JtYWwgdGV4dC1sZWZ0IG5vLXVuZGVybGluZSB1bmRlcmxpbmUtb2Zmc2V0LWF1dG8gbm9ybWFsLWNhc2UgbGVhZGluZy02IHRyYWNraW5nLW5vcm1hbCBicmVhay1ub3JtYWwgd2hpdGVzcGFjZS1ub3JtYWwgZGFyazpiZy1uZXV0cmFsLTcwMCBkYXJrOmJvcmRlci0wIGRhcms6dGV4dC13aGl0ZSBkYXRhLVtwb3BwZXItcmVmZXJlbmNlLWhpZGRlbl06aGlkZGVuXCIgcm9sZT1cInRvb2x0aXBcIj48aDMgY2xhc3M9XCJwb3BvdmVyLWhlYWRlciBweS0yIHB4LTQgbWItMCBib3JkZXItYi0yIGJvcmRlci1uZXV0cmFsLTEwMCByb3VuZGVkLXQtbGcgZm9udC1tZWRpdW0gZW1wdHk6aGlkZGVuIGRhcms6Ym9yZGVyLW5ldXRyYWwtNTAwXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5IHAtNCB0ZXh0LVsjMjEyNTI5XSBkYXJrOnRleHQtd2hpdGVcIj48L2Rpdj48L2Rpdj4nXG59LCBJXyA9IHtcbiAgLi4ucmkuRGVmYXVsdFR5cGUsXG4gIGNvbnRlbnQ6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiXG59LCBEXyA9IHtcbiAgSElERTogYGhpZGUke3h0fWAsXG4gIEhJRERFTjogYGhpZGRlbiR7eHR9YCxcbiAgU0hPVzogYHNob3cke3h0fWAsXG4gIFNIT1dOOiBgc2hvd24ke3h0fWAsXG4gIElOU0VSVEVEOiBgaW5zZXJ0ZWQke3h0fWAsXG4gIENMSUNLOiBgY2xpY2ske3h0fWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHt4dH1gLFxuICBGT0NVU09VVDogYGZvY3Vzb3V0JHt4dH1gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7eHR9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke3h0fWBcbn0sICRfID0gXCIucG9wb3Zlci1oZWFkZXJcIiwgTF8gPSBcIi5wb3BvdmVyLWJvZHlcIjtcbmNsYXNzIG5oIGV4dGVuZHMgcmkge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gU187XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBrXztcbiAgfVxuICBzdGF0aWMgZ2V0IEV2ZW50KCkge1xuICAgIHJldHVybiBEXztcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBJXztcbiAgfVxuICAvLyBPdmVycmlkZXNcbiAgaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKTtcbiAgfVxuICBzZXRDb250ZW50KHQpIHtcbiAgICB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgdGhpcy5nZXRUaXRsZSgpLCAkXyksIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLl9nZXRDb250ZW50KCksIExfKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY29udGVudCk7XG4gIH1cbiAgX2dldEJhc2ljQ2xhc3NQcmVmaXgoKSB7XG4gICAgcmV0dXJuIE9fO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IG5oLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBYbiA9IFwic2Nyb2xsc3B5XCIsIE5fID0gXCJ0ZS5zY3JvbGxzcHlcIiwgeXIgPSBgLiR7Tl99YCwgeGEgPSB7XG4gIG9mZnNldDogMTAsXG4gIG1ldGhvZDogXCJhdXRvXCIsXG4gIHRhcmdldDogXCJcIlxufSwgTV8gPSB7XG4gIG9mZnNldDogXCJudW1iZXJcIixcbiAgbWV0aG9kOiBcInN0cmluZ1wiLFxuICB0YXJnZXQ6IFwiKHN0cmluZ3xlbGVtZW50KVwiXG59LCBSXyA9IHtcbiAgYWN0aXZlOiBcIiF0ZXh0LXByaW1hcnkgZGFyazohdGV4dC1wcmltYXJ5LTQwMCBmb250LXNlbWlib2xkIGJvcmRlci1sLVswLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci1wcmltYXJ5IGRhcms6Ym9yZGVyLXByaW1hcnktNDAwXCJcbn0sIFBfID0ge1xuICBhY3RpdmU6IFwic3RyaW5nXCJcbn0sIEJfID0gYGFjdGl2YXRlJHt5cn1gLCBIXyA9IGBzY3JvbGwke3lyfWAsIEduID0gXCJkYXRhLXRlLW5hdi1saW5rLWFjdGl2ZVwiLCBvaCA9IFwiW2RhdGEtdGUtZHJvcGRvd24taXRlbS1yZWZdXCIsIFZfID0gXCJbZGF0YS10ZS1uYXYtbGlzdC1yZWZdXCIsIFVvID0gXCJbZGF0YS10ZS1uYXYtbGluay1yZWZdXCIsIFdfID0gXCJbZGF0YS10ZS1uYXYtaXRlbS1yZWZdXCIsIHJoID0gXCJbZGF0YS10ZS1saXN0LWdyb3VwLWl0ZW0tcmVmXVwiLCBxbiA9IGAke1VvfSwgJHtyaH0sICR7b2h9YCwgRl8gPSBcIltkYXRhLXRlLWRyb3Bkb3duLXJlZl1cIiwgWV8gPSBcIltkYXRhLXRlLWRyb3Bkb3duLXRvZ2dsZS1yZWZdXCIsIGpfID0gXCJtYXhPZmZzZXRcIiwgT2EgPSBcInBvc2l0aW9uXCI7XG5jbGFzcyBhaCBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9zY3JvbGxFbGVtZW50ID0gdGhpcy5fZWxlbWVudC50YWdOYW1lID09PSBcIkJPRFlcIiA/IHdpbmRvdyA6IHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX29mZnNldHMgPSBbXSwgdGhpcy5fdGFyZ2V0cyA9IFtdLCB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsLCB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwLCBjLm9uKHRoaXMuX3Njcm9sbEVsZW1lbnQsIEhfLCAoKSA9PiB0aGlzLl9wcm9jZXNzKCkpLCB0aGlzLnJlZnJlc2goKSwgdGhpcy5fcHJvY2VzcygpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiB4YTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFhuO1xuICB9XG4gIC8vIFB1YmxpY1xuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB0aGlzLl9zY3JvbGxFbGVtZW50LndpbmRvdyA/IGpfIDogT2EsIGUgPSB0aGlzLl9jb25maWcubWV0aG9kID09PSBcImF1dG9cIiA/IHQgOiB0aGlzLl9jb25maWcubWV0aG9kLCBpID0gZSA9PT0gT2EgPyB0aGlzLl9nZXRTY3JvbGxUb3AoKSA6IDA7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IFtdLCB0aGlzLl90YXJnZXRzID0gW10sIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpLCBkLmZpbmQoXG4gICAgICBxbixcbiAgICAgIHRoaXMuX2NvbmZpZy50YXJnZXRcbiAgICApLm1hcCgobykgPT4ge1xuICAgICAgY29uc3QgciA9IGxyKG8pLCBhID0gciA/IGQuZmluZE9uZShyKSA6IG51bGw7XG4gICAgICBpZiAoYSkge1xuICAgICAgICBjb25zdCBsID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGwud2lkdGggfHwgbC5oZWlnaHQpXG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGhbZV0oYSkudG9wICsgaSxcbiAgICAgICAgICAgIHJcbiAgICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZmlsdGVyKChvKSA9PiBvKS5zb3J0KChvLCByKSA9PiBvWzBdIC0gclswXSkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgdGhpcy5fb2Zmc2V0cy5wdXNoKG9bMF0pLCB0aGlzLl90YXJnZXRzLnB1c2gob1sxXSk7XG4gICAgfSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZih0aGlzLl9zY3JvbGxFbGVtZW50LCB5ciksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ueGEsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgdC50YXJnZXQgPSBlZSh0LnRhcmdldCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBJKFhuLCB0LCBNXyksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5SXyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgSShYbiwgdCwgUF8pLCB0O1xuICB9XG4gIF9nZXRTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/IHRoaXMuX3Njcm9sbEVsZW1lbnQucGFnZVlPZmZzZXQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuICBfZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChcbiAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LFxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICk7XG4gIH1cbiAgX2dldE9mZnNldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gd2luZG93LmlubmVySGVpZ2h0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gIH1cbiAgX3Byb2Nlc3MoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldFNjcm9sbFRvcCgpICsgdGhpcy5fY29uZmlnLm9mZnNldCwgZSA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpLCBpID0gdGhpcy5fY29uZmlnLm9mZnNldCArIGUgLSB0aGlzLl9nZXRPZmZzZXRIZWlnaHQoKTtcbiAgICBpZiAodGhpcy5fc2Nyb2xsSGVpZ2h0ICE9PSBlICYmIHRoaXMucmVmcmVzaCgpLCB0ID49IGkpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoIC0gMV07XG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IG4gJiYgdGhpcy5fYWN0aXZhdGUobik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgJiYgdCA8IHRoaXMuX29mZnNldHNbMF0gJiYgdGhpcy5fb2Zmc2V0c1swXSA+IDApIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGwsIHRoaXMuX2NsZWFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IG4gPSB0aGlzLl9vZmZzZXRzLmxlbmd0aDsgbi0tOyApXG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbbl0gJiYgdCA+PSB0aGlzLl9vZmZzZXRzW25dICYmICh0eXBlb2YgdGhpcy5fb2Zmc2V0c1tuICsgMV0gPiBcInVcIiB8fCB0IDwgdGhpcy5fb2Zmc2V0c1tuICsgMV0pICYmIHRoaXMuX2FjdGl2YXRlKHRoaXMuX3RhcmdldHNbbl0pO1xuICB9XG4gIF9hY3RpdmF0ZSh0KSB7XG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdCwgdGhpcy5fY2xlYXIoKTtcbiAgICBjb25zdCBlID0gcW4uc3BsaXQoXCIsXCIpLm1hcChcbiAgICAgIChuKSA9PiBgJHtufVtkYXRhLXRlLXRhcmdldD1cIiR7dH1cIl0sJHtufVtocmVmPVwiJHt0fVwiXWBcbiAgICApLCBpID0gZC5maW5kT25lKGUuam9pbihcIixcIiksIHRoaXMuX2NvbmZpZy50YXJnZXQpO1xuICAgIGkuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCBpLnNldEF0dHJpYnV0ZShHbiwgXCJcIiksIGkuZ2V0QXR0cmlidXRlKG9oKSA/IGQuZmluZE9uZShcbiAgICAgIFlfLFxuICAgICAgaS5jbG9zZXN0KEZfKVxuICAgICkuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpIDogZC5wYXJlbnRzKGksIFZfKS5mb3JFYWNoKFxuICAgICAgKG4pID0+IHtcbiAgICAgICAgZC5wcmV2KFxuICAgICAgICAgIG4sXG4gICAgICAgICAgYCR7VW99LCAke3JofWBcbiAgICAgICAgKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgICAgby5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSksIG8uc2V0QXR0cmlidXRlKEduLCBcIlwiKTtcbiAgICAgICAgfSksIGQucHJldihuLCBXXykuZm9yRWFjaChcbiAgICAgICAgICAobykgPT4ge1xuICAgICAgICAgICAgZC5jaGlsZHJlbihvLCBVbykuZm9yRWFjaChcbiAgICAgICAgICAgICAgKHIpID0+IHIuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApLCBjLnRyaWdnZXIodGhpcy5fc2Nyb2xsRWxlbWVudCwgQl8sIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICB9KTtcbiAgfVxuICBfY2xlYXIoKSB7XG4gICAgZC5maW5kKHFuLCB0aGlzLl9jb25maWcudGFyZ2V0KS5maWx0ZXIoXG4gICAgICAodCkgPT4gdC5jbGFzc0xpc3QuY29udGFpbnMoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKVxuICAgICkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdC5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSksIHQucmVtb3ZlQXR0cmlidXRlKEduKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBhaC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgU2EgPSBcInRhYlwiLCBLXyA9IFwidGUudGFiXCIsIFRuID0gYC4ke0tffWAsIHpfID0gYGhpZGUke1RufWAsIFVfID0gYGhpZGRlbiR7VG59YCwgWF8gPSBgc2hvdyR7VG59YCwgR18gPSBgc2hvd24ke1RufWAsIHFfID0gXCJkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXCIsIEhlID0gXCJkYXRhLXRlLXRhYi1hY3RpdmVcIiwgS3MgPSBcImRhdGEtdGUtbmF2LWFjdGl2ZVwiLCBaXyA9IFwiW2RhdGEtdGUtZHJvcGRvd24tcmVmXVwiLCBRXyA9IFwiW2RhdGEtdGUtbmF2LXJlZl1cIiwgSWEgPSBgWyR7SGV9XWAsIEpfID0gYFske0tzfV1gLCBEYSA9IFwiOnNjb3BlID4gbGkgPiAuYWN0aXZlXCIsIHRmID0gXCJbZGF0YS10ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBlZiA9IFwiOnNjb3BlID4gW2RhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZdIFtkYXRhLXRlLWRyb3Bkb3duLXNob3ddXCIsIHNmID0ge1xuICBzaG93OiBcIm9wYWNpdHktMTAwXCIsXG4gIGhpZGU6IFwib3BhY2l0eS0wXCJcbn0sIG5mID0ge1xuICBzaG93OiBcInN0cmluZ1wiLFxuICBoaWRlOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgbGggZXh0ZW5kcyBmdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoZSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFNhO1xuICB9XG4gIC8vIFB1YmxpY1xuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgJiYgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShLcykgPT09IFwiXCIpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHQ7XG4gICAgY29uc3QgZSA9IHRlKHRoaXMuX2VsZW1lbnQpLCBpID0gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFFfKSwgbiA9IGQuZmluZE9uZShcbiAgICAgIEpfLFxuICAgICAgaVxuICAgICk7XG4gICAgaWYgKGkpIHtcbiAgICAgIGNvbnN0IGwgPSBpLm5vZGVOYW1lID09PSBcIlVMXCIgfHwgaS5ub2RlTmFtZSA9PT0gXCJPTFwiID8gRGEgOiBJYTtcbiAgICAgIHQgPSBkLmZpbmQobCwgaSksIHQgPSB0W3QubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNvbnN0IG8gPSB0ID8gYy50cmlnZ2VyKHQsIHpfLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfSkgOiBudWxsO1xuICAgIGlmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWF8sIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkIHx8IG8gIT09IG51bGwgJiYgby5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2FjdGl2YXRlKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGksXG4gICAgICBudWxsLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIGNvbnN0IGEgPSAoKSA9PiB7XG4gICAgICBjLnRyaWdnZXIodCwgVV8sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgfSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBHXywge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGUgPyB0aGlzLl9hY3RpdmF0ZShcbiAgICAgIGUsXG4gICAgICBlLnBhcmVudE5vZGUsXG4gICAgICBhLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApIDogYSgpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5zZixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgSShTYSwgdCwgbmYpLCB0O1xuICB9XG4gIF9hY3RpdmF0ZSh0LCBlLCBpLCBuLCBvKSB7XG4gICAgY29uc3QgYSA9IChlICYmIChlLm5vZGVOYW1lID09PSBcIlVMXCIgfHwgZS5ub2RlTmFtZSA9PT0gXCJPTFwiKSA/IGQuZmluZChEYSwgZSkgOiBkLmNoaWxkcmVuKGUsIElhKSlbMF0sIGwgPSBpICYmIGEgJiYgYS5oYXNBdHRyaWJ1dGUoSGUpLCBwID0gKCkgPT4gdGhpcy5fdHJhbnNpdGlvbkNvbXBsZXRlKFxuICAgICAgdCxcbiAgICAgIGEsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIG9cbiAgICApO1xuICAgIGEgJiYgbCA/IChoLnJlbW92ZUNsYXNzKGEsIHRoaXMuX2NsYXNzZXMuc2hvdyksIGguYWRkQ2xhc3MoYSwgdGhpcy5fY2xhc3Nlcy5oaWRlKSwgdGhpcy5fcXVldWVDYWxsYmFjayhwLCB0LCAhMCkpIDogcCgpO1xuICB9XG4gIF90cmFuc2l0aW9uQ29tcGxldGUodCwgZSwgaSwgbiwgbykge1xuICAgIGlmIChlICYmIG4pIHtcbiAgICAgIGUucmVtb3ZlQXR0cmlidXRlKEhlKSwgbi5yZW1vdmVBdHRyaWJ1dGUoS3MpO1xuICAgICAgY29uc3QgYSA9IGQuZmluZE9uZShcbiAgICAgICAgZWYsXG4gICAgICAgIGUucGFyZW50Tm9kZVxuICAgICAgKTtcbiAgICAgIGEgJiYgYS5yZW1vdmVBdHRyaWJ1dGUoSGUpLCBlLmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwidGFiXCIgJiYgZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICExKTtcbiAgICB9XG4gICAgdC5zZXRBdHRyaWJ1dGUoSGUsIFwiXCIpLCBvLnNldEF0dHJpYnV0ZShLcywgXCJcIiksIHQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PT0gXCJ0YWJcIiAmJiB0LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgITApLCBzaSh0KSwgdC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5fY2xhc3Nlcy5oaWRlKSAmJiAoaC5yZW1vdmVDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLmhpZGUpLCBoLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMuc2hvdykpO1xuICAgIGxldCByID0gdC5wYXJlbnROb2RlO1xuICAgIGlmIChyICYmIHIubm9kZU5hbWUgPT09IFwiTElcIiAmJiAociA9IHIucGFyZW50Tm9kZSksIHIgJiYgci5oYXNBdHRyaWJ1dGUocV8pKSB7XG4gICAgICBjb25zdCBhID0gdC5jbG9zZXN0KFpfKTtcbiAgICAgIGEgJiYgZC5maW5kKHRmLCBhKS5mb3JFYWNoKFxuICAgICAgICAobCkgPT4gbC5zZXRBdHRyaWJ1dGUoSGUsIFwiXCIpXG4gICAgICApLCB0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgITApO1xuICAgIH1cbiAgICBpICYmIGkoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBsaC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgWm4gPSBcInRvYXN0XCIsIG9mID0gXCJ0ZS50b2FzdFwiLCBuZSA9IGAuJHtvZn1gLCByZiA9IGBtb3VzZW92ZXIke25lfWAsIGFmID0gYG1vdXNlb3V0JHtuZX1gLCBsZiA9IGBmb2N1c2luJHtuZX1gLCBjZiA9IGBmb2N1c291dCR7bmV9YCwgaGYgPSBgaGlkZSR7bmV9YCwgZGYgPSBgaGlkZGVuJHtuZX1gLCB1ZiA9IGBzaG93JHtuZX1gLCBwZiA9IGBzaG93biR7bmV9YCwgJGEgPSBcImRhdGEtdGUtdG9hc3QtaGlkZVwiLCBRbiA9IFwiZGF0YS10ZS10b2FzdC1zaG93XCIsIGFzID0gXCJkYXRhLXRlLXRvYXN0LXNob3dpbmdcIiwgX2YgPSB7XG4gIGFuaW1hdGlvbjogXCJib29sZWFuXCIsXG4gIGF1dG9oaWRlOiBcImJvb2xlYW5cIixcbiAgZGVsYXk6IFwibnVtYmVyXCJcbn0sIExhID0ge1xuICBhbmltYXRpb246ICEwLFxuICBhdXRvaGlkZTogITAsXG4gIGRlbGF5OiA1ZTNcbn0sIGZmID0ge1xuICBmYWRlSW46IFwiYW5pbWF0ZS1bZmFkZS1pbl8wLjNzX2JvdGhdIHAtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsXG4gIGZhZGVPdXQ6IFwiYW5pbWF0ZS1bZmFkZS1vdXRfMC4zc19ib3RoXSBwLVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiXG59LCBtZiA9IHtcbiAgZmFkZUluOiBcInN0cmluZ1wiLFxuICBmYWRlT3V0OiBcInN0cmluZ1wiXG59O1xuY2xhc3MgWG8gZXh0ZW5kcyBmdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fdGltZW91dCA9IG51bGwsIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSAhMSwgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9ICExLCB0aGlzLl9zZXRMaXN0ZW5lcnMoKSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBfZjtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIExhO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gWm47XG4gIH1cbiAgLy8gUHVibGljXG4gIHNob3coKSB7XG4gICAgaWYgKGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB1ZikuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKSwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiAoaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSk7XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGFzKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHBmKSwgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgICB9O1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCRhKSwgc2kodGhpcy5fZWxlbWVudCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFFuLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXMsIFwiXCIpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50IHx8IHRoaXMuX2VsZW1lbnQuZGF0YXNldC50ZVRvYXN0U2hvdyA9PT0gdm9pZCAwIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBoZikuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gKCkgPT4ge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiAoaSA9IDMwMCwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVJbiksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgkYSwgXCJcIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGFzKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoUW4pLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZGYpO1xuICAgICAgfSwgaSk7XG4gICAgfTtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShhcywgXCJcIiksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKSwgdGhpcy5fZWxlbWVudC5kYXRhc2V0LnRlVG9hc3RTaG93ICE9PSB2b2lkIDAgJiYgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoUW4pLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8ICh2bihYbyksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5MYSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgPyB0IDoge31cbiAgICB9LCBJKFpuLCB0LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmZmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKFpuLCB0LCBtZiksIHQ7XG4gIH1cbiAgX21heWJlU2NoZWR1bGVIaWRlKCkge1xuICAgIHRoaXMuX2NvbmZpZy5hdXRvaGlkZSAmJiAodGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiB8fCB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uIHx8ICh0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpKSk7XG4gIH1cbiAgX29uSW50ZXJhY3Rpb24odCwgZSkge1xuICAgIHN3aXRjaCAodC50eXBlKSB7XG4gICAgICBjYXNlIFwibW91c2VvdmVyXCI6XG4gICAgICBjYXNlIFwibW91c2VvdXRcIjpcbiAgICAgICAgdGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiA9IGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZvY3VzaW5cIjpcbiAgICAgIGNhc2UgXCJmb2N1c291dFwiOlxuICAgICAgICB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChlKSB7XG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaSA9IHQucmVsYXRlZFRhcmdldDtcbiAgICB0aGlzLl9lbGVtZW50ID09PSBpIHx8IHRoaXMuX2VsZW1lbnQuY29udGFpbnMoaSkgfHwgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgfVxuICBfc2V0TGlzdGVuZXJzKCkge1xuICAgIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgcmYsXG4gICAgICAodCkgPT4gdGhpcy5fb25JbnRlcmFjdGlvbih0LCAhMClcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGFmLFxuICAgICAgKHQpID0+IHRoaXMuX29uSW50ZXJhY3Rpb24odCwgITEpXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBsZixcbiAgICAgICh0KSA9PiB0aGlzLl9vbkludGVyYWN0aW9uKHQsICEwKVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgY2YsXG4gICAgICAodCkgPT4gdGhpcy5fb25JbnRlcmFjdGlvbih0LCAhMSlcbiAgICApO1xuICB9XG4gIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpLCB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBYby5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbigoKSA9PiB7XG4gIHZhciBzID0geyA0NTQ6IChpLCBuLCBvKSA9PiB7XG4gICAgby5kKG4sIHsgWjogKCkgPT4gbCB9KTtcbiAgICB2YXIgciA9IG8oNjQ1KSwgYSA9IG8ubihyKSgpKGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBwWzFdO1xuICAgIH0pO1xuICAgIGEucHVzaChbaS5pZCwgXCJJTlBVVDotd2Via2l0LWF1dG9maWxsLFNFTEVDVDotd2Via2l0LWF1dG9maWxsLFRFWFRBUkVBOi13ZWJraXQtYXV0b2ZpbGx7YW5pbWF0aW9uLW5hbWU6b25hdXRvZmlsbHN0YXJ0fUlOUFVUOm5vdCg6LXdlYmtpdC1hdXRvZmlsbCksU0VMRUNUOm5vdCg6LXdlYmtpdC1hdXRvZmlsbCksVEVYVEFSRUE6bm90KDotd2Via2l0LWF1dG9maWxsKXthbmltYXRpb24tbmFtZTpvbmF1dG9maWxsY2FuY2VsfUBrZXlmcmFtZXMgb25hdXRvZmlsbHN0YXJ0e31Aa2V5ZnJhbWVzIG9uYXV0b2ZpbGxjYW5jZWx7fVwiLCBcIlwiXSk7XG4gICAgY29uc3QgbCA9IGE7XG4gIH0sIDY0NTogKGkpID0+IHtcbiAgICBpLmV4cG9ydHMgPSBmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgbyA9IFtdO1xuICAgICAgcmV0dXJuIG8udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICB2YXIgYSA9IG4ocik7XG4gICAgICAgICAgcmV0dXJuIHJbMl0gPyBcIkBtZWRpYSBcIi5jb25jYXQoclsyXSwgXCIge1wiKS5jb25jYXQoYSwgXCJ9XCIpIDogYTtcbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgIH0sIG8uaSA9IGZ1bmN0aW9uKHIsIGEsIGwpIHtcbiAgICAgICAgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiAmJiAociA9IFtbbnVsbCwgciwgXCJcIl1dKTtcbiAgICAgICAgdmFyIHAgPSB7fTtcbiAgICAgICAgaWYgKGwpXG4gICAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCB0aGlzLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHRoaXNbdV1bMF07XG4gICAgICAgICAgICBfICE9IG51bGwgJiYgKHBbX10gPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBmID0gMDsgZiA8IHIubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICB2YXIgZyA9IFtdLmNvbmNhdChyW2ZdKTtcbiAgICAgICAgICBsICYmIHBbZ1swXV0gfHwgKGEgJiYgKGdbMl0gPyBnWzJdID0gXCJcIi5jb25jYXQoYSwgXCIgYW5kIFwiKS5jb25jYXQoZ1syXSkgOiBnWzJdID0gYSksIG8ucHVzaChnKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIG87XG4gICAgfTtcbiAgfSwgODEwOiAoKSA9PiB7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIilcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgaSA9IG5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoXCJ0ZXN0XCIsIHsgY2FuY2VsYWJsZTogITAgfSk7XG4gICAgICAgICAgaWYgKGkucHJldmVudERlZmF1bHQoKSwgaS5kZWZhdWx0UHJldmVudGVkICE9PSAhMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwcmV2ZW50IGRlZmF1bHRcIik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHZhciBuID0gZnVuY3Rpb24ociwgYSkge1xuICAgICAgICAgICAgdmFyIGwsIHA7XG4gICAgICAgICAgICByZXR1cm4gKGEgPSBhIHx8IHt9KS5idWJibGVzID0gISFhLmJ1YmJsZXMsIGEuY2FuY2VsYWJsZSA9ICEhYS5jYW5jZWxhYmxlLCAobCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIikpLmluaXRDdXN0b21FdmVudChyLCBhLmJ1YmJsZXMsIGEuY2FuY2VsYWJsZSwgYS5kZXRhaWwpLCBwID0gbC5wcmV2ZW50RGVmYXVsdCwgbC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBwLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdFByZXZlbnRlZFwiLCB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gITA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBuLnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGUsIHdpbmRvdy5DdXN0b21FdmVudCA9IG47XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICB9LCAzNzk6IChpLCBuLCBvKSA9PiB7XG4gICAgdmFyIHIsIGEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBDID0ge307XG4gICAgICByZXR1cm4gZnVuY3Rpb24oRSkge1xuICAgICAgICBpZiAoQ1tFXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIHcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKEUpO1xuICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgdyBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHcgPSB3LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIENbRV0gPSB3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDW0VdO1xuICAgICAgfTtcbiAgICB9KCksIGwgPSBbXTtcbiAgICBmdW5jdGlvbiBwKEMpIHtcbiAgICAgIGZvciAodmFyIEUgPSAtMSwgdyA9IDA7IHcgPCBsLmxlbmd0aDsgdysrKVxuICAgICAgICBpZiAobFt3XS5pZGVudGlmaWVyID09PSBDKSB7XG4gICAgICAgICAgRSA9IHc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBFO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1KEMsIEUpIHtcbiAgICAgIGZvciAodmFyIHcgPSB7fSwgayA9IFtdLCBEID0gMDsgRCA8IEMubGVuZ3RoOyBEKyspIHtcbiAgICAgICAgdmFyIE8gPSBDW0RdLCB4ID0gRS5iYXNlID8gT1swXSArIEUuYmFzZSA6IE9bMF0sIEwgPSB3W3hdIHx8IDAsIFMgPSBcIlwiLmNvbmNhdCh4LCBcIiBcIikuY29uY2F0KEwpO1xuICAgICAgICB3W3hdID0gTCArIDE7XG4gICAgICAgIHZhciBOID0gcChTKSwgUCA9IHsgY3NzOiBPWzFdLCBtZWRpYTogT1syXSwgc291cmNlTWFwOiBPWzNdIH07XG4gICAgICAgIE4gIT09IC0xID8gKGxbTl0ucmVmZXJlbmNlcysrLCBsW05dLnVwZGF0ZXIoUCkpIDogbC5wdXNoKHsgaWRlbnRpZmllcjogUywgdXBkYXRlcjogeShQLCBFKSwgcmVmZXJlbmNlczogMSB9KSwgay5wdXNoKFMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGs7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF8oQykge1xuICAgICAgdmFyIEUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiksIHcgPSBDLmF0dHJpYnV0ZXMgfHwge307XG4gICAgICBpZiAody5ub25jZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBrID0gby5uYztcbiAgICAgICAgayAmJiAody5ub25jZSA9IGspO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHcpLmZvckVhY2goZnVuY3Rpb24oTykge1xuICAgICAgICBFLnNldEF0dHJpYnV0ZShPLCB3W09dKTtcbiAgICAgIH0pLCB0eXBlb2YgQy5pbnNlcnQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBDLmluc2VydChFKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgRCA9IGEoQy5pbnNlcnQgfHwgXCJoZWFkXCIpO1xuICAgICAgICBpZiAoIUQpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgRC5hcHBlbmRDaGlsZChFKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFO1xuICAgIH1cbiAgICB2YXIgZiwgZyA9IChmID0gW10sIGZ1bmN0aW9uKEMsIEUpIHtcbiAgICAgIHJldHVybiBmW0NdID0gRSwgZi5maWx0ZXIoQm9vbGVhbikuam9pbihgXG5gKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBtKEMsIEUsIHcsIGspIHtcbiAgICAgIHZhciBEID0gdyA/IFwiXCIgOiBrLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KGsubWVkaWEsIFwiIHtcIikuY29uY2F0KGsuY3NzLCBcIn1cIikgOiBrLmNzcztcbiAgICAgIGlmIChDLnN0eWxlU2hlZXQpXG4gICAgICAgIEMuc3R5bGVTaGVldC5jc3NUZXh0ID0gZyhFLCBEKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgTyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKEQpLCB4ID0gQy5jaGlsZE5vZGVzO1xuICAgICAgICB4W0VdICYmIEMucmVtb3ZlQ2hpbGQoeFtFXSksIHgubGVuZ3RoID8gQy5pbnNlcnRCZWZvcmUoTywgeFtFXSkgOiBDLmFwcGVuZENoaWxkKE8pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBiKEMsIEUsIHcpIHtcbiAgICAgIHZhciBrID0gdy5jc3MsIEQgPSB3Lm1lZGlhLCBPID0gdy5zb3VyY2VNYXA7XG4gICAgICBpZiAoRCA/IEMuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgRCkgOiBDLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpLCBPICYmIHR5cGVvZiBidG9hIDwgXCJ1XCIgJiYgKGsgKz0gYFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxgLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShPKSkpKSwgXCIgKi9cIikpLCBDLnN0eWxlU2hlZXQpXG4gICAgICAgIEMuc3R5bGVTaGVldC5jc3NUZXh0ID0gaztcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKDsgQy5maXJzdENoaWxkOyApXG4gICAgICAgICAgQy5yZW1vdmVDaGlsZChDLmZpcnN0Q2hpbGQpO1xuICAgICAgICBDLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGspKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHYgPSBudWxsLCBUID0gMDtcbiAgICBmdW5jdGlvbiB5KEMsIEUpIHtcbiAgICAgIHZhciB3LCBrLCBEO1xuICAgICAgaWYgKEUuc2luZ2xldG9uKSB7XG4gICAgICAgIHZhciBPID0gVCsrO1xuICAgICAgICB3ID0gdiB8fCAodiA9IF8oRSkpLCBrID0gbS5iaW5kKG51bGwsIHcsIE8sICExKSwgRCA9IG0uYmluZChudWxsLCB3LCBPLCAhMCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdyA9IF8oRSksIGsgPSBiLmJpbmQobnVsbCwgdywgRSksIEQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAoZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgaWYgKHgucGFyZW50Tm9kZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgeC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHgpO1xuICAgICAgICAgIH0pKHcpO1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIGsoQyksIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICBpZiAoeC5jc3MgPT09IEMuY3NzICYmIHgubWVkaWEgPT09IEMubWVkaWEgJiYgeC5zb3VyY2VNYXAgPT09IEMuc291cmNlTWFwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGsoQyA9IHgpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBEKCk7XG4gICAgICB9O1xuICAgIH1cbiAgICBpLmV4cG9ydHMgPSBmdW5jdGlvbihDLCBFKSB7XG4gICAgICAoRSA9IEUgfHwge30pLnNpbmdsZXRvbiB8fCB0eXBlb2YgRS5zaW5nbGV0b24gPT0gXCJib29sZWFuXCIgfHwgKEUuc2luZ2xldG9uID0gKHIgPT09IHZvaWQgMCAmJiAociA9ICEhKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKSksIHIpKTtcbiAgICAgIHZhciB3ID0gdShDID0gQyB8fCBbXSwgRSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oaykge1xuICAgICAgICBpZiAoayA9IGsgfHwgW10sIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChrKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgZm9yICh2YXIgRCA9IDA7IEQgPCB3Lmxlbmd0aDsgRCsrKSB7XG4gICAgICAgICAgICB2YXIgTyA9IHAod1tEXSk7XG4gICAgICAgICAgICBsW09dLnJlZmVyZW5jZXMtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgeCA9IHUoaywgRSksIEwgPSAwOyBMIDwgdy5sZW5ndGg7IEwrKykge1xuICAgICAgICAgICAgdmFyIFMgPSBwKHdbTF0pO1xuICAgICAgICAgICAgbFtTXS5yZWZlcmVuY2VzID09PSAwICYmIChsW1NdLnVwZGF0ZXIoKSwgbC5zcGxpY2UoUywgMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3ID0geDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9IH0sIHQgPSB7fTtcbiAgZnVuY3Rpb24gZShpKSB7XG4gICAgdmFyIG4gPSB0W2ldO1xuICAgIGlmIChuICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gbi5leHBvcnRzO1xuICAgIHZhciBvID0gdFtpXSA9IHsgaWQ6IGksIGV4cG9ydHM6IHt9IH07XG4gICAgcmV0dXJuIHNbaV0obywgby5leHBvcnRzLCBlKSwgby5leHBvcnRzO1xuICB9XG4gIGUubiA9IChpKSA9PiB7XG4gICAgdmFyIG4gPSBpICYmIGkuX19lc01vZHVsZSA/ICgpID0+IGkuZGVmYXVsdCA6ICgpID0+IGk7XG4gICAgcmV0dXJuIGUuZChuLCB7IGE6IG4gfSksIG47XG4gIH0sIGUuZCA9IChpLCBuKSA9PiB7XG4gICAgZm9yICh2YXIgbyBpbiBuKVxuICAgICAgZS5vKG4sIG8pICYmICFlLm8oaSwgbykgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIG8sIHsgZW51bWVyYWJsZTogITAsIGdldDogbltvXSB9KTtcbiAgfSwgZS5vID0gKGksIG4pID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLCBuKSwgKCgpID0+IHtcbiAgICB2YXIgaSA9IGUoMzc5KSwgbiA9IGUubihpKSwgbyA9IGUoNDU0KTtcbiAgICBmdW5jdGlvbiByKGwpIHtcbiAgICAgIGlmICghbC5oYXNBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIpKSB7XG4gICAgICAgIGwuc2V0QXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiLCBcIlwiKTtcbiAgICAgICAgdmFyIHAgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwib25hdXRvY29tcGxldGVcIiwgeyBidWJibGVzOiAhMCwgY2FuY2VsYWJsZTogITAsIGRldGFpbDogbnVsbCB9KTtcbiAgICAgICAgbC5kaXNwYXRjaEV2ZW50KHApIHx8IChsLnZhbHVlID0gXCJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEobCkge1xuICAgICAgbC5oYXNBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIpICYmIChsLnJlbW92ZUF0dHJpYnV0ZShcImF1dG9jb21wbGV0ZWRcIiksIGwuZGlzcGF0Y2hFdmVudChuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwib25hdXRvY29tcGxldGVcIiwgeyBidWJibGVzOiAhMCwgY2FuY2VsYWJsZTogITEsIGRldGFpbDogbnVsbCB9KSkpO1xuICAgIH1cbiAgICBuKCkoby5aLCB7IGluc2VydDogXCJoZWFkXCIsIHNpbmdsZXRvbjogITEgfSksIG8uWi5sb2NhbHMsIGUoODEwKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uKGwpIHtcbiAgICAgIGwuYW5pbWF0aW9uTmFtZSA9PT0gXCJvbmF1dG9maWxsc3RhcnRcIiA/IHIobC50YXJnZXQpIDogYShsLnRhcmdldCk7XG4gICAgfSwgITApLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZnVuY3Rpb24obCkge1xuICAgICAgbC5pbnB1dFR5cGUgIT09IFwiaW5zZXJ0UmVwbGFjZW1lbnRUZXh0XCIgJiYgXCJkYXRhXCIgaW4gbCA/IGEobC50YXJnZXQpIDogcihsLnRhcmdldCk7XG4gICAgfSwgITApO1xuICB9KSgpO1xufSkoKTtcbmNvbnN0IEpuID0gXCJpbnB1dFwiLCBscyA9IFwidGUuaW5wdXRcIiwgY2ggPSBcImRhdGEtdGUtaW5wdXQtd3JhcHBlci1pbml0XCIsIGhoID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLXJlZlwiLCBkaCA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1sZWFkaW5nLXJlZlwiLCB1aCA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1taWRkbGUtcmVmXCIsIGdmID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLXRyYWlsaW5nLXJlZlwiLCBiZiA9IFwiZGF0YS10ZS1pbnB1dC1oZWxwZXItcmVmXCIsIHZmID0gXCJkYXRhLXRlLWlucHV0LXBsYWNlaG9sZGVyLWFjdGl2ZVwiLCBZdCA9IFwiZGF0YS10ZS1pbnB1dC1zdGF0ZS1hY3RpdmVcIiwgTmEgPSBcImRhdGEtdGUtaW5wdXQtZm9jdXNlZFwiLCBNYSA9IFwiZGF0YS10ZS1pbnB1dC1mb3JtLWNvdW50ZXJcIiwgY3MgPSBgWyR7Y2h9XSBpbnB1dGAsIGhzID0gYFske2NofV0gdGV4dGFyZWFgLCBJZSA9IGBbJHtoaH1dYCwgUmEgPSBgWyR7ZGh9XWAsIFBhID0gYFske3VofV1gLCBUZiA9IGBbJHtiZn1dYCwgRWYgPSB7XG4gIGlucHV0Rm9ybVdoaXRlOiAhMVxufSwgQ2YgPSB7XG4gIGlucHV0Rm9ybVdoaXRlOiBcIihib29sZWFuKVwiXG59LCBwaCA9IHtcbiAgbm90Y2g6IFwiZ3JvdXAgZmxleCBhYnNvbHV0ZSBsZWZ0LTAgdG9wLTAgdy1mdWxsIG1heC13LWZ1bGwgaC1mdWxsIHRleHQtbGVmdCBwb2ludGVyLWV2ZW50cy1ub25lXCIsXG4gIG5vdGNoTGVhZGluZzogXCJwb2ludGVyLWV2ZW50cy1ub25lIGJvcmRlciBib3JkZXItc29saWQgYm94LWJvcmRlciBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbGVmdC0wIHRvcC0wIGgtZnVsbCB3LTIgYm9yZGVyLXItMCByb3VuZGVkLWwtWzAuMjVyZW1dIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1yLTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItci0wXCIsXG4gIG5vdGNoTGVhZGluZ05vcm1hbDogXCJib3JkZXItbmV1dHJhbC0zMDAgZGFyazpib3JkZXItbmV1dHJhbC02MDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVstMXB4XzBfMF8jM2I3MWNhLF8wXzFweF8wXzBfIzNiNzFjYSxfMF8tMXB4XzBfMF8jM2I3MWNhXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiLFxuICBub3RjaExlYWRpbmdXaGl0ZTogXCJib3JkZXItbmV1dHJhbC0yMDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVstMXB4XzBfMF8jZmZmZmZmLF8wXzFweF8wXzBfI2ZmZmZmZixfMF8tMXB4XzBfMF8jZmZmZmZmXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItd2hpdGVcIixcbiAgbm90Y2hNaWRkbGU6IFwicG9pbnRlci1ldmVudHMtbm9uZSBib3JkZXIgYm9yZGVyLXNvbGlkIGJveC1ib3JkZXIgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGdyb3ctMCBzaHJpbmstMCBiYXNpcy1hdXRvIHctYXV0byBtYXgtdy1bY2FsYygxMDAlLTFyZW0pXSBoLWZ1bGwgYm9yZGVyLXItMCBib3JkZXItbC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci14LTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXIteC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci10IGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXQgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXNvbGlkIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXNvbGlkIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci10LXRyYW5zcGFyZW50IGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXQtdHJhbnNwYXJlbnRcIixcbiAgbm90Y2hNaWRkbGVOb3JtYWw6IFwiYm9yZGVyLW5ldXRyYWwtMzAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMF8xcHhfMF8wXyMzYjcxY2FdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1wcmltYXJ5XCIsXG4gIG5vdGNoTWlkZGxlV2hpdGU6IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMF8xcHhfMF8wXyNmZmZmZmZdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci13aGl0ZVwiLFxuICBub3RjaFRyYWlsaW5nOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYm9yZGVyIGJvcmRlci1zb2xpZCBib3gtYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBncm93IGgtZnVsbCBib3JkZXItbC0wIHJvdW5kZWQtci1bMC4yNXJlbV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLWwtMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci1sLTBcIixcbiAgbm90Y2hUcmFpbGluZ05vcm1hbDogXCJib3JkZXItbmV1dHJhbC0zMDAgZGFyazpib3JkZXItbmV1dHJhbC02MDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVsxcHhfMF8wXyMzYjcxY2EsXzBfLTFweF8wXzBfIzNiNzFjYSxfMF8xcHhfMF8wXyMzYjcxY2FdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1wcmltYXJ5XCIsXG4gIG5vdGNoVHJhaWxpbmdXaGl0ZTogXCJib3JkZXItbmV1dHJhbC0yMDAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVsxcHhfMF8wXyNmZmZmZmYsXzBfLTFweF8wXzBfI2ZmZmZmZixfMF8xcHhfMF8wXyNmZmZmZmZdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci13aGl0ZVwiLFxuICBjb3VudGVyOiBcInRleHQtcmlnaHQgbGVhZGluZy1bMS42XVwiXG59LCBBZiA9IHtcbiAgbm90Y2g6IFwic3RyaW5nXCIsXG4gIG5vdGNoTGVhZGluZzogXCJzdHJpbmdcIixcbiAgbm90Y2hMZWFkaW5nTm9ybWFsOiBcInN0cmluZ1wiLFxuICBub3RjaExlYWRpbmdXaGl0ZTogXCJzdHJpbmdcIixcbiAgbm90Y2hNaWRkbGU6IFwic3RyaW5nXCIsXG4gIG5vdGNoTWlkZGxlTm9ybWFsOiBcInN0cmluZ1wiLFxuICBub3RjaE1pZGRsZVdoaXRlOiBcInN0cmluZ1wiLFxuICBub3RjaFRyYWlsaW5nOiBcInN0cmluZ1wiLFxuICBub3RjaFRyYWlsaW5nTm9ybWFsOiBcInN0cmluZ1wiLFxuICBub3RjaFRyYWlsaW5nV2hpdGU6IFwic3RyaW5nXCIsXG4gIGNvdW50ZXI6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBWIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlLCB0KSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9sYWJlbCA9IG51bGwsIHRoaXMuX2xhYmVsV2lkdGggPSAwLCB0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSAwLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBudWxsLCB0aGlzLl9ub3RjaE1pZGRsZSA9IG51bGwsIHRoaXMuX25vdGNoVHJhaWxpbmcgPSBudWxsLCB0aGlzLl9pbml0aWF0ZWQgPSAhMSwgdGhpcy5faGVscGVyID0gbnVsbCwgdGhpcy5fY291bnRlciA9ICExLCB0aGlzLl9jb3VudGVyRWxlbWVudCA9IG51bGwsIHRoaXMuX21heExlbmd0aCA9IDAsIHRoaXMuX2xlYWRpbmdJY29uID0gbnVsbCwgdGhpcy5fZWxlbWVudCAmJiAoQS5zZXREYXRhKHQsIGxzLCB0aGlzKSwgdGhpcy5pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBKbjtcbiAgfVxuICBnZXQgaW5wdXQoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcImlucHV0XCIsIHRoaXMuX2VsZW1lbnQpIHx8IGQuZmluZE9uZShcInRleHRhcmVhXCIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2luaXRpYXRlZCB8fCAodGhpcy5fZ2V0TGFiZWxEYXRhKCksIHRoaXMuX2FwcGx5RGl2cygpLCB0aGlzLl9hcHBseU5vdGNoKCksIHRoaXMuX2FjdGl2YXRlKCksIHRoaXMuX2dldEhlbHBlcigpLCB0aGlzLl9nZXRDb3VudGVyKCksIHRoaXMuX2dldEV2ZW50cygpLCB0aGlzLl9pbml0aWF0ZWQgPSAhMCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX2dldExhYmVsRGF0YSgpLCB0aGlzLl9nZXROb3RjaERhdGEoKSwgdGhpcy5fYXBwbHlOb3RjaCgpLCB0aGlzLl9hY3RpdmF0ZSgpLCB0aGlzLl9nZXRIZWxwZXIoKSwgdGhpcy5fZ2V0Q291bnRlcigpO1xuICB9XG4gIGZvcmNlQWN0aXZlKCkge1xuICAgIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKFl0LCBcIlwiKSwgZC5maW5kT25lKEllLCB0aGlzLmlucHV0LnBhcmVudE5vZGUpLnNldEF0dHJpYnV0ZShcbiAgICAgIFl0LFxuICAgICAgXCJcIlxuICAgICk7XG4gIH1cbiAgZm9yY2VJbmFjdGl2ZSgpIHtcbiAgICB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShZdCksIGQuZmluZE9uZShcbiAgICAgIEllLFxuICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlXG4gICAgKS5yZW1vdmVBdHRyaWJ1dGUoWXQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcmVtb3ZlQm9yZGVyKCksIEEucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBscyksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldENvbmZpZyh0LCBlKSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5FZixcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXMoZSksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XG4gICAgfSwgSShKbiwgdCwgQ2YpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ucGgsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoSm4sIHQsIEFmKSwgdDtcbiAgfVxuICBfZ2V0TGFiZWxEYXRhKCkge1xuICAgIHRoaXMuX2xhYmVsID0gZC5maW5kT25lKFwibGFiZWxcIiwgdGhpcy5fZWxlbWVudCksIHRoaXMuX2xhYmVsID09PSBudWxsID8gdGhpcy5fc2hvd1BsYWNlaG9sZGVyKCkgOiAodGhpcy5fZ2V0TGFiZWxXaWR0aCgpLCB0aGlzLl9nZXRMYWJlbFBvc2l0aW9uSW5JbnB1dEdyb3VwKCksIHRoaXMuX3RvZ2dsZURlZmF1bHREYXRlUGxhY2Vob2xkZXIoKSk7XG4gIH1cbiAgX2dldEhlbHBlcigpIHtcbiAgICB0aGlzLl9oZWxwZXIgPSBkLmZpbmRPbmUoVGYsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF9nZXRDb3VudGVyKCkge1xuICAgIHRoaXMuX2NvdW50ZXIgPSBoLmdldERhdGFBdHRyaWJ1dGUoXG4gICAgICB0aGlzLmlucHV0LFxuICAgICAgXCJpbnB1dFNob3djb3VudGVyXCJcbiAgICApLCB0aGlzLl9jb3VudGVyICYmICh0aGlzLl9tYXhMZW5ndGggPSB0aGlzLmlucHV0Lm1heExlbmd0aCwgdGhpcy5fc2hvd0NvdW50ZXIoKSk7XG4gIH1cbiAgX2dldEV2ZW50cygpIHtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwiZm9jdXNcIixcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIFYuYWN0aXZhdGUobmV3IFYoKSlcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIFYuYWN0aXZhdGUobmV3IFYoKSlcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwiYmx1clwiLFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgVi5kZWFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImZvY3VzXCIsXG4gICAgICBcInRleHRhcmVhXCIsXG4gICAgICBWLmFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImlucHV0XCIsXG4gICAgICBcInRleHRhcmVhXCIsXG4gICAgICBWLmFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImJsdXJcIixcbiAgICAgIFwidGV4dGFyZWFcIixcbiAgICAgIFYuZGVhY3RpdmF0ZShuZXcgVigpKVxuICAgICksIGMub24od2luZG93LCBcInNob3duLnRlLm1vZGFsXCIsICh0KSA9PiB7XG4gICAgICBkLmZpbmQoY3MsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSBWLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgaSAmJiBpLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApLCBkLmZpbmQoaHMsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSBWLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgaSAmJiBpLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pLCBjLm9uKHdpbmRvdywgXCJzaG93bi50ZS5kcm9wZG93blwiLCAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHQudGFyZ2V0LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcihcbiAgICAgICAgXCJbZGF0YS10ZS1kcm9wZG93bi1tZW51LXJlZl1cIlxuICAgICAgKTtcbiAgICAgIGUgJiYgKGQuZmluZChjcywgZSkuZm9yRWFjaChcbiAgICAgICAgKGkpID0+IHtcbiAgICAgICAgICBjb25zdCBuID0gVi5nZXRJbnN0YW5jZShpLnBhcmVudE5vZGUpO1xuICAgICAgICAgIG4gJiYgbi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKSwgZC5maW5kKGhzLCBlKS5mb3JFYWNoKFxuICAgICAgICAoaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG4gPSBWLmdldEluc3RhbmNlKGkucGFyZW50Tm9kZSk7XG4gICAgICAgICAgbiAmJiBuLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApKTtcbiAgICB9KSwgYy5vbih3aW5kb3csIFwic2hvd24udGUudGFiXCIsICh0KSA9PiB7XG4gICAgICBsZXQgZTtcbiAgICAgIHQudGFyZ2V0LmhyZWYgPyBlID0gdC50YXJnZXQuaHJlZi5zcGxpdChcIiNcIilbMV0gOiBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQudGFyZ2V0LCBcInRhcmdldFwiKS5zcGxpdChcbiAgICAgICAgXCIjXCJcbiAgICAgIClbMV07XG4gICAgICBjb25zdCBpID0gZC5maW5kT25lKGAjJHtlfWApO1xuICAgICAgZC5maW5kKGNzLCBpKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBWLmdldEluc3RhbmNlKG4ucGFyZW50Tm9kZSk7XG4gICAgICAgIG8gJiYgby51cGRhdGUoKTtcbiAgICAgIH0pLCBkLmZpbmQoaHMsIGkpLmZvckVhY2goXG4gICAgICAgIChuKSA9PiB7XG4gICAgICAgICAgY29uc3QgbyA9IFYuZ2V0SW5zdGFuY2Uobi5wYXJlbnROb2RlKTtcbiAgICAgICAgICBvICYmIG8udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSksIGMub24od2luZG93LCBcInJlc2V0XCIsICh0KSA9PiB7XG4gICAgICBkLmZpbmQoY3MsIHQudGFyZ2V0KS5mb3JFYWNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGkgPSBWLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgaSAmJiBpLmZvcmNlSW5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgKSwgZC5maW5kKGhzLCB0LnRhcmdldCkuZm9yRWFjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gVi5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGkgJiYgaS5mb3JjZUluYWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSksIGMub24od2luZG93LCBcIm9uYXV0b2NvbXBsZXRlXCIsICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gVi5nZXRJbnN0YW5jZSh0LnRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICFlIHx8ICF0LmNhbmNlbGFibGUgfHwgZS5mb3JjZUFjdGl2ZSgpO1xuICAgIH0pO1xuICB9XG4gIF9zaG93Q291bnRlcigpIHtcbiAgICBpZiAoZC5maW5kKFxuICAgICAgYFske01hfV1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkubGVuZ3RoID4gMClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9jb3VudGVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGguYWRkQ2xhc3ModGhpcy5fY291bnRlckVsZW1lbnQsIHRoaXMuX2NsYXNzZXMuY291bnRlciksIHRoaXMuX2NvdW50ZXJFbGVtZW50LnNldEF0dHJpYnV0ZShNYSwgXCJcIik7XG4gICAgY29uc3QgZSA9IHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoO1xuICAgIHRoaXMuX2NvdW50ZXJFbGVtZW50LmlubmVySFRNTCA9IGAke2V9IC8gJHt0aGlzLl9tYXhMZW5ndGh9YCwgdGhpcy5faGVscGVyLmFwcGVuZENoaWxkKHRoaXMuX2NvdW50ZXJFbGVtZW50KSwgdGhpcy5fYmluZENvdW50ZXIoKTtcbiAgfVxuICBfYmluZENvdW50ZXIoKSB7XG4gICAgYy5vbih0aGlzLmlucHV0LCBcImlucHV0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aDtcbiAgICAgIHRoaXMuX2NvdW50ZXJFbGVtZW50LmlubmVySFRNTCA9IGAke3R9IC8gJHt0aGlzLl9tYXhMZW5ndGh9YDtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlRGVmYXVsdERhdGVQbGFjZWhvbGRlcih0ID0gdGhpcy5pbnB1dCkge1xuICAgIGlmICghKHQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PT0gXCJkYXRlXCIpKVxuICAgICAgcmV0dXJuO1xuICAgICEoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdCkgJiYgIXQudmFsdWUgPyB0LnN0eWxlLm9wYWNpdHkgPSAwIDogdC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgfVxuICBfc2hvd1BsYWNlaG9sZGVyKCkge1xuICAgIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKHZmLCBcIlwiKTtcbiAgfVxuICBfZ2V0Tm90Y2hEYXRhKCkge1xuICAgIHRoaXMuX25vdGNoTWlkZGxlID0gZC5maW5kT25lKFxuICAgICAgUGEsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gZC5maW5kT25lKFxuICAgICAgUmEsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgfVxuICBfZ2V0TGFiZWxXaWR0aCgpIHtcbiAgICB0aGlzLl9sYWJlbFdpZHRoID0gdGhpcy5fbGFiZWwuY2xpZW50V2lkdGggKiAwLjggKyA4O1xuICB9XG4gIF9nZXRMYWJlbFBvc2l0aW9uSW5JbnB1dEdyb3VwKCkge1xuICAgIGlmICh0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSAwLCAhdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXRlLWlucHV0LWdyb3VwLXJlZlwiKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5pbnB1dCwgZSA9IGQucHJldihcbiAgICAgIHQsXG4gICAgICBcIltkYXRhLXRlLWlucHV0LWdyb3VwLXRleHQtcmVmXVwiXG4gICAgKVswXTtcbiAgICBlID09PSB2b2lkIDAgPyB0aGlzLl9sYWJlbE1hcmdpbkxlZnQgPSAwIDogdGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gZS5vZmZzZXRXaWR0aCAtIDE7XG4gIH1cbiAgX2FwcGx5RGl2cygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY29uZmlnLmlucHV0Rm9ybVdoaXRlID8gdGhpcy5fY2xhc3Nlcy5ub3RjaExlYWRpbmdXaGl0ZSA6IHRoaXMuX2NsYXNzZXMubm90Y2hMZWFkaW5nTm9ybWFsLCBlID0gdGhpcy5fY29uZmlnLmlucHV0Rm9ybVdoaXRlID8gdGhpcy5fY2xhc3Nlcy5ub3RjaE1pZGRsZVdoaXRlIDogdGhpcy5fY2xhc3Nlcy5ub3RjaE1pZGRsZU5vcm1hbCwgaSA9IHRoaXMuX2NvbmZpZy5pbnB1dEZvcm1XaGl0ZSA/IHRoaXMuX2NsYXNzZXMubm90Y2hUcmFpbGluZ1doaXRlIDogdGhpcy5fY2xhc3Nlcy5ub3RjaFRyYWlsaW5nTm9ybWFsLCBuID0gZC5maW5kKEllLCB0aGlzLl9lbGVtZW50KSwgbyA9ICQoXCJkaXZcIik7XG4gICAgaC5hZGRDbGFzcyhvLCB0aGlzLl9jbGFzc2VzLm5vdGNoKSwgby5zZXRBdHRyaWJ1dGUoaGgsIFwiXCIpLCB0aGlzLl9ub3RjaExlYWRpbmcgPSAkKFwiZGl2XCIpLCBoLmFkZENsYXNzKFxuICAgICAgdGhpcy5fbm90Y2hMZWFkaW5nLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5ub3RjaExlYWRpbmd9ICR7dH1gXG4gICAgKSwgdGhpcy5fbm90Y2hMZWFkaW5nLnNldEF0dHJpYnV0ZShkaCwgXCJcIiksIHRoaXMuX25vdGNoTWlkZGxlID0gJChcImRpdlwiKSwgaC5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX25vdGNoTWlkZGxlLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5ub3RjaE1pZGRsZX0gJHtlfWBcbiAgICApLCB0aGlzLl9ub3RjaE1pZGRsZS5zZXRBdHRyaWJ1dGUodWgsIFwiXCIpLCB0aGlzLl9ub3RjaFRyYWlsaW5nID0gJChcImRpdlwiKSwgaC5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX25vdGNoVHJhaWxpbmcsXG4gICAgICBgJHt0aGlzLl9jbGFzc2VzLm5vdGNoVHJhaWxpbmd9ICR7aX1gXG4gICAgKSwgdGhpcy5fbm90Y2hUcmFpbGluZy5zZXRBdHRyaWJ1dGUoZ2YsIFwiXCIpLCAhKG4ubGVuZ3RoID49IDEpICYmIChvLmFwcGVuZCh0aGlzLl9ub3RjaExlYWRpbmcpLCBvLmFwcGVuZCh0aGlzLl9ub3RjaE1pZGRsZSksIG8uYXBwZW5kKHRoaXMuX25vdGNoVHJhaWxpbmcpLCB0aGlzLl9lbGVtZW50LmFwcGVuZChvKSk7XG4gIH1cbiAgX2FwcGx5Tm90Y2goKSB7XG4gICAgdGhpcy5fbm90Y2hNaWRkbGUuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9sYWJlbFdpZHRofXB4YCwgdGhpcy5fbm90Y2hMZWFkaW5nLnN0eWxlLndpZHRoID0gYCR7dGhpcy5fbGFiZWxNYXJnaW5MZWZ0ICsgOX1weGAsIHRoaXMuX2xhYmVsICE9PSBudWxsICYmICh0aGlzLl9sYWJlbC5zdHlsZS5tYXJnaW5MZWZ0ID0gYCR7dGhpcy5fbGFiZWxNYXJnaW5MZWZ0fXB4YCk7XG4gIH1cbiAgX3JlbW92ZUJvcmRlcigpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKEllLCB0aGlzLl9lbGVtZW50KTtcbiAgICB0ICYmIHQucmVtb3ZlKCk7XG4gIH1cbiAgX2FjdGl2YXRlKHQpIHtcbiAgICBnYygoKSA9PiB7XG4gICAgICB0aGlzLl9nZXRFbGVtZW50cyh0KTtcbiAgICAgIGNvbnN0IGUgPSB0ID8gdC50YXJnZXQgOiB0aGlzLmlucHV0LCBpID0gZC5maW5kT25lKFxuICAgICAgICBJZSxcbiAgICAgICAgdGhpcy5fZWxlbWVudFxuICAgICAgKTtcbiAgICAgIHQgJiYgdC50eXBlID09PSBcImZvY3VzXCIgJiYgaSAmJiBpLnNldEF0dHJpYnV0ZShOYSwgXCJcIiksIGUudmFsdWUgIT09IFwiXCIgJiYgKGUuc2V0QXR0cmlidXRlKFl0LCBcIlwiKSwgaSAmJiBpLnNldEF0dHJpYnV0ZShZdCwgXCJcIikpLCB0aGlzLl90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKGUpO1xuICAgIH0pO1xuICB9XG4gIF9nZXRFbGVtZW50cyh0KSB7XG4gICAgaWYgKHQgJiYgKHRoaXMuX2VsZW1lbnQgPSB0LnRhcmdldC5wYXJlbnROb2RlLCB0aGlzLl9sYWJlbCA9IGQuZmluZE9uZShcImxhYmVsXCIsIHRoaXMuX2VsZW1lbnQpKSwgdCAmJiB0aGlzLl9sYWJlbCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX2xhYmVsV2lkdGg7XG4gICAgICB0aGlzLl9nZXRMYWJlbERhdGEoKSwgZSAhPT0gdGhpcy5fbGFiZWxXaWR0aCAmJiAodGhpcy5fbm90Y2hNaWRkbGUgPSBkLmZpbmRPbmUoXG4gICAgICAgIFBhLFxuICAgICAgICB0LnRhcmdldC5wYXJlbnROb2RlXG4gICAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBkLmZpbmRPbmUoXG4gICAgICAgIFJhLFxuICAgICAgICB0LnRhcmdldC5wYXJlbnROb2RlXG4gICAgICApLCB0aGlzLl9hcHBseU5vdGNoKCkpO1xuICAgIH1cbiAgfVxuICBfZGVhY3RpdmF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyB0LnRhcmdldCA6IHRoaXMuaW5wdXQsIGkgPSBkLmZpbmRPbmUoXG4gICAgICBJZSxcbiAgICAgIGUucGFyZW50Tm9kZVxuICAgICk7XG4gICAgaS5yZW1vdmVBdHRyaWJ1dGUoTmEpLCBlLnZhbHVlID09PSBcIlwiICYmIChlLnJlbW92ZUF0dHJpYnV0ZShZdCksIGkucmVtb3ZlQXR0cmlidXRlKFl0KSksIHRoaXMuX3RvZ2dsZURlZmF1bHREYXRlUGxhY2Vob2xkZXIoZSk7XG4gIH1cbiAgc3RhdGljIGFjdGl2YXRlKHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdC5fYWN0aXZhdGUoZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVhY3RpdmF0ZSh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHQuX2RlYWN0aXZhdGUoZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSBBLmdldERhdGEodGhpcywgbHMpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAoaSB8fCAoaSA9IG5ldyBWKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIGxzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBCYSA9IFwiYW5pbWF0aW9uXCIsIHRvID0gXCJ0ZS5hbmltYXRpb25cIiwgeWYgPSB7XG4gIGFuaW1hdGlvbjogXCJzdHJpbmdcIixcbiAgYW5pbWF0aW9uU3RhcnQ6IFwic3RyaW5nXCIsXG4gIGFuaW1hdGlvblNob3dPbkxvYWQ6IFwiYm9vbGVhblwiLFxuICBvblN0YXJ0OiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBvbkVuZDogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgb25IaWRlOiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBvblNob3c6IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIGFuaW1hdGlvbk9uU2Nyb2xsOiBcIihzdHJpbmcpXCIsXG4gIGFuaW1hdGlvbldpbmRvd0hlaWdodDogXCJudW1iZXJcIixcbiAgYW5pbWF0aW9uT2Zmc2V0OiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBhbmltYXRpb25EZWxheTogXCIobnVtYmVyfHN0cmluZylcIixcbiAgYW5pbWF0aW9uUmV2ZXJzZTogXCJib29sZWFuXCIsXG4gIGFuaW1hdGlvbkludGVydmFsOiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBhbmltYXRpb25SZXBlYXQ6IFwiKG51bWJlcnxib29sZWFuKVwiLFxuICBhbmltYXRpb25SZXNldDogXCJib29sZWFuXCJcbn0sIHdmID0ge1xuICBhbmltYXRpb246IFwiZmFkZVwiLFxuICBhbmltYXRpb25TdGFydDogXCJvbkNsaWNrXCIsXG4gIGFuaW1hdGlvblNob3dPbkxvYWQ6ICEwLFxuICBvblN0YXJ0OiBudWxsLFxuICBvbkVuZDogbnVsbCxcbiAgb25IaWRlOiBudWxsLFxuICBvblNob3c6IG51bGwsXG4gIGFuaW1hdGlvbk9uU2Nyb2xsOiBcIm9uY2VcIixcbiAgYW5pbWF0aW9uV2luZG93SGVpZ2h0OiAwLFxuICBhbmltYXRpb25PZmZzZXQ6IDAsXG4gIGFuaW1hdGlvbkRlbGF5OiAwLFxuICBhbmltYXRpb25SZXZlcnNlOiAhMSxcbiAgYW5pbWF0aW9uSW50ZXJ2YWw6IDAsXG4gIGFuaW1hdGlvblJlcGVhdDogITEsXG4gIGFuaW1hdGlvblJlc2V0OiAhMVxufTtcbmNsYXNzIHdyIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9hbmltYXRlRWxlbWVudCA9IHRoaXMuX2dldEFuaW1hdGVFbGVtZW50KCksIHRoaXMuX2lzRmlyc3RTY3JvbGwgPSAhMCwgdGhpcy5fcmVwZWF0QW5pbWF0ZU9uU2Nyb2xsID0gITAsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2VsZW1lbnQgJiYgKEEuc2V0RGF0YSh0LCB0bywgdGhpcyksIHRoaXMuX2luaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEJhO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuICBzdGFydEFuaW1hdGlvbigpIHtcbiAgICB0aGlzLl9zdGFydEFuaW1hdGlvbigpO1xuICB9XG4gIHN0b3BBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fY2xlYXJBbmltYXRpb25DbGFzcygpO1xuICB9XG4gIGNoYW5nZUFuaW1hdGlvblR5cGUodCkge1xuICAgIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uID0gdDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwibW91c2Vkb3duXCIpLCBjLm9mZih0aGlzLl9hbmltYXRlRWxlbWVudCwgXCJhbmltYXRpb25lbmRcIiksIGMub2ZmKHdpbmRvdywgXCJzY3JvbGxcIiksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwibW91c2VvdmVyXCIpLCBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgdG8pLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fYW5pbWF0ZUVsZW1lbnQgPSBudWxsLCB0aGlzLl9pc0ZpcnN0U2Nyb2xsID0gbnVsbCwgdGhpcy5fcmVwZWF0QW5pbWF0ZU9uU2Nyb2xsID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uU3RhcnQpIHtcbiAgICAgIGNhc2UgXCJvbkhvdmVyXCI6XG4gICAgICAgIHRoaXMuX2JpbmRIb3ZlckV2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvbkxvYWRcIjpcbiAgICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib25TY3JvbGxcIjpcbiAgICAgICAgdGhpcy5fYmluZFNjcm9sbEV2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvbkNsaWNrXCI6XG4gICAgICAgIHRoaXMuX2JpbmRDbGlja0V2ZW50cygpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fYmluZFRyaWdnZXJPbkVuZENhbGxiYWNrKCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVzZXQgJiYgdGhpcy5fYmluZFJlc2V0QW5pbWF0aW9uQWZ0ZXJGaW5pc2goKTtcbiAgfVxuICBfZ2V0QW5pbWF0ZUVsZW1lbnQoKSB7XG4gICAgY29uc3QgdCA9IGguZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImFuaW1hdGlvbi10YXJnZXRcIlxuICAgICk7XG4gICAgcmV0dXJuIHQgPyBkLmZpbmQodClbMF0gOiB0aGlzLl9lbGVtZW50O1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2FuaW1hdGVFbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLndmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKEJhLCB0LCB5ZiksIHQ7XG4gIH1cbiAgX2FuaW1hdGVPblNjcm9sbCgpIHtcbiAgICBjb25zdCB0ID0gaC5vZmZzZXQodGhpcy5fYW5pbWF0ZUVsZW1lbnQpLnRvcCwgZSA9IHRoaXMuX2FuaW1hdGVFbGVtZW50Lm9mZnNldEhlaWdodCwgaSA9IHdpbmRvdy5pbm5lckhlaWdodCwgbiA9IHQgKyB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbk9mZnNldCA8PSBpICYmIHQgKyB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbk9mZnNldCArIGUgPj0gMCwgbyA9IHRoaXMuX2FuaW1hdGVFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPT09IFwidmlzaWJsZVwiO1xuICAgIHN3aXRjaCAoITApIHtcbiAgICAgIGNhc2UgKG4gJiYgdGhpcy5faXNGaXJzdFNjcm9sbCk6XG4gICAgICAgIHRoaXMuX2lzRmlyc3RTY3JvbGwgPSAhMSwgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICghbiAmJiB0aGlzLl9pc0ZpcnN0U2Nyb2xsKTpcbiAgICAgICAgdGhpcy5faXNGaXJzdFNjcm9sbCA9ICExLCB0aGlzLl9oaWRlQW5pbWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIChuICYmICFvICYmIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCk6XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uT25TY3JvbGwgIT09IFwicmVwZWF0XCIgJiYgKHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCA9ICExKSwgdGhpcy5fY2FsbGJhY2sodGhpcy5fb3B0aW9ucy5vblNob3cpLCB0aGlzLl9zaG93QW5pbWF0ZUVsZW1lbnQoKSwgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICghbiAmJiBvICYmIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCk6XG4gICAgICAgIHRoaXMuX2hpZGVBbmltYXRlRWxlbWVudCgpLCB0aGlzLl9jbGVhckFuaW1hdGlvbkNsYXNzKCksIHRoaXMuX2NhbGxiYWNrKHRoaXMuX29wdGlvbnMub25IaWRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIF9hZGRBbmltYXRlZENsYXNzKCkge1xuICAgIGguYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9hbmltYXRlRWxlbWVudCxcbiAgICAgIGBhbmltYXRlLSR7dGhpcy5fb3B0aW9ucy5hbmltYXRpb259YFxuICAgICk7XG4gIH1cbiAgX2NsZWFyQW5pbWF0aW9uQ2xhc3MoKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgYW5pbWF0ZS0ke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9ufWApO1xuICB9XG4gIF9zdGFydEFuaW1hdGlvbigpIHtcbiAgICB0aGlzLl9jYWxsYmFjayh0aGlzLl9vcHRpb25zLm9uU3RhcnQpLCB0aGlzLl9hZGRBbmltYXRlZENsYXNzKCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVwZWF0ICYmICF0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkludGVydmFsICYmIHRoaXMuX3NldEFuaW1hdGlvblJlcGVhdCgpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJldmVyc2UgJiYgdGhpcy5fc2V0QW5pbWF0aW9uUmV2ZXJzZSgpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkRlbGF5ICYmIHRoaXMuX3NldEFuaW1hdGlvbkRlbGF5KCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24gJiYgdGhpcy5fc2V0QW5pbWF0aW9uRHVyYXRpb24oKSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCAmJiB0aGlzLl9zZXRBbmltYXRpb25JbnRlcnZhbCgpO1xuICB9XG4gIF9zZXRBbmltYXRpb25SZXZlcnNlKCkge1xuICAgIGguc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHtcbiAgICAgIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJlcGVhdCA9PT0gITAgPyBcImluZmluaXRlXCIgOiBcIjJcIixcbiAgICAgIGFuaW1hdGlvbkRpcmVjdGlvbjogXCJhbHRlcm5hdGVcIlxuICAgIH0pO1xuICB9XG4gIF9zZXRBbmltYXRpb25EdXJhdGlvbigpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7XG4gICAgICBhbmltYXRpb25EdXJhdGlvbjogYCR7dGhpcy5fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbn1tc2BcbiAgICB9KTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uRGVsYXkoKSB7XG4gICAgaC5zdHlsZSh0aGlzLl9hbmltYXRlRWxlbWVudCwge1xuICAgICAgYW5pbWF0aW9uRGVsYXk6IGAke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9uRGVsYXl9bXNgXG4gICAgfSk7XG4gIH1cbiAgX3NldEFuaW1hdGlvblJlcGVhdCgpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7XG4gICAgICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXBlYXQgPT09ICEwID8gXCJpbmZpbml0ZVwiIDogdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXBlYXRcbiAgICB9KTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uSW50ZXJ2YWwoKSB7XG4gICAgYy5vbih0aGlzLl9hbmltYXRlRWxlbWVudCwgXCJhbmltYXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fY2xlYXJBbmltYXRpb25DbGFzcygpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkQW5pbWF0ZWRDbGFzcygpO1xuICAgICAgfSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCk7XG4gICAgfSk7XG4gIH1cbiAgX2hpZGVBbmltYXRlRWxlbWVudCgpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfSk7XG4gIH1cbiAgX3Nob3dBbmltYXRlRWxlbWVudCgpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7IHZpc2liaWxpdHk6IFwidmlzaWJsZVwiIH0pO1xuICB9XG4gIF9iaW5kUmVzZXRBbmltYXRpb25BZnRlckZpbmlzaCgpIHtcbiAgICBjLm9uKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jbGVhckFuaW1hdGlvbkNsYXNzKCk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRUcmlnZ2VyT25FbmRDYWxsYmFjaygpIHtcbiAgICBjLm9uKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jYWxsYmFjayh0aGlzLl9vcHRpb25zLm9uRW5kKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZFNjcm9sbEV2ZW50cygpIHtcbiAgICB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblNob3dPbkxvYWQgfHwgdGhpcy5fYW5pbWF0ZU9uU2Nyb2xsKCksIGMub24od2luZG93LCBcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9hbmltYXRlT25TY3JvbGwoKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZENsaWNrRXZlbnRzKCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZEhvdmVyRXZlbnRzKCkge1xuICAgIGMub25lKHRoaXMuX2VsZW1lbnQsIFwibW91c2VvdmVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgfSksIGMub25lKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fYmluZEhvdmVyRXZlbnRzKCk7XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICB9XG4gIF9jYWxsYmFjayh0KSB7XG4gICAgdCBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIHQoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGF1dG9Jbml0KHQpIHtcbiAgICB0Ll9pbml0KCk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgbmV3IHdyKHRoaXNbMF0sIHQpLmluaXQoKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgdG8pO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IGtmID0ge1xuICBwcm9wZXJ0eTogXCJjb2xvclwiLFxuICBkZWZhdWx0VmFsdWU6IG51bGwsXG4gIGluaGVyaXQ6ICEwXG59LCBEZSA9IChzLCB0KSA9PiB7XG4gIGNvbnN0IHsgcHJvcGVydHk6IGUsIGRlZmF1bHRWYWx1ZTogaSwgaW5oZXJpdDogbiB9ID0geyAuLi5rZiwgLi4udCB9LCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgby5jbGFzc0xpc3QuYWRkKHMpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG8pO1xuICBjb25zdCBhID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobylbZV0gfHwgaSwgcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG8ucGFyZW50RWxlbWVudClbZV07XG4gIHJldHVybiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG8pLCAhbiAmJiBwICYmIGEgPT09IHAgPyBpIDogYSB8fCBpO1xufSwgZW8gPSBcInJpcHBsZVwiLCBkcyA9IFwidGUucmlwcGxlXCIsIHhmID0gXCJyZ2JhKHt7Y29sb3J9fSwgMC4yKSAwLCByZ2JhKHt7Y29sb3J9fSwgMC4zKSA0MCUsIHJnYmEoe3tjb2xvcn19LCAwLjQpIDUwJSwgcmdiYSh7e2NvbG9yfX0sIDAuNSkgNjAlLCByZ2JhKHt7Y29sb3J9fSwgMCkgNzAlXCIsIE9mID0gW1wiW2RhdGEtdGUtcmlwcGxlLWluaXRdXCJdLCB1cyA9IFswLCAwLCAwXSwgU2YgPSBbXG4gIHtcbiAgICBuYW1lOiBcInByaW1hcnlcIixcbiAgICBncmFkaWVudENvbG9yOiBEZShcInRleHQtcHJpbWFyeVwiLCB7IGRlZmF1bHRWYWx1ZTogXCIjM0I3MUNBXCIsIGluaGVyaXQ6ICExIH0pXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcInNlY29uZGFyeVwiLFxuICAgIGdyYWRpZW50Q29sb3I6IERlKFwidGV4dC1zZWNvbmRhcnlcIiwgeyBkZWZhdWx0VmFsdWU6IFwiIzlGQTZCMlwiLCBpbmhlcml0OiAhMSB9KVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJzdWNjZXNzXCIsXG4gICAgZ3JhZGllbnRDb2xvcjogRGUoXCJ0ZXh0LXN1Y2Nlc3NcIiwgeyBkZWZhdWx0VmFsdWU6IFwiIzE0QTQ0RFwiLCBpbmhlcml0OiAhMSB9KVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJkYW5nZXJcIixcbiAgICBncmFkaWVudENvbG9yOiBEZShcInRleHQtZGFuZ2VyXCIsIHsgZGVmYXVsdFZhbHVlOiBcIiNEQzRDNjRcIiwgaW5oZXJpdDogITEgfSlcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwid2FybmluZ1wiLFxuICAgIGdyYWRpZW50Q29sb3I6IERlKFwidGV4dC13YXJuaW5nXCIsIHsgZGVmYXVsdFZhbHVlOiBcIiNFNEExMUJcIiwgaW5oZXJpdDogITEgfSlcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiaW5mb1wiLFxuICAgIGdyYWRpZW50Q29sb3I6IERlKFwidGV4dC1pbmZvXCIsIHsgZGVmYXVsdFZhbHVlOiBcIiM1NEI0RDNcIiwgaW5oZXJpdDogITEgfSlcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwibGlnaHRcIixcbiAgICBncmFkaWVudENvbG9yOiBcIiNmYmZiZmJcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJkYXJrXCIsXG4gICAgZ3JhZGllbnRDb2xvcjogXCIjMjYyNjI2XCJcbiAgfVxuXSwgSGEgPSAwLjUsIElmID0ge1xuICByaXBwbGVDZW50ZXJlZDogITEsXG4gIHJpcHBsZUNvbG9yOiBcIlwiLFxuICByaXBwbGVDb2xvckRhcms6IFwiXCIsXG4gIHJpcHBsZUR1cmF0aW9uOiBcIjUwMG1zXCIsXG4gIHJpcHBsZVJhZGl1czogMCxcbiAgcmlwcGxlVW5ib3VuZDogITFcbn0sIERmID0ge1xuICByaXBwbGVDZW50ZXJlZDogXCJib29sZWFuXCIsXG4gIHJpcHBsZUNvbG9yOiBcInN0cmluZ1wiLFxuICByaXBwbGVDb2xvckRhcms6IFwic3RyaW5nXCIsXG4gIHJpcHBsZUR1cmF0aW9uOiBcInN0cmluZ1wiLFxuICByaXBwbGVSYWRpdXM6IFwibnVtYmVyXCIsXG4gIHJpcHBsZVVuYm91bmQ6IFwiYm9vbGVhblwiXG59LCAkZiA9IHtcbiAgcmlwcGxlOiBcInJlbGF0aXZlIG92ZXJmbG93LWhpZGRlbiBpbmxpbmUtYmxvY2sgYWxpZ24tYm90dG9tXCIsXG4gIHJpcHBsZVdhdmU6IFwicm91bmRlZC1bNTAlXSBvcGFjaXR5LTUwIHBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgdG91Y2gtbm9uZSBzY2FsZS0wIHRyYW5zaXRpb24tW3RyYW5zZm9ybSxfb3BhY2l0eV0gZWFzZS1bY3ViaWMtYmV6aWVyKDAsMCwwLjE1LDEpLF9jdWJpYy1iZXppZXIoMCwwLDAuMTUsMSldIHotWzk5OV1cIixcbiAgdW5ib3VuZDogXCJvdmVyZmxvdy12aXNpYmxlXCJcbn0sIExmID0ge1xuICByaXBwbGU6IFwic3RyaW5nXCIsXG4gIHJpcHBsZVdhdmU6IFwic3RyaW5nXCIsXG4gIHVuYm91bmQ6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBlaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2VsZW1lbnQgJiYgKEEuc2V0RGF0YSh0LCBkcywgdGhpcyksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpKSwgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5fY3JlYXRlUmlwcGxlLmJpbmQodGhpcyksIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbCwgdGhpcy5faXNNaW5XaWR0aFNldCA9ICExLCB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IG51bGwsIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBlbztcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9hZGRDbGlja0V2ZW50KHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIGRzKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfYXV0b0luaXQodCkge1xuICAgIE9mLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGQuY2xvc2VzdCh0LnRhcmdldCwgZSkgJiYgKHRoaXMuX2VsZW1lbnQgPSBkLmNsb3Nlc3QodC50YXJnZXQsIGUpKTtcbiAgICB9KSwgdGhpcy5fZWxlbWVudC5zdHlsZS5taW5XaWR0aCB8fCAoaC5zdHlsZSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICBcIm1pbi13aWR0aFwiOiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLndpZHRoXG4gICAgfSksIHRoaXMuX2lzTWluV2lkdGhTZXQgPSAhMCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoKSwgdGhpcy5faW5pdGlhbENsYXNzZXMgPSBbLi4udGhpcy5fZWxlbWVudC5jbGFzc0xpc3RdLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucmlwcGxlKSwgdGhpcy5fY3JlYXRlUmlwcGxlKHQpO1xuICB9XG4gIF9hZGRDbGlja0V2ZW50KHQpIHtcbiAgICBjLm9uKHQsIFwibW91c2Vkb3duXCIsIHRoaXMuX2NsaWNrSGFuZGxlcik7XG4gIH1cbiAgX2NyZWF0ZVJpcHBsZSh0KSB7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZih0aGlzLl9jbGFzc2VzLnJpcHBsZSkgPCAwICYmIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpO1xuICAgIGNvbnN0IHsgbGF5ZXJYOiBlLCBsYXllclk6IGkgfSA9IHQsIG4gPSB0Lm9mZnNldFggfHwgZSwgbyA9IHQub2Zmc2V0WSB8fCBpLCByID0gdGhpcy5fZWxlbWVudC5vZmZzZXRIZWlnaHQsIGEgPSB0aGlzLl9lbGVtZW50Lm9mZnNldFdpZHRoLCBsID0gdGhpcy5fZHVyYXRpb25Ub01zTnVtYmVyKHRoaXMuX29wdGlvbnMucmlwcGxlRHVyYXRpb24pLCBwID0ge1xuICAgICAgb2Zmc2V0WDogdGhpcy5fb3B0aW9ucy5yaXBwbGVDZW50ZXJlZCA/IHIgLyAyIDogbixcbiAgICAgIG9mZnNldFk6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyBhIC8gMiA6IG8sXG4gICAgICBoZWlnaHQ6IHIsXG4gICAgICB3aWR0aDogYVxuICAgIH0sIHUgPSB0aGlzLl9nZXREaWFtZXRlcihwKSwgXyA9IHRoaXMuX29wdGlvbnMucmlwcGxlUmFkaXVzIHx8IHUgLyAyLCBmID0ge1xuICAgICAgZGVsYXk6IGwgKiBIYSxcbiAgICAgIGR1cmF0aW9uOiBsIC0gbCAqIEhhXG4gICAgfSwgZyA9IHtcbiAgICAgIGxlZnQ6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyBgJHthIC8gMiAtIF99cHhgIDogYCR7biAtIF99cHhgLFxuICAgICAgdG9wOiB0aGlzLl9vcHRpb25zLnJpcHBsZUNlbnRlcmVkID8gYCR7ciAvIDIgLSBffXB4YCA6IGAke28gLSBffXB4YCxcbiAgICAgIGhlaWdodDogYCR7dGhpcy5fb3B0aW9ucy5yaXBwbGVSYWRpdXMgKiAyIHx8IHV9cHhgLFxuICAgICAgd2lkdGg6IGAke3RoaXMuX29wdGlvbnMucmlwcGxlUmFkaXVzICogMiB8fCB1fXB4YCxcbiAgICAgIHRyYW5zaXRpb25EZWxheTogYDBzLCAke2YuZGVsYXl9bXNgLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBgJHtsfW1zLCAke2YuZHVyYXRpb259bXNgXG4gICAgfSwgbSA9ICQoXCJkaXZcIik7XG4gICAgdGhpcy5fY3JlYXRlSFRNTFJpcHBsZSh7XG4gICAgICB3cmFwcGVyOiB0aGlzLl9lbGVtZW50LFxuICAgICAgcmlwcGxlOiBtLFxuICAgICAgc3R5bGVzOiBnXG4gICAgfSksIHRoaXMuX3JlbW92ZUhUTUxSaXBwbGUoeyByaXBwbGU6IG0sIGR1cmF0aW9uOiBsIH0pO1xuICB9XG4gIF9jcmVhdGVIVE1MUmlwcGxlKHsgd3JhcHBlcjogdCwgcmlwcGxlOiBlLCBzdHlsZXM6IGkgfSkge1xuICAgIE9iamVjdC5rZXlzKGkpLmZvckVhY2goXG4gICAgICAobikgPT4gZS5zdHlsZVtuXSA9IGlbbl1cbiAgICApLCBoLmFkZENsYXNzKGUsIHRoaXMuX2NsYXNzZXMucmlwcGxlV2F2ZSksIGUuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1yaXBwbGUtcmVmXCIsIFwiXCIpLCB0aGlzLl9hZGRDb2xvcihlLCB0KSwgdGhpcy5fdG9nZ2xlVW5ib3VuZCh0KSwgdGhpcy5fYXBwZW5kUmlwcGxlKGUsIHQpO1xuICB9XG4gIF9yZW1vdmVIVE1MUmlwcGxlKHsgcmlwcGxlOiB0LCBkdXJhdGlvbjogZSB9KSB7XG4gICAgdGhpcy5fcmlwcGxlVGltZXIgJiYgKGNsZWFyVGltZW91dCh0aGlzLl9yaXBwbGVUaW1lciksIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbCksIHQgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0LmNsYXNzTGlzdC5hZGQoXCIhb3BhY2l0eS0wXCIpO1xuICAgIH0sIDEwKSwgdGhpcy5fcmlwcGxlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0ICYmICh0LnJlbW92ZSgpLCB0aGlzLl9lbGVtZW50KSkge1xuICAgICAgICBkLmZpbmQoXCJbZGF0YS10ZS1yaXBwbGUtcmVmXVwiLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKFxuICAgICAgICAgIChuKSA9PiB7XG4gICAgICAgICAgICBuLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSwgdGhpcy5faXNNaW5XaWR0aFNldCAmJiAoaC5zdHlsZSh0aGlzLl9lbGVtZW50LCB7IFwibWluLXdpZHRoXCI6IFwiXCIgfSksIHRoaXMuX2lzTWluV2lkdGhTZXQgPSAhMSk7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9pbml0aWFsQ2xhc3NlcyA/IHRoaXMuX2FkZGVkTmV3UmlwcGxlQ2xhc3NlcyhcbiAgICAgICAgICB0aGlzLl9jbGFzc2VzLnJpcHBsZSxcbiAgICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3Nlc1xuICAgICAgICApIDogdGhpcy5fY2xhc3Nlcy5yaXBwbGUuc3BsaXQoXCIgXCIpO1xuICAgICAgICBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIGkpO1xuICAgICAgfVxuICAgIH0sIGUpO1xuICB9XG4gIF9hZGRlZE5ld1JpcHBsZUNsYXNzZXModCwgZSkge1xuICAgIHJldHVybiB0LnNwbGl0KFwiIFwiKS5maWx0ZXIoXG4gICAgICAoaSkgPT4gZS5maW5kSW5kZXgoKG4pID0+IGkgPT09IG4pID09PSAtMVxuICAgICk7XG4gIH1cbiAgX2R1cmF0aW9uVG9Nc051bWJlcih0KSB7XG4gICAgcmV0dXJuIE51bWJlcih0LnJlcGxhY2UoXCJtc1wiLCBcIlwiKS5yZXBsYWNlKFwic1wiLCBcIjAwMFwiKSk7XG4gIH1cbiAgX2dldENvbmZpZyh0ID0ge30pIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLklmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKGVvLCB0LCBEZiksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCA9IHt9KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLiRmLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKGVvLCB0LCBMZiksIHQ7XG4gIH1cbiAgX2dldERpYW1ldGVyKHsgb2Zmc2V0WDogdCwgb2Zmc2V0WTogZSwgaGVpZ2h0OiBpLCB3aWR0aDogbiB9KSB7XG4gICAgY29uc3QgbyA9IGUgPD0gaSAvIDIsIHIgPSB0IDw9IG4gLyAyLCBhID0gKGYsIGcpID0+IE1hdGguc3FydChmICoqIDIgKyBnICoqIDIpLCBsID0gZSA9PT0gaSAvIDIgJiYgdCA9PT0gbiAvIDIsIHAgPSB7XG4gICAgICBmaXJzdDogbyA9PT0gITAgJiYgciA9PT0gITEsXG4gICAgICBzZWNvbmQ6IG8gPT09ICEwICYmIHIgPT09ICEwLFxuICAgICAgdGhpcmQ6IG8gPT09ICExICYmIHIgPT09ICEwLFxuICAgICAgZm91cnRoOiBvID09PSAhMSAmJiByID09PSAhMVxuICAgIH0sIHUgPSB7XG4gICAgICB0b3BMZWZ0OiBhKHQsIGUpLFxuICAgICAgdG9wUmlnaHQ6IGEobiAtIHQsIGUpLFxuICAgICAgYm90dG9tTGVmdDogYSh0LCBpIC0gZSksXG4gICAgICBib3R0b21SaWdodDogYShuIC0gdCwgaSAtIGUpXG4gICAgfTtcbiAgICBsZXQgXyA9IDA7XG4gICAgcmV0dXJuIGwgfHwgcC5mb3VydGggPyBfID0gdS50b3BMZWZ0IDogcC50aGlyZCA/IF8gPSB1LnRvcFJpZ2h0IDogcC5zZWNvbmQgPyBfID0gdS5ib3R0b21SaWdodCA6IHAuZmlyc3QgJiYgKF8gPSB1LmJvdHRvbUxlZnQpLCBfICogMjtcbiAgfVxuICBfYXBwZW5kUmlwcGxlKHQsIGUpIHtcbiAgICBlLmFwcGVuZENoaWxkKHQpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGguYWRkQ2xhc3ModCwgXCJvcGFjaXR5LTAgc2NhbGUtMTAwXCIpO1xuICAgIH0sIDUwKTtcbiAgfVxuICBfdG9nZ2xlVW5ib3VuZCh0KSB7XG4gICAgdGhpcy5fb3B0aW9ucy5yaXBwbGVVbmJvdW5kID09PSAhMCA/IGguYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy51bmJvdW5kKSA6IGgucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy51bmJvdW5kKTtcbiAgfVxuICBfYWRkQ29sb3IodCkge1xuICAgIGxldCBlID0gdGhpcy5fb3B0aW9ucy5yaXBwbGVDb2xvciB8fCBcInJnYigwLDAsMClcIjtcbiAgICAobG9jYWxTdG9yYWdlLnRoZW1lID09PSBcImRhcmtcIiB8fCAhKFwidGhlbWVcIiBpbiBsb2NhbFN0b3JhZ2UpICYmIHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzKSAmJiAoZSA9IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3JEYXJrIHx8IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3IpO1xuICAgIGNvbnN0IGkgPSBTZi5maW5kKFxuICAgICAgKHIpID0+IHIubmFtZSA9PT0gZS50b0xvd2VyQ2FzZSgpXG4gICAgKSwgbiA9IGkgPyB0aGlzLl9jb2xvclRvUkdCKGkuZ3JhZGllbnRDb2xvcikuam9pbihcIixcIikgOiB0aGlzLl9jb2xvclRvUkdCKGUpLmpvaW4oXCIsXCIpLCBvID0geGYuc3BsaXQoXCJ7e2NvbG9yfX1cIikuam9pbihgJHtufWApO1xuICAgIHQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHJhZGlhbC1ncmFkaWVudChjaXJjbGUsICR7b30pYDtcbiAgfVxuICBfY29sb3JUb1JHQih0KSB7XG4gICAgZnVuY3Rpb24gZShvKSB7XG4gICAgICByZXR1cm4gby5sZW5ndGggPCA3ICYmIChvID0gYCMke29bMV19JHtvWzFdfSR7b1syXX0ke29bMl19JHtvWzNdfSR7b1szXX1gKSwgW1xuICAgICAgICBwYXJzZUludChvLnN1YnN0cigxLCAyKSwgMTYpLFxuICAgICAgICBwYXJzZUludChvLnN1YnN0cigzLCAyKSwgMTYpLFxuICAgICAgICBwYXJzZUludChvLnN1YnN0cig1LCAyKSwgMTYpXG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpKG8pIHtcbiAgICAgIGNvbnN0IHIgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKFxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmljdHVtXCIpXG4gICAgICApLCBhID0gXCJyZ2IoMSwgMiwgMylcIjtcbiAgICAgIHJldHVybiByLnN0eWxlLmNvbG9yID0gYSwgci5zdHlsZS5jb2xvciAhPT0gYSB8fCAoci5zdHlsZS5jb2xvciA9IG8sIHIuc3R5bGUuY29sb3IgPT09IGEgfHwgci5zdHlsZS5jb2xvciA9PT0gXCJcIikgPyB1cyA6IChvID0gZ2V0Q29tcHV0ZWRTdHlsZShyKS5jb2xvciwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyKSwgbyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG4obykge1xuICAgICAgcmV0dXJuIG8gPSBvLm1hdGNoKC9bLlxcZF0rL2cpLm1hcCgocikgPT4gK051bWJlcihyKSksIG8ubGVuZ3RoID0gMywgbztcbiAgICB9XG4gICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cmFuc3BhcmVudFwiID8gdXMgOiB0WzBdID09PSBcIiNcIiA/IGUodCkgOiAodC5pbmRleE9mKFwicmdiXCIpID09PSAtMSAmJiAodCA9IGkodCkpLCB0LmluZGV4T2YoXCJyZ2JcIikgPT09IDAgPyBuKHQpIDogdXMpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgYXV0b0luaXRpYWwodCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICB0Ll9hdXRvSW5pdChlKTtcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQS5nZXREYXRhKHRoaXMsIGRzKSA/IG51bGwgOiBuZXcgZWkodGhpcywgdCk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIGRzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5mdW5jdGlvbiB0dChzKSB7XG4gIHJldHVybiBzLmdldERhdGUoKTtcbn1cbmZ1bmN0aW9uIHpzKHMpIHtcbiAgcmV0dXJuIHMuZ2V0RGF5KCk7XG59XG5mdW5jdGlvbiBZKHMpIHtcbiAgcmV0dXJuIHMuZ2V0TW9udGgoKTtcbn1cbmZ1bmN0aW9uIEIocykge1xuICByZXR1cm4gcy5nZXRGdWxsWWVhcigpO1xufVxuZnVuY3Rpb24gTmYocywgdCwgZSkge1xuICBjb25zdCBpID0gZS5zdGFydERheSwgbiA9IGkgPiAwID8gNyAtIGkgOiAwLCByID0gbmV3IERhdGUocywgdCkuZ2V0RGF5KCkgKyBuO1xuICByZXR1cm4gciA+PSA3ID8gciAtIDcgOiByO1xufVxuZnVuY3Rpb24gR28ocykge1xuICByZXR1cm4gTWYocykuZ2V0RGF0ZSgpO1xufVxuZnVuY3Rpb24gTWYocykge1xuICByZXR1cm4gQ3Qocy5nZXRGdWxsWWVhcigpLCBzLmdldE1vbnRoKCkgKyAxLCAwKTtcbn1cbmZ1bmN0aW9uIGplKCkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG59XG5mdW5jdGlvbiBhdChzLCB0KSB7XG4gIHJldHVybiBsdChzLCB0ICogMTIpO1xufVxuZnVuY3Rpb24gbHQocywgdCkge1xuICBjb25zdCBlID0gQ3QoXG4gICAgcy5nZXRGdWxsWWVhcigpLFxuICAgIHMuZ2V0TW9udGgoKSArIHQsXG4gICAgcy5nZXREYXRlKClcbiAgKSwgaSA9IHR0KHMpLCBuID0gdHQoZSk7XG4gIHJldHVybiBpICE9PSBuICYmIGUuc2V0RGF0ZSgwKSwgZTtcbn1cbmZ1bmN0aW9uICRlKHMsIHQpIHtcbiAgcmV0dXJuIEN0KHMuZ2V0RnVsbFllYXIoKSwgcy5nZXRNb250aCgpLCBzLmdldERhdGUoKSArIHQpO1xufVxuZnVuY3Rpb24gQ3QocywgdCwgZSkge1xuICBjb25zdCBpID0gbmV3IERhdGUocywgdCwgZSk7XG4gIHJldHVybiBzID49IDAgJiYgcyA8IDEwMCAmJiBpLnNldEZ1bGxZZWFyKGkuZ2V0RnVsbFllYXIoKSAtIDE5MDApLCBpO1xufVxuZnVuY3Rpb24gVmEocykge1xuICBjb25zdCB0ID0gcy5zcGxpdChcIi1cIiksIGUgPSB0WzBdLCBpID0gdFsxXSwgbiA9IHRbMl07XG4gIHJldHVybiBDdChlLCBpLCBuKTtcbn1cbmZ1bmN0aW9uIFJmKHMpIHtcbiAgcmV0dXJuICFOdW1iZXIuaXNOYU4ocy5nZXRUaW1lKCkpO1xufVxuZnVuY3Rpb24gRmUocywgdCkge1xuICByZXR1cm4gQihzKSAtIEIodCkgfHwgWShzKSAtIFkodCkgfHwgdHQocykgLSB0dCh0KTtcbn1cbmZ1bmN0aW9uIG1lKHMsIHQpIHtcbiAgcmV0dXJuIHMuc2V0SG91cnMoMCwgMCwgMCwgMCksIHQuc2V0SG91cnMoMCwgMCwgMCwgMCksIHMuZ2V0VGltZSgpID09PSB0LmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIFVzKHMsIHQpIHtcbiAgY29uc3QgaSA9IEIocykgLSBCZigpO1xuICByZXR1cm4gUGYoaSwgdCk7XG59XG5mdW5jdGlvbiBQZihzLCB0KSB7XG4gIHJldHVybiAocyAlIHQgKyB0KSAlIHQ7XG59XG5mdW5jdGlvbiBCZihzLCB0LCBlKSB7XG4gIGxldCBpID0gMDtcbiAgcmV0dXJuIGUgPyBpID0gQihlKSAtIHMgKyAxIDogdCAmJiAoaSA9IEIodCkpLCBpO1xufVxuZnVuY3Rpb24gX24ocywgdCwgZSwgaSwgbiwgbykge1xuICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIHIuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGNvbnN0IGEgPSB0ICYmIEZlKHMsIHQpIDw9IC0xLCBsID0gZSAmJiBGZShzLCBlKSA+PSAxLCBwID0gbiAmJiBGZShzLCByKSA8PSAtMSwgdSA9IG8gJiYgRmUocywgcikgPj0gMSwgXyA9IGkgJiYgaShzKSA9PT0gITE7XG4gIHJldHVybiBhIHx8IGwgfHwgXyB8fCBwIHx8IHU7XG59XG5mdW5jdGlvbiBfaChzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgYSA9IGkgJiYgQihpKSwgbCA9IGkgJiYgWShpKSwgcCA9IGUgJiYgQihlKSwgdSA9IGUgJiYgWShlKSwgXyA9IEIociksIGYgPSBZKHIpLCBnID0gbCAmJiBhICYmICh0ID4gYSB8fCB0ID09PSBhICYmIHMgPiBsKSwgbSA9IHUgJiYgcCAmJiAodCA8IHAgfHwgdCA9PT0gcCAmJiBzIDwgdSksIGIgPSBuICYmICh0IDwgXyB8fCB0ID09PSBfICYmIHMgPCBmKSwgdiA9IG8gJiYgKHQgPiBfIHx8IHQgPT09IF8gJiYgcyA+IGYpO1xuICByZXR1cm4gZyB8fCBtIHx8IGIgfHwgdjtcbn1cbmZ1bmN0aW9uIHFvKHMsIHQsIGUsIGksIG4pIHtcbiAgY29uc3QgbyA9IHQgJiYgQih0KSwgciA9IGUgJiYgQihlKSwgYSA9IEIoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLCBsID0gciAmJiBzID4gciwgcCA9IG8gJiYgcyA8IG8sIHUgPSBpICYmIHMgPCBhLCBfID0gbiAmJiBzID4gYTtcbiAgcmV0dXJuIGwgfHwgcCB8fCB1IHx8IF87XG59XG5mdW5jdGlvbiBIZihzLCB0LCBlLCBpLCBuLCBvLCByLCBhKSB7XG4gIGNvbnN0IGwgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgcmV0dXJuIGwuc2V0SG91cnMoMCwgMCwgMCwgMCksIChzICYmIG8gJiYgRmUobywgbCkgPCAwIHx8IHMpICYmIChvID0gbCksIG8gJiYgUGkoXG4gICAgdCxcbiAgICBvLFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhXG4gICk7XG59XG5mdW5jdGlvbiBWZihzLCB0LCBlLCBpLCBuLCBvLCByLCBhKSB7XG4gIGNvbnN0IGwgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgcmV0dXJuIGwuc2V0SG91cnMoMCwgMCwgMCwgMCksIChzICYmIG4gJiYgRmUobiwgbCkgPCAwIHx8IHMpICYmIChuID0gbCksIG4gJiYgUGkoXG4gICAgdCxcbiAgICBuLFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhXG4gICk7XG59XG5mdW5jdGlvbiBQaShzLCB0LCBlLCBpLCBuLCBvLCByLCBhKSB7XG4gIHJldHVybiBlID09PSBcImRheXNcIiA/IEIocykgPT09IEIodCkgJiYgWShzKSA9PT0gWSh0KSA6IGUgPT09IFwibW9udGhzXCIgPyBCKHMpID09PSBCKHQpIDogZSA9PT0gXCJ5ZWFyc1wiID8gQih0KSA+PSBhICYmIEIodCkgPD0gciA6ICExO1xufVxuY29uc3QgV2YgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1tb2RhbC1jb250YWluZXItcmVmXCIsIEZmID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItZHJvcGRvd24tY29udGFpbmVyLXJlZlwiLCBZZiA9IFwiZGF0YS10ZS1kcm9wZG93bi1iYWNrZHJvcC1yZWZcIiwgamYgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1kYXRlLXRleHQtcmVmXCIsIFdhID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItdmlldy1yZWZcIiwgS2YgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1wcmV2aW91cy1idXR0b24tcmVmXCIsIHpmID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItbmV4dC1idXR0b24tcmVmXCIsIFVmID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItb2stYnV0dG9uLXJlZlwiLCBYZiA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNhbmNlbC1idXR0b24tcmVmXCIsIEdmID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2xlYXItYnV0dG9uLXJlZlwiLCBxZiA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctY2hhbmdlLWJ1dHRvbi1yZWZcIjtcbmZ1bmN0aW9uIFpmKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEsIGwsIHApIHtcbiAgY29uc3QgdSA9IFkocyksIF8gPSBCKHMpLCBmID0gdHQocyksIGcgPSB6cyhzKSwgbSA9ICQoXCJkaXZcIiksIGIgPSBgXG4gICAgICAgICR7RmEoXG4gICAgcyxcbiAgICB1LFxuICAgIF8sXG4gICAgdCxcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYSxcbiAgICBwXG4gICl9XG4gICAgYCwgdiA9IGBcbiAgICAgICR7SmYoZiwgZywgdSwgbiwgcCl9XG4gICAgICAke0ZhKFxuICAgIHMsXG4gICAgdSxcbiAgICBfLFxuICAgIHQsXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGEsXG4gICAgcFxuICApfVxuICAgIGA7XG4gIHJldHVybiBuLmlubGluZSA/IChoLmFkZENsYXNzKG0sIHAuZGF0ZXBpY2tlckRyb3Bkb3duQ29udGFpbmVyKSwgbS5zZXRBdHRyaWJ1dGUoRmYsIGwpLCBtLmlubmVySFRNTCA9IGIpIDogKGguYWRkQ2xhc3MobSwgcC5tb2RhbENvbnRhaW5lciksIG0uc2V0QXR0cmlidXRlKFdmLCBsKSwgbS5pbm5lckhUTUwgPSB2KSwgbTtcbn1cbmZ1bmN0aW9uIFFmKHMpIHtcbiAgY29uc3QgdCA9ICQoXCJkaXZcIik7XG4gIHJldHVybiBoLmFkZENsYXNzKHQsIHMpLCB0LnNldEF0dHJpYnV0ZShZZiwgXCJcIiksIHQ7XG59XG5mdW5jdGlvbiBKZihzLCB0LCBlLCBpLCBuKSB7XG4gIHJldHVybiBgXG4gICAgICA8ZGl2IGNsYXNzPVwiJHtuLmRhdGVwaWNrZXJIZWFkZXJ9XCIgZGF0YS10ZS1kYXRlcGlja2VyLWhlYWRlcj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7bi5kYXRlcGlja2VyVGl0bGV9XCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCIke24uZGF0ZXBpY2tlclRpdGxlVGV4dH1cIj4ke2kudGl0bGV9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7bi5kYXRlcGlja2VyRGF0ZX1cIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7bi5kYXRlcGlja2VyRGF0ZVRleHR9XCIgJHtqZn0gPiR7aS53ZWVrZGF5c1Nob3J0W3RdfSwgJHtpLm1vbnRoc1Nob3J0W2VdfSAke3N9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG59XG5mdW5jdGlvbiBGYShzLCB0LCBlLCBpLCBuLCBvLCByLCBhLCBsLCBwLCB1KSB7XG4gIGxldCBfO1xuICByZXR1cm4gci5pbmxpbmUgPyBfID0gYFxuICAgIDxkaXYgY2xhc3M9XCIke3UuZGF0ZXBpY2tlck1haW59XCI+XG4gICAgICAke2phKHQsIGUsIHIsIHUpfVxuICAgICAgPGRpdiBjbGFzcz1cIiR7dS5kYXRlcGlja2VyVmlld31cIiAke1dhfSB0YWJpbmRleD1cIjBcIj5cbiAgICAgICAgJHtZYShcbiAgICBzLFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhLFxuICAgIGwsXG4gICAgcCxcbiAgICB1XG4gICl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCA6IF8gPSBgXG4gICAgPGRpdiBjbGFzcz1cIiR7dS5kYXRlcGlja2VyTWFpbn1cIj5cbiAgICAgICR7amEodCwgZSwgciwgdSl9XG4gICAgICA8ZGl2IGNsYXNzPVwiJHt1LmRhdGVwaWNrZXJWaWV3fVwiICR7V2F9IHRhYmluZGV4PVwiMFwiPlxuICAgICAgICAke1lhKFxuICAgIHMsXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGEsXG4gICAgbCxcbiAgICBwLFxuICAgIHVcbiAgKX1cbiAgICAgIDwvZGl2PlxuICAgICAgJHt0bShyLCB1KX1cbiAgICA8L2Rpdj5cbiAgYCwgXztcbn1cbmZ1bmN0aW9uIFlhKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEsIGwsIHApIHtcbiAgbGV0IHU7XG4gIHJldHVybiBvLnZpZXcgPT09IFwiZGF5c1wiID8gdSA9IFhzKHMsIGUsIG8sIHApIDogby52aWV3ID09PSBcIm1vbnRoc1wiID8gdSA9IEdzKFxuICAgIHQsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBwXG4gICkgOiB1ID0gcXMoXG4gICAgcyxcbiAgICBpLFxuICAgIG8sXG4gICAgYSxcbiAgICBsLFxuICAgIHBcbiAgKSwgdTtcbn1cbmZ1bmN0aW9uIGphKHMsIHQsIGUsIGkpIHtcbiAgcmV0dXJuIGBcbiAgICA8ZGl2IGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJEYXRlQ29udHJvbHN9XCI+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJWaWV3Q2hhbmdlQnV0dG9ufVwiIGFyaWEtbGFiZWw9XCIke2Uuc3dpdGNoVG9NdWx0aVllYXJWaWV3TGFiZWx9XCIgJHtxZn0+XG4gICAgICAgICR7ZS5tb250aHNGdWxsW3NdfSAke3R9ICR7THQoXG4gICAgZSxcbiAgICBpXG4gICl9XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxkaXYgY2xhc3M9XCIke2kuZGF0ZXBpY2tlckFycm93Q29udHJvbHN9XCI+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCIke2kuZGF0ZXBpY2tlclByZXZpb3VzQnV0dG9ufVwiIGFyaWEtbGFiZWw9XCIke2UucHJldk1vbnRoTGFiZWx9XCIgJHtLZn0+JHtlLmNoYW5nZU1vbnRoSWNvblRlbXBsYXRlfTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJOZXh0QnV0dG9ufVwiIGFyaWEtbGFiZWw9XCIke2UubmV4dE1vbnRoTGFiZWx9XCIgJHt6Zn0+JHtlLmNoYW5nZU1vbnRoSWNvblRlbXBsYXRlfTwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYDtcbn1cbmZ1bmN0aW9uIEx0KHMsIHQpIHtcbiAgcmV0dXJuIGBcbiAgPHNwYW4gY2xhc3M9XCIke3QuZGF0ZXBpY2tlclZpZXdDaGFuZ2VJY29ufVwiPlxuICAke3Mudmlld0NoYW5nZUljb25UZW1wbGF0ZX1cbiAgPC9zcGFuPlxuICBgO1xufVxuZnVuY3Rpb24gdG0ocywgdCkge1xuICBjb25zdCBlID0gYDxidXR0b24gY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3RlckJ0bn1cIiBhcmlhLWxhYmVsPVwiJHtzLm9rQnRuTGFiZWx9XCIgJHtVZn0+JHtzLm9rQnRuVGV4dH08L2J1dHRvbj5gLCBpID0gYDxidXR0b24gY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3RlckJ0bn1cIiBhcmlhLWxhYmVsPVwiJHtzLmNhbmNlbEJ0bkxhYmVsfVwiICR7WGZ9PiR7cy5jYW5jZWxCdG5UZXh0fTwvYnV0dG9uPmAsIG4gPSBgPGJ1dHRvbiBjbGFzcz1cIiR7dC5kYXRlcGlja2VyRm9vdGVyQnRufSAke3QuZGF0ZXBpY2tlckNsZWFyQnRufVwiIGFyaWEtbGFiZWw9XCIke3MuY2xlYXJCdG5MYWJlbH1cIiAke0dmfT4ke3MuY2xlYXJCdG5UZXh0fTwvYnV0dG9uPmA7XG4gIHJldHVybiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3Rlcn1cIj5cbiAgICAgICAgICBcbiAgICAgICAgJHtzLnJlbW92ZUNsZWFyQnRuID8gXCJcIiA6IG59XG4gICAgICAgICR7cy5yZW1vdmVDYW5jZWxCdG4gPyBcIlwiIDogaX1cbiAgICAgICAgJHtzLnJlbW92ZU9rQnRuID8gXCJcIiA6IGV9XG4gICAgICAgIDwvZGl2PlxuICAgICAgYDtcbn1cbmZ1bmN0aW9uIFhzKHMsIHQsIGUsIGkpIHtcbiAgY29uc3QgbiA9IGVtKHMsIHQsIGUpLCByID0gYFxuICAgICAgPHRyPlxuICAgICAgICAke2Uud2Vla2RheXNOYXJyb3cubWFwKChsLCBwKSA9PiBgPHRoIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJEYXlIZWFkaW5nfVwiIHNjb3BlPVwiY29sXCIgYXJpYS1sYWJlbD1cIiR7ZS53ZWVrZGF5c0Z1bGxbcF19XCI+JHtsfTwvdGg+YCkuam9pbihcIlwiKX1cbiAgICAgIDwvdHI+XG4gICAgYCwgYSA9IG4ubWFwKChsKSA9PiBgXG4gICAgICAgIDx0cj5cbiAgICAgICAgICAke2wubWFwKChwKSA9PiBgXG4gICAgICAgICAgICAgIDx0ZFxuICAgICAgICAgICAgICBjbGFzcz1cIiR7aS5kYXRlcGlja2VyQ2VsbH0gJHtpLmRhdGVwaWNrZXJDZWxsU21hbGx9XCJcbiAgICAgICAgICAgICAgZGF0YS10ZS1kYXRlPVwiJHtCKHAuZGF0ZSl9LSR7WShcbiAgICBwLmRhdGVcbiAgKX0tJHt0dChwLmRhdGUpfVwiXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCIke3AuZGF0ZX1cIlxuICAgICAgICAgICAgICBhcmlhLXNlbGVjdGVkPVwiJHtwLmlzU2VsZWN0ZWR9XCJcbiAgICAgICAgICAgICAgJHtwLmlzU2VsZWN0ZWQgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIgOiBcIlwifVxuICAgICAgICAgICAgICAkeyFwLmN1cnJlbnRNb250aCB8fCBwLmRpc2FibGVkID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgJHtwLmlzVG9kYXkgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICBjbGFzcz1cIiR7aS5kYXRlcGlja2VyQ2VsbENvbnRlbnR9ICR7aS5kYXRlcGlja2VyQ2VsbENvbnRlbnRTbWFsbH1cIlxuICAgICAgICAgICAgICAgICAgc3R5bGU9XCIke3AuY3VycmVudE1vbnRoID8gXCJkaXNwbGF5OiBibG9ja1wiIDogXCJkaXNwbGF5OiBub25lXCJ9XCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICR7cC5kYXlOdW1iZXJ9XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIGApLmpvaW4oXCJcIil9XG4gICAgICAgIDwvdHI+XG4gICAgICBgKS5qb2luKFwiXCIpO1xuICByZXR1cm4gYFxuICAgICAgPHRhYmxlIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJUYWJsZX1cIj5cbiAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICR7cn1cbiAgICAgICAgPC90aGVhZD5cbiAgICAgICAgPHRib2R5PlxuICAgICAgICAgJHthfVxuICAgICAgICA8L3Rib2R5PlxuICAgICAgPC90YWJsZT5cbiAgICBgO1xufVxuZnVuY3Rpb24gZW0ocywgdCwgZSkge1xuICBjb25zdCBpID0gW10sIG4gPSBZKHMpLCBvID0gWShsdChzLCAtMSkpLCByID0gWShsdChzLCAxKSksIGEgPSBCKHMpLCBsID0gTmYoYSwgbiwgZSksIHAgPSBHbyhzKSwgdSA9IEdvKGx0KHMsIC0xKSksIF8gPSA3O1xuICBsZXQgZiA9IDEsIGcgPSAhMTtcbiAgZm9yIChsZXQgbSA9IDE7IG0gPCBfOyBtKyspIHtcbiAgICBjb25zdCBiID0gW107XG4gICAgaWYgKG0gPT09IDEpIHtcbiAgICAgIGNvbnN0IHYgPSB1IC0gbCArIDE7XG4gICAgICBmb3IgKGxldCB5ID0gdjsgeSA8PSB1OyB5KyspIHtcbiAgICAgICAgY29uc3QgQyA9IEN0KGEsIG8sIHkpO1xuICAgICAgICBiLnB1c2goe1xuICAgICAgICAgIGRhdGU6IEMsXG4gICAgICAgICAgY3VycmVudE1vbnRoOiBnLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IHQgJiYgbWUoQywgdCksXG4gICAgICAgICAgaXNUb2RheTogbWUoQywgamUoKSksXG4gICAgICAgICAgZGF5TnVtYmVyOiB0dChDKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGcgPSAhMDtcbiAgICAgIGNvbnN0IFQgPSBfIC0gYi5sZW5ndGg7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IFQ7IHkrKykge1xuICAgICAgICBjb25zdCBDID0gQ3QoYSwgbiwgZik7XG4gICAgICAgIGIucHVzaCh7XG4gICAgICAgICAgZGF0ZTogQyxcbiAgICAgICAgICBjdXJyZW50TW9udGg6IGcsXG4gICAgICAgICAgaXNTZWxlY3RlZDogdCAmJiBtZShDLCB0KSxcbiAgICAgICAgICBpc1RvZGF5OiBtZShDLCBqZSgpKSxcbiAgICAgICAgICBkYXlOdW1iZXI6IHR0KEMpLFxuICAgICAgICAgIGRpc2FibGVkOiBfbihcbiAgICAgICAgICAgIEMsXG4gICAgICAgICAgICBlLm1pbixcbiAgICAgICAgICAgIGUubWF4LFxuICAgICAgICAgICAgZS5maWx0ZXIsXG4gICAgICAgICAgICBlLmRpc2FibGVQYXN0LFxuICAgICAgICAgICAgZS5kaXNhYmxlRnV0dXJlXG4gICAgICAgICAgKVxuICAgICAgICB9KSwgZisrO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZm9yIChsZXQgdiA9IDE7IHYgPCA4OyB2KyspIHtcbiAgICAgICAgZiA+IHAgJiYgKGYgPSAxLCBnID0gITEpO1xuICAgICAgICBjb25zdCBUID0gQ3QoXG4gICAgICAgICAgYSxcbiAgICAgICAgICBnID8gbiA6IHIsXG4gICAgICAgICAgZlxuICAgICAgICApO1xuICAgICAgICBiLnB1c2goe1xuICAgICAgICAgIGRhdGU6IFQsXG4gICAgICAgICAgY3VycmVudE1vbnRoOiBnLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IHQgJiYgbWUoVCwgdCksXG4gICAgICAgICAgaXNUb2RheTogbWUoVCwgamUoKSksXG4gICAgICAgICAgZGF5TnVtYmVyOiB0dChUKSxcbiAgICAgICAgICBkaXNhYmxlZDogX24oXG4gICAgICAgICAgICBULFxuICAgICAgICAgICAgZS5taW4sXG4gICAgICAgICAgICBlLm1heCxcbiAgICAgICAgICAgIGUuZmlsdGVyLFxuICAgICAgICAgICAgZS5kaXNhYmxlUGFzdCxcbiAgICAgICAgICAgIGUuZGlzYWJsZUZ1dHVyZVxuICAgICAgICAgIClcbiAgICAgICAgfSksIGYrKztcbiAgICAgIH1cbiAgICBpLnB1c2goYik7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBHcyhzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSBpbShpLCBuKSwgYSA9IFkoamUoKSksIGwgPSBCKGplKCkpLCBwID0gYFxuICAgICAgJHtyLm1hcCgodSkgPT4gYFxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICR7dS5tYXAoKF8pID0+IHtcbiAgICBjb25zdCBmID0gaS5tb250aHNTaG9ydC5pbmRleE9mKF8pO1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiJHtvLmRhdGVwaWNrZXJDZWxsfSAke28uZGF0ZXBpY2tlckNlbGxMYXJnZX1cIlxuICAgICAgICAgICAgICAgICR7X2goXG4gICAgICBmLFxuICAgICAgcyxcbiAgICAgIGkubWluLFxuICAgICAgaS5tYXgsXG4gICAgICBpLmRpc2FibGVQYXN0LFxuICAgICAgaS5kaXNhYmxlRnV0dXJlXG4gICAgKSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZGF0YS10ZS1tb250aD1cIiR7Zn1cIiBkYXRhLXRlLXllYXI9XCIke3N9XCIgYXJpYS1sYWJlbD1cIiR7X30sICR7c31cIlxuICAgICAgICAgICAgICAgICR7ZiA9PT0gZSAmJiBzID09PSB0ID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgICAke2YgPT09IGEgJiYgcyA9PT0gbCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudFwiIDogXCJcIn1cIiBkYXRhLXRlLW1vbnRoPVwiJHtmfVwiIGRhdGEtdGUteWVhcj1cIiR7c31cIiBhcmlhLWxhYmVsPVwiJHtffSwgJHtzfVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnR9ICR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnRMYXJnZX1cIj4ke199PC9kaXY+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgYDtcbiAgfSkuam9pbihcIlwiKX1cbiAgICAgICAgICA8L3RyPlxuICAgICAgICBgKS5qb2luKFwiXCIpfVxuICAgIGA7XG4gIHJldHVybiBgXG4gICAgICA8dGFibGUgY2xhc3M9XCIke28uZGF0ZXBpY2tlclRhYmxlfVwiPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAke3B9XG4gICAgICAgIDwvdGJvZHk+XG4gICAgICA8L3RhYmxlPlxuICAgIGA7XG59XG5mdW5jdGlvbiBpbShzLCB0KSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgbGV0IGkgPSBbXTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLm1vbnRoc1Nob3J0Lmxlbmd0aDsgbisrKVxuICAgIGlmIChpLnB1c2gocy5tb250aHNTaG9ydFtuXSksIGkubGVuZ3RoID09PSB0KSB7XG4gICAgICBjb25zdCBvID0gaTtcbiAgICAgIGUucHVzaChvKSwgaSA9IFtdO1xuICAgIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBxcyhzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSBzbShzLCBpLCBuKSwgYSA9IEIoamUoKSksIGwgPSBgXG4gICAgJHtyLm1hcCgocCkgPT4gYFxuICAgICAgICA8dHI+XG4gICAgICAgICAgJHtwLm1hcCgodSkgPT4gYFxuICAgICAgICAgICAgICA8dGQgY2xhc3M9XCIke28uZGF0ZXBpY2tlckNlbGx9ICR7by5kYXRlcGlja2VyQ2VsbExhcmdlfVwiICBhcmlhLWxhYmVsPVwiJHt1fVwiIGRhdGEtdGUteWVhcj1cIiR7dX1cIlxuICAgICAgICAgICAgICAke3FvKFxuICAgIHUsXG4gICAgZS5taW4sXG4gICAgZS5tYXgsXG4gICAgZS5kaXNhYmxlUGFzdCxcbiAgICBlLmRpc2FibGVGdXR1cmVcbiAgKSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7dSA9PT0gdCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7dSA9PT0gYSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke28uZGF0ZXBpY2tlckNlbGxDb250ZW50fSAke28uZGF0ZXBpY2tlckNlbGxDb250ZW50TGFyZ2V9XCI+JHt1fTwvZGl2PlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgYCkuam9pbihcIlwiKX1cbiAgICAgICAgPC90cj5cbiAgICAgIGApLmpvaW4oXCJcIil9XG4gIGA7XG4gIHJldHVybiBgXG4gICAgICA8dGFibGUgY2xhc3M9XCIke28uZGF0ZXBpY2tlclRhYmxlfVwiPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICR7bH1cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgYDtcbn1cbmZ1bmN0aW9uIHNtKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IFtdLCBuID0gQihzKSwgbyA9IFVzKHMsIHQpLCByID0gbiAtIG87XG4gIGxldCBhID0gW107XG4gIGZvciAobGV0IGwgPSAwOyBsIDwgdDsgbCsrKVxuICAgIGlmIChhLnB1c2gociArIGwpLCBhLmxlbmd0aCA9PT0gZSkge1xuICAgICAgY29uc3QgcCA9IGE7XG4gICAgICBpLnB1c2gocCksIGEgPSBbXTtcbiAgICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gbm0ocywgdCkge1xuICByZXR1cm4gYFxuICAgIDxidXR0b24gaWQ9XCIke3N9XCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHt0fVwiIGRhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZiBkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLXJlZj5cbiAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+XG4gICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk02Ljc1IDIuMjVBLjc1Ljc1IDAgMDE3LjUgM3YxLjVoOVYzQS43NS43NSAwIDAxMTggM3YxLjVoLjc1YTMgMyAwIDAxMyAzdjExLjI1YTMgMyAwIDAxLTMgM0g1LjI1YTMgMyAwIDAxLTMtM1Y3LjVhMyAzIDAgMDEzLTNINlYzYS43NS43NSAwIDAxLjc1LS43NXptMTMuNSA5YTEuNSAxLjUgMCAwMC0xLjUtMS41SDUuMjVhMS41IDEuNSAwIDAwLTEuNSAxLjV2Ny41YTEuNSAxLjUgMCAwMDEuNSAxLjVoMTMuNWExLjUgMS41IDAgMDAxLjUtMS41di03LjV6XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICA8L3N2Zz4gIFxuICAgIDwvYnV0dG9uPlxuICBgO1xufVxuY29uc3QgS2UgPSAzNywgVSA9IDM4LCB6ZSA9IDM5LCB6ID0gNDAsIFRlID0gMzYsIEVlID0gMzUsIGlvID0gMzMsIHNvID0gMzQsIGl0ID0gMTMsIFpzID0gMzIsIHdlID0gMjcsIGtlID0gOSwgb20gPSA4LCBybSA9IDQ2LCBUdCA9IDI0LCBwcyA9IDQsIF9zID0gNCwgbm8gPSBcImRhdGVwaWNrZXJcIiwgUXMgPSBcInRlLmRhdGVwaWNrZXJcIiwgRW4gPSBgLiR7UXN9YCwgYW0gPSBcIi5kYXRhLWFwaVwiLCBsbSA9IGBjbG9zZSR7RW59YCwgY20gPSBgb3BlbiR7RW59YCwgaG0gPSBgZGF0ZUNoYW5nZSR7RW59YCwgZnMgPSBgY2xpY2ske0VufSR7YW19YCwgZmggPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1tb2RhbC1jb250YWluZXItcmVmXCIsIG1oID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItZHJvcGRvd24tY29udGFpbmVyLXJlZlwiLCBtcyA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtcmVmXVwiLCBkbSA9IGBbJHtmaH1dYCwgdW0gPSBgWyR7bWh9XWAsIHBtID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctY2hhbmdlLWJ1dHRvbi1yZWZdXCIsIF9tID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXByZXZpb3VzLWJ1dHRvbi1yZWZdXCIsIGZtID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLW5leHQtYnV0dG9uLXJlZl1cIiwgbW0gPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItb2stYnV0dG9uLXJlZl1cIiwgZ20gPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItY2FuY2VsLWJ1dHRvbi1yZWZdXCIsIGJtID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLWNsZWFyLWJ1dHRvbi1yZWZdXCIsIHZtID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLXZpZXctcmVmXVwiLCBUbSA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZl1cIiwgRW0gPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItZGF0ZS10ZXh0LXJlZl1cIiwgQ20gPSBcIltkYXRhLXRlLWRyb3Bkb3duLWJhY2tkcm9wLXJlZl1cIiwgQW0gPSBcImFuaW1hdGUtW2ZhZGUtaW5fMC4zc19ib3RoXSBweC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIiwgeW0gPSBcImFuaW1hdGUtW2ZhZGUtb3V0XzAuM3NfYm90aF0gcHgtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsIHdtID0gXCJhbmltYXRlLVtmYWRlLWluXzAuMTVzX2JvdGhdIHB4LVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLCBrbSA9IFwiYW5pbWF0ZS1bZmFkZS1vdXRfMC4xNXNfYm90aF0gcHgtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsIHhtID0gXCJmbGV4IGZsZXgtY29sIGZpeGVkIHRvcC0xLzIgbGVmdC0xLzIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIHctWzMyOHB4XSBoLVs1MTJweF0gYmctd2hpdGUgcm91bmRlZC1bMC42cmVtXSBzaGFkb3ctbGcgei1bMTA2Nl0geHM6bWF4LW1kOmxhbmRzY2FwZTp3LVs0NzVweF0geHM6bWF4LW1kOmxhbmRzY2FwZTpoLVszNjBweF0geHM6bWF4LW1kOmxhbmRzY2FwZTpmbGV4LXJvdyBkYXJrOmJnLXppbmMtNzAwXCIsIE9tID0gXCJ3LWZ1bGwgaC1mdWxsIGZpeGVkIHRvcC0wIHJpZ2h0LTAgbGVmdC0wIGJvdHRvbS0wIGJnLWJsYWNrLzQwIHotWzEwNjVdXCIsIFNtID0gXCJyZWxhdGl2ZSBoLWZ1bGxcIiwgSW0gPSBcInhzOm1heC1tZDpsYW5kc2NhcGU6aC1mdWxsIGgtWzEyMHB4XSBweC02IGJnLXByaW1hcnkgZmxleCBmbGV4LWNvbCByb3VuZGVkLXQtbGcgZGFyazpiZy16aW5jLTgwMFwiLCBEbSA9IFwiaC04IGZsZXggZmxleC1jb2wganVzdGlmeS1lbmRcIiwgJG0gPSBcInRleHQtWzEwcHhdIGZvbnQtbm9ybWFsIHVwcGVyY2FzZSB0cmFja2luZy1bMS43cHhdIHRleHQtd2hpdGVcIiwgTG0gPSBcInhzOm1heC1tZDpsYW5kc2NhcGU6bXQtMjQgaC1bNzJweF0gZmxleCBmbGV4LWNvbCBqdXN0aWZ5LWVuZFwiLCBObSA9IFwidGV4dC1bMzRweF0gZm9udC1ub3JtYWwgdGV4dC13aGl0ZVwiLCBNbSA9IFwib3V0bGluZS1ub25lIHB4LTNcIiwgUm0gPSBcInB4LTMgcHQtMi41IHBiLTAgZmxleCBqdXN0aWZ5LWJldHdlZW4gdGV4dC1ibGFjay9bNjRdXCIsIFBtID0gXCJmbGV4IGl0ZW1zLWNlbnRlciBvdXRsaW5lLW5vbmUgcC0yLjUgdGV4dC1uZXV0cmFsLTUwMCBmb250LW1lZGl1bSB0ZXh0LVswLjlyZW1dIHJvdW5kZWQteGwgc2hhZG93LW5vbmUgYmctdHJhbnNwYXJlbnQgbS0wIGJvcmRlci1ub25lIGhvdmVyOmJnLW5ldXRyYWwtMjAwIGZvY3VzOmJnLW5ldXRyYWwtMjAwICBkYXJrOnRleHQtd2hpdGUgZGFyazpob3ZlcjpiZy13aGl0ZS8xMCBkYXJrOmZvY3VzOmJnLXdoaXRlLzEwXCIsIEJtID0gXCJtdC0yLjVcIiwgSG0gPSBcInAtMCB3LTEwIGgtMTAgbGVhZGluZy0xMCBib3JkZXItbm9uZSBvdXRsaW5lLW5vbmUgbS0wIHRleHQtZ3JheS02MDAgYmctdHJhbnNwYXJlbnQgbXItNiBob3ZlcjpiZy1uZXV0cmFsLTIwMCBob3Zlcjpyb3VuZGVkLVs1MCVdIGZvY3VzOmJnLW5ldXRyYWwtMjAwIGZvY3VzOnJvdW5kZWQtWzUwJV0gZGFyazp0ZXh0LXdoaXRlIGRhcms6aG92ZXI6Ymctd2hpdGUvMTAgZGFyazpmb2N1czpiZy13aGl0ZS8xMCBbJj5zdmddOnctNCBbJj5zdmddOmgtNCBbJj5zdmddOm14LWF1dG9cIiwgVm0gPSBcInAtMCB3LTEwIGgtMTAgbGVhZGluZy0xMCBib3JkZXItbm9uZSBvdXRsaW5lLW5vbmUgbS0wIHRleHQtZ3JheS02MDAgYmctdHJhbnNwYXJlbnQgaG92ZXI6YmctbmV1dHJhbC0yMDAgaG92ZXI6cm91bmRlZC1bNTAlXSBmb2N1czpiZy1uZXV0cmFsLTIwMCBmb2N1czpyb3VuZGVkLVs1MCVdIGRhcms6dGV4dC13aGl0ZSBkYXJrOmhvdmVyOmJnLXdoaXRlLzEwIGRhcms6Zm9jdXM6Ymctd2hpdGUvMTAgWyY+c3ZnXTp3LTQgWyY+c3ZnXTpoLTQgWyY+c3ZnXTpyb3RhdGUtMTgwIFsmPnN2Z106bXgtYXV0b1wiLCBXbSA9IFwiaC0xNCBmbGV4IGFic29sdXRlIHctZnVsbCBib3R0b20tMCBqdXN0aWZ5LWVuZCBpdGVtcy1jZW50ZXIgcHgtM1wiLCBGbSA9IFwib3V0bGluZS1ub25lIGJnLXdoaXRlIHRleHQtcHJpbWFyeSBib3JkZXItbm9uZSBjdXJzb3ItcG9pbnRlciBweS0wIHB4LTIuNSB1cHBlcmNhc2UgdGV4dC1bMC44cmVtXSBsZWFkaW5nLTEwIGZvbnQtbWVkaXVtIGgtMTAgdHJhY2tpbmctWy4xcmVtXSByb3VuZGVkLVsxMHB4XSBtYi0yLjUgaG92ZXI6YmctbmV1dHJhbC0yMDAgZm9jdXM6YmctbmV1dHJhbC0yMDAgZGFyazpiZy10cmFuc3BhcmVudCBkYXJrOnRleHQtd2hpdGUgZGFyazpob3ZlcjpiZy13aGl0ZS8xMCBkYXJrOmZvY3VzOmJnLXdoaXRlLzEwXCIsIFltID0gXCJtci1hdXRvXCIsIGptID0gXCJ3LTEwIGgtMTAgdGV4dC1jZW50ZXIgdGV4dC1bMTJweF0gZm9udC1ub3JtYWwgZGFyazp0ZXh0LXdoaXRlXCIsIEttID0gXCJ0ZXh0LWNlbnRlciBkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdOnRleHQtbmV1dHJhbC0zMDAgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTpjdXJzb3ItZGVmYXVsdCBkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdOnBvaW50ZXItZXZlbnRzLW5vbmUgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTpob3ZlcjpjdXJzb3ItZGVmYXVsdCBob3ZlcjpjdXJzb3ItcG9pbnRlciBncm91cFwiLCB6bSA9IFwidy0xMCBoLTEwIHhzOm1heC1tZDpsYW5kc2NhcGU6dy04IHhzOm1heC1tZDpsYW5kc2NhcGU6aC04XCIsIFVtID0gXCJ3LVs3NnB4XSBoLVs0MnB4XVwiLCBYbSA9IFwibXgtYXV0byBncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdKTpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXSk6aG92ZXJdOmJnLW5ldXRyYWwtMzAwIGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdXTpiZy1wcmltYXJ5IGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdXTp0ZXh0LXdoaXRlIGdyb3VwLVs6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRdXTpiZy1uZXV0cmFsLTEwMCBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRdXTpkYXRhLVt0ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdOmJnLXByaW1hcnkgZ3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XV06Ym9yZGVyLXNvbGlkIGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudF1dOmJvcmRlci1ibGFjayBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRdXTpib3JkZXIgZGFyazpncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdKTpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXSk6aG92ZXJdOmJnLXdoaXRlLzEwIGRhcms6Z3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XV06Ym9yZGVyLXdoaXRlIGRhcms6dGV4dC13aGl0ZSBkYXJrOmdyb3VwLVs6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRdXTpiZy13aGl0ZS8xMCBkYXJrOmdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRdXTp0ZXh0LW5ldXRyYWwtNTAwXCIsIEdtID0gXCJ3LTkgaC05IGxlYWRpbmctOSByb3VuZGVkLVs1MCVdIHRleHQtWzEzcHhdXCIsIHFtID0gXCJ3LVs3MnB4XSBoLTEwIGxlYWRpbmctMTAgcHktWzFweF0gcHgtMC41IHJvdW5kZWQtWzk5OXB4XVwiLCBabSA9IFwibXgtYXV0byB3LVszMDRweF1cIiwgUW0gPSBcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY29udGVudC1jZW50ZXIgWyY+c3ZnXTp3LTUgWyY+c3ZnXTpoLTUgYWJzb2x1dGUgb3V0bGluZS1ub25lIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHJpZ2h0LTAuNSB0b3AtMS8yIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiBob3Zlcjp0ZXh0LXByaW1hcnkgZm9jdXM6dGV4dC1wcmltYXJ5IGRhcms6aG92ZXI6dGV4dC1wcmltYXJ5LTQwMCBkYXJrOmZvY3VzOnRleHQtcHJpbWFyeS00MDAgZGFyazp0ZXh0LW5ldXRyYWwtMjAwXCIsIEptID0gXCJpbmxpbmUtYmxvY2sgcG9pbnRlci1ldmVudHMtbm9uZSBtbC1bM3B4XSBbJj5zdmddOnctNCBbJj5zdmddOmgtNCBbJj5zdmddOmZpbGwtbmV1dHJhbC01MDAgZGFyazpbJj5zdmddOmZpbGwtd2hpdGVcIiwgdGcgPSBcInctWzMyOHB4XSBoLVszODBweF0gYmctd2hpdGUgcm91bmRlZC1sZyBzaGFkb3ctWzBweF8ycHhfMTVweF8tM3B4X3JnYmEoMCwwLDAsLjA3KSxfMHB4XzEwcHhfMjBweF8tMnB4X3JnYmEoMCwwLDAsLjA0KV0gei1bMTA2Nl0gZGFyazpiZy16aW5jLTcwMFwiLCBlZyA9IHtcbiAgdGl0bGU6IFwiU2VsZWN0IGRhdGVcIixcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgZGlzYWJsZVBhc3Q6ICExLFxuICBkaXNhYmxlRnV0dXJlOiAhMSxcbiAgbW9udGhzRnVsbDogW1xuICAgIFwiSmFudWFyeVwiLFxuICAgIFwiRmVicnVhcnlcIixcbiAgICBcIk1hcmNoXCIsXG4gICAgXCJBcHJpbFwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5lXCIsXG4gICAgXCJKdWx5XCIsXG4gICAgXCJBdWd1c3RcIixcbiAgICBcIlNlcHRlbWJlclwiLFxuICAgIFwiT2N0b2JlclwiLFxuICAgIFwiTm92ZW1iZXJcIixcbiAgICBcIkRlY2VtYmVyXCJcbiAgXSxcbiAgbW9udGhzU2hvcnQ6IFtcbiAgICBcIkphblwiLFxuICAgIFwiRmViXCIsXG4gICAgXCJNYXJcIixcbiAgICBcIkFwclwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5cIixcbiAgICBcIkp1bFwiLFxuICAgIFwiQXVnXCIsXG4gICAgXCJTZXBcIixcbiAgICBcIk9jdFwiLFxuICAgIFwiTm92XCIsXG4gICAgXCJEZWNcIlxuICBdLFxuICB3ZWVrZGF5c0Z1bGw6IFtcbiAgICBcIlN1bmRheVwiLFxuICAgIFwiTW9uZGF5XCIsXG4gICAgXCJUdWVzZGF5XCIsXG4gICAgXCJXZWRuZXNkYXlcIixcbiAgICBcIlRodXJzZGF5XCIsXG4gICAgXCJGcmlkYXlcIixcbiAgICBcIlNhdHVyZGF5XCJcbiAgXSxcbiAgd2Vla2RheXNTaG9ydDogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICB3ZWVrZGF5c05hcnJvdzogW1wiU1wiLCBcIk1cIiwgXCJUXCIsIFwiV1wiLCBcIlRcIiwgXCJGXCIsIFwiU1wiXSxcbiAgb2tCdG5UZXh0OiBcIk9rXCIsXG4gIGNsZWFyQnRuVGV4dDogXCJDbGVhclwiLFxuICBjYW5jZWxCdG5UZXh0OiBcIkNhbmNlbFwiLFxuICBva0J0bkxhYmVsOiBcIkNvbmZpcm0gc2VsZWN0aW9uXCIsXG4gIGNsZWFyQnRuTGFiZWw6IFwiQ2xlYXIgc2VsZWN0aW9uXCIsXG4gIGNhbmNlbEJ0bkxhYmVsOiBcIkNhbmNlbCBzZWxlY3Rpb25cIixcbiAgbmV4dE1vbnRoTGFiZWw6IFwiTmV4dCBtb250aFwiLFxuICBwcmV2TW9udGhMYWJlbDogXCJQcmV2aW91cyBtb250aFwiLFxuICBuZXh0WWVhckxhYmVsOiBcIk5leHQgeWVhclwiLFxuICBwcmV2WWVhckxhYmVsOiBcIlByZXZpb3VzIHllYXJcIixcbiAgY2hhbmdlTW9udGhJY29uVGVtcGxhdGU6IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTYgaC02XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTUuNzUgMTkuNUw4LjI1IDEybDcuNS03LjVcIiAvPlxuICA8L3N2Zz5cbiAgYCxcbiAgbmV4dE11bHRpWWVhckxhYmVsOiBcIk5leHQgMjQgeWVhcnNcIixcbiAgcHJldk11bHRpWWVhckxhYmVsOiBcIlByZXZpb3VzIDI0IHllYXJzXCIsXG4gIHN3aXRjaFRvTXVsdGlZZWFyVmlld0xhYmVsOiBcIkNob29zZSB5ZWFyIGFuZCBtb250aFwiLFxuICBzd2l0Y2hUb01vbnRoVmlld0xhYmVsOiBcIkNob29zZSBkYXRlXCIsXG4gIHN3aXRjaFRvRGF5Vmlld0xhYmVsOiBcIkNob29zZSBkYXRlXCIsXG4gIHN0YXJ0RGF0ZTogbnVsbCxcbiAgc3RhcnREYXk6IDAsXG4gIGZvcm1hdDogXCJkZC9tbS95eXl5XCIsXG4gIHZpZXc6IFwiZGF5c1wiLFxuICB2aWV3Q2hhbmdlSWNvblRlbXBsYXRlOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMFwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy02IGgtNlwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbiAgPC9zdmc+XG4gIGAsXG4gIG1pbjogbnVsbCxcbiAgbWF4OiBudWxsLFxuICBmaWx0ZXI6IG51bGwsXG4gIGlubGluZTogITEsXG4gIHRvZ2dsZUJ1dHRvbjogITAsXG4gIGRpc2FibGVUb2dnbGVCdXR0b246ICExLFxuICBkaXNhYmxlSW5wdXQ6ICExLFxuICBhbmltYXRpb25zOiAhMCxcbiAgY29uZmlybURhdGVPblNlbGVjdDogITEsXG4gIHJlbW92ZU9rQnRuOiAhMSxcbiAgcmVtb3ZlQ2FuY2VsQnRuOiAhMSxcbiAgcmVtb3ZlQ2xlYXJCdG46ICExXG59LCBpZyA9IHtcbiAgdGl0bGU6IFwic3RyaW5nXCIsXG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZGlzYWJsZVBhc3Q6IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlRnV0dXJlOiBcImJvb2xlYW5cIixcbiAgbW9udGhzRnVsbDogXCJhcnJheVwiLFxuICBtb250aHNTaG9ydDogXCJhcnJheVwiLFxuICB3ZWVrZGF5c0Z1bGw6IFwiYXJyYXlcIixcbiAgd2Vla2RheXNTaG9ydDogXCJhcnJheVwiLFxuICB3ZWVrZGF5c05hcnJvdzogXCJhcnJheVwiLFxuICBva0J0blRleHQ6IFwic3RyaW5nXCIsXG4gIGNsZWFyQnRuVGV4dDogXCJzdHJpbmdcIixcbiAgY2FuY2VsQnRuVGV4dDogXCJzdHJpbmdcIixcbiAgb2tCdG5MYWJlbDogXCJzdHJpbmdcIixcbiAgY2xlYXJCdG5MYWJlbDogXCJzdHJpbmdcIixcbiAgY2FuY2VsQnRuTGFiZWw6IFwic3RyaW5nXCIsXG4gIG5leHRNb250aExhYmVsOiBcInN0cmluZ1wiLFxuICBwcmV2TW9udGhMYWJlbDogXCJzdHJpbmdcIixcbiAgbmV4dFllYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgcHJldlllYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgbmV4dE11bHRpWWVhckxhYmVsOiBcInN0cmluZ1wiLFxuICBwcmV2TXVsdGlZZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNoYW5nZU1vbnRoSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBzd2l0Y2hUb011bHRpWWVhclZpZXdMYWJlbDogXCJzdHJpbmdcIixcbiAgc3dpdGNoVG9Nb250aFZpZXdMYWJlbDogXCJzdHJpbmdcIixcbiAgc3dpdGNoVG9EYXlWaWV3TGFiZWw6IFwic3RyaW5nXCIsXG4gIHN0YXJ0RGF0ZTogXCIobnVsbHxzdHJpbmd8ZGF0ZSlcIixcbiAgc3RhcnREYXk6IFwibnVtYmVyXCIsXG4gIGZvcm1hdDogXCJzdHJpbmdcIixcbiAgdmlldzogXCJzdHJpbmdcIixcbiAgdmlld0NoYW5nZUljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgbWluOiBcIihudWxsfHN0cmluZ3xkYXRlKVwiLFxuICBtYXg6IFwiKG51bGx8c3RyaW5nfGRhdGUpXCIsXG4gIGZpbHRlcjogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgaW5saW5lOiBcImJvb2xlYW5cIixcbiAgdG9nZ2xlQnV0dG9uOiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZVRvZ2dsZUJ1dHRvbjogXCJib29sZWFuXCIsXG4gIGRpc2FibGVJbnB1dDogXCJib29sZWFuXCIsXG4gIGFuaW1hdGlvbnM6IFwiYm9vbGVhblwiLFxuICBjb25maXJtRGF0ZU9uU2VsZWN0OiBcImJvb2xlYW5cIixcbiAgcmVtb3ZlT2tCdG46IFwiYm9vbGVhblwiLFxuICByZW1vdmVDYW5jZWxCdG46IFwiYm9vbGVhblwiLFxuICByZW1vdmVDbGVhckJ0bjogXCJib29sZWFuXCJcbn0sIHNnID0ge1xuICBmYWRlSW46IEFtLFxuICBmYWRlT3V0OiB5bSxcbiAgZmFkZUluU2hvcnQ6IHdtLFxuICBmYWRlT3V0U2hvcnQ6IGttLFxuICBtb2RhbENvbnRhaW5lcjogeG0sXG4gIGRhdGVwaWNrZXJCYWNrZHJvcDogT20sXG4gIGRhdGVwaWNrZXJNYWluOiBTbSxcbiAgZGF0ZXBpY2tlckhlYWRlcjogSW0sXG4gIGRhdGVwaWNrZXJUaXRsZTogRG0sXG4gIGRhdGVwaWNrZXJUaXRsZVRleHQ6ICRtLFxuICBkYXRlcGlja2VyRGF0ZTogTG0sXG4gIGRhdGVwaWNrZXJEYXRlVGV4dDogTm0sXG4gIGRhdGVwaWNrZXJWaWV3OiBNbSxcbiAgZGF0ZXBpY2tlckRhdGVDb250cm9sczogUm0sXG4gIGRhdGVwaWNrZXJWaWV3Q2hhbmdlQnV0dG9uOiBQbSxcbiAgZGF0ZXBpY2tlclZpZXdDaGFuZ2VJY29uOiBKbSxcbiAgZGF0ZXBpY2tlckFycm93Q29udHJvbHM6IEJtLFxuICBkYXRlcGlja2VyUHJldmlvdXNCdXR0b246IEhtLFxuICBkYXRlcGlja2VyTmV4dEJ1dHRvbjogVm0sXG4gIGRhdGVwaWNrZXJGb290ZXI6IFdtLFxuICBkYXRlcGlja2VyRm9vdGVyQnRuOiBGbSxcbiAgZGF0ZXBpY2tlckNsZWFyQnRuOiBZbSxcbiAgZGF0ZXBpY2tlckRheUhlYWRpbmc6IGptLFxuICBkYXRlcGlja2VyQ2VsbDogS20sXG4gIGRhdGVwaWNrZXJDZWxsU21hbGw6IHptLFxuICBkYXRlcGlja2VyQ2VsbExhcmdlOiBVbSxcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50OiBYbSxcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50U21hbGw6IEdtLFxuICBkYXRlcGlja2VyQ2VsbENvbnRlbnRMYXJnZTogcW0sXG4gIGRhdGVwaWNrZXJUYWJsZTogWm0sXG4gIGRhdGVwaWNrZXJUb2dnbGVCdXR0b246IFFtLFxuICBkYXRlcGlja2VyRHJvcGRvd25Db250YWluZXI6IHRnXG59LCBuZyA9IHtcbiAgZmFkZUluOiBcInN0cmluZ1wiLFxuICBmYWRlT3V0OiBcInN0cmluZ1wiLFxuICBmYWRlSW5TaG9ydDogXCJzdHJpbmdcIixcbiAgZmFkZU91dFNob3J0OiBcInN0cmluZ1wiLFxuICBtb2RhbENvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckJhY2tkcm9wOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyTWFpbjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckhlYWRlcjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRpdGxlOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVGl0bGVUZXh0OiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRGF0ZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRhdGVUZXh0OiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVmlldzogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRhdGVDb250cm9sczogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclZpZXdDaGFuZ2VCdXR0b246IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJBcnJvd0NvbnRyb2xzOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyUHJldmlvdXNCdXR0b246IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJOZXh0QnV0dG9uOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRm9vdGVyOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRm9vdGVyQnRuOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2xlYXJCdG46IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEYXlIZWFkaW5nOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2VsbDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxTbWFsbDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxMYXJnZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50OiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQ2VsbENvbnRlbnRTbWFsbDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50TGFyZ2U6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJUYWJsZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRvZ2dsZUJ1dHRvbjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRyb3Bkb3duQ29udGFpbmVyOiBcInN0cmluZ1wiXG59O1xuY2xhc3Mgb2cge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2lucHV0ID0gZC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9hY3RpdmVEYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLl9oZWFkZXJEYXRlID0gbnVsbCwgdGhpcy5faGVhZGVyWWVhciA9IG51bGwsIHRoaXMuX2hlYWRlck1vbnRoID0gbnVsbCwgdGhpcy5fdmlldyA9IHRoaXMuX29wdGlvbnMudmlldywgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX3RvZ2dsZUJ1dHRvbklkID0gZXQoXCJkYXRlcGlja2VyLXRvZ2dsZS1cIiksIHRoaXMuX2FuaW1hdGlvbnMgPSAhd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiKS5tYXRjaGVzICYmIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9ucywgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IHRpKCksIHRoaXMuX2VsZW1lbnQgJiYgQS5zZXREYXRhKHQsIFFzLCB0aGlzKSwgdGhpcy5faW5pdCgpLCB0aGlzLnRvZ2dsZUJ1dHRvbiAmJiB0aGlzLl9vcHRpb25zLmRpc2FibGVUb2dnbGUgJiYgKHRoaXMudG9nZ2xlQnV0dG9uLmRpc2FibGVkID0gXCJ0cnVlXCIpLCB0aGlzLl9vcHRpb25zLmRpc2FibGVJbnB1dCAmJiAodGhpcy5faW5wdXQuZGlzYWJsZWQgPSBcInRydWVcIik7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIG5vO1xuICB9XG4gIGdldCBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcbiAgICAgIGBbJHtmaH09JyR7dGhpcy5fdG9nZ2xlQnV0dG9uSWR9J11gXG4gICAgKSB8fCBkLmZpbmRPbmUoXG4gICAgICBgWyR7bWh9PScke3RoaXMuX3RvZ2dsZUJ1dHRvbklkfSddYFxuICAgICk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgZ2V0IGFjdGl2ZUNlbGwoKSB7XG4gICAgbGV0IHQ7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiICYmICh0ID0gdGhpcy5fZ2V0QWN0aXZlRGF5Q2VsbCgpKSwgdGhpcy5fdmlldyA9PT0gXCJtb250aHNcIiAmJiAodCA9IHRoaXMuX2dldEFjdGl2ZU1vbnRoQ2VsbCgpKSwgdGhpcy5fdmlldyA9PT0gXCJ5ZWFyc1wiICYmICh0ID0gdGhpcy5fZ2V0QWN0aXZlWWVhckNlbGwoKSksIHQ7XG4gIH1cbiAgZ2V0IGFjdGl2ZURheSgpIHtcbiAgICByZXR1cm4gdHQodGhpcy5fYWN0aXZlRGF0ZSk7XG4gIH1cbiAgZ2V0IGFjdGl2ZU1vbnRoKCkge1xuICAgIHJldHVybiBZKHRoaXMuX2FjdGl2ZURhdGUpO1xuICB9XG4gIGdldCBhY3RpdmVZZWFyKCkge1xuICAgIHJldHVybiBCKHRoaXMuX2FjdGl2ZURhdGUpO1xuICB9XG4gIGdldCBmaXJzdFllYXJJblZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlWWVhciAtIFVzKHRoaXMuX2FjdGl2ZURhdGUsIFR0KTtcbiAgfVxuICBnZXQgbGFzdFllYXJJblZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3RZZWFySW5WaWV3ICsgVHQgLSAxO1xuICB9XG4gIGdldCB2aWV3Q2hhbmdlQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUocG0sIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgcHJldmlvdXNCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShfbSwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBuZXh0QnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoZm0sIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgb2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShtbSwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBjYW5jZWxCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShnbSwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBjbGVhckJ1dHRvbigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKGJtLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IGRhdGVzQ29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUodm0sIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgdG9nZ2xlQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoVG0sIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIHVwZGF0ZSh0ID0ge30pIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKHsgLi4udGhpcy5fb3B0aW9ucywgLi4udCB9KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAodCA9IHtcbiAgICAgIC4uLmVnLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKG5vLCB0LCBpZyksIHQubWF4ICYmIHR5cGVvZiB0Lm1heCA9PSBcInN0cmluZ1wiICYmICh0Lm1heCA9IG5ldyBEYXRlKHQubWF4KSksIHQubWluICYmIHR5cGVvZiB0Lm1pbiA9PSBcInN0cmluZ1wiICYmICh0Lm1pbiA9IG5ldyBEYXRlKHQubWluKSksIHQuc3RhcnREYXkgJiYgdC5zdGFydERheSAhPT0gMCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2dldE5ld0RheXNPcmRlckFycmF5KHQpO1xuICAgICAgdC53ZWVrZGF5c05hcnJvdyA9IGk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uc2csXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkobm8sIHQsIG5nKSwgdDtcbiAgfVxuICBfZ2V0Q29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUodGhpcy5fb3B0aW9ucy5jb250YWluZXIpO1xuICB9XG4gIF9nZXROZXdEYXlzT3JkZXJBcnJheSh0KSB7XG4gICAgY29uc3QgZSA9IHQuc3RhcnREYXksIGkgPSB0LndlZWtkYXlzTmFycm93O1xuICAgIHJldHVybiBpLnNsaWNlKGUpLmNvbmNhdChpLnNsaWNlKDAsIGUpKTtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICAhdGhpcy50b2dnbGVCdXR0b24gJiYgdGhpcy5fb3B0aW9ucy50b2dnbGVCdXR0b24gJiYgKHRoaXMuX2FwcGVuZFRvZ2dsZUJ1dHRvbigpLCAodGhpcy5faW5wdXQucmVhZE9ubHkgfHwgdGhpcy5faW5wdXQuZGlzYWJsZWQpICYmICh0aGlzLnRvZ2dsZUJ1dHRvbi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCIpKSwgdGhpcy5fbGlzdGVuVG9Vc2VySW5wdXQoKSwgdGhpcy5fbGlzdGVuVG9Ub2dnbGVDbGljaygpLCB0aGlzLl9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKTtcbiAgfVxuICBfYXBwZW5kVG9nZ2xlQnV0dG9uKCkge1xuICAgIGNvbnN0IHQgPSBubShcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlcy5kYXRlcGlja2VyVG9nZ2xlQnV0dG9uXG4gICAgKTtcbiAgICB0aGlzLl9lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCB0KTtcbiAgfVxuICBvcGVuKCkge1xuICAgIGlmICh0aGlzLl9pbnB1dC5yZWFkT25seSB8fCB0aGlzLl9pbnB1dC5kaXNhYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGNtKTtcbiAgICBpZiAodGhpcy5faXNPcGVuIHx8IHQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9zZXRJbml0aWFsRGF0ZSgpO1xuICAgIGNvbnN0IGUgPSBRZih0aGlzLl9jbGFzc2VzLmRhdGVwaWNrZXJCYWNrZHJvcCksIGkgPSBaZihcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl9zZWxlY3RlZERhdGUsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIF9zLFxuICAgICAgVHQsXG4gICAgICBwcyxcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5fb3B0aW9ucy5pbmxpbmUgPyB0aGlzLl9vcGVuRHJvcGRvd24oaSkgOiAodGhpcy5fb3Blbk1vZGFsKGUsIGkpLCB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpKSwgdGhpcy5fYW5pbWF0aW9ucyAmJiAoaC5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgdGhpcy5fY2xhc3Nlcy5mYWRlSW4pLCBoLmFkZENsYXNzKGUsIHRoaXMuX2NsYXNzZXMuZmFkZUluU2hvcnQpKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKHRoaXMuY29udGFpbmVyKSwgdGhpcy5fbGlzdGVuVG9EYXRlU2VsZWN0aW9uKCksIHRoaXMuX2FkZENvbnRyb2xzTGlzdGVuZXJzKCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpLCB0aGlzLl9saXN0ZW5Ub0VzY2FwZUNsaWNrKCksIHRoaXMuX2xpc3RlblRvS2V5Ym9hcmROYXZpZ2F0aW9uKCksIHRoaXMuX2xpc3RlblRvRGF0ZXNDb250YWluZXJGb2N1cygpLCB0aGlzLl9saXN0ZW5Ub0RhdGVzQ29udGFpbmVyQmx1cigpLCB0aGlzLl9hc3luY0ZvY3VzRGF0ZXNDb250YWluZXIoKSwgdGhpcy5fdXBkYXRlVmlld0NvbnRyb2xzQW5kQXR0cmlidXRlcyh0aGlzLl92aWV3KSwgdGhpcy5faXNPcGVuID0gITAsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fbGlzdGVuVG9PdXRzaWRlQ2xpY2soKTtcbiAgICB9LCAwKTtcbiAgfVxuICBfb3BlbkRyb3Bkb3duKHQpIHtcbiAgICB0aGlzLl9wb3BwZXIgPSBzZSh0aGlzLl9pbnB1dCwgdCwge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiXG4gICAgfSksIHRoaXMuX2dldENvbnRhaW5lcigpLmFwcGVuZENoaWxkKHQpO1xuICB9XG4gIF9vcGVuTW9kYWwodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICBpLmFwcGVuZENoaWxkKHQpLCBpLmFwcGVuZENoaWxkKGUpO1xuICB9XG4gIF9zZXRGb2N1c1RyYXAodCkge1xuICAgIHRoaXMuX2ZvY3VzVHJhcCA9IG5ldyB6aSh0LCB7XG4gICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICBjb25kaXRpb246IChlKSA9PiBlLmtleSA9PT0gXCJUYWJcIlxuICAgIH0pLCB0aGlzLl9mb2N1c1RyYXAudHJhcCgpO1xuICB9XG4gIF9saXN0ZW5Ub1VzZXJJbnB1dCgpIHtcbiAgICBjLm9uKHRoaXMuX2lucHV0LCBcImlucHV0XCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVVc2VySW5wdXQodC50YXJnZXQudmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub1RvZ2dsZUNsaWNrKCkge1xuICAgIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgZnMsXG4gICAgICBtcyxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9Ub2dnbGVLZXlkb3duKCkge1xuICAgIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICBtcyxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQua2V5Q29kZSA9PT0gaXQgJiYgIXRoaXMuX2lzT3BlbiAmJiB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub0RhdGVTZWxlY3Rpb24oKSB7XG4gICAgYy5vbih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImNsaWNrXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVEYXRlU2VsZWN0aW9uKHQpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVEYXRlU2VsZWN0aW9uKHQpIHtcbiAgICBjb25zdCBlID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldC5wYXJlbnROb2RlLmRhdGFzZXQgOiB0LnRhcmdldC5kYXRhc2V0LCBpID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldC5wYXJlbnROb2RlIDogdC50YXJnZXQ7XG4gICAgaWYgKGUudGVEYXRlICYmIHRoaXMuX3BpY2tEYXkoZS50ZURhdGUsIGkpLCBlLnRlTW9udGggJiYgZS50ZVllYXIpIHtcbiAgICAgIGNvbnN0IG4gPSBwYXJzZUludChlLnRlTW9udGgsIDEwKSwgbyA9IHBhcnNlSW50KGUudGVZZWFyLCAxMCk7XG4gICAgICB0aGlzLl9waWNrTW9udGgobiwgbyk7XG4gICAgfVxuICAgIGlmIChlLnRlWWVhciAmJiAhZS50ZU1vbnRoKSB7XG4gICAgICBjb25zdCBuID0gcGFyc2VJbnQoZS50ZVllYXIsIDEwKTtcbiAgICAgIHRoaXMuX3BpY2tZZWFyKG4pO1xuICAgIH1cbiAgICB0aGlzLl9vcHRpb25zLmlubGluZSB8fCB0aGlzLl91cGRhdGVIZWFkZXJEYXRlKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMubW9udGhzU2hvcnQsXG4gICAgICB0aGlzLl9vcHRpb25zLndlZWtkYXlzU2hvcnRcbiAgICApO1xuICB9XG4gIF91cGRhdGVIZWFkZXJEYXRlKHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gZC5maW5kT25lKFxuICAgICAgRW0sXG4gICAgICB0aGlzLmNvbnRhaW5lclxuICAgICksIG8gPSBZKHQpLCByID0gdHQodCksIGEgPSB6cyh0KTtcbiAgICBuLmlubmVySFRNTCA9IGAke2lbYV19LCAke2Vbb119ICR7cn1gO1xuICB9XG4gIF9hZGRDb250cm9sc0xpc3RlbmVycygpIHtcbiAgICBjLm9uKHRoaXMubmV4dEJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl92aWV3ID09PSBcImRheXNcIiA/IHRoaXMubmV4dE1vbnRoKCkgOiB0aGlzLl92aWV3ID09PSBcInllYXJzXCIgPyB0aGlzLm5leHRZZWFycygpIDogdGhpcy5uZXh0WWVhcigpLCB0aGlzLl91cGRhdGVDb250cm9sc0Rpc2FibGVkU3RhdGUoKTtcbiAgICB9KSwgYy5vbih0aGlzLnByZXZpb3VzQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiID8gdGhpcy5wcmV2aW91c01vbnRoKCkgOiB0aGlzLl92aWV3ID09PSBcInllYXJzXCIgPyB0aGlzLnByZXZpb3VzWWVhcnMoKSA6IHRoaXMucHJldmlvdXNZZWFyKCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpO1xuICAgIH0pLCBjLm9uKHRoaXMudmlld0NoYW5nZUJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl92aWV3ID09PSBcImRheXNcIiA/IHRoaXMuX2NoYW5nZVZpZXcoXCJ5ZWFyc1wiKSA6ICh0aGlzLl92aWV3ID09PSBcInllYXJzXCIgfHwgdGhpcy5fdmlldyA9PT0gXCJtb250aHNcIikgJiYgdGhpcy5fY2hhbmdlVmlldyhcImRheXNcIik7XG4gICAgfSksIHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX2xpc3RlblRvRm9vdGVyQnV0dG9uc0NsaWNrKCk7XG4gIH1cbiAgX2xpc3RlblRvRm9vdGVyQnV0dG9uc0NsaWNrKCkge1xuICAgIGMub24odGhpcy5va0J1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLmhhbmRsZU9rKCkpLCBjLm9uKHRoaXMuY2FuY2VsQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHRoaXMuaGFuZGxlQ2FuY2VsKCkpLCBjLm9uKHRoaXMuY2xlYXJCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5oYW5kbGVDbGVhcigpKTtcbiAgfVxuICBfbGlzdGVuVG9PdXRzaWRlQ2xpY2soKSB7XG4gICAgYy5vbihkb2N1bWVudCwgZnMsICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gdC50YXJnZXQgPT09IHRoaXMuY29udGFpbmVyLCBpID0gdGhpcy5jb250YWluZXIgJiYgdGhpcy5jb250YWluZXIuY29udGFpbnModC50YXJnZXQpO1xuICAgICAgIWUgJiYgIWkgJiYgdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0VzY2FwZUNsaWNrKCkge1xuICAgIGMub24oZG9jdW1lbnQsIFwia2V5ZG93blwiLCAodCkgPT4ge1xuICAgICAgdC5rZXlDb2RlID09PSB3ZSAmJiB0aGlzLl9pc09wZW4gJiYgdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0tleWJvYXJkTmF2aWdhdGlvbigpIHtcbiAgICBjLm9uKHRoaXMuZGF0ZXNDb250YWluZXIsIFwia2V5ZG93blwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5faGFuZGxlS2V5ZG93bih0KTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9EYXRlc0NvbnRhaW5lckZvY3VzKCkge1xuICAgIGMub24odGhpcy5kYXRlc0NvbnRhaW5lciwgXCJmb2N1c1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwodGhpcy5hY3RpdmVDZWxsKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9EYXRlc0NvbnRhaW5lckJsdXIoKSB7XG4gICAgYy5vbih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImJsdXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVtb3ZlQ3VycmVudEZvY3VzU3R5bGVzKCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUtleWRvd24odCkge1xuICAgIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiICYmIHRoaXMuX2hhbmRsZURheXNWaWV3S2V5ZG93bih0KSwgdGhpcy5fdmlldyA9PT0gXCJtb250aHNcIiAmJiB0aGlzLl9oYW5kbGVNb250aHNWaWV3S2V5ZG93bih0KSwgdGhpcy5fdmlldyA9PT0gXCJ5ZWFyc1wiICYmIHRoaXMuX2hhbmRsZVllYXJzVmlld0tleWRvd24odCk7XG4gIH1cbiAgX2hhbmRsZURheXNWaWV3S2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZURhdGUsIGkgPSB0aGlzLmFjdGl2ZUNlbGw7XG4gICAgc3dpdGNoICh0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgS2U6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSAkZSh0aGlzLl9hY3RpdmVEYXRlLCBXKCkgPyAxIDogLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgemU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSAkZSh0aGlzLl9hY3RpdmVEYXRlLCBXKCkgPyAtMSA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9ICRlKHRoaXMuX2FjdGl2ZURhdGUsIC03KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHo6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSAkZSh0aGlzLl9hY3RpdmVEYXRlLCA3KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gJGUoXG4gICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICAxIC0gdHQodGhpcy5fYWN0aXZlRGF0ZSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gJGUoXG4gICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICBHbyh0aGlzLl9hY3RpdmVEYXRlKSAtIHR0KHRoaXMuX2FjdGl2ZURhdGUpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpbzpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGx0KHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHNvOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbHQodGhpcy5fYWN0aXZlRGF0ZSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpdDpcbiAgICAgIGNhc2UgWnM6XG4gICAgICAgIHRoaXMuX3NlbGVjdERhdGUodGhpcy5fYWN0aXZlRGF0ZSksIHRoaXMuX2hhbmRsZURhdGVTZWxlY3Rpb24odCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBQaShcbiAgICAgIGUsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIFR0LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heFxuICAgICkgfHwgdGhpcy5fY2hhbmdlVmlldyhcImRheXNcIiksIHRoaXMuX3JlbW92ZUhpZ2hsaWdodEZyb21DZWxsKGkpLCB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwodGhpcy5hY3RpdmVDZWxsKSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9hc3luY0ZvY3VzRGF0ZXNDb250YWluZXIoKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmRhdGVzQ29udGFpbmVyLmZvY3VzKCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX2ZvY3VzQWN0aXZlQ2VsbCh0KSB7XG4gICAgdCAmJiB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRcIiwgXCJcIik7XG4gIH1cbiAgX3JlbW92ZUhpZ2hsaWdodEZyb21DZWxsKHQpIHtcbiAgICB0ICYmIHQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZm9jdXNlZFwiKTtcbiAgfVxuICBfZ2V0QWN0aXZlRGF5Q2VsbCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKFwidGRcIiwgdGhpcy5kYXRlc0NvbnRhaW5lcik7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odCkuZmluZCgoaSkgPT4ge1xuICAgICAgY29uc3QgbiA9IFZhKGkuZGF0YXNldC50ZURhdGUpO1xuICAgICAgcmV0dXJuIG1lKG4sIHRoaXMuX2FjdGl2ZURhdGUpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVNb250aHNWaWV3S2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZURhdGUsIGkgPSB0aGlzLmFjdGl2ZUNlbGw7XG4gICAgc3dpdGNoICh0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgS2U6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBsdCh0aGlzLl9hY3RpdmVEYXRlLCBXKCkgPyAxIDogLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgemU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBsdCh0aGlzLl9hY3RpdmVEYXRlLCBXKCkgPyAtMSA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGx0KHRoaXMuX2FjdGl2ZURhdGUsIC00KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHo6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBsdCh0aGlzLl9hY3RpdmVEYXRlLCA0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbHQodGhpcy5fYWN0aXZlRGF0ZSwgLXRoaXMuYWN0aXZlTW9udGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRWU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBsdCh0aGlzLl9hY3RpdmVEYXRlLCAxMSAtIHRoaXMuYWN0aXZlTW9udGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaW86XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBhdCh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzbzpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGF0KHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXQ6XG4gICAgICBjYXNlIFpzOlxuICAgICAgICB0aGlzLl9zZWxlY3RNb250aCh0aGlzLmFjdGl2ZU1vbnRoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBQaShcbiAgICAgIGUsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIFR0LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heFxuICAgICkgfHwgdGhpcy5fY2hhbmdlVmlldyhcIm1vbnRoc1wiKSwgdGhpcy5fcmVtb3ZlSGlnaGxpZ2h0RnJvbUNlbGwoaSksIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCh0aGlzLmFjdGl2ZUNlbGwpLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX2dldEFjdGl2ZU1vbnRoQ2VsbCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKFwidGRcIiwgdGhpcy5kYXRlc0NvbnRhaW5lcik7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odCkuZmluZCgoaSkgPT4ge1xuICAgICAgY29uc3QgbiA9IHBhcnNlSW50KGkuZGF0YXNldC50ZVllYXIsIDEwKSwgbyA9IHBhcnNlSW50KGkuZGF0YXNldC50ZU1vbnRoLCAxMCk7XG4gICAgICByZXR1cm4gbiA9PT0gdGhpcy5hY3RpdmVZZWFyICYmIG8gPT09IHRoaXMuYWN0aXZlTW9udGg7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVllYXJzVmlld0tleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9hY3RpdmVEYXRlLCBpID0gdGhpcy5hY3RpdmVDZWxsLCBuID0gNCwgbyA9IDI0O1xuICAgIHN3aXRjaCAodC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIEtlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gYXQodGhpcy5fYWN0aXZlRGF0ZSwgVygpID8gMSA6IC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHplOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gYXQodGhpcy5fYWN0aXZlRGF0ZSwgVygpID8gLTEgOiAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBhdCh0aGlzLl9hY3RpdmVEYXRlLCAtbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB6OlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gYXQodGhpcy5fYWN0aXZlRGF0ZSwgbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGF0KFxuICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgLVVzKHRoaXMuX2FjdGl2ZURhdGUsIG8pXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGF0KFxuICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgbyAtIFVzKHRoaXMuX2FjdGl2ZURhdGUsIG8pIC0gMVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaW86XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBhdCh0aGlzLl9hY3RpdmVEYXRlLCAtbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzbzpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGF0KHRoaXMuX2FjdGl2ZURhdGUsIG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXQ6XG4gICAgICBjYXNlIFpzOlxuICAgICAgICB0aGlzLl9zZWxlY3RZZWFyKHRoaXMuYWN0aXZlWWVhcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgUGkoXG4gICAgICBlLFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICBUdCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXhcbiAgICApIHx8IHRoaXMuX2NoYW5nZVZpZXcoXCJ5ZWFyc1wiKSwgdGhpcy5fcmVtb3ZlSGlnaGxpZ2h0RnJvbUNlbGwoaSksIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCh0aGlzLmFjdGl2ZUNlbGwpLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX2dldEFjdGl2ZVllYXJDZWxsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoXCJ0ZFwiLCB0aGlzLmRhdGVzQ29udGFpbmVyKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0KS5maW5kKChpKSA9PiBwYXJzZUludChpLmRhdGFzZXQudGVZZWFyLCAxMCkgPT09IHRoaXMuYWN0aXZlWWVhcik7XG4gIH1cbiAgX3NldEluaXRpYWxEYXRlKCkge1xuICAgIHRoaXMuX2lucHV0LnZhbHVlID8gdGhpcy5faGFuZGxlVXNlcklucHV0KHRoaXMuX2lucHV0LnZhbHVlKSA6IHRoaXMuX29wdGlvbnMuc3RhcnREYXRlID8gdGhpcy5fYWN0aXZlRGF0ZSA9IG5ldyBEYXRlKHRoaXMuX29wdGlvbnMuc3RhcnREYXRlKSA6IHRoaXMuX2FjdGl2ZURhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBjb25zdCB0ID0gYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGxtKTtcbiAgICAhdGhpcy5faXNPcGVuIHx8IHQuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5fcmVtb3ZlRGF0ZXBpY2tlckxpc3RlbmVycygpLCB0aGlzLl9hbmltYXRpb25zICYmIGguYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCksIHRoaXMuX29wdGlvbnMuaW5saW5lID8gdGhpcy5fY2xvc2VEcm9wZG93bigpIDogdGhpcy5fY2xvc2VNb2RhbCgpLCB0aGlzLl9pc09wZW4gPSAhMSwgdGhpcy5fdmlldyA9IHRoaXMuX29wdGlvbnMudmlldywgdGhpcy50b2dnbGVCdXR0b24gPyB0aGlzLnRvZ2dsZUJ1dHRvbi5mb2N1cygpIDogdGhpcy5faW5wdXQuZm9jdXMoKSk7XG4gIH1cbiAgX2Nsb3NlRHJvcGRvd24oKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZSh1bSksIGUgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIpLm1hdGNoZXMgJiYgKHQgJiYgZS5yZW1vdmVDaGlsZCh0KSwgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci5kZXN0cm95KCkpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgdCAmJiBlLnJlbW92ZUNoaWxkKHQpLCB0aGlzLl9wb3BwZXIgJiYgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICB9KSwgdGhpcy5fcmVtb3ZlRm9jdXNUcmFwKCk7XG4gIH1cbiAgX2Nsb3NlTW9kYWwoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShDbSksIGUgPSBkLmZpbmRPbmUoZG0pO1xuICAgICFlIHx8ICF0IHx8ICh0aGlzLl9hbmltYXRpb25zID8gKGguYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0U2hvcnQpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVtb3ZlUGlja2VyKHQsIGUpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgICB9KSkgOiAodGhpcy5fcmVtb3ZlUGlja2VyKHQsIGUpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKSkpO1xuICB9XG4gIF9yZW1vdmVQaWNrZXIodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICBpLnJlbW92ZUNoaWxkKHQpLCBpLnJlbW92ZUNoaWxkKGUpO1xuICB9XG4gIF9yZW1vdmVGb2N1c1RyYXAoKSB7XG4gICAgdGhpcy5fZm9jdXNUcmFwICYmICh0aGlzLl9mb2N1c1RyYXAuZGlzYWJsZSgpLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsKTtcbiAgfVxuICBfcmVtb3ZlRGF0ZXBpY2tlckxpc3RlbmVycygpIHtcbiAgICBjLm9mZih0aGlzLm5leHRCdXR0b24sIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMucHJldmlvdXNCdXR0b24sIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMudmlld0NoYW5nZUJ1dHRvbiwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5va0J1dHRvbiwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5jYW5jZWxCdXR0b24sIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuY2xlYXJCdXR0b24sIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwia2V5ZG93blwiKSwgYy5vZmYodGhpcy5kYXRlc0NvbnRhaW5lciwgXCJmb2N1c1wiKSwgYy5vZmYodGhpcy5kYXRlc0NvbnRhaW5lciwgXCJibHVyXCIpLCBjLm9mZihkb2N1bWVudCwgZnMpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5faXNPcGVuICYmIHRoaXMuY2xvc2UoKSwgdGhpcy5fcmVtb3ZlSW5wdXRBbmRUb2dnbGVMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgYCMke3RoaXMuX3RvZ2dsZUJ1dHRvbklkfWBcbiAgICApO1xuICAgIHQgJiYgdGhpcy5fZWxlbWVudC5yZW1vdmVDaGlsZCh0KSwgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIFFzKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX2lucHV0ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMuX2FjdGl2ZURhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5faGVhZGVyRGF0ZSA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX3ZpZXcgPSBudWxsLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsO1xuICB9XG4gIF9yZW1vdmVJbnB1dEFuZFRvZ2dsZUxpc3RlbmVycygpIHtcbiAgICBjLm9mZih0aGlzLl9pbnB1dCwgXCJpbnB1dFwiKSwgYy5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgZnMsXG4gICAgICBtc1xuICAgICksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwia2V5ZG93blwiLCBtcyk7XG4gIH1cbiAgaGFuZGxlT2soKSB7XG4gICAgdGhpcy5fY29uZmlybVNlbGVjdGlvbih0aGlzLl9oZWFkZXJEYXRlKSwgdGhpcy5jbG9zZSgpO1xuICB9XG4gIF9zZWxlY3REYXRlKHQsIGUgPSB0aGlzLmFjdGl2ZUNlbGwpIHtcbiAgICBjb25zdCB7IG1pbjogaSwgbWF4OiBuLCBmaWx0ZXI6IG8sIGRpc2FibGVQYXN0OiByLCBkaXNhYmxlRnV0dXJlOiBhIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIF9uKHQsIGksIG4sIG8sIHIsIGEpIHx8ICh0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpLCB0aGlzLl9hZGRTZWxlY3RlZFN0eWxlcyhlKSwgdGhpcy5fc2VsZWN0ZWREYXRlID0gdCwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gQih0KSwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IFkodCksIHRoaXMuX2hlYWRlckRhdGUgPSB0LCAodGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5vcHRpb25zLmNvbmZpcm1EYXRlT25TZWxlY3QpICYmICh0aGlzLl9jb25maXJtU2VsZWN0aW9uKHQpLCB0aGlzLmNsb3NlKCkpKTtcbiAgfVxuICBfc2VsZWN0WWVhcih0LCBlID0gdGhpcy5hY3RpdmVDZWxsKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ3VycmVudFNlbGVjdGlvblN0eWxlcygpLCB0aGlzLl9yZW1vdmVDdXJyZW50Rm9jdXNTdHlsZXMoKSwgdGhpcy5fYWRkU2VsZWN0ZWRTdHlsZXMoZSksIHRoaXMuX2hlYWRlclllYXIgPSB0LCB0aGlzLl9hc3luY0NoYW5nZVZpZXcoXCJtb250aHNcIik7XG4gIH1cbiAgX3NlbGVjdE1vbnRoKHQsIGUgPSB0aGlzLmFjdGl2ZUNlbGwpIHtcbiAgICB0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpLCB0aGlzLl9hZGRTZWxlY3RlZFN0eWxlcyhlKSwgdGhpcy5faGVhZGVyTW9udGggPSB0LCB0aGlzLl9hc3luY0NoYW5nZVZpZXcoXCJkYXlzXCIpO1xuICB9XG4gIF9yZW1vdmVTZWxlY3RlZFN0eWxlcyh0KSB7XG4gICAgdCAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIpO1xuICB9XG4gIF9hZGRTZWxlY3RlZFN0eWxlcyh0KSB7XG4gICAgdCAmJiB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIsIFwiXCIpO1xuICB9XG4gIF9jb25maXJtU2VsZWN0aW9uKHQpIHtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuZm9ybWF0RGF0ZSh0KTtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gZSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGhtLCB7IGRhdGU6IHQgfSksIGMudHJpZ2dlcih0aGlzLl9pbnB1dCwgXCJpbnB1dFwiKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlQ2FuY2VsKCkge1xuICAgIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgaGFuZGxlQ2xlYXIoKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWREYXRlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX2hlYWRlckRhdGUgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX2lucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5fc2V0SW5pdGlhbERhdGUoKSwgdGhpcy5fY2hhbmdlVmlldyhcImRheXNcIiksIHRoaXMuX3VwZGF0ZUhlYWRlckRhdGUoXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tb250aHNTaG9ydCxcbiAgICAgIHRoaXMuX29wdGlvbnMud2Vla2RheXNTaG9ydFxuICAgICk7XG4gIH1cbiAgX3JlbW92ZUN1cnJlbnRTZWxlY3Rpb25TdHlsZXMoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgIFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXVwiLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICAgIHQgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiKTtcbiAgfVxuICBfcmVtb3ZlQ3VycmVudEZvY3VzU3R5bGVzKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICBcIltkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXVwiLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICAgIHQgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXCIpO1xuICB9XG4gIGZvcm1hdERhdGUodCkge1xuICAgIGNvbnN0IGUgPSB0dCh0KSwgaSA9IHRoaXMuX2FkZExlYWRpbmdaZXJvKHR0KHQpKSwgbiA9IHRoaXMuX29wdGlvbnMud2Vla2RheXNTaG9ydFt6cyh0KV0sIG8gPSB0aGlzLl9vcHRpb25zLndlZWtkYXlzRnVsbFt6cyh0KV0sIHIgPSBZKHQpICsgMSwgYSA9IHRoaXMuX2FkZExlYWRpbmdaZXJvKFkodCkgKyAxKSwgbCA9IHRoaXMuX29wdGlvbnMubW9udGhzU2hvcnRbWSh0KV0sIHAgPSB0aGlzLl9vcHRpb25zLm1vbnRoc0Z1bGxbWSh0KV0sIHUgPSBCKHQpLnRvU3RyaW5nKCkubGVuZ3RoID09PSAyID8gQih0KSA6IEIodCkudG9TdHJpbmcoKS5zbGljZSgyLCA0KSwgXyA9IEIodCksIGYgPSB0aGlzLl9vcHRpb25zLmZvcm1hdC5zcGxpdChcbiAgICAgIC8oZHsxLDR9fG17MSw0fXx5ezR9fHl5fCEuKS9nXG4gICAgKTtcbiAgICBsZXQgZyA9IFwiXCI7XG4gICAgcmV0dXJuIGYuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgc3dpdGNoIChtKSB7XG4gICAgICAgIGNhc2UgXCJkZGRkXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCBvKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRkZFwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgaSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1tbW1cIjpcbiAgICAgICAgICBtID0gbS5yZXBsYWNlKG0sIHApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW1tXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCBsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCBhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICBtID0gbS5yZXBsYWNlKG0sIHIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieXl5eVwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgXyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ5eVwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgdSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBnICs9IG07XG4gICAgfSksIGc7XG4gIH1cbiAgX2FkZExlYWRpbmdaZXJvKHQpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodCwgMTApIDwgMTAgPyBgMCR7dH1gIDogdDtcbiAgfVxuICBfcGlja0RheSh0LCBlKSB7XG4gICAgY29uc3QgaSA9IFZhKHQpLCB7IG1pbjogbiwgbWF4OiBvLCBmaWx0ZXI6IHIsIGRpc2FibGVQYXN0OiBhLCBkaXNhYmxlRnV0dXJlOiBsIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIF9uKGksIG4sIG8sIHIsIGEsIGwpIHx8ICh0aGlzLl9hY3RpdmVEYXRlID0gaSwgdGhpcy5fc2VsZWN0RGF0ZShpLCBlKSk7XG4gIH1cbiAgX3BpY2tZZWFyKHQpIHtcbiAgICBjb25zdCB7IG1pbjogZSwgbWF4OiBpLCBkaXNhYmxlUGFzdDogbiwgZGlzYWJsZUZ1dHVyZTogbyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAocW8odCwgZSwgaSwgbiwgbykpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IEN0KHQsIHRoaXMuYWN0aXZlTW9udGgsIHRoaXMuYWN0aXZlRGF5KTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gciwgdGhpcy5fc2VsZWN0ZWREYXRlID0gciwgdGhpcy5fc2VsZWN0WWVhcih0KTtcbiAgfVxuICBfcGlja01vbnRoKHQsIGUpIHtcbiAgICBjb25zdCB7IG1pbjogaSwgbWF4OiBuLCBkaXNhYmxlUGFzdDogbywgZGlzYWJsZUZ1dHVyZTogciB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAoX2godCwgZSwgaSwgbiwgbywgcikgfHwgcW8oZSwgaSwgbiwgbywgcikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYSA9IEN0KGUsIHQsIHRoaXMuYWN0aXZlRGF5KTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gYSwgdGhpcy5fc2VsZWN0TW9udGgodCk7XG4gIH1cbiAgbmV4dE1vbnRoKCkge1xuICAgIGNvbnN0IHQgPSBsdCh0aGlzLl9hY3RpdmVEYXRlLCAxKSwgZSA9IFhzKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX2hlYWRlckRhdGUsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuX29wdGlvbnMubW9udGhzRnVsbFt0aGlzLmFjdGl2ZU1vbnRoXX0gJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSBMdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIHByZXZpb3VzTW9udGgoKSB7XG4gICAgY29uc3QgdCA9IGx0KHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdDtcbiAgICBjb25zdCBlID0gWHMoXG4gICAgICB0LFxuICAgICAgdGhpcy5faGVhZGVyRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLl9vcHRpb25zLm1vbnRoc0Z1bGxbdGhpcy5hY3RpdmVNb250aF19ICR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gTHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBuZXh0WWVhcigpIHtcbiAgICBjb25zdCB0ID0gYXQodGhpcy5fYWN0aXZlRGF0ZSwgMSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IEx0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIGNvbnN0IGUgPSBHcyhcbiAgICAgIHRoaXMuYWN0aXZlWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkTW9udGgsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgX3MsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgcHJldmlvdXNZZWFyKCkge1xuICAgIGNvbnN0IHQgPSBhdCh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IEx0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIGNvbnN0IGUgPSBHcyhcbiAgICAgIHRoaXMuYWN0aXZlWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkTW9udGgsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgX3MsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgbmV4dFllYXJzKCkge1xuICAgIGNvbnN0IHQgPSBhdCh0aGlzLl9hY3RpdmVEYXRlLCAyNCk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQ7XG4gICAgY29uc3QgZSA9IHFzKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBUdCxcbiAgICAgIHBzLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5maXJzdFllYXJJblZpZXd9IC0gJHt0aGlzLmxhc3RZZWFySW5WaWV3fWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gTHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBwcmV2aW91c1llYXJzKCkge1xuICAgIGNvbnN0IHQgPSBhdCh0aGlzLl9hY3RpdmVEYXRlLCAtMjQpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0O1xuICAgIGNvbnN0IGUgPSBxcyhcbiAgICAgIHQsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgVHQsXG4gICAgICBwcyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuZmlyc3RZZWFySW5WaWV3fSAtICR7dGhpcy5sYXN0WWVhckluVmlld31gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IEx0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgX2FzeW5jQ2hhbmdlVmlldyh0KSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9jaGFuZ2VWaWV3KHQpO1xuICAgIH0sIDApO1xuICB9XG4gIF9jaGFuZ2VWaWV3KHQpIHtcbiAgICB0aGlzLl92aWV3ID0gdCwgdGhpcy5kYXRlc0NvbnRhaW5lci5ibHVyKCksIHQgPT09IFwiZGF5c1wiICYmICh0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IFhzKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX2hlYWRlckRhdGUsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICkpLCB0ID09PSBcIm1vbnRoc1wiICYmICh0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IEdzKFxuICAgICAgdGhpcy5hY3RpdmVZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fc2VsZWN0ZWRNb250aCxcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBfcyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApKSwgdCA9PT0gXCJ5ZWFyc1wiICYmICh0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IHFzKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICBUdCxcbiAgICAgIHBzLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICkpLCB0aGlzLmRhdGVzQ29udGFpbmVyLmZvY3VzKCksIHRoaXMuX3VwZGF0ZVZpZXdDb250cm9sc0FuZEF0dHJpYnV0ZXModCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpO1xuICB9XG4gIF91cGRhdGVWaWV3Q29udHJvbHNBbmRBdHRyaWJ1dGVzKHQpIHtcbiAgICB0ID09PSBcImRheXNcIiAmJiAodGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5fb3B0aW9ucy5tb250aHNGdWxsW3RoaXMuYWN0aXZlTW9udGhdfSAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IEx0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN3aXRjaFRvTXVsdGlZZWFyVmlld0xhYmVsXG4gICAgKSwgdGhpcy5wcmV2aW91c0J1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMucHJldk1vbnRoTGFiZWxcbiAgICApLCB0aGlzLm5leHRCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLl9vcHRpb25zLm5leHRNb250aExhYmVsKSksIHQgPT09IFwibW9udGhzXCIgJiYgKHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IEx0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN3aXRjaFRvRGF5Vmlld0xhYmVsXG4gICAgKSwgdGhpcy5wcmV2aW91c0J1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMucHJldlllYXJMYWJlbFxuICAgICksIHRoaXMubmV4dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMuX29wdGlvbnMubmV4dFllYXJMYWJlbCkpLCB0ID09PSBcInllYXJzXCIgJiYgKHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuZmlyc3RZZWFySW5WaWV3fSAtICR7dGhpcy5sYXN0WWVhckluVmlld31gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9IEx0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN3aXRjaFRvTW9udGhWaWV3TGFiZWxcbiAgICApLCB0aGlzLnByZXZpb3VzQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5wcmV2TXVsdGlZZWFyTGFiZWxcbiAgICApLCB0aGlzLm5leHRCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLm5leHRNdWx0aVllYXJMYWJlbFxuICAgICkpO1xuICB9XG4gIF91cGRhdGVDb250cm9sc0Rpc2FibGVkU3RhdGUoKSB7XG4gICAgSGYoXG4gICAgICB0aGlzLl9vcHRpb25zLmRpc2FibGVGdXR1cmUsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIFR0LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heCxcbiAgICAgIHRoaXMubGFzdFllYXJJblZpZXcsXG4gICAgICB0aGlzLmZpcnN0WWVhckluVmlld1xuICAgICkgPyB0aGlzLm5leHRCdXR0b24uZGlzYWJsZWQgPSAhMCA6IHRoaXMubmV4dEJ1dHRvbi5kaXNhYmxlZCA9ICExLCBWZihcbiAgICAgIHRoaXMuX29wdGlvbnMuZGlzYWJsZVBhc3QsXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fdmlldyxcbiAgICAgIFR0LFxuICAgICAgdGhpcy5fb3B0aW9ucy5taW4sXG4gICAgICB0aGlzLl9vcHRpb25zLm1heCxcbiAgICAgIHRoaXMubGFzdFllYXJJblZpZXcsXG4gICAgICB0aGlzLmZpcnN0WWVhckluVmlld1xuICAgICkgPyB0aGlzLnByZXZpb3VzQnV0dG9uLmRpc2FibGVkID0gITAgOiB0aGlzLnByZXZpb3VzQnV0dG9uLmRpc2FibGVkID0gITE7XG4gIH1cbiAgX2hhbmRsZVVzZXJJbnB1dCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldERlbGltZXRlcnModGhpcy5fb3B0aW9ucy5mb3JtYXQpLCBpID0gdGhpcy5fcGFyc2VEYXRlKHQsIHRoaXMuX29wdGlvbnMuZm9ybWF0LCBlKTtcbiAgICBSZihpKSA/ICh0aGlzLl9hY3RpdmVEYXRlID0gaSwgdGhpcy5fc2VsZWN0ZWREYXRlID0gaSwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gQihpKSwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IFkoaSksIHRoaXMuX2hlYWRlckRhdGUgPSBpKSA6ICh0aGlzLl9hY3RpdmVEYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9oZWFkZXJEYXRlID0gbnVsbCwgdGhpcy5faGVhZGVyTW9udGggPSBudWxsLCB0aGlzLl9oZWFkZXJZZWFyID0gbnVsbCk7XG4gIH1cbiAgX2dldERlbGltZXRlcnModCkge1xuICAgIHJldHVybiB0Lm1hdGNoKC9bXihkbXkpXXsxLH0vZyk7XG4gIH1cbiAgX3BhcnNlRGF0ZSh0LCBlLCBpKSB7XG4gICAgbGV0IG47XG4gICAgaVswXSAhPT0gaVsxXSA/IG4gPSBpWzBdICsgaVsxXSA6IG4gPSBpWzBdO1xuICAgIGNvbnN0IG8gPSBuZXcgUmVnRXhwKGBbJHtufV1gKSwgciA9IHQuc3BsaXQobyksIGEgPSBlLnNwbGl0KG8pLCBsID0gZS5pbmRleE9mKFwibW1tXCIpICE9PSAtMSwgcCA9IFtdO1xuICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYS5sZW5ndGg7IGIrKylcbiAgICAgIGFbYl0uaW5kZXhPZihcInl5XCIpICE9PSAtMSAmJiAocFswXSA9IHsgdmFsdWU6IHJbYl0sIGZvcm1hdDogYVtiXSB9KSwgYVtiXS5pbmRleE9mKFwibVwiKSAhPT0gLTEgJiYgKHBbMV0gPSB7IHZhbHVlOiByW2JdLCBmb3JtYXQ6IGFbYl0gfSksIGFbYl0uaW5kZXhPZihcImRcIikgIT09IC0xICYmIGFbYl0ubGVuZ3RoIDw9IDIgJiYgKHBbMl0gPSB7IHZhbHVlOiByW2JdLCBmb3JtYXQ6IGFbYl0gfSk7XG4gICAgbGV0IHU7XG4gICAgZS5pbmRleE9mKFwibW1tbVwiKSAhPT0gLTEgPyB1ID0gdGhpcy5fb3B0aW9ucy5tb250aHNGdWxsIDogdSA9IHRoaXMuX29wdGlvbnMubW9udGhzU2hvcnQ7XG4gICAgY29uc3QgXyA9IE51bWJlcihwWzBdLnZhbHVlKSwgZiA9IGwgPyB0aGlzLmdldE1vbnRoTnVtYmVyQnlNb250aE5hbWUocFsxXS52YWx1ZSwgdSkgOiBOdW1iZXIocFsxXS52YWx1ZSkgLSAxLCBnID0gTnVtYmVyKHBbMl0udmFsdWUpO1xuICAgIHJldHVybiBDdChfLCBmLCBnKTtcbiAgfVxuICBnZXRNb250aE51bWJlckJ5TW9udGhOYW1lKHQsIGUpIHtcbiAgICByZXR1cm4gZS5maW5kSW5kZXgoKGkpID0+IGkgPT09IHQpO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEEuZ2V0RGF0YSh0LCBRcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgcmcgPSAoe1xuICBmb3JtYXQyNDogcyxcbiAgb2tMYWJlbDogdCxcbiAgY2FuY2VsTGFiZWw6IGUsXG4gIGhlYWRJRDogaSxcbiAgZm9vdGVySUQ6IG4sXG4gIGJvZHlJRDogbyxcbiAgcGlja2VySUQ6IHIsXG4gIGNsZWFyTGFiZWw6IGEsXG4gIGlubGluZTogbCxcbiAgc2hvd0NsZWFyQnRuOiBwLFxuICBhbUxhYmVsOiB1LFxuICBwbUxhYmVsOiBfXG59LCBmKSA9PiB7XG4gIGNvbnN0IGcgPSBgPGRpdiBpZD0nJHtyfScgY2xhc3M9JyR7Zi50aW1lcGlja2VyV3JhcHBlcn0nIGRhdGEtdGUtdGltZXBpY2tlci13cmFwcGVyPlxuICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyQ29udGFpbmVyfVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJFbGVtZW50c31cIiBkYXRhLXRlLXRpbWVwaWNrZXItZWxlbWVudHMtd3JhcHBlcj5cbiAgICAgICAgPGRpdiBpZD0nJHtpfScgY2xhc3M9JyR7Zi50aW1lcGlja2VySGVhZH0nIHN0eWxlPSdwYWRkaW5nLXJpZ2h0OiR7cyA/IDUwIDogMTB9cHgnPlxuICAgICAgICA8ZGl2IGNsYXNzPScke2YudGltZXBpY2tlckhlYWRDb250ZW50fSc+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50V3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlckN1cnJlbnRCdXR0b25XcmFwcGVyfVwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJDdXJyZW50QnV0dG9ufScgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS10aW1lcGlja2VyLWFjdGl2ZSBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudCBkYXRhLXRlLXRpbWVwaWNrZXItaG91ciBkYXRhLXRlLXJpcHBsZS1pbml0PjIxPC9idXR0b24+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlckRvdH0nIGRpc2FibGVkPjo8L2J1dHRvbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50QnV0dG9uV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlckN1cnJlbnRCdXR0b259JyB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudCBkYXRhLXRlLXRpbWVwaWNrZXItbWludXRlIGRhdGEtdGUtcmlwcGxlLWluaXQ+MjE8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgJHtzID8gXCJcIiA6IGA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJNb2RlV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz1cIiR7Zi50aW1lcGlja2VyTW9kZUFtfVwiIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtdGltZXBpY2tlci1hbSBkYXRhLXRlLXRpbWVwaWNrZXItaG91ci1tb2RlIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHt1fTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyTW9kZVBtfVwiIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtdGltZXBpY2tlci1wbSBkYXRhLXRlLXRpbWVwaWNrZXItaG91ci1tb2RlIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHtffTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PmB9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICAke2wgPyBcIlwiIDogYDxkaXYgaWQ9JyR7b30nIGNsYXNzPScke2YudGltZXBpY2tlckNsb2NrV3JhcHBlcn0nIGRhdGEtdGUtdGltZXBpY2tlci1jbG9jay13cmFwcGVyPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJDbG9ja30nIGRhdGEtdGUtdGltZXBpY2tlci1jbG9jaz5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9JyR7Zi50aW1lcGlja2VyTWlkZGxlRG90fScgZGF0YS10ZS10aW1lcGlja2VyLW1pZGRsZS1kb3Q+PC9zcGFuPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPScke2YudGltZXBpY2tlckhhbmRQb2ludGVyfScgZGF0YS10ZS10aW1lcGlja2VyLWhhbmQtcG9pbnRlcj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPScke2YudGltZXBpY2tlclBvaW50ZXJDaXJjbGV9JyBkYXRhLXRlLXRpbWVwaWNrZXItY2lyY2xlPjwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgJHtzID8gJzxkaXYgY2xhc3M9XCInICsgZi50aW1lcGlja2VyQ2xvY2tJbm5lciArICdcIiBkYXRhLXRlLXRpbWVwaWNrZXItY2xvY2staW5uZXI+PC9kaXY+JyA6IFwiXCJ9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5gfVxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9JyR7bn0nIGNsYXNzPScke2YudGltZXBpY2tlckZvb3RlcldyYXBwZXJ9Jz5cbiAgICAgIDxkaXYgY2xhc3M9XCIke2YudGltZXBpY2tlckZvb3Rlcn1cIj5cbiAgICAgICAgJHtwID8gYDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJGb290ZXJCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItY2xlYXIgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke2F9PC9idXR0b24+YCA6IFwiXCJ9XG4gICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJGb290ZXJCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItY2FuY2VsIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHtlfTwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VyRm9vdGVyQnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLXN1Ym1pdCB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7dH08L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PmAsIG0gPSBgPGRpdiBpZD0nJHtyfScgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lV3JhcHBlcn0nIGRhdGEtdGUtdGltZXBpY2tlci13cmFwcGVyPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVDb250YWluZXJ9XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lRWxlbWVudHN9XCIgZGF0YS10ZS10aW1lcGlja2VyLWVsZW1lbnRzLXdyYXBwZXI+XG4gICAgICAgICAgPGRpdiBpZD0nJHtpfScgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lSGVhZH0nXG4gICAgICAgICAgc3R5bGU9J3BhZGRpbmctcmlnaHQ6MTBweCc+XG4gICAgICAgICAgPGRpdiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVIZWFkQ29udGVudH0nPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50V3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSG91cldyYXBwZXJ9XCIgZGF0YS10ZS10aW1lcGlja2VyLWlubGluZS1ob3VyLWljb25zPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25VcH1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi11cCBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1pbmxpbmUtaG91cj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Tdmd9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTUgaC01XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk00LjUgMTUuNzVsNy41LTcuNSA3LjUgNy41XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz4gICBcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZUN1cnJlbnRCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItaG91ciBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudCBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudC1pbmxpbmUgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4yMTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Eb3dufVwiIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWlubGluZS1ob3VyIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWRvd24+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnfVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy01IGgtNVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTkuNSA4LjI1bC03LjUgNy41LTcuNS03LjVcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPiAgXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZURvdH0nIGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50LWlubGluZSBkaXNhYmxlZD46PC9idXR0b24+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50TWludXRlV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvblVwfVwiIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLXVwIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWlubGluZS1taW51dGU+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvblN2Z31cIj5cbiAgICAgICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTUgaC01XCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNC41IDE1Ljc1bDcuNS03LjUgNy41IDcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lQ3VycmVudEJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1taW51dGUgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQtaW5saW5lIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+MjE8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvbkRvd259XCIgZGF0YS10ZS10aW1lcGlja2VyLWljb24taW5saW5lLW1pbnV0ZSBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1kb3duPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Tdmd9XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy01IGgtNVwiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+IFxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgJHtzID8gXCJcIiA6IGA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVNb2RlV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZU1vZGVBbX1cIiBkYXRhLXRlLXRpbWVwaWNrZXItYW0gZGF0YS10ZS10aW1lcGlja2VyLWhvdXItbW9kZSB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7dX08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVNb2RlUG19XCIgZGF0YS10ZS10aW1lcGlja2VyLWhvdXItbW9kZSBkYXRhLXRlLXRpbWVwaWNrZXItcG0gdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke199PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZVN1Ym1pdEJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1zdWJtaXQgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke3R9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PmB9XG4gICAgICAgICAgICAgICR7cyA/IGA8YnV0dG9uIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZVN1Ym1pdEJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1zdWJtaXQgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke3R9PC9idXR0b24+YCA6IFwiXCJ9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5gO1xuICByZXR1cm4gbCA/IG0gOiBnO1xufSwgYWcgPSAocywgdCwgZSkgPT4ge1xuICBjb25zdCB7IGljb25TVkc6IGkgfSA9IHM7XG4gIHJldHVybiBgXG4gIDxidXR0b24gaWQ9XCIke3R9XCIgdGFiaW5kZXg9XCIwXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtlLnRpbWVwaWNrZXJUb2dnbGVCdXR0b259XCIgZGF0YS10ZS10b2dnbGU9XCJ0aW1lcGlja2VyXCIgZGF0YS10ZS10aW1lcGlja2VyLXRvZ2dsZS1idXR0b24gZGF0YS10ZS10aW1lcGlja2VyLWljb24+XG4gICAgJHtpfVxuICA8L2J1dHRvbj5cbmA7XG59LCBDbiA9IFwiZGF0YS10ZS10aW1lcGlja2VyLWRpc2FibGVkXCIsIGdzID0gXCJkYXRhLXRlLXRpbWVwaWNrZXItYWN0aXZlXCIsIENlID0gKHMpID0+IHtcbiAgaWYgKHMgPT09IFwiXCIpXG4gICAgcmV0dXJuO1xuICBsZXQgdCwgZSwgaSwgbjtcbiAgcmV0dXJuIGdoKHMpID8gKHQgPSBzLmdldEhvdXJzKCksIG4gPSB0LCBlID0gcy5nZXRNaW51dGVzKCksIHQgJT0gMTIsIG4gPT09IDAgJiYgdCA9PT0gMCAmJiAoaSA9IFwiQU1cIiksIHQgPSB0IHx8IDEyLCBpID09PSB2b2lkIDAgJiYgKGkgPSBOdW1iZXIobikgPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCIpLCBlID0gZSA8IDEwID8gYDAke2V9YCA6IGUpIDogKFt0LCBlLCBpXSA9IFIocywgITEpLCBuID0gdCwgdCAlPSAxMiwgbiA9PT0gMCAmJiB0ID09PSAwICYmIChpID0gXCJBTVwiKSwgdCA9IHQgfHwgMTIsIGkgPT09IHZvaWQgMCAmJiAoaSA9IE51bWJlcihuKSA+PSAxMiA/IFwiUE1cIiA6IFwiQU1cIikpLCB7XG4gICAgaG91cnM6IHQsXG4gICAgbWludXRlczogZSxcbiAgICBhbU9yUG06IGlcbiAgfTtcbn0sIGdoID0gKHMpID0+IHMgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHMpID09PSBcIltvYmplY3QgRGF0ZV1cIiAmJiAhTnVtYmVyLmlzTmFOKHMpLCBLYSA9IChzKSA9PiB7XG4gIGlmIChzID09PSBcIlwiKVxuICAgIHJldHVybjtcbiAgbGV0IHQsIGU7XG4gIHJldHVybiBnaChzKSA/ICh0ID0gcy5nZXRIb3VycygpLCBlID0gcy5nZXRNaW51dGVzKCkpIDogW3QsIGVdID0gUihzLCAhMSksIGUgPSBOdW1iZXIoZSkgPCAxMCA/IGAwJHtOdW1iZXIoZSl9YCA6IGUsIHtcbiAgICBob3VyczogdCxcbiAgICBtaW51dGVzOiBlXG4gIH07XG59LCBsZyA9IChzLCB0LCBlKSA9PiBjLm9uKGRvY3VtZW50LCBzLCB0LCAoeyB0YXJnZXQ6IGkgfSkgPT4ge1xuICBpZiAoaS5oYXNBdHRyaWJ1dGUoZ3MpKVxuICAgIHJldHVybjtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KS5mb3JFYWNoKChvKSA9PiB7XG4gICAgby5oYXNBdHRyaWJ1dGUoZ3MpICYmIChoLnJlbW92ZUNsYXNzKG8sIGUub3BhY2l0eSksIG8ucmVtb3ZlQXR0cmlidXRlKGdzKSk7XG4gIH0pLCBoLmFkZENsYXNzKGksIGUub3BhY2l0eSksIGkuc2V0QXR0cmlidXRlKGdzLCBcIlwiKTtcbn0pLCB6YSA9ICh7IGNsaWVudFg6IHMsIGNsaWVudFk6IHQsIHRvdWNoZXM6IGUgfSwgaSwgbiA9ICExKSA9PiB7XG4gIGNvbnN0IHsgbGVmdDogbywgdG9wOiByIH0gPSBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBsZXQgYSA9IHt9O1xuICByZXR1cm4gIW4gfHwgIWUgPyBhID0ge1xuICAgIHg6IHMgLSBvLFxuICAgIHk6IHQgLSByXG4gIH0gOiBuICYmIE9iamVjdC5rZXlzKGUpLmxlbmd0aCA+IDAgJiYgKGEgPSB7XG4gICAgeDogZVswXS5jbGllbnRYIC0gbyxcbiAgICB5OiBlWzBdLmNsaWVudFkgLSByXG4gIH0pLCBhO1xufSwgYnMgPSAoKSA9PiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMiAmJiAvTWFjSW50ZWwvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSB8fCAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QoXG4gIG5hdmlnYXRvci51c2VyQWdlbnRcbiksIFIgPSAocywgdCA9ICEwKSA9PiB0ID8gcy52YWx1ZS5yZXBsYWNlKC86L2dpLCBcIiBcIikuc3BsaXQoXCIgXCIpIDogcy5yZXBsYWNlKC86L2dpLCBcIiBcIikuc3BsaXQoXCIgXCIpLCBiaCA9IChzLCB0KSA9PiB7XG4gIGNvbnN0IFtlLCBpLCBuXSA9IFIocywgITEpLCBbbywgciwgYV0gPSBSKHQsICExKTtcbiAgcmV0dXJuIG4gPT09IFwiUE1cIiAmJiBhID09PSBcIkFNXCIgfHwgbiA9PT0gYSAmJiBlID4gbyB8fCBpID4gcjtcbn0sIHZoID0gKCkgPT4ge1xuICBjb25zdCBzID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHQgPSBzLmdldEhvdXJzKCksIGUgPSBzLmdldE1pbnV0ZXMoKTtcbiAgcmV0dXJuIGAke3R9OiR7ZSA8IDEwID8gYDAke2V9YCA6IGV9YDtcbn0sIEd0ID0gKHMsIHQsIGUpID0+IHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBzO1xuICBsZXQgaSA9IHZoKCk7XG4gIHJldHVybiBlICYmIChpID0gYCR7Q2UoaSkuaG91cnN9OiR7Q2UoaSkubWludXRlc30gJHtDZShpKS5hbU9yUG19YCksIChzICE9PSBcIlwiICYmIGJoKGksIHMpIHx8IHMgPT09IFwiXCIpICYmIChzID0gaSksIHM7XG59LCBxdCA9IChzLCB0LCBlKSA9PiB7XG4gIGlmICghdClcbiAgICByZXR1cm4gcztcbiAgbGV0IGkgPSB2aCgpO1xuICByZXR1cm4gZSAmJiAoaSA9IGAke0NlKGkpLmhvdXJzfToke0NlKGkpLm1pbnV0ZXN9ICR7Q2UoaSkuYW1PclBtfWApLCAocyAhPT0gXCJcIiAmJiAhYmgoaSwgcykgfHwgcyA9PT0gXCJcIikgJiYgKHMgPSBpKSwgcztcbn0sIGNnID0gKHsgZm9ybWF0MTI6IHMsIG1heFRpbWU6IHQsIG1pblRpbWU6IGUsIGRpc2FibGVQYXN0OiBpLCBkaXNhYmxlRnV0dXJlOiBuIH0sIG8sIHIpID0+IHtcbiAgY29uc3QgYSA9IFIobylbMV07XG4gIGUgPSBHdChlLCBpLCBzKSwgdCA9IHF0KHQsIG4sIHMpO1xuICBjb25zdCBbbCwgcCwgdV0gPSBSKHQsICExKSwgW18sIGYsIGddID0gUihlLCAhMSk7XG4gIGlmICh1ICE9PSB2b2lkIDAgfHwgZyAhPT0gdm9pZCAwKVxuICAgIHJldHVybiBbciwgYV07XG4gIGlmICghKGwgIT09IFwiXCIgJiYgXyA9PT0gXCJcIiAmJiBOdW1iZXIocikgPiBOdW1iZXIobCkpICYmICEobCA9PT0gXCJcIiAmJiBfICE9PSBcIlwiICYmIHAgPT09IHZvaWQgMCAmJiBmICE9PSBcIlwiICYmIE51bWJlcihyKSA8IE51bWJlcihfKSkpXG4gICAgcmV0dXJuIFtyLCBhXTtcbn0sIFVhID0gKHMsIHQsIGUsIGkpID0+IHtcbiAgcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgdCA9IHQgPT09IFwiMTJcIiAmJiBpID8gXCIwXCIgOiB0LCAobi50ZXh0Q29udGVudCA9PT0gXCIwMFwiIHx8IE51bWJlcihuLnRleHRDb250ZW50ID09PSBcIjEyXCIgJiYgaSA/IFwiMFwiIDogbi50ZXh0Q29udGVudCkgPiB0KSAmJiAoaC5hZGRDbGFzcyhuLCBlLnRpcHNEaXNhYmxlZCksIG4uc2V0QXR0cmlidXRlKENuLCBcIlwiKSk7XG4gIH0pO1xufSwgWGEgPSAocywgdCwgZSwgaSkgPT4ge1xuICBzLmZvckVhY2goKG4pID0+IHtcbiAgICB0ID0gdCA9PT0gXCIxMlwiICYmIGkgPyBcIjBcIiA6IHQsIG4udGV4dENvbnRlbnQgIT09IFwiMDBcIiAmJiBOdW1iZXIobi50ZXh0Q29udGVudCA9PT0gXCIxMlwiICYmIGkgPyBcIjBcIiA6IG4udGV4dENvbnRlbnQpIDwgTnVtYmVyKHQpICYmIChoLmFkZENsYXNzKG4sIGUudGlwc0Rpc2FibGVkKSwgbi5zZXRBdHRyaWJ1dGUoQ24sIFwiXCIpKTtcbiAgfSk7XG59LCBUaCA9IChzLCB0LCBlLCBpKSA9PiB7XG4gIGlmICh0ID09PSBcIjEyXCIgfHwgdCA9PT0gXCIyNFwiKVxuICAgIHJldHVybjtcbiAgY29uc3QgbiA9IGUgPyAxMiA6IDI0O1xuICByZXR1cm4gaSA9PT0gXCJtYXhcIiA/IChOdW1iZXIocykgPT09IG4gPyAwIDogTnVtYmVyKHMpKSA+IE51bWJlcih0KSA6IChOdW1iZXIocykgPT09IG4gPyAwIDogTnVtYmVyKHMpKSA8IE51bWJlcih0KTtcbn0sIGhnID0gKHMsIHQsIGUsIGksIG4sIG8pID0+IHtcbiAgcy5mb3JFYWNoKChyKSA9PiB7XG4gICAgKFRoKGksIGUsIG8sIFwibWF4XCIpIHx8IE51bWJlcihyLnRleHRDb250ZW50KSA+IHQgJiYgTnVtYmVyKGkpID09PSBOdW1iZXIoZSkpICYmIChoLmFkZENsYXNzKHIsIG4udGlwc0Rpc2FibGVkKSwgci5zZXRBdHRyaWJ1dGUoQ24sIFwiXCIpKTtcbiAgfSk7XG59LCBkZyA9IChzLCB0LCBlLCBpLCBuLCBvKSA9PiB7XG4gIHMuZm9yRWFjaCgocikgPT4ge1xuICAgIChUaChpLCBlLCBvLCBcIm1pblwiKSB8fCBOdW1iZXIoci50ZXh0Q29udGVudCkgPCB0ICYmIE51bWJlcihpKSA9PT0gTnVtYmVyKGUpKSAmJiAoaC5hZGRDbGFzcyhyLCBuLnRpcHNEaXNhYmxlZCksIHIuc2V0QXR0cmlidXRlKENuLCBcIlwiKSk7XG4gIH0pO1xufSwgdWcgPSAocykgPT4gcy5zdGFydHNXaXRoKFwiMFwiKSA/IE51bWJlcihzLnNsaWNlKDEpKSA6IE51bWJlcihzKSwgQmkgPSBcInRpbWVwaWNrZXJcIiwgTSA9IGBkYXRhLXRlLSR7Qml9YCwgR2EgPSBcIltkYXRhLXRlLXRvZ2dsZV1cIiwgSnMgPSBgdGUuJHtCaX1gLCBQdCA9IGAuJHtKc31gLCBCdCA9IFwiLmRhdGEtYXBpXCIsIHFhID0gYGNsaWNrJHtQdH0ke0J0fWAsIHZzID0gYGtleWRvd24ke1B0fSR7QnR9YCwgWmEgPSBgbW91c2Vkb3duJHtQdH0ke0J0fWAsIFFhID0gYG1vdXNldXAke1B0fSR7QnR9YCwgSmEgPSBgbW91c2Vtb3ZlJHtQdH0ke0J0fWAsIHRsID0gYG1vdXNlbGVhdmUke1B0fSR7QnR9YCwgZWwgPSBgbW91c2VvdmVyJHtQdH0ke0J0fWAsIGlsID0gYHRvdWNobW92ZSR7UHR9JHtCdH1gLCBzbCA9IGB0b3VjaGVuZCR7UHR9JHtCdH1gLCBubCA9IGB0b3VjaHN0YXJ0JHtQdH0ke0J0fWAsIHBnID0gYFske019LWFtXWAsIF9nID0gYFske019LXBtXWAsIGZnID0gYFske019LWZvcm1hdDI0XWAsIFRzID0gYFske019LWN1cnJlbnRdYCwgRXMgPSBgWyR7TX0taG91ci1tb2RlXWAsIG1nID0gYFske019LXRvZ2dsZS1idXR0b25dYCwgb28gPSBgJHtNfS1jYW5jZWxgLCBvbCA9IGAke019LWNsZWFyYCwgcm8gPSBgJHtNfS1zdWJtaXRgLCBnZyA9IGAke019LWljb25gLCBhbyA9IGAke019LWljb24tdXBgLCBsbyA9IGAke019LWljb24tZG93bmAsIGJnID0gYCR7TX0taWNvbi1pbmxpbmUtaG91cmAsIHZnID0gYCR7TX0taWNvbi1pbmxpbmUtbWludXRlYCwgcmwgPSBgJHtNfS1pbmxpbmUtaG91ci1pY29uc2AsIFRnID0gYCR7TX0tY3VycmVudC1pbmxpbmVgLCBFZyA9IFwicmVhZG9ubHlcIiwgQ2cgPSBgJHtNfS1pbnZhbGlkLWZlZWRiYWNrYCwgY28gPSBgJHtNfS1pcy1pbnZhbGlkYCwganQgPSBgJHtNfS1kaXNhYmxlZGAsIEggPSBgJHtNfS1hY3RpdmVgLCBBZyA9IGAke019LWlucHV0YCwgdWUgPSBgJHtNfS1jbG9ja2AsIG1pID0gYCR7TX0tY2xvY2staW5uZXJgLCBobyA9IGAke019LXdyYXBwZXJgLCBhbCA9IGAke019LWNsb2NrLXdyYXBwZXJgLCBDcyA9IGAke019LWhvdXJgLCB1byA9IGAke019LW1pbnV0ZWAsIEFzID0gYCR7TX0tdGlwcy1lbGVtZW50YCwgWCA9IGAke019LXRpcHMtaG91cnNgLCBxID0gYCR7TX0tdGlwcy1taW51dGVzYCwgaHQgPSBgJHtNfS10aXBzLWlubmVyYCwgeXMgPSBgJHtNfS10aXBzLWlubmVyLWVsZW1lbnRgLCBsbCA9IGAke019LW1pZGRsZS1kb3RgLCBwbyA9IGAke019LWhhbmQtcG9pbnRlcmAsIF9vID0gYCR7TX0tY2lyY2xlYCwgY2wgPSBgJHtNfS1tb2RhbGAsIHlnID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTEyIDZ2Nmg0LjVtNC41IDBhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6XCIgLz5cbjwvc3ZnPmAsIHdnID0ge1xuICBhcHBlbmRWYWxpZGF0aW9uSW5mbzogITAsXG4gIGJvZHlJRDogXCJcIixcbiAgY2FuY2VsTGFiZWw6IFwiQ2FuY2VsXCIsXG4gIGNsZWFyTGFiZWw6IFwiQ2xlYXJcIixcbiAgY2xvc2VNb2RhbE9uQmFja2Ryb3BDbGljazogITAsXG4gIGNsb3NlTW9kYWxPbk1pbnV0ZXNDbGljazogITEsXG4gIGNvbnRhaW5lcjogXCJib2R5XCIsXG4gIGRlZmF1bHRUaW1lOiBcIlwiLFxuICBkaXNhYmxlZDogITEsXG4gIGRpc2FibGVQYXN0OiAhMSxcbiAgZGlzYWJsZUZ1dHVyZTogITEsXG4gIGVuYWJsZVZhbGlkYXRpb246ICEwLFxuICBmb2N1c0lucHV0QWZ0ZXJBcHByb3ZlOiAhMSxcbiAgZm9vdGVySUQ6IFwiXCIsXG4gIGZvcm1hdDEyOiAhMCxcbiAgZm9ybWF0MjQ6ICExLFxuICBoZWFkSUQ6IFwiXCIsXG4gIGluY3JlbWVudDogITEsXG4gIGlubGluZTogITEsXG4gIGludmFsaWRMYWJlbDogXCJJbnZhbGlkIFRpbWUgRm9ybWF0XCIsXG4gIG1heFRpbWU6IFwiXCIsXG4gIG1pblRpbWU6IFwiXCIsXG4gIG1vZGFsSUQ6IFwiXCIsXG4gIG9rTGFiZWw6IFwiT2tcIixcbiAgb3ZlcmZsb3dIaWRkZW46ICEwLFxuICBwaWNrZXJJRDogXCJcIixcbiAgcmVhZE9ubHk6ICExLFxuICBzaG93Q2xlYXJCdG46ICEwLFxuICBzd2l0Y2hIb3Vyc1RvTWludXRlc09uQ2xpY2s6ICEwLFxuICBpY29uU1ZHOiB5ZyxcbiAgd2l0aEljb246ICEwLFxuICBwbUxhYmVsOiBcIlBNXCIsXG4gIGFtTGFiZWw6IFwiQU1cIixcbiAgYW5pbWF0aW9uczogITBcbn0sIGtnID0ge1xuICBhcHBlbmRWYWxpZGF0aW9uSW5mbzogXCJib29sZWFuXCIsXG4gIGJvZHlJRDogXCJzdHJpbmdcIixcbiAgY2FuY2VsTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNsZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNsb3NlTW9kYWxPbkJhY2tkcm9wQ2xpY2s6IFwiYm9vbGVhblwiLFxuICBjbG9zZU1vZGFsT25NaW51dGVzQ2xpY2s6IFwiYm9vbGVhblwiLFxuICBjb250YWluZXI6IFwic3RyaW5nXCIsXG4gIGRpc2FibGVkOiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZVBhc3Q6IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlRnV0dXJlOiBcImJvb2xlYW5cIixcbiAgZW5hYmxlVmFsaWRhdGlvbjogXCJib29sZWFuXCIsXG4gIGZvb3RlcklEOiBcInN0cmluZ1wiLFxuICBmb3JtYXQxMjogXCJib29sZWFuXCIsXG4gIGZvcm1hdDI0OiBcImJvb2xlYW5cIixcbiAgaGVhZElEOiBcInN0cmluZ1wiLFxuICBpbmNyZW1lbnQ6IFwiYm9vbGVhblwiLFxuICBpbmxpbmU6IFwiYm9vbGVhblwiLFxuICBpbnZhbGlkTGFiZWw6IFwic3RyaW5nXCIsXG4gIG1vZGFsSUQ6IFwic3RyaW5nXCIsXG4gIG9rTGFiZWw6IFwic3RyaW5nXCIsXG4gIG92ZXJmbG93SGlkZGVuOiBcImJvb2xlYW5cIixcbiAgcGlja2VySUQ6IFwic3RyaW5nXCIsXG4gIHJlYWRPbmx5OiBcImJvb2xlYW5cIixcbiAgc2hvd0NsZWFyQnRuOiBcImJvb2xlYW5cIixcbiAgc3dpdGNoSG91cnNUb01pbnV0ZXNPbkNsaWNrOiBcImJvb2xlYW5cIixcbiAgZGVmYXVsdFRpbWU6IFwiKHN0cmluZ3xkYXRlfG51bWJlcilcIixcbiAgaWNvblNWRzogXCJzdHJpbmdcIixcbiAgd2l0aEljb246IFwiYm9vbGVhblwiLFxuICBwbUxhYmVsOiBcInN0cmluZ1wiLFxuICBhbUxhYmVsOiBcInN0cmluZ1wiLFxuICBhbmltYXRpb25zOiBcImJvb2xlYW5cIlxufSwgeGcgPSB7XG4gIHRpcHM6IFwiYWJzb2x1dGUgcm91bmRlZC1bMTAwJV0gdy1bMzJweF0gaC1bMzJweF0gdGV4dC1jZW50ZXIgY3Vyc29yLXBvaW50ZXIgdGV4dC1bMS4xcmVtXSByb3VuZGVkLVsxMDAlXSBiZy10cmFuc3BhcmVudCBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBmb250LWxpZ2h0IGZvY3VzOm91dGxpbmUtbm9uZSBzZWxlY3Rpb246YmctdHJhbnNwYXJlbnRcIixcbiAgdGlwc0FjdGl2ZTogXCJ0ZXh0LXdoaXRlIGJnLVsjM2I3MWNhXSBmb250LW5vcm1hbFwiLFxuICB0aXBzRGlzYWJsZWQ6IFwidGV4dC1bI2IzYWZhZl0gcG9pbnRlci1ldmVudHMtbm9uZSBiZy10cmFuc3BhcmVudFwiLFxuICB0cmFuc2Zvcm06IFwidHJhbnNpdGlvbi1bdHJhbnNmb3JtLGhlaWdodF0gZWFzZS1pbi1vdXQgZHVyYXRpb24tWzQwMG1zXVwiLFxuICBtb2RhbDogXCJ6LVsxMDY1XVwiLFxuICBjbG9ja0FuaW1hdGlvbjogXCJhbmltYXRlLVtzaG93LXVwLWNsb2NrXzM1MG1zX2xpbmVhcl1cIixcbiAgb3BhY2l0eTogXCIhb3BhY2l0eS0xMDBcIixcbiAgdGltZXBpY2tlcldyYXBwZXI6IFwidG91Y2gtbm9uZSBvcGFjaXR5LTEwMCB6LVsxMDY1XSBpbnNldC0wIGJnLVsjMDAwMDAwNjZdIGgtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCBmaXhlZFwiLFxuICB0aW1lcGlja2VyQ29udGFpbmVyOiBcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGZsZXgtY29sIG1heC1oLVtjYWxjKDEwMCUtNjRweCldIG92ZXJmbG93LXktYXV0byBzaGFkb3ctWzBfMTBweF8xNXB4Xy0zcHhfcmdiYSgwLDAsMCwwLjA3KSwwXzRweF82cHhfLTJweF9yZ2JhKDAsMCwwLDAuMDUpXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC1sZ1wiLFxuICB0aW1lcGlja2VyRWxlbWVudHM6IFwiZmxleCBmbGV4LWNvbCBtaW4tdy1bMzEwcHhdIG1pbi1oLVszMjVweF0gYmctd2hpdGUgcm91bmRlZC10LVswLjZyZW1dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohZmxleC1yb3cgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm1pbi13LVthdXRvXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLWgtW2F1dG9dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpvdmVyZmxvdy15LWF1dG8ganVzdGlmeS1hcm91bmRcIixcbiAgdGltZXBpY2tlckhlYWQ6IFwiYmctWyMzYjcxY2FdIGRhcms6YmctemluYy03MDAgaC1bMTAwcHhdIHJvdW5kZWQtdC1sZyBwci1bMjRweF0gcGwtWzUwcHhdIHB5LVsxMHB4XSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC10ci1ub25lIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLWJsLW5vbmUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnAtWzEwcHhdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpwci1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmgtYXV0byBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLWgtWzMwNXB4XSBmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiLFxuICB0aW1lcGlja2VySGVhZENvbnRlbnQ6IFwibWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZsZXgtY29sIGZsZXggdy1mdWxsIGp1c3RpZnktZXZlbmx5XCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50V3JhcHBlcjogXCJbZGlyZWN0aW9uOmx0cl0gcnRsOltkaXJlY3Rpb246cnRsXVwiLFxuICB0aW1lcGlja2VyQ3VycmVudEJ1dHRvbldyYXBwZXI6IFwicmVsYXRpdmUgaC1mdWxsXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50QnV0dG9uOiBcInRleHQtWzMuNzVyZW1dIGZvbnQtbGlnaHQgbGVhZGluZy1bMS4yXSB0cmFja2luZy1bLTAuMDA4MzNlbV0gdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHAtMCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6dGV4dC01eGwgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZvbnQtbm9ybWFsIGN1cnNvci1wb2ludGVyIGhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmUgXCIsXG4gIHRpbWVwaWNrZXJEb3Q6IFwiZm9udC1saWdodCBsZWFkaW5nLVsxLjJdIHRyYWNraW5nLVstMC4wMDgzM2VtXSB0ZXh0LVszLjc1cmVtXSBvcGFjaXR5LVsuNTRdIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHAtMCB0ZXh0LXdoaXRlIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTp0ZXh0LVszcmVtXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6Zm9udC1ub3JtYWxcIixcbiAgdGltZXBpY2tlck1vZGVXcmFwcGVyOiBcImZsZXggZmxleC1jb2wganVzdGlmeS1jZW50ZXIgdGV4dC1bMThweF0gdGV4dC1bI2ZmZmZmZjhhXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWp1c3RpZnktYXJvdW5kIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohZmxleC1yb3dcIixcbiAgdGltZXBpY2tlck1vZGVBbTogXCJwLTAgYmctdHJhbnNwYXJlbnQgYm9yZGVyLW5vbmUgdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGN1cnNvci1wb2ludGVyIGhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmVcIixcbiAgdGltZXBpY2tlck1vZGVQbTogXCJwLTAgYmctdHJhbnNwYXJlbnQgYm9yZGVyLW5vbmUgdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGN1cnNvci1wb2ludGVyIGhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmVcIixcbiAgdGltZXBpY2tlckNsb2NrV3JhcHBlcjogXCJtaW4tdy1bMzEwcHhdIG1heC13LVszMjVweF0gbWluLWgtWzMwNXB4XSBvdmVyZmxvdy14LWhpZGRlbiBoLWZ1bGwgZmxleCBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgZGFyazpiZy16aW5jLTUwMFwiLFxuICB0aW1lcGlja2VyQ2xvY2s6IFwicmVsYXRpdmUgcm91bmRlZC1bMTAwJV0gdy1bMjYwcHhdIGgtWzI2MHB4XSBjdXJzb3ItZGVmYXVsdCBteS0wIG14LWF1dG8gYmctWyMwMDAwMDAxMl0gZGFyazpiZy16aW5jLTYwMC81MFwiLFxuICB0aW1lcGlja2VyTWlkZGxlRG90OiBcInRvcC0xLzIgbGVmdC0xLzIgdy1bNnB4XSBoLVs2cHhdIC10cmFuc2xhdGUteS0xLzIgLXRyYW5zbGF0ZS14LTEvMiByb3VuZGVkLVs1MCVdIGJnLVsjM2I3MWNhXSBhYnNvbHV0ZVwiLFxuICB0aW1lcGlja2VySGFuZFBvaW50ZXI6IFwiYmctWyMzYjcxY2FdIGJvdHRvbS0xLzIgaC0yLzUgbGVmdC1bY2FsYyg1MCUtMXB4KV0gcnRsOiFsZWZ0LWF1dG8gb3JpZ2luLVtjZW50ZXJfYm90dG9tXzBdIHJ0bDohb3JpZ2luLVs1MCVfNTAlXzBdIHctWzJweF0gYWJzb2x1dGVcIixcbiAgdGltZXBpY2tlclBvaW50ZXJDaXJjbGU6IFwiLXRvcC1bMjFweF0gLWxlZnQtWzE1cHhdIHctWzRweF0gYm9yZGVyLVsxNHB4XSBib3JkZXItc29saWQgYm9yZGVyLVsjM2I3MWNhXSBoLVs0cHhdIGJveC1jb250ZW50IHJvdW5kZWQtWzEwMCVdIGFic29sdXRlXCIsXG4gIHRpbWVwaWNrZXJDbG9ja0lubmVyOiBcImFic29sdXRlIHRvcC0xLzIgbGVmdC0xLzIgLXRyYW5zbGF0ZS15LTEvMiAtdHJhbnNsYXRlLXgtMS8yIHctWzE2MHB4XSBoLVsxNjBweF0gcm91bmRlZC1bMTAwJV1cIixcbiAgdGltZXBpY2tlckZvb3RlcldyYXBwZXI6IFwicm91bmRlZC1iLWxnIGZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlciB3LWZ1bGwgaC1bNTZweF0gcHgtWzEycHhdIGJnLXdoaXRlIGRhcms6YmctemluYy01MDBcIixcbiAgdGltZXBpY2tlckZvb3RlcjogXCJ3LWZ1bGwgZmxleCBqdXN0aWZ5LWJldHdlZW5cIixcbiAgdGltZXBpY2tlckZvb3RlckJ1dHRvbjogXCJ0ZXh0LVswLjhyZW1dIG1pbi13LVs2NHB4XSBib3gtYm9yZGVyIGZvbnQtbWVkaXVtIGxlYWRpbmctWzQwcHhdIHJvdW5kZWQtWzEwcHhdIHRyYWNraW5nLVswLjFyZW1dIHVwcGVyY2FzZSB0ZXh0LVsjM2I3MWNhXSBkYXJrOnRleHQtd2hpdGUgYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1bYmFja2dyb3VuZC1jb2xvcixib3gtc2hhZG93LGJvcmRlcl0gZHVyYXRpb24tWzI1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC40LDAsMC4yLDEpXSBkZWxheS1bMG1zXSBvdXRsaW5lLW5vbmUgcHktMCBweC1bMTBweF0gaC1bNDBweF0gbWItWzEwcHhdIGhvdmVyOmJnLVsjMDAwMDAwMTRdIGZvY3VzOmJnLVsjMDAwMDAwMTRdIGZvY3VzOm91dGxpbmUtbm9uZVwiLFxuICB0aW1lcGlja2VySW5saW5lV3JhcHBlcjogXCJ0b3VjaC1ub25lIG9wYWNpdHktMTAwIHotWzEwNjVdIGluc2V0LTAgYmctWyMwMDAwMDA2Nl0gaC1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGZsZXgtY29sIHJvdW5kZWQtbGdcIixcbiAgdGltZXBpY2tlcklubGluZUNvbnRhaW5lcjogXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCBtYXgtaC1bY2FsYygxMDAlLTY0cHgpXSBvdmVyZmxvdy15LWF1dG8gc2hhZG93LVswXzEwcHhfMTVweF8tM3B4X3JnYmEoMCwwLDAsMC4wNyksMF80cHhfNnB4Xy0ycHhfcmdiYSgwLDAsMCwwLjA1KV1cIixcbiAgdGltZXBpY2tlcklubGluZUVsZW1lbnRzOiBcImZsZXggZmxleC1jb2wgbWluLWgtW2F1dG9dIG1pbi13LVszMTBweF0gYmctd2hpdGUgcm91bmRlZC1bMC42cmVtXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWZsZXgtcm93IG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLWJsLWxnIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTptaW4tdy1bYXV0b10gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOjptaW4taC1bYXV0b10gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm92ZXJmbG93LXktYXV0byBqdXN0aWZ5LWFyb3VuZFwiLFxuICB0aW1lcGlja2VySW5saW5lSGVhZDogXCJiZy1bIzNiNzFjYV0gZGFyazpiZy16aW5jLTcwMCBoLVsxMDBweF0gcm91bmRlZC10LWxnIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLXRyLW5vbmUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtYmwtbm9uZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cC1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnByLVsxMHB4XSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6aC1hdXRvIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTptaW4taC1bMzA1cHhdIGZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHAtMCByb3VuZGVkLWItbGdcIixcbiAgdGltZXBpY2tlcklubGluZUhlYWRDb250ZW50OiBcIm1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmbGV4LWNvbCBmbGV4IHctZnVsbCBqdXN0aWZ5LWV2ZW5seSBpdGVtcy1jZW50ZXJcIixcbiAgdGltZXBpY2tlcklubGluZUhvdXJXcmFwcGVyOiBcInJlbGF0aXZlIGgtZnVsbCAhb3BhY2l0eS0xMDBcIixcbiAgdGltZXBpY2tlckN1cnJlbnRNaW51dGVXcmFwcGVyOiBcInJlbGF0aXZlIGgtZnVsbFwiLFxuICB0aW1lcGlja2VySW5saW5lSWNvblVwOiBcImFic29sdXRlIHRleHQtd2hpdGUgLXRvcC1bMzVweF0gb3BhY2l0eS0wIGhvdmVyOm9wYWNpdHktMTAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLVtlYXNlXSBjdXJzb3ItcG9pbnRlciAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgbGVmdC0xLzIgdy1bMzBweF0gaC1bMzBweF0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIixcbiAgdGltZXBpY2tlcklubGluZUljb25Tdmc6IFwiaC00IHctNFwiLFxuICB0aW1lcGlja2VySW5saW5lQ3VycmVudEJ1dHRvbjogXCJmb250LWxpZ2h0IGxlYWRpbmctWzEuMl0gdHJhY2tpbmctWy0wLjAwODMzZW1dIHRleHQtd2hpdGUgYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcC0wIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTp0ZXh0LTV4bCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6Zm9udC1ub3JtYWwgIW9wYWNpdHktMTAwIGN1cnNvci1wb2ludGVyIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpvdXRsaW5lLW5vbmUgdGV4dC1bMi41cmVtXSBob3ZlcjpiZy1bdW5zZXRdXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uRG93bjogXCJhYnNvbHV0ZSB0ZXh0LXdoaXRlIC1ib3R0b20tWzQ3cHhdIG9wYWNpdHktMCBob3ZlcjpvcGFjaXR5LTEwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1bZWFzZV0gY3Vyc29yLXBvaW50ZXIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIGxlZnQtMS8yIHctWzMwcHhdIGgtWzMwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVEb3Q6IFwiZm9udC1saWdodCBsZWFkaW5nLVsxLjJdIHRyYWNraW5nLVstMC4wMDgzM2VtXSBvcGFjaXR5LVsuNTRdIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHAtMCB0ZXh0LXdoaXRlIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTp0ZXh0LVszcmVtXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6Zm9udC1ub3JtYWwgdGV4dC1bMi41cmVtXVwiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZVdyYXBwZXI6IFwiZmxleCBqdXN0aWZ5LWNlbnRlciB0ZXh0LVsxOHB4XSB0ZXh0LVsjZmZmZmZmOGFdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohanVzdGlmeS1hcm91bmQgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFmbGV4LXJvd1wiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZUFtOiBcImhvdmVyOmJnLVsjMDAwMDAwMjZdIGhvdmVyOm91dGxpbmUtbm9uZSBmb2N1czpiZy1bIzAwMDAwMDI2XSBmb2N1czpvdXRsaW5lLW5vbmUgcC0wIGJnLXRyYW5zcGFyZW50IGJvcmRlci1ub25lIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBjdXJzb3ItcG9pbnRlciBtci0yIG1sLTZcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVQbTogXCJob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lIHAtMCBiZy10cmFuc3BhcmVudCBib3JkZXItbm9uZSB0ZXh0LXdoaXRlIG9wYWNpdHktWy41NF0gY3Vyc29yLXBvaW50ZXJcIixcbiAgdGltZXBpY2tlcklubGluZVN1Ym1pdEJ1dHRvbjogXCJob3ZlcjpiZy1bIzAwMDAwMDE0XSBmb2N1czpiZy1bIzAwMDAwMDE0XSBmb2N1czpvdXRsaW5lLW5vbmUgdGV4dC1bMC44cmVtXSBib3gtYm9yZGVyIGZvbnQtbWVkaXVtIGxlYWRpbmctWzQwcHhdIHRyYWNraW5nLVsuMXJlbV0gdXBwZXJjYXNlIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IFt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3JfMjUwbXNfY3ViaWMtYmV6aWVyKDAuNCwwLDAuMiwxKV8wbXMsYm94LXNoYWRvd18yNTBtc19jdWJpYy1iZXppZXIoMC40LDAsMC4yLDEpXzBtcyxib3JkZXJfMjUwbXNfY3ViaWMtYmV6aWVyKDAuNCwwLDAuMiwxKV8wbXNdIG91dGxpbmUtbm9uZSByb3VuZGVkLVsxMDAlXSBoLVs0OHB4XSBtaW4tdy1bNDhweF0gaW5saW5lLWJsb2NrIG1sLVszMHB4XSB0ZXh0LXdoaXRlIHB5LTEgcHgtMiBtYi0wXCIsXG4gIHRpbWVwaWNrZXJUb2dnbGVCdXR0b246IFwiaC00IHctNCBtbC1hdXRvIGFic29sdXRlIG91dGxpbmUtbm9uZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCByaWdodC0xLjUgdG9wLTEvMiAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEpXSBjdXJzb3ItcG9pbnRlciBob3Zlcjp0ZXh0LVsjM2I3MWNhXSBmb2N1czp0ZXh0LVsjM2I3MWNhXSBkYXJrOmhvdmVyOnRleHQtWyMzYjcxY2FdIGRhcms6Zm9jdXM6dGV4dC1bIzNiNzFjYV0gZGFyazp0ZXh0LXdoaXRlXCJcbn0sIE9nID0ge1xuICB0aXBzOiBcInN0cmluZ1wiLFxuICB0aXBzQWN0aXZlOiBcInN0cmluZ1wiLFxuICB0aXBzRGlzYWJsZWQ6IFwic3RyaW5nXCIsXG4gIHRyYW5zZm9ybTogXCJzdHJpbmdcIixcbiAgbW9kYWw6IFwic3RyaW5nXCIsXG4gIGNsb2NrQW5pbWF0aW9uOiBcInN0cmluZ1wiLFxuICBvcGFjaXR5OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckVsZW1lbnRzOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySGVhZDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckhlYWRDb250ZW50OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ3VycmVudFdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50QnV0dG9uV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckN1cnJlbnRCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJEb3Q6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJNb2RlV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlck1vZGVBbTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlck1vZGVQbTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNsb2NrV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNsb2NrOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyTWlkZGxlRG90OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySGFuZFBvaW50ZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJQb2ludGVyQ2lyY2xlOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ2xvY2tJbm5lcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckZvb3RlcldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJGb290ZXJCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lQ29udGFpbmVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lRWxlbWVudHM6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIZWFkOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSGVhZENvbnRlbnQ6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIb3VyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckN1cnJlbnRNaW51dGVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSWNvblVwOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSWNvblN2ZzogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUN1cnJlbnRCdXR0b246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uRG93bjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZURvdDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZUFtOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lTW9kZVBtOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lU3VibWl0QnV0dG9uOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyVG9nZ2xlQnV0dG9uOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgU2cge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkpIHtcbiAgICB3dCh0aGlzLCBcIl90b2dnbGVBbVBtXCIsICh0KSA9PiB7XG4gICAgICB0ID09PSBcIlBNXCIgPyAodGhpcy5faXNQbUVuYWJsZWQgPSAhMCwgdGhpcy5faXNBbUVuYWJsZWQgPSAhMSkgOiB0ID09PSBcIkFNXCIgJiYgKHRoaXMuX2lzUG1FbmFibGVkID0gITEsIHRoaXMuX2lzQW1FbmFibGVkID0gITApO1xuICAgIH0pO1xuICAgIHd0KHRoaXMsIFwiX3RvZ2dsZUJhY2tncm91bmRDb2xvckNpcmNsZVwiLCAodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX21vZGFsLnF1ZXJ5U2VsZWN0b3IoYCR7dH1bJHtIfV1gKSAhPT0gbnVsbCkge1xuICAgICAgICBoLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMTk3NmQyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGguYWRkU3R5bGUodGhpcy5fY2lyY2xlLCB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB3dCh0aGlzLCBcIl90b2dnbGVDbGFzc0FjdGl2ZVwiLCAodCwgeyB0ZXh0Q29udGVudDogZSB9LCBpKSA9PiB7XG4gICAgICBjb25zdCBuID0gWy4uLnRdLmZpbmQoXG4gICAgICAgIChvKSA9PiBOdW1iZXIobykgPT09IE51bWJlcihlKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgaWYgKCFvLmhhc0F0dHJpYnV0ZShqdCkpIHtcbiAgICAgICAgICBpZiAoby50ZXh0Q29udGVudCA9PT0gbikge1xuICAgICAgICAgICAgaC5hZGRDbGFzcyhvLCB0aGlzLl9jbGFzc2VzLnRpcHNBY3RpdmUpLCBvLnNldEF0dHJpYnV0ZShILCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaC5yZW1vdmVDbGFzcyhvLCB0aGlzLl9jbGFzc2VzLnRpcHNBY3RpdmUpLCBvLnJlbW92ZUF0dHJpYnV0ZShIKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgd3QodGhpcywgXCJfbWFrZU1pbnV0ZXNEZWdyZWVzXCIsICh0LCBlKSA9PiB7XG4gICAgICBjb25zdCB7IGluY3JlbWVudDogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIHJldHVybiB0IDwgMCA/IChlID0gTWF0aC5yb3VuZCgzNjAgKyB0IC8gNikgJSA2MCwgdCA9IDM2MCArIE1hdGgucm91bmQodCAvIDYpICogNikgOiAoZSA9IE1hdGgucm91bmQodCAvIDYpICUgNjAsIHQgPSBNYXRoLnJvdW5kKHQgLyA2KSAqIDYpLCBpICYmICh0ID0gTWF0aC5yb3VuZCh0IC8gMzApICogMzAsIGUgPSBNYXRoLnJvdW5kKHQgLyA2KSAqIDYgLyA2LCBlID09PSA2MCAmJiAoZSA9IFwiMDBcIikpLCB0ID49IDM2MCAmJiAodCA9IDApLCB7XG4gICAgICAgIGRlZ3JlZXM6IHQsXG4gICAgICAgIG1pbnV0ZTogZSxcbiAgICAgICAgYWRkRGVncmVlczogaSA/IDMwIDogNlxuICAgICAgfTtcbiAgICB9KTtcbiAgICB3dCh0aGlzLCBcIl9tYWtlSG91ckRlZ3JlZXNcIiwgKHQsIGUsIGkpID0+IHtcbiAgICAgIGlmICh0KVxuICAgICAgICByZXR1cm4gdGhpcy5faGFzVGFyZ2V0SW5uZXJDbGFzcyh0KSA/IGUgPCAwID8gKGkgPSBNYXRoLnJvdW5kKDM2MCArIGUgLyAzMCkgJSAyNCwgZSA9IDM2MCArIGUpIDogKGkgPSBNYXRoLnJvdW5kKGUgLyAzMCkgKyAxMiwgaSA9PT0gMTIgJiYgKGkgPSBcIjAwXCIpKSA6IGUgPCAwID8gKGkgPSBNYXRoLnJvdW5kKDM2MCArIGUgLyAzMCkgJSAxMiwgZSA9IDM2MCArIGUpIDogKGkgPSBNYXRoLnJvdW5kKGUgLyAzMCkgJSAxMiwgKGkgPT09IDAgfHwgaSA+IDEyKSAmJiAoaSA9IDEyKSksIGUgPj0gMzYwICYmIChlID0gMCksIHtcbiAgICAgICAgICBkZWdyZWVzOiBlLFxuICAgICAgICAgIGhvdXI6IGksXG4gICAgICAgICAgYWRkRGVncmVlczogMzBcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICB3dCh0aGlzLCBcIl9tYWtlSW5uZXJIb3Vyc0RlZ3JlZXNcIiwgKHQsIGUpID0+ICh0IDwgMCA/IChlID0gTWF0aC5yb3VuZCgzNjAgKyB0IC8gMzApICUgMjQsIHQgPSAzNjAgKyB0KSA6IChlID0gTWF0aC5yb3VuZCh0IC8gMzApICsgMTIsIGUgPT09IDEyICYmIChlID0gXCIwMFwiKSksIHtcbiAgICAgIGRlZ3JlZXM6IHQsXG4gICAgICBob3VyOiBlLFxuICAgICAgYWRkRGVncmVlczogMzBcbiAgICB9KSk7XG4gICAgd3QodGhpcywgXCJfZ2V0QXBwZW5kQ2xvY2tcIiwgKHQgPSBbXSwgZSA9IGBbJHt1ZX1dYCwgaSkgPT4ge1xuICAgICAgbGV0IHsgbWluVGltZTogbiwgbWF4VGltZTogbyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIGNvbnN0IHsgaW5saW5lOiByLCBmb3JtYXQxMjogYSwgZGlzYWJsZVBhc3Q6IGwsIGRpc2FibGVGdXR1cmU6IHAgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICBuID0gR3QobiwgbCwgYSksIG8gPSBxdChvLCBwLCBhKTtcbiAgICAgIGNvbnN0IFt1LCBfLCBmXSA9IFIoXG4gICAgICAgIG8sXG4gICAgICAgICExXG4gICAgICApLCBbZywgbSwgYl0gPSBSKFxuICAgICAgICBuLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICAgICFyICYmIGEgJiYgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCAmJiAhdGhpcy5fQU0uaGFzQXR0cmlidXRlKEgpICYmIChoLmFkZENsYXNzKHRoaXMuX1BNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9QTS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpO1xuICAgICAgY29uc3QgdiA9IGQuZmluZE9uZShlKSwgVCA9IDM2MCAvIHQubGVuZ3RoO1xuICAgICAgZnVuY3Rpb24geShrKSB7XG4gICAgICAgIHJldHVybiBrICogKE1hdGguUEkgLyAxODApO1xuICAgICAgfVxuICAgICAgaWYgKHYgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IEMgPSAodi5vZmZzZXRXaWR0aCAtIDMyKSAvIDIsIEUgPSAodi5vZmZzZXRIZWlnaHQgLSAzMikgLyAyLCB3ID0gQyAtIDQ7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGV0IGs7XG4gICAgICAgIGEgJiYgKGsgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYCR7RXN9WyR7SH1dYFxuICAgICAgICApLnRleHRDb250ZW50KSwgdGhpcy5faGFuZGxlRGlzYWJsaW5nVGlwc01pblRpbWUoXG4gICAgICAgICAgayxcbiAgICAgICAgICBiLFxuICAgICAgICAgIG0sXG4gICAgICAgICAgZ1xuICAgICAgICApLCB0aGlzLl9oYW5kbGVEaXNhYmxpbmdUaXBzTWF4VGltZShcbiAgICAgICAgICBrLFxuICAgICAgICAgIGYsXG4gICAgICAgICAgXyxcbiAgICAgICAgICB1XG4gICAgICAgICk7XG4gICAgICB9LCAwKSwgWy4uLnRdLmZvckVhY2goKGssIEQpID0+IHtcbiAgICAgICAgY29uc3QgTyA9IHkoRCAqIFQpLCB4ID0gJChcInNwYW5cIiksIEwgPSAkKFwic3BhblwiKTtcbiAgICAgICAgTC5pbm5lckhUTUwgPSBrLCBoLmFkZENsYXNzKHgsIHRoaXMuX2NsYXNzZXMudGlwcyksIHguc2V0QXR0cmlidXRlKGksIFwiXCIpO1xuICAgICAgICBjb25zdCBTID0geC5vZmZzZXRXaWR0aCwgTiA9IHgub2Zmc2V0SGVpZ2h0O1xuICAgICAgICByZXR1cm4gaC5hZGRTdHlsZSh4LCB7XG4gICAgICAgICAgbGVmdDogYCR7QyArIE1hdGguc2luKE8pICogdyAtIFN9cHhgLFxuICAgICAgICAgIGJvdHRvbTogYCR7RSArIE1hdGguY29zKE8pICogdyAtIE59cHhgXG4gICAgICAgIH0pLCB0LmluY2x1ZGVzKFwiMDVcIikgJiYgeC5zZXRBdHRyaWJ1dGUocSwgXCJcIiksIHQuaW5jbHVkZXMoXCIxM1wiKSA/IEwuc2V0QXR0cmlidXRlKHlzLCBcIlwiKSA6IEwuc2V0QXR0cmlidXRlKEFzLCBcIlwiKSwgeC5hcHBlbmRDaGlsZChMKSwgdi5hcHBlbmRDaGlsZCh4KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9lbGVtZW50ICYmIEEuc2V0RGF0YSh0LCBKcywgdGhpcyksIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9jdXJyZW50VGltZSA9IG51bGwsIHRoaXMuX3RvZ2dsZUJ1dHRvbklkID0gZXQoXCJ0aW1lcGlja2VyLXRvZ2dsZS1cIiksIHRoaXMuaG91cnNBcnJheSA9IFtcbiAgICAgIFwiMTJcIixcbiAgICAgIFwiMVwiLFxuICAgICAgXCIyXCIsXG4gICAgICBcIjNcIixcbiAgICAgIFwiNFwiLFxuICAgICAgXCI1XCIsXG4gICAgICBcIjZcIixcbiAgICAgIFwiN1wiLFxuICAgICAgXCI4XCIsXG4gICAgICBcIjlcIixcbiAgICAgIFwiMTBcIixcbiAgICAgIFwiMTFcIlxuICAgIF0sIHRoaXMuaW5uZXJIb3VycyA9IFtcbiAgICAgIFwiMDBcIixcbiAgICAgIFwiMTNcIixcbiAgICAgIFwiMTRcIixcbiAgICAgIFwiMTVcIixcbiAgICAgIFwiMTZcIixcbiAgICAgIFwiMTdcIixcbiAgICAgIFwiMThcIixcbiAgICAgIFwiMTlcIixcbiAgICAgIFwiMjBcIixcbiAgICAgIFwiMjFcIixcbiAgICAgIFwiMjJcIixcbiAgICAgIFwiMjNcIlxuICAgIF0sIHRoaXMubWludXRlc0FycmF5ID0gW1xuICAgICAgXCIwMFwiLFxuICAgICAgXCIwNVwiLFxuICAgICAgXCIxMFwiLFxuICAgICAgXCIxNVwiLFxuICAgICAgXCIyMFwiLFxuICAgICAgXCIyNVwiLFxuICAgICAgXCIzMFwiLFxuICAgICAgXCIzNVwiLFxuICAgICAgXCI0MFwiLFxuICAgICAgXCI0NVwiLFxuICAgICAgXCI1MFwiLFxuICAgICAgXCI1NVwiXG4gICAgXSwgdGhpcy5pbnB1dCA9IGQuZmluZE9uZShcImlucHV0XCIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLmRhdGFXaXRoSWNvbiA9IHQuZGF0YXNldC53aXRoSWNvbiwgdGhpcy5kYXRhVG9nZ2xlID0gdC5kYXRhc2V0LnRvZ2dsZSwgdGhpcy5jdXN0b21JY29uID0gZC5maW5kT25lKFxuICAgICAgbWcsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fY2hlY2tUb2dnbGVCdXR0b24oKSwgdGhpcy5pbnB1dEZvcm1hdFNob3cgPSBkLmZpbmRPbmUoXG4gICAgICBmZyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLmlucHV0Rm9ybWF0ID0gdGhpcy5pbnB1dEZvcm1hdFNob3cgPT09IG51bGwgPyBcIlwiIDogT2JqZWN0LnZhbHVlcyh0aGlzLmlucHV0Rm9ybWF0U2hvdy5kYXRhc2V0KVswXSwgdGhpcy5lbGVtZW50VG9nZ2xlID0gZC5maW5kT25lKFxuICAgICAgR2EsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy50b2dnbGVFbGVtZW50ID0gT2JqZWN0LnZhbHVlcyhcbiAgICAgIHQucXVlcnlTZWxlY3RvcihHYSkuZGF0YXNldFxuICAgIClbMF0sIHRoaXMuX2hvdXIgPSBudWxsLCB0aGlzLl9taW51dGVzID0gbnVsbCwgdGhpcy5fQU0gPSBudWxsLCB0aGlzLl9QTSA9IG51bGwsIHRoaXMuX3dyYXBwZXIgPSBudWxsLCB0aGlzLl9tb2RhbCA9IG51bGwsIHRoaXMuX2hhbmQgPSBudWxsLCB0aGlzLl9jaXJjbGUgPSBudWxsLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9pbnRlcnZhbCA9IG51bGwsIHRoaXMuX3RpbWVvdXRJbnRlcnZhbCA9IG51bGwsIHRoaXMuX2lucHV0VmFsdWUgPSB0aGlzLl9vcHRpb25zLmRlZmF1bHRUaW1lICE9PSBcIlwiID8gdGhpcy5fb3B0aW9ucy5kZWZhdWx0VGltZSA6IHRoaXMuaW5wdXQudmFsdWUsIHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgJiYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MTIgPSAhMSwgdGhpcy5fY3VycmVudFRpbWUgPSBLYSh0aGlzLl9pbnB1dFZhbHVlKSksIHRoaXMuX29wdGlvbnMuZm9ybWF0MTIgJiYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgPSAhMSwgdGhpcy5fY3VycmVudFRpbWUgPSBDZSh0aGlzLl9pbnB1dFZhbHVlKSksIHRoaXMuX29wdGlvbnMucmVhZE9ubHkgJiYgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoRWcsICEwKSwgdGhpcy5pbnB1dEZvcm1hdCA9PT0gXCJ0cnVlXCIgJiYgdGhpcy5pbnB1dEZvcm1hdCAhPT0gXCJcIiAmJiAodGhpcy5fb3B0aW9ucy5mb3JtYXQxMiA9ICExLCB0aGlzLl9vcHRpb25zLmZvcm1hdDI0ID0gITAsIHRoaXMuX2N1cnJlbnRUaW1lID0gS2EodGhpcy5faW5wdXRWYWx1ZSkpLCB0aGlzLl9hbmltYXRpb25zID0gIXdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIikubWF0Y2hlcyAmJiB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbnMsIHRoaXMuaW5pdCgpLCB0aGlzLl9pc0hvdXJzID0gITAsIHRoaXMuX2lzTWludXRlcyA9ICExLCB0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0ID0gITEsIHRoaXMuX2lzTW91c2VNb3ZlID0gITEsIHRoaXMuX2lzSW5uZXIgPSAhMSwgdGhpcy5faXNBbUVuYWJsZWQgPSAhMSwgdGhpcy5faXNQbUVuYWJsZWQgPSAhMSwgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMiAmJiAhdGhpcy5fb3B0aW9ucy5kZWZhdWx0VGltZSAmJiAodGhpcy5faXNQbUVuYWJsZWQgPSAhMCksIHRoaXMuX29ialdpdGhEYXRhT25DaGFuZ2UgPSB7IGRlZ3JlZXM6IG51bGwgfSwgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IHRpKCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEJpO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIGNvbnN0IHsgZm9ybWF0MTI6IHQsIGZvcm1hdDI0OiBlLCBlbmFibGVWYWxpZGF0aW9uOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGxldCBuLCBvLCByO1xuICAgIGlmICh0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShBZywgXCJcIiksIHRoaXMuX2N1cnJlbnRUaW1lICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHsgaG91cnM6IGEsIG1pbnV0ZXM6IGwsIGFtT3JQbTogcCB9ID0gdGhpcy5fY3VycmVudFRpbWU7XG4gICAgICBuID0gTnVtYmVyKGEpIDwgMTAgPyAwIDogXCJcIiwgbyA9IGAke259JHtOdW1iZXIoYSl9OiR7bH1gLCByID0gcCwgdCA/IHRoaXMuaW5wdXQudmFsdWUgPSBgJHtvfSAke3J9YCA6IGUgJiYgKHRoaXMuaW5wdXQudmFsdWUgPSBgJHtvfWApO1xuICAgIH0gZWxzZVxuICAgICAgbiA9IFwiXCIsIG8gPSBcIlwiLCByID0gXCJcIiwgdGhpcy5pbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgdGhpcy5pbnB1dC52YWx1ZS5sZW5ndGggPiAwICYmIHRoaXMuaW5wdXQudmFsdWUgIT09IFwiXCIgJiYgKHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKEgsIFwiXCIpLCBjLnRyaWdnZXIodGhpcy5pbnB1dCwgXCJpbnB1dFwiKSksICEodGhpcy5fb3B0aW9ucyA9PT0gbnVsbCAmJiB0aGlzLl9lbGVtZW50ID09PSBudWxsKSAmJiAoaSAmJiB0aGlzLl9nZXRWYWxpZGF0ZShcImtleWRvd24gY2hhbmdlIGJsdXIgZm9jdXNcIiksIHRoaXMuX2hhbmRsZU9wZW4oKSwgdGhpcy5fbGlzdGVuVG9Ub2dnbGVLZXlkb3duKCkpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcmVtb3ZlTW9kYWwoKSwgdGhpcy5fZWxlbWVudCAhPT0gbnVsbCAmJiBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgSnMpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbCwgdGhpcy5pbnB1dCA9IG51bGwsIHRoaXMuX2ZvY3VzVHJhcCA9IG51bGw7XG4gICAgfSwgMzUwKSwgYy5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgYFtkYXRhLXRlLXRvZ2dsZT0nJHt0aGlzLnRvZ2dsZUVsZW1lbnR9J11gXG4gICAgKSwgYy5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICBgW2RhdGEtdGUtdG9nZ2xlPScke3RoaXMudG9nZ2xlRWxlbWVudH0nXWBcbiAgICApO1xuICB9XG4gIHVwZGF0ZSh0ID0ge30pIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKHsgLi4udGhpcy5fb3B0aW9ucywgLi4udCB9KTtcbiAgfVxuICAvLyBwcml2YXRlXG4gIF9jaGVja1RvZ2dsZUJ1dHRvbigpIHtcbiAgICB0aGlzLmN1c3RvbUljb24gPT09IG51bGwgJiYgKHRoaXMuZGF0YVdpdGhJY29uICE9PSB2b2lkIDAgJiYgKHRoaXMuX29wdGlvbnMud2l0aEljb24gPSBudWxsLCB0aGlzLmRhdGFXaXRoSWNvbiA9PT0gXCJ0cnVlXCIgJiYgdGhpcy5fYXBwZW5kVG9nZ2xlQnV0dG9uKHRoaXMuX29wdGlvbnMpKSwgdGhpcy5fb3B0aW9ucy53aXRoSWNvbiAmJiB0aGlzLl9hcHBlbmRUb2dnbGVCdXR0b24odGhpcy5fb3B0aW9ucykpO1xuICB9XG4gIF9hcHBlbmRUb2dnbGVCdXR0b24oKSB7XG4gICAgY29uc3QgdCA9IGFnKFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5pbnB1dC5pbnNlcnRBZGphY2VudEhUTUwoXCJhZnRlcmVuZFwiLCB0KTtcbiAgfVxuICBfZ2V0RG9tRWxlbWVudHMoKSB7XG4gICAgdGhpcy5faG91ciA9IGQuZmluZE9uZShgWyR7Q3N9XWApLCB0aGlzLl9taW51dGVzID0gZC5maW5kT25lKGBbJHt1b31dYCksIHRoaXMuX0FNID0gZC5maW5kT25lKHBnKSwgdGhpcy5fUE0gPSBkLmZpbmRPbmUoX2cpLCB0aGlzLl93cmFwcGVyID0gZC5maW5kT25lKGBbJHtob31dYCksIHRoaXMuX21vZGFsID0gZC5maW5kT25lKGBbJHtjbH1dYCksIHRoaXMuX2hhbmQgPSBkLmZpbmRPbmUoYFske3BvfV1gKSwgdGhpcy5fY2lyY2xlID0gZC5maW5kT25lKGBbJHtfb31dYCksIHRoaXMuX2Nsb2NrID0gZC5maW5kT25lKGBbJHt1ZX1dYCksIHRoaXMuX2Nsb2NrSW5uZXIgPSBkLmZpbmRPbmUoXG4gICAgICBgWyR7bWl9XWBcbiAgICApO1xuICB9XG4gIF9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKHQsIGUsIGksIG4sIG8sIHIpIHtcbiAgICBpZiAoIWUgJiYgIWkpXG4gICAgICByZXR1cm4gITA7XG4gICAgY29uc3QgeyBmb3JtYXQyNDogYSwgZm9ybWF0MTI6IGwsIGRpc2FibGVQYXN0OiBwLCBkaXNhYmxlRnV0dXJlOiB1IH0gPSB0aGlzLl9vcHRpb25zLCB7IF9pc0FtRW5hYmxlZDogXywgX2lzUG1FbmFibGVkOiBmIH0gPSB0aGlzLCBnID0gci5rZXlDb2RlLCBtID0gci50YXJnZXQuaGFzQXR0cmlidXRlKG1pKSB8fCByLnRhcmdldC5oYXNBdHRyaWJ1dGUoaHQpIHx8IHIudGFyZ2V0Lmhhc0F0dHJpYnV0ZSh5cyk7XG4gICAgaSA9IEd0KGksIHAsIGwpLCBlID0gcXQoZSwgdSwgbCksIHR5cGVvZiBlICE9IFwibnVtYmVyXCIgJiYgKGUgPSBSKGUsICExKVswXSk7XG4gICAgY29uc3QgYiA9IGUgIT09IFwiXCIgPyBlICogMzAgOiBcIlwiLCB2ID0gaSAhPT0gXCJcIiA/IGkgKiAzMCA6IFwiXCI7XG4gICAgdCA8IDAgJiYgKHQgPSAzNjAgKyB0KSwgdCA9IHQgPT09IDM2MCA/IDAgOiB0O1xuICAgIGNvbnN0IFQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBEID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgYFske0FzfV1gXG4gICAgICApLCBPID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgYFske3lzfV1gXG4gICAgICApLCB4ID0gdWcodGhpcy5faG91ci5pbm5lclRleHQpO1xuICAgICAgbGV0IEwsIFMsIE47XG4gICAgICByZXR1cm4gZyA9PT0gVSA/IFMgPSAxIDogZyA9PT0geiAmJiAoUyA9IC0xKSwgeCA9PT0gMTIgJiYgZyA9PT0gVSA/IE4gPSAxIDogeCA9PT0gMCAmJiBnID09PSBVID8gTiA9IDEzIDogeCA9PT0gMCAmJiBnID09PSB6ID8gTiA9IDIzIDogeCA9PT0gMTMgJiYgZyA9PT0geiA/IE4gPSAwIDogeCA9PT0gMSAmJiBnID09PSB6ID8gTiA9IDEyIDogTiA9IHggKyBTLCBELmZvckVhY2goKFApID0+IHtcbiAgICAgICAgTnVtYmVyKFAudGV4dENvbnRlbnQpID09PSBOICYmIChMID0gUCk7XG4gICAgICB9KSwgTy5mb3JFYWNoKChQKSA9PiB7XG4gICAgICAgIE51bWJlcihQLnRleHRDb250ZW50KSA9PT0gTiAmJiAoTCA9IFApO1xuICAgICAgfSksICFMLnBhcmVudEVsZW1lbnQuaGFzQXR0cmlidXRlKGp0KTtcbiAgICB9LCB5ID0gKCkgPT4ge1xuICAgICAgY29uc3QgRCA9IGkgIT09IFwiXCIgJiYgaSA+IDEyID8gKGkgLSAxMikgKiAzMCA6IFwiXCIsIE8gPSBlICE9PSBcIlwiICYmIGUgPiAxMiA/IChlIC0gMTIpICogMzAgOiBcIlwiO1xuICAgICAgaWYgKCEoRCAmJiB0IDwgRCB8fCBPICYmIHQgPiBPIHx8IGUgJiYgZSA8IDEyKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH07XG4gICAgaWYgKGEgJiYgci50eXBlICE9PSBcImtleWRvd25cIiAmJiBtKVxuICAgICAgcmV0dXJuIHkoKTtcbiAgICBpZiAoci50eXBlID09PSBcImtleWRvd25cIilcbiAgICAgIHJldHVybiBUKCk7XG4gICAgY29uc3QgQyA9ICFvIHx8IG8gPT09IFwiUE1cIiAmJiBmIHx8IGkgIT09IFwiXCIgJiYgbyA9PT0gXCJBTVwiICYmIF8sIEUgPSAhbiB8fCBuID09PSBcIlBNXCIgJiYgZiB8fCBlICE9PSBcIlwiICYmIG4gPT09IFwiQU1cIiAmJiBfLCB3ID0gKCkgPT4ge1xuICAgICAgY29uc3QgRCA9IHYgPT09IDM2MCAmJiBsID8gMCA6IHY7XG4gICAgICBpZiAoaSkge1xuICAgICAgICBpZiAobyA9PT0gXCJQTVwiICYmIF8gfHwgQyAmJiB0IDwgRClcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIGsgPSAoKSA9PiB7XG4gICAgICBjb25zdCBEID0gYiA9PT0gMzYwICYmIGwgPyAwIDogYjtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGlmIChuID09PSBcIkFNXCIgJiYgZiB8fCBFICYmIHQgPiBEKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITA7XG4gICAgfTtcbiAgICByZXR1cm4gdygpICYmIGsoKTtcbiAgfVxuICBfaGFuZGxlS2V5Ym9hcmQoKSB7XG4gICAgYy5vbih0aGlzLl9kb2N1bWVudCwgdnMsIFwiXCIsICh0KSA9PiB7XG4gICAgICBsZXQgZSwgaSwgbjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5jcmVtZW50OiBvLFxuICAgICAgICBtYXhUaW1lOiByLFxuICAgICAgICBtaW5UaW1lOiBhLFxuICAgICAgICBmb3JtYXQxMjogbCxcbiAgICAgICAgZGlzYWJsZVBhc3Q6IHAsXG4gICAgICAgIGRpc2FibGVGdXR1cmU6IHVcbiAgICAgIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgbGV0IF8gPSBSKGEsICExKVswXSwgZiA9IFIociwgITEpWzBdO1xuICAgICAgY29uc3QgZyA9IFIoYSwgITEpWzJdLCBtID0gUihyLCAhMSlbMl07XG4gICAgICBfID0gR3QoXywgcCwgbCksIGYgPSBxdChmLCB1LCBsKSwgdHlwZW9mIGYgIT0gXCJudW1iZXJcIiAmJiAoZiA9IFIoZiwgITEpWzBdKTtcbiAgICAgIGNvbnN0IGIgPSBkLmZpbmRPbmUoYFske3F9XWApID09PSBudWxsLCB2ID0gZC5maW5kT25lKGBbJHtodH1dYCkgIT09IG51bGwsIFQgPSBOdW1iZXIodGhpcy5faGFuZC5zdHlsZS50cmFuc2Zvcm0ucmVwbGFjZSgvW15cXGQtXS9nLCBcIlwiKSksIHkgPSBkLmZpbmQoXG4gICAgICAgIGBbJHtxfV1gLFxuICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgKSwgQyA9IGQuZmluZChcbiAgICAgICAgYFske1h9XWAsXG4gICAgICAgIHRoaXMuX21vZGFsXG4gICAgICApLCBFID0gZC5maW5kKFxuICAgICAgICBgWyR7aHR9XWAsXG4gICAgICAgIHRoaXMuX21vZGFsXG4gICAgICApO1xuICAgICAgbGV0IHcgPSB0aGlzLl9tYWtlSG91ckRlZ3JlZXModC50YXJnZXQsIFQsIGUpLmhvdXI7XG4gICAgICBjb25zdCB7IGRlZ3JlZXM6IGssIGFkZERlZ3JlZXM6IEQgfSA9IHRoaXMuX21ha2VIb3VyRGVncmVlcyhcbiAgICAgICAgdC50YXJnZXQsXG4gICAgICAgIFQsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgICBsZXQgeyBtaW51dGU6IE8sIGRlZ3JlZXM6IHggfSA9IHRoaXMuX21ha2VNaW51dGVzRGVncmVlcyhULCBpKTtcbiAgICAgIGNvbnN0IEwgPSB0aGlzLl9tYWtlTWludXRlc0RlZ3JlZXMoXG4gICAgICAgIFQsXG4gICAgICAgIGlcbiAgICAgICkuYWRkRGVncmVlcztcbiAgICAgIGxldCB7IGhvdXI6IFMgfSA9IHRoaXMuX21ha2VJbm5lckhvdXJzRGVncmVlcyhcbiAgICAgICAgVCxcbiAgICAgICAgblxuICAgICAgKTtcbiAgICAgIGlmICh0LmtleUNvZGUgPT09IHdlKSB7XG4gICAgICAgIGNvbnN0IE4gPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske29vfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICk7XG4gICAgICAgIGMudHJpZ2dlcihOLCBcImNsaWNrXCIpO1xuICAgICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICAgIGlmICh2ICYmICh0LmtleUNvZGUgPT09IHplICYmICh0aGlzLl9pc0lubmVyID0gITEsIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgIGhlaWdodDogXCJjYWxjKDQwJSArIDFweClcIlxuICAgICAgICB9KSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShcbiAgICAgICAgICB3ID4gMTIgPyAxIDogd1xuICAgICAgICApLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmhvdXJzQXJyYXksIHRoaXMuX2hvdXIsIEMpLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIEUpKSwgdC5rZXlDb2RlID09PSBLZSAmJiAodGhpcy5faXNJbm5lciA9ICEwLCBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICBoZWlnaHQ6IFwiMjEuNSVcIlxuICAgICAgICB9KSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShcbiAgICAgICAgICBTID49IDI0IHx8IFMgPT09IFwiMDBcIiA/IDAgOiBTXG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaW5uZXJIb3VycywgdGhpcy5faG91ciwgRSksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKFxuICAgICAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgICAgICB0aGlzLl9ob3VyIC0gMSxcbiAgICAgICAgICBDXG4gICAgICAgICkpKSwgdC5rZXlDb2RlID09PSBVKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKFxuICAgICAgICAgICAgayArIDMwLFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIF8sXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIHRcbiAgICAgICAgICApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke2sgKyBEfWRlZylgXG4gICAgICAgICAgfSksIHRoaXMuX2lzSW5uZXIgPyAoUyArPSAxLCBTID09PSAyNCA/IFMgPSAwIDogKFMgPT09IDI1IHx8IFMgPT09IFwiMDAxXCIpICYmIChTID0gMTMpLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFMpLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIEUpKSA6ICh3ICs9IDEsIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoXG4gICAgICAgICAgICB3ID4gMTIgPyAxIDogd1xuICAgICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgQykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0LmtleUNvZGUgPT09IHopIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJNYXhNaW5Ib3Vyc09wdGlvbnMoXG4gICAgICAgICAgICBrIC0gMzAsXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgXyxcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgdFxuICAgICAgICAgICkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7ayAtIER9ZGVnKWBcbiAgICAgICAgICB9KSwgdGhpcy5faXNJbm5lciA/IChTIC09IDEsIFMgPT09IDEyID8gUyA9IDAgOiBTID09PSAtMSAmJiAoUyA9IDIzKSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShTKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5pbm5lckhvdXJzLCB0aGlzLl9ob3VyLCBFKSkgOiAodyAtPSAxLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgICAgdyA9PT0gMCA/IDEyIDogd1xuICAgICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgQykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgdC5rZXlDb2RlID09PSBVICYmICh4ICs9IEwsIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt4fWRlZylgXG4gICAgICAgIH0pLCBPICs9IDEsIG8gJiYgKE8gKz0gNCwgTyA9PT0gXCIwMDE0XCIgJiYgKE8gPSA1KSksIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoXG4gICAgICAgICAgTyA+IDU5ID8gMCA6IE9cbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUoXG4gICAgICAgICAgdGhpcy5taW51dGVzQXJyYXksXG4gICAgICAgICAgdGhpcy5fbWludXRlcyxcbiAgICAgICAgICB5XG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUJhY2tncm91bmRDb2xvckNpcmNsZShcbiAgICAgICAgICBgWyR7cX1dYFxuICAgICAgICApKSwgdC5rZXlDb2RlID09PSB6ICYmICh4IC09IEwsIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt4fWRlZylgXG4gICAgICAgIH0pLCBvID8gTyAtPSA1IDogTyAtPSAxLCBPID09PSAtMSA/IE8gPSA1OSA6IE8gPT09IC01ICYmIChPID0gNTUpLCB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKE8pLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZShcbiAgICAgICAgICB0aGlzLm1pbnV0ZXNBcnJheSxcbiAgICAgICAgICB0aGlzLl9taW51dGVzLFxuICAgICAgICAgIHlcbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQmFja2dyb3VuZENvbG9yQ2lyY2xlKFxuICAgICAgICAgIGBbJHtxfV1gXG4gICAgICAgICkpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRBY3RpdmVDbGFzc1RvVGlwc09uT3Blbih0LCAuLi5lKSB7XG4gICAgaWYgKCF0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0KVxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MjQpIHtcbiAgICAgICAgY29uc3QgaSA9IGQuZmluZChcbiAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBuID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtodH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKGksIHQpLCB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKG4sIHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWy4uLmVdLmZpbHRlcigobikgPT4gKG4udG9Mb3dlckNhc2UoKSA9PT0gXCJwbVwiID8gKGguYWRkQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX1BNLnNldEF0dHJpYnV0ZShILCBcIlwiKSkgOiBuLnRvTG93ZXJDYXNlKCkgPT09IFwiYW1cIiA/IChoLmFkZENsYXNzKHRoaXMuX0FNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9BTS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpIDogKGgucmVtb3ZlQ2xhc3ModGhpcy5fQU0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIGgucmVtb3ZlQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX0FNLnJlbW92ZUF0dHJpYnV0ZShIKSwgdGhpcy5fUE0ucmVtb3ZlQXR0cmlidXRlKEgpKSwgbikpO1xuICAgICAgICBjb25zdCBpID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtYfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoaSwgdCk7XG4gICAgICB9XG4gIH1cbiAgX3NldFRpcHNBbmRUaW1lc0RlcGVuZE9uSW5wdXRWYWx1ZSh0LCBlKSB7XG4gICAgY29uc3QgeyBpbmxpbmU6IGksIGZvcm1hdDEyOiBuIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGlmICh0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0KVxuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IFwiMTJcIiwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IFwiMDBcIiwgaSB8fCBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZVooMGRlZylcIlxuICAgICAgfSksIG4gJiYgKGguYWRkQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX1BNLnNldEF0dHJpYnV0ZShILCBcIlwiKSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBvID0gdCA+IDEyID8gdCAqIDMwIC0gMzYwIDogdCAqIDMwO1xuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHQsIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSBlLCBpIHx8IChoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke299ZGVnKWBcbiAgICAgIH0pLCBoLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzE5NzZkMlwiXG4gICAgICB9KSwgKE51bWJlcih0KSA+IDEyIHx8IHQgPT09IFwiMDBcIikgJiYgaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIF9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIGBbZGF0YS10ZS10b2dnbGU9JyR7dGhpcy50b2dnbGVFbGVtZW50fSddYCxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQua2V5Q29kZSA9PT0gaXQgJiYgKHQucHJldmVudERlZmF1bHQoKSwgYy50cmlnZ2VyKHRoaXMuZWxlbWVudFRvZ2dsZSwgXCJjbGlja1wiKSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlT3BlbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZ2V0Q29udGFpbmVyKCk7XG4gICAgSy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBgW2RhdGEtdGUtdG9nZ2xlPScke3RoaXMudG9nZ2xlRWxlbWVudH0nXWAsXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGkgPSBoLmdldERhdGFBdHRyaWJ1dGUodGhpcy5pbnB1dCwgXCJ0b2dnbGVcIikgIT09IG51bGwgPyAyMDAgOiAwO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBoLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICAgICAgICB9KSwgdGhpcy5lbGVtZW50VG9nZ2xlLmJsdXIoKTtcbiAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICBSKHRoaXMuaW5wdXQpWzBdID09PSBcIlwiID8gbiA9IFtcIjEyXCIsIFwiMDBcIiwgXCJQTVwiXSA6IG4gPSBSKHRoaXMuaW5wdXQpO1xuICAgICAgICAgIGNvbnN0IHsgbW9kYWxJRDogbywgaW5saW5lOiByLCBmb3JtYXQxMjogYSB9ID0gdGhpcy5fb3B0aW9ucywgW2wsIHAsIHVdID0gbiwgXyA9ICQoXCJkaXZcIik7XG4gICAgICAgICAgaWYgKChOdW1iZXIobCkgPiAxMiB8fCBsID09PSBcIjAwXCIpICYmICh0aGlzLl9pc0lubmVyID0gITApLCB0aGlzLmlucHV0LmJsdXIoKSwgZS50YXJnZXQuYmx1cigpLCBfLmlubmVySFRNTCA9IHJnKHRoaXMuX29wdGlvbnMsIHRoaXMuX2NsYXNzZXMpLCBoLmFkZENsYXNzKF8sIHRoaXMuX2NsYXNzZXMubW9kYWwpLCBfLnNldEF0dHJpYnV0ZShjbCwgXCJcIiksIF8uc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImRpYWxvZ1wiKSwgXy5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCBcIi0xXCIpLCBfLnNldEF0dHJpYnV0ZShcImlkXCIsIG8pLCByID8gKHRoaXMuX3BvcHBlciA9IHNlKHRoaXMuaW5wdXQsIF8sIHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogXCJib3R0b20tc3RhcnRcIlxuICAgICAgICAgIH0pLCB0LmFwcGVuZENoaWxkKF8pKSA6ICh0LmFwcGVuZENoaWxkKF8pLCB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpKSwgdGhpcy5fZ2V0RG9tRWxlbWVudHMoKSwgdGhpcy5fYW5pbWF0aW9ucyA/IHRoaXMuX3RvZ2dsZUJhY2tkcm9wQW5pbWF0aW9uKCkgOiBoLmFkZENsYXNzKHRoaXMuX3dyYXBwZXIsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX3NldEFjdGl2ZUNsYXNzVG9UaXBzT25PcGVuKGwsIHAsIHUpLCB0aGlzLl9hcHBlbmRUaW1lcygpLCB0aGlzLl9zZXRBY3RpdmVDbGFzc1RvVGlwc09uT3BlbihsLCBwLCB1KSwgdGhpcy5fc2V0VGlwc0FuZFRpbWVzRGVwZW5kT25JbnB1dFZhbHVlKGwsIHApLCB0aGlzLmlucHV0LnZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gZC5maW5kKFxuICAgICAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhICYmIChoLmFkZENsYXNzKHRoaXMuX1BNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9QTS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gXCIxMlwiLCB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gXCIwMFwiLCB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKFxuICAgICAgICAgICAgICBmLFxuICAgICAgICAgICAgICBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVTd2l0Y2hUaW1lTW9kZSgpLCB0aGlzLl9oYW5kbGVPa0J1dHRvbigpLCB0aGlzLl9oYW5kbGVDbG9zZSgpLCByKVxuICAgICAgICAgICAgdGhpcy5faGFuZGxlSG92ZXJJbmxpbmVCdG4oKSwgdGhpcy5faGFuZGxlRG9jdW1lbnRDbGlja0lubGluZSgpLCB0aGlzLl9oYW5kbGVJbmxpbmVDbGlja3MoKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVN3aXRjaEhvdXJNaW51dGUoKSwgdGhpcy5faGFuZGxlQ2xvY2tDbGljaygpLCB0aGlzLl9oYW5kbGVLZXlib2FyZCgpO1xuICAgICAgICAgICAgY29uc3QgZiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgIGAke1RzfVske0h9XWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBoLmFkZENsYXNzKGYsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIGguYWRkU3R5bGUodGhpcy5faG91ciwge1xuICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgICAgICAgICAgfSksIGguYWRkU3R5bGUodGhpcy5fbWludXRlcywge1xuICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZm9jdXNUcmFwID0gbmV3IHppKHRoaXMuX3dyYXBwZXIsIHtcbiAgICAgICAgICAgIGV2ZW50OiBcImtleWRvd25cIixcbiAgICAgICAgICAgIGNvbmRpdGlvbjogKHsga2V5OiBmIH0pID0+IGYgPT09IFwiVGFiXCJcbiAgICAgICAgICB9KSwgdGhpcy5fZm9jdXNUcmFwLnRyYXAoKTtcbiAgICAgICAgfSwgaSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlSW5saW5lQ2xpY2tzKCkge1xuICAgIGxldCB0LCBlO1xuICAgIGNvbnN0IGkgPSAoZykgPT4ge1xuICAgICAgbGV0IG0gPSBnO1xuICAgICAgcmV0dXJuIG0gPiA1OSA/IG0gPSAwIDogbSA8IDAgJiYgKG0gPSA1OSksIG07XG4gICAgfSwgbiA9IChnKSA9PiB7XG4gICAgICBsZXQgbSA9IGc7XG4gICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5mb3JtYXQyNCA/IChtID4gMjQgPyBtID0gMSA6IG0gPCAwICYmIChtID0gMjMpLCBtID4gMjMgJiYgKG0gPSAwKSkgOiAobSA+IDEyID8gbSA9IDEgOiBtIDwgMSAmJiAobSA9IDEyKSwgbSA+IDEyICYmIChtID0gMSkpLCBtO1xuICAgIH0sIG8gPSAoZykgPT4ge1xuICAgICAgY29uc3QgbSA9IG4oZyk7XG4gICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKG0pO1xuICAgIH0sIHIgPSAoZykgPT4ge1xuICAgICAgY29uc3QgbSA9IGkoZyk7XG4gICAgICB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKG0pO1xuICAgIH0sIGEgPSAoKSA9PiB7XG4gICAgICB0ID0gbih0KSArIDEsIG8odCk7XG4gICAgfSwgbCA9ICgpID0+IHtcbiAgICAgIGUgPSBpKGUpICsgMSwgcihlKTtcbiAgICB9LCBwID0gKCkgPT4ge1xuICAgICAgdCA9IG4odCkgLSAxLCBvKHQpO1xuICAgIH0sIHUgPSAoKSA9PiB7XG4gICAgICBlID0gaShlKSAtIDEsIHIoZSk7XG4gICAgfSwgXyA9ICgpID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dEludGVydmFsKTtcbiAgICB9LCBmID0gKGcpID0+IHtcbiAgICAgIF8oKSwgdGhpcy5fdGltZW91dEludGVydmFsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoZywgMTAwKTtcbiAgICAgIH0sIDUwMCk7XG4gICAgfTtcbiAgICBLLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcImNsaWNrIG1vdXNlZG93biBtb3VzZXVwIHRvdWNoc3RhcnQgdG91Y2hlbmQgY29udGV4dG1lbnVcIixcbiAgICAgIGBbJHthb31dLCBbJHtsb31dYCxcbiAgICAgIChnKSA9PiB7XG4gICAgICAgIHQgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGUgPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCk7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0OiBtLCB0eXBlOiBiIH0gPSBnLCB2ID0gYiA9PT0gXCJtb3VzZWRvd25cIiB8fCBiID09PSBcInRvdWNoc3RhcnRcIjtcbiAgICAgICAgbS5jbG9zZXN0KGBbJHthb31dYCkgPyBtLmNsb3Nlc3QoYFske2FvfV1gKS5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShybCkgPyB2ID8gZihhKSA6IGIgPT09IFwibW91c2V1cFwiIHx8IGIgPT09IFwidG91Y2hlbmRcIiB8fCBiID09PSBcImNvbnRleHRtZW51XCIgPyBfKCkgOiBhKCkgOiB2ID8gZihsKSA6IGIgPT09IFwibW91c2V1cFwiIHx8IGIgPT09IFwidG91Y2hlbmRcIiB8fCBiID09PSBcImNvbnRleHRtZW51XCIgPyBfKCkgOiBsKCkgOiBtLmNsb3Nlc3QoYFske2xvfV1gKSAmJiAobS5jbG9zZXN0KGBbJHtsb31dYCkucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUocmwpID8gdiA/IGYocCkgOiBiID09PSBcIm1vdXNldXBcIiB8fCBiID09PSBcInRvdWNoZW5kXCIgPyBfKCkgOiBwKCkgOiB2ID8gZih1KSA6IGIgPT09IFwibW91c2V1cFwiIHx8IGIgPT09IFwidG91Y2hlbmRcIiA/IF8oKSA6IHUoKSk7XG4gICAgICB9XG4gICAgKSwgYy5vbih3aW5kb3csIHZzLCAoZykgPT4ge1xuICAgICAgY29uc3QgbSA9IGcuY29kZSwgYiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKENzKSwgdiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKFxuICAgICAgICB1b1xuICAgICAgKSwgVCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHk7XG4gICAgICBzd2l0Y2ggKHQgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGUgPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCksIG0pIHtcbiAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICBnLnByZXZlbnREZWZhdWx0KCksIFQgfHwgYiA/ICh0aGlzLl9ob3VyLmZvY3VzKCksIGEoKSkgOiB2ICYmIGwoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICAgIGcucHJldmVudERlZmF1bHQoKSwgVCB8fCBiID8gKHRoaXMuX2hvdXIuZm9jdXMoKSwgcCgpKSA6IHYgJiYgdSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVDbG9zZSgpIHtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBgWyR7aG99XSwgWyR7b299XSwgWyR7b2x9XWAsXG4gICAgICAoeyB0YXJnZXQ6IHQgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IGNsb3NlTW9kYWxPbkJhY2tkcm9wQ2xpY2s6IGUgfSA9IHRoaXMuX29wdGlvbnMsIGkgPSAoKSA9PiB7XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgaC5hZGRTdHlsZSh0aGlzLmVsZW1lbnRUb2dnbGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgICAgfSksIHRoaXMuX2FuaW1hdGlvbnMgJiYgdGhpcy5fdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24oITApLCB0aGlzLl9yZW1vdmVNb2RhbCgpLCAobiA9IHRoaXMuX2ZvY3VzVHJhcCkgPT0gbnVsbCB8fCBuLmRpc2FibGUoKSwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5lbGVtZW50VG9nZ2xlID8gdGhpcy5lbGVtZW50VG9nZ2xlLmZvY3VzKCkgOiB0aGlzLmlucHV0ICYmIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHQuaGFzQXR0cmlidXRlKG9sKSkge1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZUFtUG0oXCJQTVwiKSwgdGhpcy5pbnB1dC52YWx1ZSA9IFwiXCIsIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKEgpO1xuICAgICAgICAgIGxldCBuO1xuICAgICAgICAgIFIodGhpcy5pbnB1dClbMF0gPT09IFwiXCIgPyBuID0gW1wiMTJcIiwgXCIwMFwiLCBcIlBNXCJdIDogbiA9IFIodGhpcy5pbnB1dCk7XG4gICAgICAgICAgY29uc3QgW28sIHIsIGFdID0gbjtcbiAgICAgICAgICB0aGlzLl9zZXRUaXBzQW5kVGltZXNEZXBlbmRPbklucHV0VmFsdWUoXCIxMlwiLCBcIjAwXCIpLCB0aGlzLl9zZXRBY3RpdmVDbGFzc1RvVGlwc09uT3BlbihvLCByLCBhKSwgdGhpcy5faG91ci5jbGljaygpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAodC5oYXNBdHRyaWJ1dGUob28pIHx8IHQuaGFzQXR0cmlidXRlKHJvKSB8fCB0Lmhhc0F0dHJpYnV0ZShobykgJiYgZSkgJiYgaSgpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgc2hvd1ZhbHVlSW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXQudmFsdWU7XG4gIH1cbiAgX2hhbmRsZU9rQnV0dG9uKCkge1xuICAgIEsub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGBbJHtyb31dYCxcbiAgICAgICgpID0+IHtcbiAgICAgICAgbGV0IHsgbWF4VGltZTogdCwgbWluVGltZTogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvcm1hdDEyOiBpLFxuICAgICAgICAgIGZvcm1hdDI0OiBuLFxuICAgICAgICAgIHJlYWRPbmx5OiBvLFxuICAgICAgICAgIGZvY3VzSW5wdXRBZnRlckFwcHJvdmU6IHIsXG4gICAgICAgICAgZGlzYWJsZVBhc3Q6IGEsXG4gICAgICAgICAgZGlzYWJsZUZ1dHVyZTogbFxuICAgICAgICB9ID0gdGhpcy5fb3B0aW9ucywgcCA9IHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgYCR7RXN9WyR7SH1dYFxuICAgICAgICApLCB1ID0gYCR7dGhpcy5faG91ci50ZXh0Q29udGVudH06JHt0aGlzLl9taW51dGVzLnRleHRDb250ZW50fWAsIF8gPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGYgPSBfID09PSAxMiAmJiBpID8gMCA6IF8sIGcgPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCk7XG4gICAgICAgIGUgPSBHdChlLCBhLCBpKSwgdCA9IHF0KHQsIGwsIGkpO1xuICAgICAgICBsZXQgW20sIGIsIHZdID0gUihcbiAgICAgICAgICB0LFxuICAgICAgICAgICExXG4gICAgICAgICksIFtULCB5LCBDXSA9IFIoXG4gICAgICAgICAgZSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgICBUID0gVCA9PT0gXCIxMlwiICYmIGkgPyBcIjAwXCIgOiBULCBtID0gbSA9PT0gXCIxMlwiICYmIGkgPyBcIjAwXCIgOiBtO1xuICAgICAgICBjb25zdCBFID0gZiA8IE51bWJlcihUKSwgdyA9IGYgPiBOdW1iZXIobSk7XG4gICAgICAgIGxldCBrID0gITA7XG4gICAgICAgIHAgJiYgKGsgPSB2ID09PSBwLnRleHRDb250ZW50KTtcbiAgICAgICAgbGV0IEQgPSAhMDtcbiAgICAgICAgcCAmJiAoRCA9IEMgPT09IHAudGV4dENvbnRlbnQpO1xuICAgICAgICBjb25zdCBPID0gZyA+IGIgJiYgZiA9PT0gTnVtYmVyKG0pLCB4ID0gZyA8IHkgJiYgZiA9PT0gTnVtYmVyKFQpO1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoSCwgXCJcIiksIGguYWRkU3R5bGUodGhpcy5lbGVtZW50VG9nZ2xlLCB7XG4gICAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCJcbiAgICAgICAgfSksIHQgIT09IFwiXCIpIHtcbiAgICAgICAgICBpZiAoayAmJiAodyB8fCBPKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAodiA9PT0gXCJBTVwiICYmIHAudGV4dENvbnRlbnQgPT09IFwiUE1cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlICE9PSBcIlwiICYmIChEICYmIChFIHx8IHgpIHx8IEMgPT09IFwiUE1cIiAmJiBwLnRleHRDb250ZW50ID09PSBcIkFNXCIpIHx8IGNnKFxuICAgICAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICAgICAgdGhpcy5pbnB1dCxcbiAgICAgICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50XG4gICAgICAgICkgIT09IHZvaWQgMCAmJiAodGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCAmJiB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShjbyksICFvICYmIHIgJiYgdGhpcy5pbnB1dC5mb2N1cygpLCBoLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgIH0pLCBuID8gdGhpcy5pbnB1dC52YWx1ZSA9IHUgOiBwID09PSBudWxsID8gdGhpcy5pbnB1dC52YWx1ZSA9IGAke3V9IFBNYCA6IHRoaXMuaW5wdXQudmFsdWUgPSBgJHt1fSAke3AudGV4dENvbnRlbnR9YCwgdGhpcy5fYW5pbWF0aW9ucyAmJiB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbighMCksIHRoaXMuX3JlbW92ZU1vZGFsKCksIGMudHJpZ2dlcih0aGlzLmlucHV0LCBcImlucHV0LnRlLnRpbWVwaWNrZXJcIiksIGMudHJpZ2dlcih0aGlzLmlucHV0LCBcImlucHV0XCIpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVIb3ZlcklubGluZUJ0bigpIHtcbiAgICBLLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcIm1vdXNlb3ZlciBtb3VzZWxlYXZlXCIsXG4gICAgICBgWyR7VGd9XWAsXG4gICAgICAoeyB0eXBlOiB0LCB0YXJnZXQ6IGUgfSkgPT4ge1xuICAgICAgICBjb25zdCBpID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtiZ31dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBuID0gZC5maW5kKFxuICAgICAgICAgIGBbJHt2Z31dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBvID0gKGwsIHApID0+IGwuZm9yRWFjaCgodSkgPT4ge1xuICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBoLmFkZENsYXNzKHUsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHUuc2V0QXR0cmlidXRlKEgsIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoLnJlbW92ZUNsYXNzKHUsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHUucmVtb3ZlQXR0cmlidXRlKEgpO1xuICAgICAgICB9KSwgYSA9IGUuaGFzQXR0cmlidXRlKENzKSA/IGkgOiBuO1xuICAgICAgICBvKGEsIHQgPT09IFwibW91c2VvdmVyXCIpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZURvY3VtZW50Q2xpY2tJbmxpbmUoKSB7XG4gICAgYy5vbihkb2N1bWVudCwgcWEsICh7IHRhcmdldDogdCB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5fbW9kYWwgJiYgIXRoaXMuX21vZGFsLmNvbnRhaW5zKHQpICYmICF0Lmhhc0F0dHJpYnV0ZShnZykpIHtcbiAgICAgICAgaWYgKGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCBoLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgIH0pLCB0aGlzLl9yZW1vdmVNb2RhbCgpLCAhdGhpcy5fYW5pbWF0aW9ucylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3RvZ2dsZUJhY2tkcm9wQW5pbWF0aW9uKCEwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlU3dpdGNoSG91ck1pbnV0ZSgpIHtcbiAgICBsZyhcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIFRzLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIGMub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIFRzLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGZvcm1hdDI0OiB0IH0gPSB0aGlzLl9vcHRpb25zLCBlID0gZC5maW5kKFxuICAgICAgICAgIFRzLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIGkgPSBkLmZpbmQoXG4gICAgICAgICAgYFske3F9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbiA9IGQuZmluZChcbiAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBvID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtodH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCByID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpLCBhID0gTnVtYmVyKHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQpLCBsID0gKHAsIHUpID0+IHtcbiAgICAgICAgICBuLmZvckVhY2goKGYpID0+IGYucmVtb3ZlKCkpLCBpLmZvckVhY2goKGYpID0+IGYucmVtb3ZlKCkpLCBoLmFkZENsYXNzKHRoaXMuX2hhbmQsIHRoaXMuX2NsYXNzZXMudHJhbnNmb3JtKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBoLnJlbW92ZUNsYXNzKHRoaXMuX2hhbmQsIHRoaXMuX2NsYXNzZXMudHJhbnNmb3JtKTtcbiAgICAgICAgICB9LCA0MDEpLCB0aGlzLl9nZXRBcHBlbmRDbG9jayhwLCBgWyR7dWV9XWAsIHUpO1xuICAgICAgICAgIGNvbnN0IF8gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmID0gZC5maW5kKFxuICAgICAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgICAgICksIGcgPSBkLmZpbmQoXG4gICAgICAgICAgICAgIGBbJHtxfV1gLFxuICAgICAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoZiwgciksIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoZywgYSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoIXQpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgXygpO1xuICAgICAgICAgICAgfSwgNDAxKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBkLmZpbmQoXG4gICAgICAgICAgICAgIGBbJHtodH1dYCxcbiAgICAgICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChmLCByKSwgXygpO1xuICAgICAgICAgICAgfSwgNDAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGUuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgIHAuaGFzQXR0cmlidXRlKEgpICYmIChwLmhhc0F0dHJpYnV0ZSh1bykgPyAoaC5hZGRDbGFzcyh0aGlzLl9oYW5kLCB0aGlzLl9jbGFzc2VzLnRyYW5zZm9ybSksIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3RoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgKiA2fWRlZylgLFxuICAgICAgICAgICAgaGVpZ2h0OiBcImNhbGMoNDAlICsgMXB4KVwiXG4gICAgICAgICAgfSksIHQgJiYgby5sZW5ndGggPiAwICYmIG8uZm9yRWFjaCgodSkgPT4gdS5yZW1vdmUoKSksIGwoXG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXNBcnJheSxcbiAgICAgICAgICAgIHFcbiAgICAgICAgICApLCB0aGlzLl9ob3VyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIlwiLCB0aGlzLl9taW51dGVzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIikgOiBwLmhhc0F0dHJpYnV0ZShDcykgJiYgKGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3RoaXMuX2hvdXIudGV4dENvbnRlbnQgKiAzMH1kZWcpYFxuICAgICAgICAgIH0pLCBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPiAxMiA/IChoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt0aGlzLl9ob3VyLnRleHRDb250ZW50ICogMzAgLSAzNjB9ZGVnKWAsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjEuNSVcIlxuICAgICAgICAgIH0pLCBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPiAxMiAmJiBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgICAgICAgfSkpIDogaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiY2FsYyg0MCUgKyAxcHgpXCJcbiAgICAgICAgICB9KSwgdCAmJiB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgICAgICAgIHRoaXMuaW5uZXJIb3VycyxcbiAgICAgICAgICAgIGBbJHttaX1dYCxcbiAgICAgICAgICAgIGh0XG4gICAgICAgICAgKSwgby5sZW5ndGggPiAwICYmIG8uZm9yRWFjaCgodSkgPT4gdS5yZW1vdmUoKSksIGwoXG4gICAgICAgICAgICB0aGlzLmhvdXJzQXJyYXksXG4gICAgICAgICAgICBYXG4gICAgICAgICAgKSwgaC5hZGRTdHlsZSh0aGlzLl9ob3VyLCB7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgICAgICAgIH0pLCBoLmFkZFN0eWxlKHRoaXMuX21pbnV0ZXMsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiXCJcbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVEaXNhYmxpbmdUaXBzTWF4VGltZSh0LCBlLCBpLCBuKSB7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLm1heFRpbWUgJiYgIXRoaXMuX29wdGlvbnMuZGlzYWJsZUZ1dHVyZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0gZC5maW5kKFxuICAgICAgYFske1h9XWBcbiAgICApLCByID0gZC5maW5kKFxuICAgICAgYFske2h0fV1gXG4gICAgKSwgYSA9IGQuZmluZChcbiAgICAgIGBbJHtxfV1gXG4gICAgKTtcbiAgICBpZiAoIWUgfHwgZSA9PT0gdCkge1xuICAgICAgVWEoXG4gICAgICAgIHIsXG4gICAgICAgIG4sXG4gICAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICAgICksIFVhKFxuICAgICAgICBvLFxuICAgICAgICBuLFxuICAgICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgICApLCBoZyhcbiAgICAgICAgYSxcbiAgICAgICAgaSxcbiAgICAgICAgbixcbiAgICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCxcbiAgICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZSA9PT0gXCJBTVwiICYmIHQgPT09IFwiUE1cIiAmJiAoby5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBoLmFkZENsYXNzKGwsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgbC5zZXRBdHRyaWJ1dGUoanQsIFwiXCIpO1xuICAgIH0pLCBhLmZvckVhY2goKGwpID0+IHtcbiAgICAgIGguYWRkQ2xhc3MobCwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCBsLnNldEF0dHJpYnV0ZShqdCwgXCJcIik7XG4gICAgfSkpO1xuICB9XG4gIF9oYW5kbGVEaXNhYmxpbmdUaXBzTWluVGltZSh0LCBlLCBpLCBuKSB7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLm1pblRpbWUgJiYgIXRoaXMuX29wdGlvbnMuZGlzYWJsZVBhc3QpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9IGQuZmluZChcbiAgICAgIGBbJHtYfV1gXG4gICAgKSwgciA9IGQuZmluZChcbiAgICAgIGBbJHtodH1dYFxuICAgICksIGEgPSBkLmZpbmQoXG4gICAgICBgWyR7cX1dYFxuICAgICk7XG4gICAgIWUgfHwgZSA9PT0gdCA/IChYYShcbiAgICAgIG8sXG4gICAgICBuLFxuICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICApLCBYYShcbiAgICAgIHIsXG4gICAgICBuLFxuICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICApLCBkZyhcbiAgICAgIGEsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2hvdXIudGV4dENvbnRlbnQsXG4gICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICkpIDogZSA9PT0gXCJQTVwiICYmIHQgPT09IFwiQU1cIiAmJiAoby5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBoLmFkZENsYXNzKGwsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgbC5zZXRBdHRyaWJ1dGUoanQsIFwiXCIpO1xuICAgIH0pLCBhLmZvckVhY2goKGwpID0+IHtcbiAgICAgIGguYWRkQ2xhc3MobCwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCBsLnNldEF0dHJpYnV0ZShqdCwgXCJcIik7XG4gICAgfSkpO1xuICB9XG4gIF9oYW5kbGVTd2l0Y2hUaW1lTW9kZSgpIHtcbiAgICBjLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBFcyxcbiAgICAgICh7IHRhcmdldDogdCB9KSA9PiB7XG4gICAgICAgIGxldCB7IG1heFRpbWU6IGUsIG1pblRpbWU6IGkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgZGlzYWJsZVBhc3Q6IG4sIGRpc2FibGVGdXR1cmU6IG8sIGZvcm1hdDEyOiByIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgICBpID0gR3QoaSwgbiwgciksIGUgPSBxdChlLCBvLCByKTtcbiAgICAgICAgY29uc3QgW2EsIGwsIHBdID0gUihcbiAgICAgICAgICBlLFxuICAgICAgICAgICExXG4gICAgICAgICksIFt1LCBfLCBmXSA9IFIoXG4gICAgICAgICAgaSxcbiAgICAgICAgICAhMVxuICAgICAgICApLCBnID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtYfV1gXG4gICAgICAgICksIG0gPSBkLmZpbmQoXG4gICAgICAgICAgYFske3F9XWBcbiAgICAgICAgKTtcbiAgICAgICAgKCgpID0+IHtcbiAgICAgICAgICBnLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3ModiwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCB2LnJlbW92ZUF0dHJpYnV0ZShqdCk7XG4gICAgICAgICAgfSksIG0uZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgICAgaC5yZW1vdmVDbGFzcyh2LCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIHYucmVtb3ZlQXR0cmlidXRlKGp0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKSwgdGhpcy5faGFuZGxlRGlzYWJsaW5nVGlwc01pblRpbWUoXG4gICAgICAgICAgdC50ZXh0Q29udGVudCxcbiAgICAgICAgICBmLFxuICAgICAgICAgIF8sXG4gICAgICAgICAgdVxuICAgICAgICApLCB0aGlzLl9oYW5kbGVEaXNhYmxpbmdUaXBzTWF4VGltZShcbiAgICAgICAgICB0LnRleHRDb250ZW50LFxuICAgICAgICAgIHAsXG4gICAgICAgICAgbCxcbiAgICAgICAgICBhXG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUFtUG0odC50ZXh0Q29udGVudCksIHQuaGFzQXR0cmlidXRlKEgpIHx8IChkLmZpbmQoXG4gICAgICAgICAgRXNcbiAgICAgICAgKS5mb3JFYWNoKChUKSA9PiB7XG4gICAgICAgICAgVC5oYXNBdHRyaWJ1dGUoSCkgJiYgKGgucmVtb3ZlQ2xhc3MoVCwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgVC5yZW1vdmVBdHRyaWJ1dGUoSCkpO1xuICAgICAgICB9KSwgaC5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0LnNldEF0dHJpYnV0ZShILCBcIlwiKSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlQ2xvY2tDbGljaygpIHtcbiAgICBsZXQgeyBtYXhUaW1lOiB0LCBtaW5UaW1lOiBlIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IHsgZGlzYWJsZVBhc3Q6IGksIGRpc2FibGVGdXR1cmU6IG4sIGZvcm1hdDEyOiBvIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGUgPSBHdChlLCBpLCBvKSwgdCA9IHF0KHQsIG4sIG8pO1xuICAgIGNvbnN0IHIgPSBSKHQsICExKVsyXSwgYSA9IFIoZSwgITEpWzJdLCBsID0gUih0LCAhMSlbMF0sIHAgPSBSKGUsICExKVswXSwgdSA9IGQuZmluZE9uZShcbiAgICAgIGBbJHthbH1dYFxuICAgICk7XG4gICAgSy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgYCR7WmF9ICR7UWF9ICR7SmF9ICR7dGx9ICR7ZWx9ICR7bmx9ICR7aWx9ICR7c2x9YCxcbiAgICAgIFwiXCIsXG4gICAgICAoXykgPT4ge1xuICAgICAgICBicygpIHx8IF8ucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgeyB0eXBlOiBmLCB0YXJnZXQ6IGcgfSA9IF8sIHsgY2xvc2VNb2RhbE9uTWludXRlc0NsaWNrOiBtLCBzd2l0Y2hIb3Vyc1RvTWludXRlc09uQ2xpY2s6IGIgfSA9IHRoaXMuX29wdGlvbnMsIHYgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske3F9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSAhPT0gbnVsbCwgVCA9IGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApICE9PSBudWxsLCB5ID0gZC5maW5kT25lKFxuICAgICAgICAgIGBbJHtodH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApICE9PSBudWxsLCBDID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtxfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIEUgPSB6YShfLCB1KSwgdyA9IHUub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICBsZXQgayA9IE1hdGguYXRhbjIoRS55IC0gdywgRS54IC0gdyk7XG4gICAgICAgIGlmIChicygpKSB7XG4gICAgICAgICAgY29uc3QgTCA9IHphKF8sIHUsICEwKTtcbiAgICAgICAgICBrID0gTWF0aC5hdGFuMihMLnkgLSB3LCBMLnggLSB3KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgRCA9IG51bGwsIE8gPSBudWxsLCB4ID0gbnVsbDtcbiAgICAgICAgaWYgKGYgPT09IFwibW91c2Vkb3duXCIgfHwgZiA9PT0gXCJtb3VzZW1vdmVcIiB8fCBmID09PSBcInRvdWNobW92ZVwiIHx8IGYgPT09IFwidG91Y2hzdGFydFwiKVxuICAgICAgICAgIChmID09PSBcIm1vdXNlZG93blwiIHx8IGYgPT09IFwidG91Y2hzdGFydFwiIHx8IGYgPT09IFwidG91Y2htb3ZlXCIpICYmICh0aGlzLl9oYXNUYXJnZXRJbm5lckNsYXNzKGcpIHx8IGcuaGFzQXR0cmlidXRlKGFsKSB8fCBnLmhhc0F0dHJpYnV0ZSh1ZSkgfHwgZy5oYXNBdHRyaWJ1dGUocSkgfHwgZy5oYXNBdHRyaWJ1dGUoWCkgfHwgZy5oYXNBdHRyaWJ1dGUoX28pIHx8IGcuaGFzQXR0cmlidXRlKHBvKSB8fCBnLmhhc0F0dHJpYnV0ZShsbCkgfHwgZy5oYXNBdHRyaWJ1dGUoQXMpKSAmJiAodGhpcy5faXNNb3VzZU1vdmUgPSAhMCwgYnMoKSAmJiBfLnRvdWNoZXMgJiYgKEQgPSBfLnRvdWNoZXNbMF0uY2xpZW50WCwgTyA9IF8udG91Y2hlc1swXS5jbGllbnRZLCB4ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChELCBPKSkpO1xuICAgICAgICBlbHNlIGlmIChmID09PSBcIm1vdXNldXBcIiB8fCBmID09PSBcInRvdWNoZW5kXCIpIHtcbiAgICAgICAgICBpZiAodGhpcy5faXNNb3VzZU1vdmUgPSAhMSwgdGhpcy5faGFzVGFyZ2V0SW5uZXJDbGFzcyhnKSB8fCBnLmhhc0F0dHJpYnV0ZSh1ZSkgfHwgZy5oYXNBdHRyaWJ1dGUoWCkgfHwgZy5oYXNBdHRyaWJ1dGUoX28pIHx8IGcuaGFzQXR0cmlidXRlKHBvKSB8fCBnLmhhc0F0dHJpYnV0ZShsbCkgfHwgZy5oYXNBdHRyaWJ1dGUoQXMpKSB7XG4gICAgICAgICAgICBpZiAoKFQgfHwgeSkgJiYgYikge1xuICAgICAgICAgICAgICBjb25zdCBMID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpID4gbCB8fCBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPCBwO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5mb3JtYXQyNCAmJiBsICE9PSBcIlwiICYmIHAgIT09IFwiXCIgJiYgTClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZvcm1hdDI0ICYmIHAgIT09IFwiXCIgJiYgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpIDwgcClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjLnRyaWdnZXIodGhpcy5fbWludXRlcywgXCJjbGlja1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHYgJiYgbSkge1xuICAgICAgICAgICAgY29uc3QgTCA9IGQuZmluZE9uZShcbiAgICAgICAgICAgICAgYFske3JvfV1gLFxuICAgICAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGMudHJpZ2dlcihMLCBcImNsaWNrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodikge1xuICAgICAgICAgIGxldCBMO1xuICAgICAgICAgIGNvbnN0IFMgPSBNYXRoLnRydW5jKGsgKiAxODAgLyBNYXRoLlBJKSArIDkwLCB7IGRlZ3JlZXM6IE4sIG1pbnV0ZTogUCB9ID0gdGhpcy5fbWFrZU1pbnV0ZXNEZWdyZWVzKFMsIEwpO1xuICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyTWF4TWluTWludXRlc09wdGlvbnMoTiwgUCkgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCB7IGRlZ3JlZXM6IG90LCBtaW51dGU6IHJ0IH0gPSB0aGlzLl9oYW5kbGVyTWF4TWluTWludXRlc09wdGlvbnMoTiwgUCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBpZiAoaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHtvdH1kZWcpYFxuICAgICAgICAgICAgfSksIHJ0ID09PSB2b2lkIDApXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IEcgPSAoKSA9PiBydCA+PSAxMCB8fCBydCA9PT0gXCIwMFwiID8gcnQgOiBgMCR7cnR9YDtcbiAgICAgICAgICAgIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSBHKCksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKFxuICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXNBcnJheSxcbiAgICAgICAgICAgICAgdGhpcy5fbWludXRlcyxcbiAgICAgICAgICAgICAgQ1xuICAgICAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQmFja2dyb3VuZENvbG9yQ2lyY2xlKFxuICAgICAgICAgICAgICBgWyR7cX1dYFxuICAgICAgICAgICAgKSwgdGhpcy5fb2JqV2l0aERhdGFPbkNoYW5nZS5kZWdyZWVzTWludXRlcyA9IG90LCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLm1pbnV0ZXMgPSBydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFQgfHwgeSkge1xuICAgICAgICAgIGxldCBMLCBTID0gTWF0aC50cnVuYyhrICogMTgwIC8gTWF0aC5QSSkgKyA5MDtcbiAgICAgICAgICBpZiAoUyA9IE1hdGgucm91bmQoUyAvIDMwKSAqIDMwLCBoLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMxOTc2ZDJcIlxuICAgICAgICAgIH0pLCB0aGlzLl9tYWtlSG91ckRlZ3JlZXMoZywgUywgTCkgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCBOID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGJzKCkgJiYgUyAmJiB4KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgZGVncmVlczogUCwgaG91cjogb3QgfSA9IHRoaXMuX21ha2VIb3VyRGVncmVlcyh4LCBTLCBMKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZU1vdmVIYW5kKFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgb3QsXG4gICAgICAgICAgICAgICAgUFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkZWdyZWVzOiBQLCBob3VyOiBvdCB9ID0gdGhpcy5fbWFrZUhvdXJEZWdyZWVzKGcsIFMsIEwpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlTW92ZUhhbmQoZywgb3QsIFApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fb2JqV2l0aERhdGFPbkNoYW5nZS5kZWdyZWVzSG91cnMgPSBTLCB0aGlzLl9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKFxuICAgICAgICAgICAgUyxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBfXG4gICAgICAgICAgKSAmJiBOKCk7XG4gICAgICAgIH1cbiAgICAgICAgXy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYXNUYXJnZXRJbm5lckNsYXNzKHQpIHtcbiAgICByZXR1cm4gdC5oYXNBdHRyaWJ1dGUobWkpIHx8IHQuaGFzQXR0cmlidXRlKGh0KSB8fCB0Lmhhc0F0dHJpYnV0ZSh5cyk7XG4gIH1cbiAgX2hhbmRsZU1vdmVIYW5kKHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gZC5maW5kKFxuICAgICAgYFske1h9XWAsXG4gICAgICB0aGlzLl9tb2RhbFxuICAgICksIG8gPSBkLmZpbmQoXG4gICAgICBgWyR7aHR9XWAsXG4gICAgICB0aGlzLl9tb2RhbFxuICAgICk7XG4gICAgdGhpcy5faXNNb3VzZU1vdmUgJiYgKHRoaXMuX2hhc1RhcmdldElubmVyQ2xhc3ModCkgPyBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgfSkgOiBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgIGhlaWdodDogXCJjYWxjKDQwJSArIDFweClcIlxuICAgIH0pLCBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHtpfWRlZylgXG4gICAgfSksIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSBlID49IDEwIHx8IGUgPT09IFwiMDBcIiA/IGUgOiBgMCR7ZX1gLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmhvdXJzQXJyYXksIHRoaXMuX2hvdXIsIG4pLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIG8pLCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLmhvdXIgPSBlID49IDEwIHx8IGUgPT09IFwiMDBcIiA/IGUgOiBgMCR7ZX1gKTtcbiAgfVxuICBfaGFuZGxlck1heE1pbk1pbnV0ZXNPcHRpb25zKHQsIGUpIHtcbiAgICBsZXQgeyBtYXhUaW1lOiBpLCBtaW5UaW1lOiBuIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IHsgZm9ybWF0MTI6IG8sIGluY3JlbWVudDogciwgZGlzYWJsZVBhc3Q6IGEsIGRpc2FibGVGdXR1cmU6IGwgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgbiA9IEd0KG4sIGEsIG8pLCBpID0gcXQoaSwgbCwgbyk7XG4gICAgY29uc3QgcCA9IFIoaSwgITEpWzFdLCB1ID0gUihuLCAhMSlbMV0sIF8gPSBSKGksICExKVswXSwgZiA9IFIobiwgITEpWzBdLCBnID0gZiA9PT0gXCIxMlwiICYmIG8gPyBcIjBcIiA6IGYsIG0gPSBfID09PSBcIjEyXCIgJiYgbyA/IFwiMFwiIDogXywgYiA9IFIoaSwgITEpWzJdLCB2ID0gUihuLCAhMSlbMl0sIFQgPSBwICE9PSBcIlwiID8gcCAqIDYgOiBcIlwiLCB5ID0gdSAhPT0gXCJcIiA/IHUgKiA2IDogXCJcIiwgQyA9IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSwgRSA9IEMgPT09IDEyICYmIG8gPyAwIDogQztcbiAgICBpZiAoIWIgJiYgIXYpIHtcbiAgICAgIGlmIChpICE9PSBcIlwiICYmIG4gIT09IFwiXCIpIHtcbiAgICAgICAgaWYgKE51bWJlcihtKSA9PT0gRSAmJiB0ID4gVCB8fCBOdW1iZXIoZykgPT09IEUgJiYgdCA8IHkpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9IGVsc2UgaWYgKG4gIT09IFwiXCIgJiYgRSA8PSBOdW1iZXIoZykpIHtcbiAgICAgICAgaWYgKHQgPD0geSAtIDYpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9IGVsc2UgaWYgKGkgIT09IFwiXCIgJiYgRSA+PSBOdW1iZXIobSkgJiYgdCA+PSBUICsgNilcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuICE9PSBcIlwiKSB7XG4gICAgICAgIGlmICh2ID09PSBcIlBNXCIgJiYgdGhpcy5faXNBbUVuYWJsZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodiA9PT0gXCJQTVwiICYmIHRoaXMuX2lzUG1FbmFibGVkKSB7XG4gICAgICAgICAgaWYgKEUgPCBOdW1iZXIoZykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaWYgKEUgPD0gTnVtYmVyKGcpICYmIHQgPD0geSAtIDYpXG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSBlbHNlIGlmICh2ID09PSBcIkFNXCIgJiYgdGhpcy5faXNBbUVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoRSA8IE51bWJlcihnKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAoRSA8PSBOdW1iZXIoZykgJiYgdCA8PSB5IC0gNilcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSAhPT0gXCJcIikge1xuICAgICAgICBpZiAoYiA9PT0gXCJBTVwiICYmIHRoaXMuX2lzUG1FbmFibGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGIgPT09IFwiUE1cIiAmJiB0aGlzLl9pc1BtRW5hYmxlZCkge1xuICAgICAgICAgIGlmIChFID49IE51bWJlcihtKSAmJiB0ID49IFQgKyA2KVxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gXCJBTVwiICYmIHRoaXMuX2lzQW1FbmFibGVkICYmIEUgPj0gTnVtYmVyKG0pICYmIHQgPj0gVCArIDYpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByICYmICh0ID0gTWF0aC5yb3VuZCh0IC8gMzApICogMzApLCB0IDwgMCA/IHQgPSAzNjAgKyB0IDogdCA+PSAzNjAgJiYgKHQgPSAwKSwge1xuICAgICAgZGVncmVlczogdCxcbiAgICAgIG1pbnV0ZTogZVxuICAgIH07XG4gIH1cbiAgX3JlbW92ZU1vZGFsKCkge1xuICAgIHRoaXMuX2FuaW1hdGlvbnMgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3JlbW92ZU1vZGFsRWxlbWVudHMoKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG4gICAgfSwgMzAwKSA6ICh0aGlzLl9yZW1vdmVNb2RhbEVsZW1lbnRzKCksIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpKSwgSy5vZmYoXG4gICAgICB0aGlzLl9kb2N1bWVudCxcbiAgICAgIGAke3FhfSAke3ZzfSAke1phfSAke1FhfSAke0phfSAke3RsfSAke2VsfSAke25sfSAke2lsfSAke3NsfWBcbiAgICApLCBjLm9mZih3aW5kb3csIHZzKTtcbiAgfVxuICBfcmVtb3ZlTW9kYWxFbGVtZW50cygpIHtcbiAgICB0aGlzLl9tb2RhbCAmJiB0aGlzLl9tb2RhbC5yZW1vdmUoKTtcbiAgfVxuICBfdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24odCA9ICExKSB7XG4gICAgdCA/IHRoaXMuX3dyYXBwZXIuY2xhc3NMaXN0LmFkZChcImFuaW1hdGUtW2ZhZGUtb3V0XzM1MG1zX2Vhc2UtaW4tb3V0XVwiKSA6ICh0aGlzLl93cmFwcGVyLmNsYXNzTGlzdC5hZGQoXCJhbmltYXRlLVtmYWRlLWluXzM1MG1zX2Vhc2UtaW4tb3V0XVwiKSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgaC5hZGRDbGFzcyh0aGlzLl9jbG9jaywgdGhpcy5fY2xhc3Nlcy5jbG9ja0FuaW1hdGlvbikpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3dyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgXCJhbmltYXRlLVtmYWRlLW91dF8zNTBtc19lYXNlLWluLW91dF1cIixcbiAgICAgICAgXCJhbmltYXRlLVtmYWRlLWluXzM1MG1zX2Vhc2UtaW4tb3V0XVwiXG4gICAgICApO1xuICAgIH0sIDM1MSk7XG4gIH1cbiAgX2FkZEFjdGl2ZUNsYXNzVG9UaXAodCwgZSkge1xuICAgIHQuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgTnVtYmVyKGkudGV4dENvbnRlbnQpID09PSBOdW1iZXIoZSkgJiYgKGguYWRkQ2xhc3MoaSwgdGhpcy5fY2xhc3Nlcy50aXBzQWN0aXZlKSwgaS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRIb3VyT3JNaW51dGUodCkge1xuICAgIHJldHVybiB0IDwgMTAgPyBgMCR7dH1gIDogdDtcbiAgfVxuICBfYXBwZW5kVGltZXMoKSB7XG4gICAgY29uc3QgeyBmb3JtYXQyNDogdCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAodCkge1xuICAgICAgdGhpcy5fZ2V0QXBwZW5kQ2xvY2soXG4gICAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgICAgYFske3VlfV1gLFxuICAgICAgICBYXG4gICAgICApLCB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgICAgdGhpcy5pbm5lckhvdXJzLFxuICAgICAgICBgWyR7bWl9XWAsXG4gICAgICAgIGh0XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgIGBbJHt1ZX1dYCxcbiAgICAgIFhcbiAgICApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ud2csXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoQmksIHQsIGtnKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnhnLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKEJpLCB0LCBPZyksIHQ7XG4gIH1cbiAgX2dldENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKHRoaXMuX29wdGlvbnMuY29udGFpbmVyKTtcbiAgfVxuICBfZ2V0VmFsaWRhdGUodCkge1xuICAgIGNvbnN0IHsgZm9ybWF0MjQ6IGUsIGZvcm1hdDEyOiBpLCBhcHBlbmRWYWxpZGF0aW9uSW5mbzogbiB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBLLm9uKHRoaXMuaW5wdXQsIHQsICh7IHRhcmdldDogbyB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucyA9PT0gbnVsbCB8fCB0aGlzLmlucHV0LnZhbHVlID09PSBcIlwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gL14oMD9bMS05XXwxWzAxMl0pKDpbMC01XVxcZCkgW0FQYXBdW21NXSQvLCBhID0gL14oWzAxXVxcZHwyWzAtM10pKDpbMC01XVxcZCkkLywgbCA9IHIudGVzdChvLnZhbHVlKTtcbiAgICAgIGlmIChhLnRlc3Qoby52YWx1ZSkgIT09ICEwICYmIGUgfHwgbCAhPT0gITAgJiYgaSkge1xuICAgICAgICBuICYmIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKGNvLCBcIlwiKSwgaC5hZGRTdHlsZShvLCB7IG1hcmdpbkJvdHRvbTogMCB9KSwgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICEwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShjbyksIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgPSAhMTtcbiAgICAgIGNvbnN0IHUgPSBkLmZpbmRPbmUoXG4gICAgICAgIGBbJHtDZ31dYFxuICAgICAgKTtcbiAgICAgIHUgIT09IG51bGwgJiYgdS5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIEpzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBJZyA9IHtcbiAgdGhyZXNob2xkOiAxMCxcbiAgZGlyZWN0aW9uOiBcImFsbFwiXG59O1xubGV0IERnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsLCB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgLi4uSWcsXG4gICAgICAuLi5lXG4gICAgfTtcbiAgfVxuICBoYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModCk7XG4gIH1cbiAgaGFuZGxlVG91Y2hNb3ZlKHQpIHtcbiAgICBpZiAoIXRoaXMuX3N0YXJ0UG9zaXRpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHQpLCBpID0ge1xuICAgICAgeDogZS54IC0gdGhpcy5fc3RhcnRQb3NpdGlvbi54LFxuICAgICAgeTogZS55IC0gdGhpcy5fc3RhcnRQb3NpdGlvbi55XG4gICAgfSwgbiA9IHRoaXMuX2dldERpcmVjdGlvbihpKTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gPT09IFwiYWxsXCIpIHtcbiAgICAgIGlmIChuLnkudmFsdWUgPCB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAmJiBuLngudmFsdWUgPCB0aGlzLl9vcHRpb25zLnRocmVzaG9sZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgciA9IG4ueS52YWx1ZSA+IG4ueC52YWx1ZSA/IG4ueS5kaXJlY3Rpb24gOiBuLnguZGlyZWN0aW9uO1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGBzd2lwZSR7cn1gKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwic3dpcGVcIiwgeyBkaXJlY3Rpb246IHIgfSksIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvID0gdGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gPT09IFwibGVmdFwiIHx8IHRoaXMuX29wdGlvbnMgPT09IFwicmlnaHRcIiA/IFwieFwiIDogXCJ5XCI7XG4gICAgbltvXS5kaXJlY3Rpb24gPT09IHRoaXMuX29wdGlvbnMuZGlyZWN0aW9uICYmIG5bb10udmFsdWUgPiB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAmJiAoYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGBzd2lwZSR7bltvXS5kaXJlY3Rpb259YCksIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsKTtcbiAgfVxuICBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgfVxuICBfZ2V0Q29vcmRpbmF0ZXModCkge1xuICAgIGNvbnN0IFtlXSA9IHQudG91Y2hlcztcbiAgICByZXR1cm4ge1xuICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgeTogZS5jbGllbnRZXG4gICAgfTtcbiAgfVxuICBfZ2V0RGlyZWN0aW9uKHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDoge1xuICAgICAgICBkaXJlY3Rpb246IHQueCA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgdmFsdWU6IE1hdGguYWJzKHQueClcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIGRpcmVjdGlvbjogdC55IDwgMCA/IFwidXBcIiA6IFwiZG93blwiLFxuICAgICAgICB2YWx1ZTogTWF0aC5hYnModC55KVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0sICRnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0gXCJzd2lwZVwiLCBpID0ge30pIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fZXZlbnQgPSBlLCB0aGlzLnN3aXBlID0gbmV3IERnKHQsIGkpLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciA9IHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQuYmluZCh0aGlzKSwgdGhpcy5fdG91Y2hNb3ZlSGFuZGxlciA9IHRoaXMuX2hhbmRsZVRvdWNoTW92ZS5iaW5kKHRoaXMpLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVUb3VjaEVuZC5iaW5kKHRoaXMpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciksIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl90b3VjaE1vdmVIYW5kbGVyKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hTdGFydCh0KVxuICAgICksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hNb3ZlKHQpXG4gICAgKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCAodCkgPT4gdGhpcy5faGFuZGxlVG91Y2hFbmQodCkpO1xuICB9XG4gIF9oYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaFN0YXJ0KHQpO1xuICB9XG4gIF9oYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoTW92ZSh0KTtcbiAgfVxuICBfaGFuZGxlVG91Y2hFbmQodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoRW5kKHQpO1xuICB9XG59O1xuY29uc3QgaGwgPSBcInNpZGVuYXZcIiwgd3MgPSBcInRlLnNpZGVuYXZcIiwgTGcgPSBcImRhdGEtdGUtc2lkZW5hdi1yb3RhdGUtaWNvbi1yZWZcIiwgZm8gPSBcIltkYXRhLXRlLXNpZGVuYXYtdG9nZ2xlLXJlZl1cIiwgTmcgPSBcIltkYXRhLXRlLWNvbGxhcHNlLWluaXRdXCIsIE1nID0gJ1tkYXRhLXRlLXNpZGVuYXYtc2xpbT1cInRydWVcIl0nLCBSZyA9ICdbZGF0YS10ZS1zaWRlbmF2LXNsaW09XCJmYWxzZVwiXScsIFBnID0gXCJbZGF0YS10ZS1zaWRlbmF2LW1lbnUtcmVmXVwiLCBMZSA9IFwiW2RhdGEtdGUtc2lkZW5hdi1jb2xsYXBzZS1yZWZdXCIsIGdpID0gXCJbZGF0YS10ZS1zaWRlbmF2LWxpbmstcmVmXVwiLCBCZyA9IFcoKSA/IDEwMCA6IC0xMDAsIEhnID0gVygpID8gLTEwMCA6IDEwMCwgVmcgPSB7XG4gIHNpZGVuYXZBY2NvcmRpb246IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZCYWNrZHJvcDogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkJhY2tkcm9wQ2xhc3M6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBzaWRlbmF2Q2xvc2VPbkVzYzogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkNvbG9yOiBcIihzdHJpbmcpXCIsXG4gIHNpZGVuYXZDb250ZW50OiBcIihudWxsfHN0cmluZylcIixcbiAgc2lkZW5hdkV4cGFuZGFibGU6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZFeHBhbmRPbkhvdmVyOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2Rm9jdXNUcmFwOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2SGlkZGVuOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2TW9kZTogXCIoc3RyaW5nKVwiLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyOiBcIihudWxsfHN0cmluZ3xudW1iZXIpXCIsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGU6IFwiKG51bGx8c3RyaW5nfG51bWJlcilcIixcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaDogXCIobnVsbHxzdHJpbmd8bnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludFNtOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50TWQ6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdkJyZWFrcG9pbnRMZzogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludFhsOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50MnhsOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZTY3JvbGxDb250YWluZXI6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBzaWRlbmF2U2xpbTogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdlNsaW1Db2xsYXBzZWQ6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZTbGltV2lkdGg6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdlBvc2l0aW9uOiBcIihzdHJpbmcpXCIsXG4gIHNpZGVuYXZSaWdodDogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdlRyYW5zaXRpb25EdXJhdGlvbjogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2V2lkdGg6IFwiKG51bWJlcilcIlxufSwgV2cgPSB7XG4gIHNpZGVuYXZBY2NvcmRpb246ICExLFxuICBzaWRlbmF2QmFja2Ryb3A6ICEwLFxuICBzaWRlbmF2QmFja2Ryb3BDbGFzczogbnVsbCxcbiAgc2lkZW5hdkNsb3NlT25Fc2M6ICEwLFxuICBzaWRlbmF2Q29sb3I6IFwicHJpbWFyeVwiLFxuICBzaWRlbmF2Q29udGVudDogbnVsbCxcbiAgc2lkZW5hdkV4cGFuZGFibGU6ICEwLFxuICBzaWRlbmF2RXhwYW5kT25Ib3ZlcjogITEsXG4gIHNpZGVuYXZGb2N1c1RyYXA6ICEwLFxuICBzaWRlbmF2SGlkZGVuOiAhMCxcbiAgc2lkZW5hdk1vZGU6IFwib3ZlclwiLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyOiBudWxsLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlOiBudWxsLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoOiBudWxsLFxuICBzaWRlbmF2QnJlYWtwb2ludFNtOiA2NDAsXG4gIHNpZGVuYXZCcmVha3BvaW50TWQ6IDc2OCxcbiAgc2lkZW5hdkJyZWFrcG9pbnRMZzogMTAyNCxcbiAgc2lkZW5hdkJyZWFrcG9pbnRYbDogMTI4MCxcbiAgc2lkZW5hdkJyZWFrcG9pbnQyeGw6IDE1MzYsXG4gIHNpZGVuYXZTY3JvbGxDb250YWluZXI6IG51bGwsXG4gIHNpZGVuYXZTbGltOiAhMSxcbiAgc2lkZW5hdlNsaW1Db2xsYXBzZWQ6ICExLFxuICBzaWRlbmF2U2xpbVdpZHRoOiA3NyxcbiAgc2lkZW5hdlBvc2l0aW9uOiBcImZpeGVkXCIsXG4gIHNpZGVuYXZSaWdodDogITEsXG4gIHNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb246IDMwMCxcbiAgc2lkZW5hdldpZHRoOiAyNDBcbn07XG5jbGFzcyBDaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHd0KHRoaXMsIFwiX2FkZEJhY2tkcm9wT25Jbml0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuX29wdGlvbnMuc2lkZW5hdkhpZGRlbiB8fCAodGhpcy5fYmFja2Ryb3Auc2hvdygpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBcInRyYW5zaXRpb25lbmRcIiwgdGhpcy5fYWRkQmFja2Ryb3BPbkluaXQpKTtcbiAgICB9KTtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IGUsIHRoaXMuX0lEID0gZXQoXCJcIiksIHRoaXMuX2NvbnRlbnQgPSBudWxsLCB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlID0gbnVsbCwgdGhpcy5fc2xpbUNvbGxhcHNlZCA9ICExLCB0aGlzLl9hY3RpdmVOb2RlID0gbnVsbCwgdGhpcy5fdGVtcFNsaW0gPSAhMSwgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKSwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5fcGVyZmVjdFNjcm9sbGJhciA9IG51bGwsIHRoaXMuX3RvdWNoID0gbnVsbCwgdGhpcy5fc2V0TW9kZUZyb21CcmVha3BvaW50cygpLCB0aGlzLmVzY0hhbmRsZXIgPSAoaSkgPT4ge1xuICAgICAgaS5rZXlDb2RlID09PSB3ZSAmJiB0aGlzLnRvZ2dsZXIgJiYgTXQodGhpcy50b2dnbGVyKSAmJiAodGhpcy5fdXBkYXRlKCExKSwgYy5vZmYod2luZG93LCBcImtleWRvd25cIiwgdGhpcy5lc2NIYW5kbGVyKSk7XG4gICAgfSwgdGhpcy5oYXNoSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRzKCk7XG4gICAgfSwgdCAmJiAoQS5zZXREYXRhKHQsIHdzLCB0aGlzKSwgdGhpcy5fc2V0dXAoKSksIHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgIXRoaXMub3B0aW9ucy5zaWRlbmF2SGlkZGVuICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgYy5vbih0aGlzLl9lbGVtZW50LCBcInRyYW5zaXRpb25lbmRcIiwgdGhpcy5fYWRkQmFja2Ryb3BPbkluaXQpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gaGw7XG4gIH1cbiAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbiA9PT0gXCJmaXhlZFwiKVxuICAgICAgcmV0dXJuIGQuZmluZE9uZShcImJvZHlcIik7XG4gICAgY29uc3QgdCA9IChlKSA9PiAhZS5wYXJlbnROb2RlIHx8IGUucGFyZW50Tm9kZSA9PT0gZG9jdW1lbnQgPyBlIDogZS5wYXJlbnROb2RlLnN0eWxlLnBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgZS5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucyhcInJlbGF0aXZlXCIpID8gZS5wYXJlbnROb2RlIDogdChlLnBhcmVudE5vZGUpO1xuICAgIHJldHVybiB0KHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgbGV0IHQgPSAwLCBlID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24gIT09IFwiZml4ZWRcIikge1xuICAgICAgY29uc3QgbiA9IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdCA9IG4ueCwgZSA9IG4ueCArIG4ud2lkdGg7XG4gICAgfVxuICAgIGNvbnN0IHsgeDogaSB9ID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodCAmJiAhVygpIHx8ICF0aGlzLm9wdGlvbnMuc2lkZW5hdlJpZ2h0ICYmIFcoKSkge1xuICAgICAgbGV0IG4gPSAwO1xuICAgICAgaWYgKHRoaXMuY29udGFpbmVyLnNjcm9sbEhlaWdodCA+IHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCAmJiAobiA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoIC0gdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgpLCB0aGlzLmNvbnRhaW5lci50YWdOYW1lID09PSBcIkJPRFlcIikge1xuICAgICAgICBjb25zdCBvID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICBuID0gTWF0aC5hYnMod2luZG93LmlubmVyV2lkdGggLSBvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLmFicyhpICsgbiAtIGUpID4gMTA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmFicyhpIC0gdCkgPCAxMDtcbiAgfVxuICBnZXQgbGlua3MoKSB7XG4gICAgcmV0dXJuIGQuZmluZChnaSwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IG5hdmlnYXRpb24oKSB7XG4gICAgcmV0dXJuIGQuZmluZChQZywgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLldnLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRoaXMuX29wdGlvbnNcbiAgICB9O1xuICAgIHJldHVybiBJKGhsLCB0LCBWZyksIHQ7XG4gIH1cbiAgZ2V0IHNpZGVuYXZTdHlsZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IGAke3RoaXMud2lkdGh9cHhgLFxuICAgICAgaGVpZ2h0OiB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBcIjEwMHZoXCIgOiBcIjEwMCVcIixcbiAgICAgIHBvc2l0aW9uOiB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uLFxuICAgICAgdHJhbnNpdGlvbjogYGFsbCAke3RoaXMudHJhbnNpdGlvbkR1cmF0aW9ufSBsaW5lYXJgXG4gICAgfTtcbiAgfVxuICBnZXQgdG9nZ2xlcigpIHtcbiAgICByZXR1cm4gZC5maW5kKGZvKS5maW5kKFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgY29uc3QgaSA9IGguZ2V0RGF0YUF0dHJpYnV0ZShlLCBcInRhcmdldFwiKTtcbiAgICAgICAgcmV0dXJuIGQuZmluZE9uZShpKSA9PT0gdGhpcy5fZWxlbWVudDtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldCB0cmFuc2l0aW9uRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5zaWRlbmF2VHJhbnNpdGlvbkR1cmF0aW9uIC8gMWUzfXNgO1xuICB9XG4gIGdldCB0cmFuc2xhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodCA/IEhnIDogQmc7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9zbGltQ29sbGFwc2VkID8gdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltV2lkdGggOiB0aGlzLm9wdGlvbnMuc2lkZW5hdldpZHRoO1xuICB9XG4gIGdldCBpc0JhY2tkcm9wVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9iYWNrZHJvcC5fZWxlbWVudDtcbiAgfVxuICAvLyBQdWJsaWNcbiAgY2hhbmdlTW9kZSh0KSB7XG4gICAgdGhpcy5fc2V0TW9kZSh0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGMub2ZmKHdpbmRvdywgXCJrZXlkb3duXCIsIHRoaXMuZXNjSGFuZGxlciksIHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpLCBjLm9mZih3aW5kb3csIFwiaGFzaGNoYW5nZVwiLCB0aGlzLmhhc2hIYW5kbGVyKSwgdGhpcy5fdG91Y2guZGlzcG9zZSgpLCBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgd3MpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuX2VtaXRFdmVudHMoITEpLCB0aGlzLl91cGRhdGUoITEpLCB0aGlzLl9vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiB0aGlzLmlzQmFja2Ryb3BWaXNpYmxlICYmIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgfVxuICBzaG93KCkge1xuICAgIHRoaXMuX2VtaXRFdmVudHMoITApLCB0aGlzLl91cGRhdGUoITApLCB0aGlzLl9vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiB0aGlzLl9vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9iYWNrZHJvcC5zaG93KCk7XG4gIH1cbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuX2VtaXRFdmVudHMoIXRoaXMuaXNWaXNpYmxlKSwgdGhpcy5fdXBkYXRlKCF0aGlzLmlzVmlzaWJsZSk7XG4gIH1cbiAgdG9nZ2xlU2xpbSgpIHtcbiAgICB0aGlzLl9zZXRTbGltKCF0aGlzLl9zbGltQ29sbGFwc2VkKTtcbiAgfVxuICB1cGRhdGUodCkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB0LCB0aGlzLl9zZXR1cCgpO1xuICB9XG4gIGdldEJyZWFrcG9pbnQodCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1CcmVha3BvaW50VmFsdWVzVG9PYmplY3QoKVt0XTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKGMub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGZvLFxuICAgICAgQ2kudG9nZ2xlU2lkZW5hdigpXG4gICAgKSwgdGhpcy5fZGlkSW5pdCA9ICEwKTtcbiAgfVxuICBfdHJhbnNmb3JtQnJlYWtwb2ludFZhbHVlc1RvT2JqZWN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBzbTogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50U20sXG4gICAgICBtZDogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50TWQsXG4gICAgICBsZzogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50TGcsXG4gICAgICB4bDogdGhpcy5vcHRpb25zLnNpZGVuYXZCcmVha3BvaW50WGwsXG4gICAgICBcIjJ4bFwiOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJyZWFrcG9pbnQyeGxcbiAgICB9O1xuICB9XG4gIF9zZXRNb2RlRnJvbUJyZWFrcG9pbnRzKCkge1xuICAgIGNvbnN0IHQgPSB3aW5kb3cuaW5uZXJXaWR0aCwgZSA9IHRoaXMuX3RyYW5zZm9ybUJyZWFrcG9pbnRWYWx1ZXNUb09iamVjdCgpO1xuICAgIGlmICh0ID09PSB2b2lkIDAgfHwgIWUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50T3ZlciA9PSBcIm51bWJlclwiID8gdCAtIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyIDogdCAtIGVbdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludE92ZXJdLCBuID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlID09IFwibnVtYmVyXCIgPyB0IC0gdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGUgOiB0IC0gZVt0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50U2lkZV0sIG8gPSB0eXBlb2YgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFB1c2ggPT0gXCJudW1iZXJcIiA/IHQgLSB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaCA6IHQgLSBlW3RoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoXSwgciA9IChsLCBwKSA9PiBsIC0gcCA8IDAgPyAtMSA6IHAgLSBsIDwgMCA/IDEgOiAwLCBhID0gW2ksIG4sIG9dLmZpbHRlcigobCkgPT4gbCAhPSBudWxsICYmIGwgPj0gMCkuc29ydChyKVswXTtcbiAgICBpID4gMCAmJiBpID09PSBhID8gKHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSBcIm92ZXJcIiwgdGhpcy5fb3B0aW9ucy5zaWRlbmF2SGlkZGVuID0gITApIDogbiA+IDAgJiYgbiA9PT0gYSA/IHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSBcInNpZGVcIiA6IG8gPiAwICYmIG8gPT09IGEgJiYgKHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPSBcInB1c2hcIik7XG4gIH1cbiAgX2NvbGxhcHNlSXRlbXMoKSB7XG4gICAgdGhpcy5uYXZpZ2F0aW9uLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGQuZmluZChMZSwgdCkuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBRdC5nZXRJbnN0YW5jZShpKS5oaWRlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfZ2V0T2Zmc2V0VmFsdWUodCwgeyBpbmRleDogZSwgcHJvcGVydHk6IGksIG9mZnNldHM6IG4gfSkge1xuICAgIGNvbnN0IG8gPSB0aGlzLl9nZXRQeFZhbHVlKFxuICAgICAgdGhpcy5faW5pdGlhbENvbnRlbnRTdHlsZVtlXVtuW2ldLnByb3BlcnR5XVxuICAgICksIHIgPSB0ID8gbltpXS52YWx1ZSA6IDA7XG4gICAgcmV0dXJuIG8gKyByO1xuICB9XG4gIF9nZXRQcm9wZXJ0eSguLi50KSB7XG4gICAgcmV0dXJuIHQubWFwKChlLCBpKSA9PiBpID09PSAwID8gZSA6IGVbMF0udG9VcHBlckNhc2UoKS5jb25jYXQoZS5zbGljZSgxKSkpLmpvaW4oXCJcIik7XG4gIH1cbiAgX2dldFB4VmFsdWUodCkge1xuICAgIHJldHVybiB0ID8gcGFyc2VGbG9hdCh0KSA6IDA7XG4gIH1cbiAgX2hhbmRsZVN3aXBlKHQsIGUpIHtcbiAgICBlICYmIHRoaXMuX3NsaW1Db2xsYXBzZWQgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2RXhwYW5kYWJsZSA/IHRoaXMudG9nZ2xlU2xpbSgpIDogZSB8fCAodGhpcy5fc2xpbUNvbGxhcHNlZCB8fCAhdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltIHx8ICF0aGlzLm9wdGlvbnMuc2lkZW5hdkV4cGFuZGFibGUgPyB0aGlzLnRvZ2dsZXIgJiYgTXQodGhpcy50b2dnbGVyKSAmJiB0aGlzLnRvZ2dsZSgpIDogdGhpcy50b2dnbGVTbGltKCkpO1xuICB9XG4gIF9pc0FjdGl2ZSh0LCBlKSB7XG4gICAgcmV0dXJuIGUgPyBlID09PSB0IDogdC5hdHRyaWJ1dGVzLmhyZWYgPyBuZXcgVVJMKHQsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5ocmVmID09PSB3aW5kb3cubG9jYXRpb24uaHJlZiA6ICExO1xuICB9XG4gIF9pc0FsbFRvQmVDb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIGQuZmluZChcbiAgICAgIE5nLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkuZmlsdGVyKFxuICAgICAgKGkpID0+IGkuZ2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiKSA9PT0gXCJ0cnVlXCJcbiAgICApLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBfaXNBbGxDb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIGQuZmluZChMZSwgdGhpcy5fZWxlbWVudCkuZmlsdGVyKFxuICAgICAgKHQpID0+IE10KHQpXG4gICAgKS5sZW5ndGggPT09IDA7XG4gIH1cbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3ApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3BDbGFzcyA/IHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3BDbGFzcy5zcGxpdChcIiBcIikgOiB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uID8gW1xuICAgICAgXCJvcGFjaXR5LTUwXCIsXG4gICAgICBcInRyYW5zaXRpb24tYWxsXCIsXG4gICAgICBcImR1cmF0aW9uLTMwMFwiLFxuICAgICAgXCJlYXNlLWluLW91dFwiLFxuICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZQb3NpdGlvbixcbiAgICAgIFwidG9wLTBcIixcbiAgICAgIFwibGVmdC0wXCIsXG4gICAgICBcInotNTBcIixcbiAgICAgIFwiYmctYmxhY2svMTBcIixcbiAgICAgIFwiZGFyazpiZy1ibGFjay02MFwiLFxuICAgICAgXCJ3LWZ1bGxcIixcbiAgICAgIFwiaC1mdWxsXCIsXG4gICAgICB0aGlzLl9lbGVtZW50LmlkXG4gICAgXSA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBDcih7XG4gICAgICBpc1Zpc2libGU6IHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AsXG4gICAgICBpc0FuaW1hdGVkOiAhMCxcbiAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICBiYWNrZHJvcENsYXNzZXM6IHQsXG4gICAgICBjbGlja0NhbGxiYWNrOiAoKSA9PiB0aGlzLmhpZGUoKVxuICAgIH0pO1xuICB9XG4gIF91cGRhdGVCYWNrZHJvcCh0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIpIHtcbiAgICAgIHQgPyB0aGlzLl9iYWNrZHJvcC5zaG93KCkgOiB0aGlzLmlzQmFja2Ryb3BWaXNpYmxlICYmIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc0JhY2tkcm9wVmlzaWJsZSAmJiB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gIH1cbiAgX3NldHVwKCkge1xuICAgIHRoaXMuX3NldHVwVG91Y2goKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZGb2N1c1RyYXAgJiYgdGhpcy5fc2V0dXBGb2N1c1RyYXAoKSwgdGhpcy5fc2V0dXBDb2xsYXBzZSgpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdlNsaW0gJiYgdGhpcy5fc2V0dXBTbGltKCksIHRoaXMuX3NldHVwSW5pdGlhbFN0eWxpbmcoKSwgdGhpcy5fc2V0dXBTY3JvbGxpbmcoKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZDb250ZW50ICYmIHRoaXMuX3NldHVwQ29udGVudCgpLCB0aGlzLl9zZXR1cEFjdGl2ZVN0YXRlKCksIHRoaXMuX3NldHVwUmlwcGxlRWZmZWN0KCksIHRoaXMub3B0aW9ucy5zaWRlbmF2SGlkZGVuIHx8IHRoaXMuX3VwZGF0ZU9mZnNldHMoITAsICEwKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9zZXRUYWJpbmRleCghMCk7XG4gIH1cbiAgX3NldHVwQWN0aXZlU3RhdGUoKSB7XG4gICAgdGhpcy5fc2V0QWN0aXZlRWxlbWVudHMoKSwgdGhpcy5saW5rcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjLm9uKHQsIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5fc2V0QWN0aXZlRWxlbWVudHModCkpLCBjLm9uKHQsIFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgICBlLmtleUNvZGUgPT09IGl0ICYmIHRoaXMuX3NldEFjdGl2ZUVsZW1lbnRzKHQpO1xuICAgICAgfSk7XG4gICAgfSksIGMub24od2luZG93LCBcImhhc2hjaGFuZ2VcIiwgdGhpcy5oYXNoSGFuZGxlcik7XG4gIH1cbiAgX3NldHVwQ29sbGFwc2UoKSB7XG4gICAgdGhpcy5uYXZpZ2F0aW9uLmZvckVhY2goKHQsIGUpID0+IHtcbiAgICAgIGQuZmluZChMZSwgdCkuZm9yRWFjaChcbiAgICAgICAgKG4sIG8pID0+IHRoaXMuX3NldHVwQ29sbGFwc2VMaXN0KHsgbGlzdDogbiwgaW5kZXg6IG8sIG1lbnU6IHQsIG1lbnVJbmRleDogZSB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBfZ2VuZXJhdGVDb2xscGFzZUlEKHQsIGUpIHtcbiAgICByZXR1cm4gYHNpZGVuYXYtY29sbGFwc2UtJHt0aGlzLl9JRH0tJHtlfS0ke3R9YDtcbiAgfVxuICBfc2V0dXBDb2xsYXBzZUxpc3QoeyBsaXN0OiB0LCBpbmRleDogZSwgbWVudTogaSwgbWVudUluZGV4OiBuIH0pIHtcbiAgICBjb25zdCBvID0gdGhpcy5fZ2VuZXJhdGVDb2xscGFzZUlEKGUsIG4pO1xuICAgIHQuc2V0QXR0cmlidXRlKFwiaWRcIiwgbyksIHQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1jb2xsYXBzZS1pdGVtXCIsIFwiXCIpO1xuICAgIGNvbnN0IFtyXSA9IGQucHJldih0LCBnaSk7XG4gICAgaC5zZXREYXRhQXR0cmlidXRlKHIsIFwiY29sbGFwc2UtaW5pdFwiLCBcIlwiKSwgci5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtvfWApLCByLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJidXR0b25cIik7XG4gICAgY29uc3QgYSA9IFF0LmdldEluc3RhbmNlKHQpIHx8IG5ldyBRdCh0LCB7XG4gICAgICB0b2dnbGU6ICExLFxuICAgICAgcGFyZW50OiB0aGlzLm9wdGlvbnMuc2lkZW5hdkFjY29yZGlvbiA/IGkgOiB0XG4gICAgfSk7XG4gICAgKHQuZGF0YXNldC50ZVNpZGVuYXZTdGF0ZVNob3cgPT09IFwiXCIgfHwgdC5kYXRhc2V0LnRlQ29sbGFwc2VTaG93ID09PSBcIlwiKSAmJiB0aGlzLl9yb3RhdGVBcnJvdyhyLCAhMSksIGMub24ociwgXCJjbGlja1wiLCAobCkgPT4ge1xuICAgICAgdGhpcy5fdG9nZ2xlQ2F0ZWdvcnkobCwgYSwgdCksIHRoaXMuX3RlbXBTbGltICYmIHRoaXMuX2lzQWxsVG9CZUNvbGxhcHNlZCgpICYmICh0aGlzLl9zZXRTbGltKCEwKSwgdGhpcy5fdGVtcFNsaW0gPSAhMSksIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgJiYgdGhpcy5fZm9jdXNUcmFwICYmIHRoaXMuX2ZvY3VzVHJhcC51cGRhdGUoKTtcbiAgICB9KSwgYy5vbihcbiAgICAgIHQsXG4gICAgICBcInNob3cudGUuY29sbGFwc2VcIixcbiAgICAgICgpID0+IHRoaXMuX3JvdGF0ZUFycm93KHIsICExKVxuICAgICksIGMub24oXG4gICAgICB0LFxuICAgICAgXCJoaWRlLnRlLmNvbGxhcHNlXCIsXG4gICAgICAoKSA9PiB0aGlzLl9yb3RhdGVBcnJvdyhyLCAhMClcbiAgICApLCBjLm9uKHQsIFwic2hvd24udGUuY29sbGFwc2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9mb2N1c1RyYXAgJiYgdGhpcy5fZm9jdXNUcmFwLnVwZGF0ZSgpO1xuICAgIH0pLCBjLm9uKHQsIFwiaGlkZGVuLnRlLmNvbGxhcHNlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3RlbXBTbGltICYmIHRoaXMuX2lzQWxsQ29sbGFwc2VkKCkgJiYgKHRoaXMuX3NldFNsaW0oITApLCB0aGlzLl90ZW1wU2xpbSA9ICExKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9mb2N1c1RyYXAgJiYgdGhpcy5fZm9jdXNUcmFwLnVwZGF0ZSgpO1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cENvbnRlbnQoKSB7XG4gICAgdGhpcy5fY29udGVudCA9IGQuZmluZCh0aGlzLm9wdGlvbnMuc2lkZW5hdkNvbnRlbnQpLCB0aGlzLl9jb250ZW50LmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBbXG4gICAgICAgIFwiIXBcIixcbiAgICAgICAgXCIhbVwiLFxuICAgICAgICBcIiFweFwiLFxuICAgICAgICBcIiFwbFwiLFxuICAgICAgICBcIiFwclwiLFxuICAgICAgICBcIiFteFwiLFxuICAgICAgICBcIiFtbFwiLFxuICAgICAgICBcIiFtclwiLFxuICAgICAgICBcIiEtcFwiLFxuICAgICAgICBcIiEtbVwiLFxuICAgICAgICBcIiEtcHhcIixcbiAgICAgICAgXCIhLXBsXCIsXG4gICAgICAgIFwiIS1wclwiLFxuICAgICAgICBcIiEtbXhcIixcbiAgICAgICAgXCIhLW1sXCIsXG4gICAgICAgIFwiIS1tclwiXG4gICAgICBdO1xuICAgICAgWy4uLnQuY2xhc3NMaXN0XS5maWx0ZXIoXG4gICAgICAgIChuKSA9PiBlLmZpbmRJbmRleCgobykgPT4gbi5pbmNsdWRlcyhvKSkgPj0gMFxuICAgICAgKS5mb3JFYWNoKChuKSA9PiB0LmNsYXNzTGlzdC5yZW1vdmUobikpO1xuICAgIH0pLCB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlID0gdGhpcy5fY29udGVudC5tYXAoKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgcGFkZGluZ0xlZnQ6IGUsIHBhZGRpbmdSaWdodDogaSwgbWFyZ2luTGVmdDogbiwgbWFyZ2luUmlnaHQ6IG8sIHRyYW5zaXRpb246IHIgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpO1xuICAgICAgcmV0dXJuIHsgcGFkZGluZ0xlZnQ6IGUsIHBhZGRpbmdSaWdodDogaSwgbWFyZ2luTGVmdDogbiwgbWFyZ2luUmlnaHQ6IG8sIHRyYW5zaXRpb246IHIgfTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXBGb2N1c1RyYXAoKSB7XG4gICAgdGhpcy5fZm9jdXNUcmFwID0gbmV3IHppKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHtcbiAgICAgICAgZXZlbnQ6IFwia2V5ZG93blwiLFxuICAgICAgICBjb25kaXRpb246ICh0KSA9PiB0LmtleUNvZGUgPT09IGtlLFxuICAgICAgICBvbmx5VmlzaWJsZTogITBcbiAgICAgIH0sXG4gICAgICB0aGlzLnRvZ2dsZXJcbiAgICApO1xuICB9XG4gIF9zZXR1cEluaXRpYWxTdHlsaW5nKCkge1xuICAgIHRoaXMuX3NldENvbG9yKCksIGguc3R5bGUodGhpcy5fZWxlbWVudCwgdGhpcy5zaWRlbmF2U3R5bGUpO1xuICB9XG4gIF9zZXR1cFNjcm9sbGluZygpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2U2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICB0ID0gZC5maW5kT25lKFxuICAgICAgICB0aGlzLm9wdGlvbnMuc2lkZW5hdlNjcm9sbENvbnRhaW5lcixcbiAgICAgICAgdGhpcy5fZWxlbWVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGkgPSBmZCh0LnBhcmVudE5vZGUuY2hpbGRyZW4pLmZpbHRlcihcbiAgICAgICAgKG4pID0+IG4gIT09IHRcbiAgICAgICkucmVkdWNlKChuLCBvKSA9PiBuICsgby5jbGllbnRIZWlnaHQsIDApO1xuICAgICAgaC5zdHlsZSh0LCB7XG4gICAgICAgIG1heEhlaWdodDogYGNhbGMoMTAwJSAtICR7aX1weClgLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcGVyZmVjdFNjcm9sbGJhciA9IG5ldyBCaCh0LCB7XG4gICAgICBzdXBwcmVzc1Njcm9sbFg6ICEwLFxuICAgICAgaGFuZGxlcnM6IFtcImNsaWNrLXJhaWxcIiwgXCJkcmFnLXRodW1iXCIsIFwid2hlZWxcIiwgXCJ0b3VjaFwiXVxuICAgIH0pO1xuICB9XG4gIF9zZXR1cFNsaW0oKSB7XG4gICAgdGhpcy5fc2xpbUNvbGxhcHNlZCA9IHRoaXMub3B0aW9ucy5zaWRlbmF2U2xpbUNvbGxhcHNlZCwgdGhpcy5fdG9nZ2xlU2xpbURpc3BsYXkodGhpcy5fc2xpbUNvbGxhcHNlZCksIHRoaXMub3B0aW9ucy5zaWRlbmF2RXhwYW5kT25Ib3ZlciAmJiAodGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zbGltQ29sbGFwc2VkICYmIHRoaXMuX3NldFNsaW0oITEpO1xuICAgIH0pLCB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3NsaW1Db2xsYXBzZWQgfHwgdGhpcy5fc2V0U2xpbSghMCk7XG4gICAgfSkpO1xuICB9XG4gIF9zZXR1cFJpcHBsZUVmZmVjdCgpIHtcbiAgICB0aGlzLmxpbmtzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGxldCBlID0gZWkuZ2V0SW5zdGFuY2UodCksIGkgPSB0aGlzLm9wdGlvbnMuc2lkZW5hdkNvbG9yO1xuICAgICAgaWYgKGUgJiYgZS5fb3B0aW9ucy5zaWRlbmF2Q29sb3IgIT09IHRoaXMub3B0aW9ucy5zaWRlbmF2Q29sb3IpXG4gICAgICAgIGUuZGlzcG9zZSgpO1xuICAgICAgZWxzZSBpZiAoZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgKGxvY2FsU3RvcmFnZS50aGVtZSA9PT0gXCJkYXJrXCIgfHwgIShcInRoZW1lXCIgaW4gbG9jYWxTdG9yYWdlKSAmJiB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikubWF0Y2hlcykgJiYgKGkgPSBcIndoaXRlXCIpLCBlID0gbmV3IGVpKHQsIHsgcmlwcGxlQ29sb3I6IGkgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwVG91Y2goKSB7XG4gICAgdGhpcy5fdG91Y2ggPSBuZXcgJGcodGhpcy5fZWxlbWVudCwgXCJzd2lwZVwiLCB7IHRocmVzaG9sZDogMjAgfSksIHRoaXMuX3RvdWNoLmluaXQoKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcInN3aXBlbGVmdFwiLFxuICAgICAgKHQpID0+IHRoaXMuX2hhbmRsZVN3aXBlKHQsIHRoaXMub3B0aW9ucy5zaWRlbmF2UmlnaHQpXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcInN3aXBlcmlnaHRcIixcbiAgICAgICh0KSA9PiB0aGlzLl9oYW5kbGVTd2lwZSh0LCAhdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodClcbiAgICApO1xuICB9XG4gIF9zZXRBY3RpdmUodCwgZSkge1xuICAgIHQuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1zaWRlYmFyLXN0YXRlLWFjdGl2ZVwiLCBcIlwiKSwgdGhpcy5fYWN0aXZlTm9kZSAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZWJhci1zdGF0ZS1hY3RpdmVcIiksIHRoaXMuX2FjdGl2ZU5vZGUgPSB0O1xuICAgIGNvbnN0IFtpXSA9IGQucGFyZW50cyhcbiAgICAgIHRoaXMuX2FjdGl2ZU5vZGUsXG4gICAgICBMZVxuICAgICk7XG4gICAgaWYgKCFpKSB7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVDYXRlZ29yeSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbbl0gPSBkLnByZXYoaSwgZ2kpO1xuICAgIHRoaXMuX3NldEFjdGl2ZUNhdGVnb3J5KG4pLCAhZSAmJiAhdGhpcy5fc2xpbUNvbGxhcHNlZCAmJiBRdC5nZXRJbnN0YW5jZShpKS5zaG93KCk7XG4gIH1cbiAgX3NldEFjdGl2ZUNhdGVnb3J5KHQpIHtcbiAgICB0aGlzLm5hdmlnYXRpb24uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZC5maW5kKExlLCBlKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGNvbnN0IFtvXSA9IGQucHJldihuLCBnaSk7XG4gICAgICAgIG8gIT09IHQgPyBvLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZW5hdi1zdGF0ZS1hY3RpdmVcIikgOiBvLnNldEF0dHJpYnV0ZShcImRhdGEtdGUtc2lkZW5hdi1zdGF0ZS1hY3RpdmVcIiwgXCJcIik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfc2V0QWN0aXZlRWxlbWVudHModCkge1xuICAgIHRoaXMubmF2aWdhdGlvbi5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBkLmZpbmQoZ2ksIGUpLmZpbHRlcigobikgPT4gZC5uZXh0KG4sIExlKS5sZW5ndGggPT09IDApLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgdGhpcy5faXNBY3RpdmUobiwgdCkgJiYgbiAhPT0gdGhpcy5fYWN0aXZlTm9kZSAmJiB0aGlzLl9zZXRBY3RpdmUobiwgdCk7XG4gICAgICB9KTtcbiAgICB9KSwgdCAmJiB0aGlzLl91cGRhdGVGb2N1cyh0aGlzLmlzVmlzaWJsZSk7XG4gIH1cbiAgX3NldENvbG9yKCkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBcInByaW1hcnlcIixcbiAgICAgIFwic2Vjb25kYXJ5XCIsXG4gICAgICBcInN1Y2Nlc3NcIixcbiAgICAgIFwiaW5mb1wiLFxuICAgICAgXCJ3YXJuaW5nXCIsXG4gICAgICBcImRhbmdlclwiLFxuICAgICAgXCJsaWdodFwiLFxuICAgICAgXCJkYXJrXCJcbiAgICBdLCB7IHNpZGVuYXZDb2xvcjogZSB9ID0gdGhpcy5vcHRpb25zLCBpID0gdC5pbmNsdWRlcyhlKSA/IGUgOiBcInByaW1hcnlcIjtcbiAgICB0LmZvckVhY2goKG4pID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgc2lkZW5hdi0ke259YCk7XG4gICAgfSksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgYHNpZGVuYXYtJHtpfWApO1xuICB9XG4gIF9zZXRDb250ZW50T2Zmc2V0cyh0LCBlLCBpKSB7XG4gICAgdGhpcy5fY29udGVudC5mb3JFYWNoKChuLCBvKSA9PiB7XG4gICAgICBjb25zdCByID0gdGhpcy5fZ2V0T2Zmc2V0VmFsdWUodCwge1xuICAgICAgICBpbmRleDogbyxcbiAgICAgICAgcHJvcGVydHk6IFwicGFkZGluZ1wiLFxuICAgICAgICBvZmZzZXRzOiBlXG4gICAgICB9KSwgYSA9IHRoaXMuX2dldE9mZnNldFZhbHVlKHQsIHtcbiAgICAgICAgaW5kZXg6IG8sXG4gICAgICAgIHByb3BlcnR5OiBcIm1hcmdpblwiLFxuICAgICAgICBvZmZzZXRzOiBlXG4gICAgICB9KSwgbCA9IHt9O1xuICAgICAgaWYgKGkgfHwgKGwudHJhbnNpdGlvbiA9IGBhbGwgJHt0aGlzLnRyYW5zaXRpb25EdXJhdGlvbn0gbGluZWFyYCksIGxbZS5wYWRkaW5nLnByb3BlcnR5XSA9IGAke3J9cHhgLCBsW2UubWFyZ2luLnByb3BlcnR5XSA9IGAke2F9cHhgLCBoLnN0eWxlKG4sIGwpLCAhIXQpIHtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICBoLnN0eWxlKG4sIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRoaXMuX2luaXRpYWxDb250ZW50U3R5bGVbb10udHJhbnNpdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjLm9uKG4sIFwidHJhbnNpdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgaC5zdHlsZShuLCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlW29dLnRyYW5zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3NldE1vZGUodCkge1xuICAgIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSAhPT0gdCAmJiAodGhpcy5fb3B0aW9ucy5zaWRlbmF2TW9kZSA9IHQsIHRoaXMuX3VwZGF0ZSh0aGlzLmlzVmlzaWJsZSkpO1xuICB9XG4gIF9zZXRTbGltKHQpIHtcbiAgICBjb25zdCBlID0gdCA/IFtcImNvbGxhcHNlXCIsIFwiY29sbGFwc2VkXCJdIDogW1wiZXhwYW5kXCIsIFwiZXhwYW5kZWRcIl07XG4gICAgdGhpcy5fdHJpZ2dlckV2ZW50cyguLi5lKSwgdCAmJiB0aGlzLl9jb2xsYXBzZUl0ZW1zKCksIHRoaXMuX3NsaW1Db2xsYXBzZWQgPSB0LCB0aGlzLl90b2dnbGVTbGltRGlzcGxheSh0KSwgaC5zdHlsZSh0aGlzLl9lbGVtZW50LCB7IHdpZHRoOiBgJHt0aGlzLndpZHRofXB4YCB9KSwgdGhpcy5fdXBkYXRlT2Zmc2V0cyh0aGlzLmlzVmlzaWJsZSk7XG4gIH1cbiAgX3NldFRhYmluZGV4KHQpIHtcbiAgICB0aGlzLmxpbmtzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUudGFiSW5kZXggPSB0ID8gMCA6IC0xO1xuICAgIH0pO1xuICB9XG4gIF9lbWl0RXZlbnRzKHQpIHtcbiAgICBjb25zdCBlID0gdCA/IFtcInNob3dcIiwgXCJzaG93blwiXSA6IFtcImhpZGVcIiwgXCJoaWRkZW5cIl07XG4gICAgdGhpcy5fdHJpZ2dlckV2ZW50cyguLi5lKTtcbiAgfVxuICBfcm90YXRlQXJyb3codCwgZSkge1xuICAgIGNvbnN0IFtpXSA9IGQuY2hpbGRyZW4odCwgYFske0xnfV1gKTtcbiAgICBpICYmIChlID8gaC5yZW1vdmVDbGFzcyhpLCBcInJvdGF0ZS0xODBcIikgOiBoLmFkZENsYXNzKGksIFwicm90YXRlLTE4MFwiKSk7XG4gIH1cbiAgX3RvZ2dsZUNhdGVnb3J5KHQsIGUpIHtcbiAgICB0LnByZXZlbnREZWZhdWx0KCksIGUudG9nZ2xlKCksIHRoaXMuX3NsaW1Db2xsYXBzZWQgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZFeHBhbmRhYmxlICYmICh0aGlzLl90ZW1wU2xpbSA9ICEwLCB0aGlzLl9zZXRTbGltKCExKSk7XG4gIH1cbiAgX3RvZ2dsZVNsaW1EaXNwbGF5KHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kKFxuICAgICAgTWcsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaSA9IGQuZmluZChcbiAgICAgIFJnLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIG4gPSAoKSA9PiB7XG4gICAgICBlLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgaC5zdHlsZShvLCB7XG4gICAgICAgICAgZGlzcGxheTogdGhpcy5fc2xpbUNvbGxhcHNlZCA/IFwidW5zZXRcIiA6IFwibm9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgfSksIGkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBoLnN0eWxlKG8sIHtcbiAgICAgICAgICBkaXNwbGF5OiB0aGlzLl9zbGltQ29sbGFwc2VkID8gXCJub25lXCIgOiBcInVuc2V0XCJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHQgPyBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4gbigpLFxuICAgICAgdGhpcy5vcHRpb25zLnNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb25cbiAgICApIDogbigpO1xuICB9XG4gIGFzeW5jIF90cmlnZ2VyRXZlbnRzKHQsIGUpIHtcbiAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYCR7dH0udGUuc2lkZW5hdmApLCBlICYmIGF3YWl0IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke2V9LnRlLnNpZGVuYXZgKTtcbiAgICB9LCB0aGlzLm9wdGlvbnMuc2lkZW5hdlRyYW5zaXRpb25EdXJhdGlvbiArIDUpO1xuICB9XG4gIF9pc2lQaG9uZSgpIHtcbiAgICByZXR1cm4gL2lQaG9uZXxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuICBfdXBkYXRlKHQpIHtcbiAgICB0ICYmIHRoaXMuX2lzaVBob25lKCkgJiYgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcInBzLS1zY3JvbGxpbmcteVwiKSwgdGhpcy50b2dnbGVyICYmIHRoaXMuX3VwZGF0ZVRvZ2dsZXJBcmlhKHQpLCB0aGlzLl91cGRhdGVEaXNwbGF5KHQpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wICYmIHRoaXMuX3VwZGF0ZUJhY2tkcm9wKHQpLCB0aGlzLl91cGRhdGVPZmZzZXRzKHQpLCB0ICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2Q2xvc2VPbkVzYyAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgIT09IFwic2lkZVwiICYmIGMub24od2luZG93LCBcImtleWRvd25cIiwgdGhpcy5lc2NIYW5kbGVyKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZGb2N1c1RyYXAgJiYgdGhpcy5fdXBkYXRlRm9jdXModCk7XG4gIH1cbiAgX3VwZGF0ZURpc3BsYXkodCkge1xuICAgIGNvbnN0IGUgPSB0ID8gMCA6IHRoaXMudHJhbnNsYXRpb247XG4gICAgaC5zdHlsZSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7ZX0lKWBcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlRm9jdXModCkge1xuICAgIGlmICh0aGlzLl9zZXRUYWJpbmRleCh0KSwgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdkZvY3VzVHJhcCkge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNUcmFwLnRyYXAoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZm9jdXNUcmFwLmRpc2FibGUoKTtcbiAgICB9XG4gICAgdGhpcy5fZm9jdXNUcmFwLmRpc2FibGUoKTtcbiAgfVxuICBfdXBkYXRlT2Zmc2V0cyh0LCBlID0gITEpIHtcbiAgICBjb25zdCBbaSwgbl0gPSB0aGlzLm9wdGlvbnMuc2lkZW5hdlJpZ2h0ID8gW1wicmlnaHRcIiwgXCJsZWZ0XCJdIDogW1wibGVmdFwiLCBcInJpZ2h0XCJdLCBvID0ge1xuICAgICAgcHJvcGVydHk6IHRoaXMuX2dldFByb3BlcnR5KFwicGFkZGluZ1wiLCBpKSxcbiAgICAgIHZhbHVlOiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiID8gMCA6IHRoaXMud2lkdGhcbiAgICB9LCByID0ge1xuICAgICAgcHJvcGVydHk6IHRoaXMuX2dldFByb3BlcnR5KFwibWFyZ2luXCIsIG4pLFxuICAgICAgdmFsdWU6IHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJwdXNoXCIgPyAtMSAqIHRoaXMud2lkdGggOiAwXG4gICAgfTtcbiAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJ1cGRhdGUudGUuc2lkZW5hdlwiLCB7XG4gICAgICBtYXJnaW46IHIsXG4gICAgICBwYWRkaW5nOiBvXG4gICAgfSksIHRoaXMuX2NvbnRlbnQgJiYgKHRoaXMuX2NvbnRlbnQuY2xhc3NOYW1lID0gXCJcIiwgdGhpcy5fc2V0Q29udGVudE9mZnNldHModCwgeyBwYWRkaW5nOiBvLCBtYXJnaW46IHIgfSwgZSkpO1xuICB9XG4gIF91cGRhdGVUb2dnbGVyQXJpYSh0KSB7XG4gICAgdGhpcy50b2dnbGVyLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgdCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyB0b2dnbGVTaWRlbmF2KCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb25zdCBlID0gZC5jbG9zZXN0KHQudGFyZ2V0LCBmbyksIGkgPSBoLmdldERhdGFBdHRyaWJ1dGVzKGUpLnRhcmdldDtcbiAgICAgIGQuZmluZChpKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIChDaS5nZXRJbnN0YW5jZShuKSB8fCBuZXcgQ2kobikpLnRvZ2dsZSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSBBLmdldERhdGEodGhpcywgd3MpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAoaSB8fCAoaSA9IG5ldyBDaSh0aGlzLCBuKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEEuZ2V0RGF0YSh0LCB3cyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgWm8gPSBcInN0ZXBwZXJcIiwgdG4gPSBcInRlLnN0ZXBwZXJcIiwgYWkgPSBgLiR7dG59YCwgVWkgPSBgZGF0YS10ZS0ke1pvfWAsIEFpID0gXCJob3Jpem9udGFsXCIsIE90ID0gXCJ2ZXJ0aWNhbFwiLCBGZyA9IGBvbkNoYW5nZVN0ZXAke2FpfWAsIFlnID0gYG9uQ2hhbmdlZFN0ZXAke2FpfWAsIGpnID0ge1xuICBzdGVwcGVyVHlwZTogXCJzdHJpbmdcIixcbiAgc3RlcHBlckxpbmVhcjogXCJib29sZWFuXCIsXG4gIHN0ZXBwZXJOb0VkaXRhYmxlOiBcImJvb2xlYW5cIixcbiAgc3RlcHBlckFjdGl2ZTogXCJzdHJpbmdcIixcbiAgc3RlcHBlckNvbXBsZXRlZDogXCJzdHJpbmdcIixcbiAgc3RlcHBlckludmFsaWQ6IFwic3RyaW5nXCIsXG4gIHN0ZXBwZXJEaXNhYmxlZDogXCJzdHJpbmdcIixcbiAgc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludDogXCJudW1iZXJcIixcbiAgc3RlcHBlck1vYmlsZUJyZWFrcG9pbnQ6IFwibnVtYmVyXCIsXG4gIHN0ZXBwZXJNb2JpbGVCYXJCcmVha3BvaW50OiBcIm51bWJlclwiLFxuICBzdGVwcGVyQW5pbWF0aW9uRHVyYXRpb246IFwibnVtYmVyXCIsXG4gIHNsaWRlSW5MZWZ0QW5pbWF0aW9uOiBcInN0cmluZ1wiLFxuICBzbGlkZU91dExlZnRBbmltYXRpb246IFwic3RyaW5nXCIsXG4gIHNsaWRlSW5SaWdodEFuaW1hdGlvbjogXCJzdHJpbmdcIixcbiAgc2xpZGVPdXRSaWdodEFuaW1hdGlvbjogXCJzdHJpbmdcIlxufSwgS2cgPSB7XG4gIHN0ZXBwZXJUeXBlOiBBaSxcbiAgc3RlcHBlckxpbmVhcjogITEsXG4gIHN0ZXBwZXJOb0VkaXRhYmxlOiAhMSxcbiAgc3RlcHBlckFjdGl2ZTogXCJcIixcbiAgc3RlcHBlckNvbXBsZXRlZDogXCJcIixcbiAgc3RlcHBlckludmFsaWQ6IFwiXCIsXG4gIHN0ZXBwZXJEaXNhYmxlZDogXCJcIixcbiAgc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludDogMCxcbiAgc3RlcHBlck1vYmlsZUJyZWFrcG9pbnQ6IDAsXG4gIHN0ZXBwZXJNb2JpbGVCYXJCcmVha3BvaW50OiA0LFxuICBzdGVwcGVyQW5pbWF0aW9uRHVyYXRpb246IDgwMCxcbiAgc2xpZGVJbkxlZnRBbmltYXRpb246IFwiYW5pbWF0ZS1bc2xpZGUtaW4tbGVmdF8wLjhzX2JvdGhdXCIsXG4gIHNsaWRlT3V0TGVmdEFuaW1hdGlvbjogXCJhbmltYXRlLVtzbGlkZS1vdXQtbGVmdF8wLjhzX2JvdGhdXCIsXG4gIHNsaWRlSW5SaWdodEFuaW1hdGlvbjogXCJhbmltYXRlLVtzbGlkZS1pbi1yaWdodF8wLjhzX2JvdGhdXCIsXG4gIHNsaWRlT3V0UmlnaHRBbmltYXRpb246IFwiYW5pbWF0ZS1bc2xpZGUtb3V0LXJpZ2h0XzAuOHNfYm90aF1cIlxufSwgZGwgPSBgbW91c2Vkb3duJHthaX1gLCB1bCA9IGBrZXlkb3duJHthaX1gLCB6ZyA9IGBrZXl1cCR7YWl9YCwgcGwgPSBgcmVzaXplJHthaX1gLCBLdCA9IGBbJHtVaX0tc3RlcC1yZWZdYCwgWiA9IGBbJHtVaX0taGVhZC1yZWZdYCwgX2wgPSBgWyR7VWl9LWhlYWQtdGV4dC1yZWZdYCwga3MgPSBgWyR7VWl9LWhlYWQtaWNvbi1yZWZdYCwgUSA9IGBbJHtVaX0tY29udGVudC1yZWZdYDtcbmNsYXNzIFVBIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9lbGVtZW50SGVpZ2h0ID0gMCwgdGhpcy5fc3RlcHMgPSBkLmZpbmQoYCR7S3R9YCwgdGhpcy5fZWxlbWVudCksIHRoaXMuX2N1cnJlbnRWaWV3ID0gXCJcIiwgdGhpcy5fYWN0aXZlU3RlcEluZGV4ID0gMCwgdGhpcy5fdmVydGljYWxTdGVwcGVyU3R5bGVzID0gW10sIHRoaXMuX3RpbWVvdXQgPSAwLCB0aGlzLl9lbGVtZW50ICYmIChBLnNldERhdGEodCwgdG4sIHRoaXMpLCB0aGlzLl9pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBabztcbiAgfVxuICBnZXQgYWN0aXZlU3RlcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlcHNbdGhpcy5fYWN0aXZlU3RlcEluZGV4XTtcbiAgfVxuICBnZXQgYWN0aXZlU3RlcEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVTdGVwSW5kZXg7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5vZmYodCwgZGwpLCBjLm9mZih0LCB1bCk7XG4gICAgfSksIGMub2ZmKHdpbmRvdywgcGwpLCBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgdG4pLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBjaGFuZ2VTdGVwKHQpIHtcbiAgICB0aGlzLl90b2dnbGVTdGVwKHQpO1xuICB9XG4gIG5leHRTdGVwKCkge1xuICAgIHRoaXMuX3RvZ2dsZVN0ZXAodGhpcy5fYWN0aXZlU3RlcEluZGV4ICsgMSk7XG4gIH1cbiAgcHJldmlvdXNTdGVwKCkge1xuICAgIHRoaXMuX3RvZ2dsZVN0ZXAodGhpcy5fYWN0aXZlU3RlcEluZGV4IC0gMSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKGAke0t0fWAsIHRoaXMuX2VsZW1lbnQpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uc2V0QXR0cmlidXRlKFwiZGF0YS10ZVwiLCBcImFjdGl2ZS1zdGVwXCIpLCBlID0gZC5maW5kKFxuICAgICAgYCR7X2x9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBpID0gZC5maW5kKFxuICAgICAgYCR7a3N9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHN3aXRjaCAodCA/ICh0aGlzLl9hY3RpdmVTdGVwSW5kZXggPSB0aGlzLl9zdGVwcy5pbmRleE9mKHQpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcImFkZFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQWN0aXZlXG4gICAgKSwgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCJmb250LW1lZGl1bVwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCIhYmctcHJpbWFyeS0xMDBcIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIXRleHQtcHJpbWFyeS03MDBcIikpIDogKGVbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiZm9udC1tZWRpdW1cIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiF0ZXh0LXByaW1hcnktNzAwXCIpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcImFkZFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQWN0aXZlXG4gICAgKSksIHRoaXMuX2JpbmRNb3VzZURvd24oKSwgdGhpcy5fYmluZEtleXNOYXZpZ2F0aW9uKCksIHRoaXMuX29wdGlvbnMuc3RlcHBlclR5cGUpIHtcbiAgICAgIGNhc2UgT3Q6XG4gICAgICAgIHRoaXMuX3RvZ2dsZVZlcnRpY2FsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5fdG9nZ2xlSG9yaXpvbnRhbCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgKHRoaXMuX29wdGlvbnMuc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludCB8fCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJNb2JpbGVCcmVha3BvaW50KSAmJiB0aGlzLl90b2dnbGVTdGVwcGVyVmlldygpLCB0aGlzLl9iaW5kUmVzaXplKCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5LZyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgSShabywgdCwgamcpLCB0O1xuICB9XG4gIF9iaW5kTW91c2VEb3duKCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7Wn1gLCB0KTtcbiAgICAgIGMub24oZSwgZGwsIChpKSA9PiB7XG4gICAgICAgIGNvbnN0IG4gPSBkLnBhcmVudHMoaS50YXJnZXQsIGAke0t0fWApWzBdLCBvID0gdGhpcy5fc3RlcHMuaW5kZXhPZihuKTtcbiAgICAgICAgaS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl90b2dnbGVTdGVwKG8pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRSZXNpemUoKSB7XG4gICAgYy5vbih3aW5kb3csIHBsLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jdXJyZW50VmlldyA9PT0gT3QgJiYgdGhpcy5fc2V0U2luZ2xlU3RlcEhlaWdodCh0aGlzLmFjdGl2ZVN0ZXApLCB0aGlzLl9jdXJyZW50VmlldyA9PT0gQWkgJiYgdGhpcy5fc2V0SGVpZ2h0KHRoaXMuYWN0aXZlU3RlcCksICh0aGlzLl9vcHRpb25zLnN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQgfHwgdGhpcy5fb3B0aW9ucy5zdGVwcGVyTW9iaWxlQnJlYWtwb2ludCkgJiYgdGhpcy5fdG9nZ2xlU3RlcHBlclZpZXcoKTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlU3RlcHBlclZpZXcoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX29wdGlvbnMuc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludCA8IHdpbmRvdy5pbm5lcldpZHRoLCBlID0gdGhpcy5fb3B0aW9ucy5zdGVwcGVyVmVydGljYWxCcmVha3BvaW50ID4gd2luZG93LmlubmVyV2lkdGgsIGkgPSB0aGlzLl9vcHRpb25zLnN0ZXBwZXJNb2JpbGVCcmVha3BvaW50ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdCAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0gQWkgJiYgdGhpcy5fdG9nZ2xlSG9yaXpvbnRhbCgpLCBlICYmICFpICYmIHRoaXMuX2N1cnJlbnRWaWV3ICE9PSBPdCAmJiAodGhpcy5fc3RlcHMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgY29uc3QgbyA9IGQuZmluZE9uZShgJHtRfWAsIG4pO1xuICAgICAgdGhpcy5fcmVzZXRTdGVwcGVySGVpZ2h0KCksIHRoaXMuX3Nob3dFbGVtZW50KG8pO1xuICAgIH0pLCB0aGlzLl90b2dnbGVWZXJ0aWNhbCgpKTtcbiAgfVxuICBfdG9nZ2xlU3RlcCh0KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCA9PT0gdClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJOb0VkaXRhYmxlICYmIHRoaXMuX3RvZ2dsZURpc2FibGVkKCk7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCwgaSA9IGMudHJpZ2dlcihcbiAgICAgIHRoaXMuYWN0aXZlU3RlcCxcbiAgICAgIEZnLFxuICAgICAge1xuICAgICAgICBjdXJyZW50U3RlcDogdGhpcy5fYWN0aXZlU3RlcEluZGV4LFxuICAgICAgICBuZXh0U3RlcDogdFxuICAgICAgfVxuICAgICk7XG4gICAgdCA+IHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCAmJiBpLmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX3Nob3dFbGVtZW50KFxuICAgICAgZC5maW5kT25lKGAke1F9YCwgdGhpcy5fc3RlcHNbdF0pXG4gICAgKSwgdGhpcy5fdG9nZ2xlQWN0aXZlKHQpLCB0ID4gdGhpcy5fYWN0aXZlU3RlcEluZGV4ICYmIHRoaXMuX3RvZ2dsZUNvbXBsZXRlZCh0aGlzLl9hY3RpdmVTdGVwSW5kZXgpLCB0aGlzLl9jdXJyZW50VmlldyA9PT0gQWkgPyB0aGlzLl9hbmltYXRlSG9yaXpvbnRhbFN0ZXAodCkgOiAodGhpcy5fYW5pbWF0ZVZlcnRpY2FsU3RlcCh0KSwgdGhpcy5fc2V0U2luZ2xlU3RlcEhlaWdodCh0aGlzLl9zdGVwc1t0XSkpLCB0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoXG4gICAgICBkLmZpbmRPbmUoYCR7Wn1gLCB0aGlzLmFjdGl2ZVN0ZXApLFxuICAgICAgZC5maW5kT25lKGAke1p9YCwgdGhpcy5fc3RlcHNbdF0pXG4gICAgKSwgdGhpcy5fYWN0aXZlU3RlcEluZGV4ID0gdCwgdGhpcy5fc3RlcHNbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlXCIsIFwiYWN0aXZlLXN0ZXBcIiksIHRoaXMuX3N0ZXBzLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIG5bdGhpcy5fYWN0aXZlU3RlcEluZGV4XSAhPT0gbyAmJiBuLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGVcIik7XG4gICAgfSksIGMudHJpZ2dlcih0aGlzLmFjdGl2ZVN0ZXAsIFlnLCB7XG4gICAgICBjdXJyZW50U3RlcDogdGhpcy5fYWN0aXZlU3RlcEluZGV4LFxuICAgICAgcHJldlN0ZXA6IGVcbiAgICB9KSk7XG4gIH1cbiAgX3Jlc2V0U3RlcHBlckhlaWdodCgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiXCI7XG4gIH1cbiAgX3NldFN0ZXBzSGVpZ2h0KCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7UX1gLCB0KSwgaSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpO1xuICAgICAgdGhpcy5fdmVydGljYWxTdGVwcGVyU3R5bGVzLnB1c2goe1xuICAgICAgICBwYWRkaW5nVG9wOiBwYXJzZUZsb2F0KGkucGFkZGluZ1RvcCksXG4gICAgICAgIHBhZGRpbmdCb3R0b206IHBhcnNlRmxvYXQoaS5wYWRkaW5nQm90dG9tKVxuICAgICAgfSk7XG4gICAgICBjb25zdCBuID0gZS5zY3JvbGxIZWlnaHQ7XG4gICAgICBlLnN0eWxlLmhlaWdodCA9IGAke259cHhgO1xuICAgIH0pO1xuICB9XG4gIF9zZXRTaW5nbGVTdGVwSGVpZ2h0KHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKGAke1F9YCwgdCksIGkgPSB0aGlzLmFjdGl2ZVN0ZXAgPT09IHQsIG4gPSB0aGlzLl9zdGVwcy5pbmRleE9mKHQpO1xuICAgIGxldCBvO1xuICAgIGkgPyAoZS5zdHlsZS5oZWlnaHQgPSBcIlwiLCBvID0gZS5zY3JvbGxIZWlnaHQpIDogbyA9IGUuc2Nyb2xsSGVpZ2h0ICsgdGhpcy5fdmVydGljYWxTdGVwcGVyU3R5bGVzW25dLnBhZGRpbmdUb3AgKyB0aGlzLl92ZXJ0aWNhbFN0ZXBwZXJTdHlsZXNbbl0ucGFkZGluZ0JvdHRvbSwgZS5zdHlsZS5oZWlnaHQgPSBgJHtvfXB4YDtcbiAgfVxuICBfdG9nZ2xlVmVydGljYWwoKSB7XG4gICAgdGhpcy5fY3VycmVudFZpZXcgPSBPdCwgdGhpcy5fc2V0U3RlcHNIZWlnaHQoKSwgdGhpcy5faGlkZUluYWN0aXZlU3RlcHMoKTtcbiAgfVxuICBfdG9nZ2xlSG9yaXpvbnRhbCgpIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9IEFpLCB0aGlzLl9zZXRIZWlnaHQodGhpcy5hY3RpdmVTdGVwKSwgdGhpcy5faGlkZUluYWN0aXZlU3RlcHMoKTtcbiAgfVxuICBfdG9nZ2xlU3RlcHBlckNsYXNzKCkge1xuICAgIGQuZmluZE9uZShcbiAgICAgIFwiW2RhdGEtdGUtc3RlcHBlci10eXBlXVwiLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkgIT09IG51bGwgJiYgdGhpcy5fc3RlcHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZC5maW5kT25lKGAke1F9YCwgZSkuY2xhc3NMaXN0LnJlbW92ZShcIiFteS0wXCIpLCBkLmZpbmRPbmUoYCR7UX1gLCBlKS5jbGFzc0xpc3QucmVtb3ZlKFwiIXB5LTBcIiksIGQuZmluZE9uZShgJHtRfWAsIGUpLmNsYXNzTGlzdC5yZW1vdmUoXCIhaC0wXCIpO1xuICAgIH0pO1xuICB9XG4gIF90b2dnbGVTdGVwQ2xhc3ModCwgZSwgaSkge1xuICAgIGkgJiYgdGhpcy5fc3RlcHNbdF0uY2xhc3NMaXN0W2VdKGkpO1xuICB9XG4gIF9iaW5kS2V5c05hdmlnYXRpb24oKSB7XG4gICAgdGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KFxuICAgICAgITEsXG4gICAgICBkLmZpbmRPbmUoYCR7Wn1gLCB0aGlzLmFjdGl2ZVN0ZXApXG4gICAgKSwgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGQuZmluZE9uZShgJHtafWAsIHQpO1xuICAgICAgYy5vbihlLCB1bCwgKGkpID0+IHtcbiAgICAgICAgY29uc3QgbiA9IGQucGFyZW50cyhcbiAgICAgICAgICBpLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgYCR7S3R9YFxuICAgICAgICApWzBdLCBvID0gZC5uZXh0KG4sIGAke0t0fWApWzBdLCByID0gZC5wcmV2KG4sIGAke0t0fWApWzBdLCBhID0gZC5maW5kT25lKFxuICAgICAgICAgIGAke1p9YCxcbiAgICAgICAgICBuXG4gICAgICAgICksIGwgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYCR7Wn1gLFxuICAgICAgICAgIHRoaXMuYWN0aXZlU3RlcFxuICAgICAgICApO1xuICAgICAgICBsZXQgcCA9IG51bGwsIHUgPSBudWxsO1xuICAgICAgICBpZiAobyAmJiAocCA9IGQuZmluZE9uZShgJHtafWAsIG8pKSwgciAmJiAodSA9IGQuZmluZE9uZShgJHtafWAsIHIpKSwgaS5rZXlDb2RlID09PSBLZSAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0gT3QgJiYgKHUgPyAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHUpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHUpLCB1LmZvY3VzKCkpIDogcCAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHApLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHApLCBwLmZvY3VzKCkpKSwgaS5rZXlDb2RlID09PSB6ZSAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0gT3QgJiYgKHAgPyAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHApLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHApLCBwLmZvY3VzKCkpIDogdSAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHUpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHUpLCB1LmZvY3VzKCkpKSwgaS5rZXlDb2RlID09PSB6ICYmIHRoaXMuX2N1cnJlbnRWaWV3ID09PSBPdCAmJiAoaS5wcmV2ZW50RGVmYXVsdCgpLCBwICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgcCksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgcCksIHAuZm9jdXMoKSkpLCBpLmtleUNvZGUgPT09IFUgJiYgdGhpcy5fY3VycmVudFZpZXcgPT09IE90ICYmIChpLnByZXZlbnREZWZhdWx0KCksIHUgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCB1KSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCB1KSwgdS5mb2N1cygpKSksIGkua2V5Q29kZSA9PT0gVGUpIHtcbiAgICAgICAgICBjb25zdCBfID0gZC5maW5kT25lKFxuICAgICAgICAgICAgYCR7Wn1gLFxuICAgICAgICAgICAgdGhpcy5fc3RlcHNbMF1cbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBfKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCBfKSwgXy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpLmtleUNvZGUgPT09IEVlKSB7XG4gICAgICAgICAgY29uc3QgXyA9IHRoaXMuX3N0ZXBzW3RoaXMuX3N0ZXBzLmxlbmd0aCAtIDFdLCBmID0gZC5maW5kT25lKGAke1p9YCwgXyk7XG4gICAgICAgICAgdGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGYpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIGYpLCBmLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgKGkua2V5Q29kZSA9PT0gaXQgfHwgaS5rZXlDb2RlID09PSBacykgJiYgKGkucHJldmVudERlZmF1bHQoKSwgdGhpcy5jaGFuZ2VTdGVwKHRoaXMuX3N0ZXBzLmluZGV4T2YobikpKSwgaS5rZXlDb2RlID09PSBrZSAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIGwpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsICExKSwgbC5mb2N1cygpKTtcbiAgICAgIH0pLCBjLm9uKGUsIHpnLCAoaSkgPT4ge1xuICAgICAgICBjb25zdCBuID0gZC5wYXJlbnRzKFxuICAgICAgICAgIGkuY3VycmVudFRhcmdldCxcbiAgICAgICAgICBgJHtLdH1gXG4gICAgICAgIClbMF0sIG8gPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYCR7Wn1gLFxuICAgICAgICAgIG5cbiAgICAgICAgKSwgciA9IGQuZmluZE9uZShcbiAgICAgICAgICBgJHtafWAsXG4gICAgICAgICAgdGhpcy5hY3RpdmVTdGVwXG4gICAgICAgICk7XG4gICAgICAgIGkua2V5Q29kZSA9PT0ga2UgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChvLCByKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyghMSwgciksIHIuZm9jdXMoKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlU3RlcFRhYkluZGV4KHQsIGUpIHtcbiAgICB0ICYmIHQuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgLTEpLCBlICYmIGUuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgMCk7XG4gIH1cbiAgX3RvZ2dsZU91dGxpbmVTdHlsZXModCwgZSkge1xuICAgIHQgJiYgKHQuc3R5bGUub3V0bGluZSA9IFwiXCIpLCBlICYmIChlLnN0eWxlLm91dGxpbmUgPSBcInJldmVydFwiKTtcbiAgfVxuICBfdG9nZ2xlRGlzYWJsZWQoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZChgJHtafWAsIHRoaXMuX2VsZW1lbnQpLCBlID0gZC5maW5kKFxuICAgICAgYCR7a3N9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHRbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiY29sb3ItWyM4NTg1ODVdXCIpLCB0W3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcImN1cnNvci1kZWZhdWx0XCIpLCBlW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiFiZy1bIzg1ODU4NV1cIiksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyhcbiAgICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCxcbiAgICAgIFwiYWRkXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJEaXNhYmxlZFxuICAgICk7XG4gIH1cbiAgX3RvZ2dsZUFjdGl2ZSh0KSB7XG4gICAgY29uc3QgZSA9IGQuZmluZChcbiAgICAgIGAke19sfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaSA9IGQuZmluZChcbiAgICAgIGAke2tzfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBlW3RdLmNsYXNzTGlzdC5hZGQoXCJmb250LW1lZGl1bVwiKSwgaVt0XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RdLmNsYXNzTGlzdC5hZGQoXCIhdGV4dC1wcmltYXJ5LTcwMFwiKSwgaVt0XS5jbGFzc0xpc3QucmVtb3ZlKFwiIWJnLXN1Y2Nlc3MtMTAwXCIpLCBpW3RdLmNsYXNzTGlzdC5yZW1vdmUoXCIhdGV4dC1zdWNjZXNzLTcwMFwiKSwgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoXCJmb250LW1lZGl1bVwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoXCIhYmctcHJpbWFyeS0xMDBcIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgXCIhdGV4dC1wcmltYXJ5LTcwMFwiXG4gICAgKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKHQsIFwiYWRkXCIsIHRoaXMuX29wdGlvbnMuc3RlcHBlckFjdGl2ZSksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyhcbiAgICAgIHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCxcbiAgICAgIFwicmVtb3ZlXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnN0ZXBwZXJBY3RpdmVcbiAgICApO1xuICB9XG4gIF90b2dnbGVDb21wbGV0ZWQodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmQoXG4gICAgICBgJHtrc31gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyTm9FZGl0YWJsZSA/IHRoaXMuX3N0ZXBzW3RdLmNsYXNzTGlzdC5hZGQoXCJwb2ludGVyLWV2ZW50cy1ub25lXCIpIDogKGVbdF0uY2xhc3NMaXN0LmFkZChcIiFiZy1zdWNjZXNzLTEwMFwiKSwgZVt0XS5jbGFzc0xpc3QuYWRkKFwiIXRleHQtc3VjY2Vzcy03MDBcIikpLCBlW3RdLmNsYXNzTGlzdC5yZW1vdmUoXCIhYmctZGFuZ2VyLTEwMFwiKSwgZVt0XS5jbGFzc0xpc3QucmVtb3ZlKFwiIXRleHQtZGFuZ2VyLTcwMFwiKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKHQsIFwiYWRkXCIsIHRoaXMuX29wdGlvbnMuc3RlcHBlckNvbXBsZXRlZCksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyh0LCBcInJlbW92ZVwiLCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJJbnZhbGlkKTtcbiAgfVxuICBfaGlkZUluYWN0aXZlU3RlcHMoKSB7XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgaWYgKCF0LmdldEF0dHJpYnV0ZShcImRhdGEtdGVcIikpIHtcbiAgICAgICAgY29uc3QgZSA9IGQuZmluZE9uZShgJHtRfWAsIHQpO1xuICAgICAgICBlLmNsYXNzTGlzdC5yZW1vdmUoXCJ0cmFuc2xhdGUteC1bMTUwJV1cIiksIHRoaXMuX2hpZGVFbGVtZW50KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9zZXRIZWlnaHQodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7UX1gLCB0KSwgaSA9IGdldENvbXB1dGVkU3R5bGUoZSksIG4gPSBkLmZpbmRPbmUoYCR7Wn1gLCB0KSwgbyA9IGdldENvbXB1dGVkU3R5bGUobiksIHIgPSBlLm9mZnNldEhlaWdodCArIHBhcnNlRmxvYXQoaS5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdChpLm1hcmdpbkJvdHRvbSksIGEgPSBuLm9mZnNldEhlaWdodCArIHBhcnNlRmxvYXQoby5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdChvLm1hcmdpbkJvdHRvbSk7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHthICsgcn1weGA7XG4gIH1cbiAgX2hpZGVFbGVtZW50KHQpIHtcbiAgICAhZC5wYXJlbnRzKFxuICAgICAgdCxcbiAgICAgIGAke0t0fWBcbiAgICApWzBdLmdldEF0dHJpYnV0ZShcImRhdGEtdGVcIikgJiYgdGhpcy5fY3VycmVudFZpZXcgIT09IE90ID8gdC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIgOiAodC5jbGFzc0xpc3QuYWRkKFwiIW15LTBcIiksIHQuY2xhc3NMaXN0LmFkZChcIiFweS0wXCIpLCB0LmNsYXNzTGlzdC5hZGQoXCIhaC0wXCIpKTtcbiAgfVxuICBfc2hvd0VsZW1lbnQodCkge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID09PSBPdCA/ICh0LmNsYXNzTGlzdC5yZW1vdmUoXCIhbXktMFwiKSwgdC5jbGFzc0xpc3QucmVtb3ZlKFwiIXB5LTBcIiksIHQuY2xhc3NMaXN0LnJlbW92ZShcIiFoLTBcIikpIDogdC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICB9XG4gIF9hbmltYXRlSG9yaXpvbnRhbFN0ZXAodCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSwgdGhpcy5fY2xlYXJTdGVwc0FuaW1hdGlvbigpO1xuICAgIGNvbnN0IGUgPSB0ID4gdGhpcy5fYWN0aXZlU3RlcEluZGV4LCBpID0gZC5maW5kT25lKFxuICAgICAgYCR7UX1gLFxuICAgICAgdGhpcy5fc3RlcHNbdF1cbiAgICApLCBuID0gZC5maW5kT25lKFxuICAgICAgYCR7UX1gLFxuICAgICAgdGhpcy5hY3RpdmVTdGVwXG4gICAgKTtcbiAgICBsZXQgbywgcjtcbiAgICB0aGlzLl9zdGVwcy5mb3JFYWNoKChhLCBsKSA9PiB7XG4gICAgICBjb25zdCBwID0gZC5maW5kT25lKGAke1F9YCwgYSk7XG4gICAgICBsICE9PSB0ICYmIGwgIT09IHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCAmJiB0aGlzLl9oaWRlRWxlbWVudChwKTtcbiAgICB9KSwgZSA/IChyID0gdGhpcy5fb3B0aW9ucy5zbGlkZU91dExlZnRBbmltYXRpb24sIG8gPSB0aGlzLl9vcHRpb25zLnNsaWRlSW5SaWdodEFuaW1hdGlvbikgOiAociA9IHRoaXMuX29wdGlvbnMuc2xpZGVPdXRSaWdodEFuaW1hdGlvbiwgbyA9IHRoaXMuX29wdGlvbnMuc2xpZGVJbkxlZnRBbmltYXRpb24pLCBuLmNsYXNzTGlzdC5hZGQociksIGkuY2xhc3NMaXN0LmFkZChvKSwgdGhpcy5fc2V0SGVpZ2h0KHRoaXMuX3N0ZXBzW3RdKSwgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5faGlkZUVsZW1lbnQobiksIHRoaXMuX2NsZWFyU3RlcHNBbmltYXRpb24oKTtcbiAgICB9LCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJBbmltYXRpb25EdXJhdGlvbik7XG4gIH1cbiAgX2NsZWFyU3RlcHNBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgZC5maW5kT25lKGAke1F9YCwgdCkuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5zbGlkZUluTGVmdEFuaW1hdGlvbixcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5zbGlkZU91dExlZnRBbmltYXRpb24sXG4gICAgICAgIHRoaXMuX29wdGlvbnMuc2xpZGVJblJpZ2h0QW5pbWF0aW9uLFxuICAgICAgICB0aGlzLl9vcHRpb25zLnNsaWRlT3V0UmlnaHRBbmltYXRpb25cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgX2FuaW1hdGVWZXJ0aWNhbFN0ZXAodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoXG4gICAgICBgJHtRfWAsXG4gICAgICB0aGlzLl9zdGVwc1t0XVxuICAgICksIGkgPSBkLmZpbmRPbmUoXG4gICAgICBgJHtRfWAsXG4gICAgICB0aGlzLmFjdGl2ZVN0ZXBcbiAgICApO1xuICAgIHRoaXMuX2hpZGVFbGVtZW50KGkpLCB0aGlzLl9zaG93RWxlbWVudChlKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgdG4pO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IGZsID0gXCJkYXRhLXRlLWlucHV0LXN0YXRlLWFjdGl2ZVwiLCB4cyA9IFwiZGF0YS10ZS1pbnB1dC1zZWxlY3RlZFwiLCBtbCA9IFwiZGF0YS10ZS1pbnB1dC1tdWx0aXBsZS1hY3RpdmVcIiwgZ2wgPSBcIltkYXRhLXRlLWZvcm0tY2hlY2staW5wdXRdXCI7XG5jbGFzcyBibCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGksIG4sIG8sIHIsIGEsIGwsIHAsIHUsIF8pIHtcbiAgICB0aGlzLmlkID0gdCwgdGhpcy5uYXRpdmVPcHRpb24gPSBlLCB0aGlzLm11bHRpcGxlID0gaSwgdGhpcy52YWx1ZSA9IG4sIHRoaXMubGFiZWwgPSBvLCB0aGlzLnNlbGVjdGVkID0gciwgdGhpcy5kaXNhYmxlZCA9IGEsIHRoaXMuaGlkZGVuID0gbCwgdGhpcy5zZWNvbmRhcnlUZXh0ID0gcCwgdGhpcy5ncm91cElkID0gdSwgdGhpcy5pY29uID0gXywgdGhpcy5ub2RlID0gbnVsbCwgdGhpcy5hY3RpdmUgPSAhMTtcbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgdGhpcy5tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdE11bHRpcGxlKCkgOiB0aGlzLl9zZWxlY3RTaW5nbGUoKTtcbiAgfVxuICBfc2VsZWN0U2luZ2xlKCkge1xuICAgIHRoaXMuc2VsZWN0ZWQgfHwgKHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoeHMsIFwiXCIpLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMCksIHRoaXMuc2VsZWN0ZWQgPSAhMCwgdGhpcy5uYXRpdmVPcHRpb24gJiYgKHRoaXMubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITApKTtcbiAgfVxuICBfc2VsZWN0TXVsdGlwbGUoKSB7XG4gICAgaWYgKCF0aGlzLnNlbGVjdGVkKSB7XG4gICAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgICBnbCxcbiAgICAgICAgdGhpcy5ub2RlXG4gICAgICApO1xuICAgICAgdC5jaGVja2VkID0gITAsIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoeHMsIFwiXCIpLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMCksIHRoaXMuc2VsZWN0ZWQgPSAhMCwgdGhpcy5uYXRpdmVPcHRpb24gJiYgKHRoaXMubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITApO1xuICAgIH1cbiAgfVxuICBkZXNlbGVjdCgpIHtcbiAgICB0aGlzLm11bHRpcGxlID8gdGhpcy5fZGVzZWxlY3RNdWx0aXBsZSgpIDogdGhpcy5fZGVzZWxlY3RTaW5nbGUoKTtcbiAgfVxuICBfZGVzZWxlY3RTaW5nbGUoKSB7XG4gICAgdGhpcy5zZWxlY3RlZCAmJiAodGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZSh4cyksIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICExKSwgdGhpcy5zZWxlY3RlZCA9ICExLCB0aGlzLm5hdGl2ZU9wdGlvbiAmJiAodGhpcy5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMSkpO1xuICB9XG4gIF9kZXNlbGVjdE11bHRpcGxlKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgICBnbCxcbiAgICAgICAgdGhpcy5ub2RlXG4gICAgICApO1xuICAgICAgdC5jaGVja2VkID0gITEsIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoeHMpLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMSksIHRoaXMuc2VsZWN0ZWQgPSAhMSwgdGhpcy5uYXRpdmVPcHRpb24gJiYgKHRoaXMubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITEpO1xuICAgIH1cbiAgfVxuICBzZXROb2RlKHQpIHtcbiAgICB0aGlzLm5vZGUgPSB0O1xuICB9XG4gIHNldEFjdGl2ZVN0eWxlcygpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKG1sLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmUgPSAhMCwgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShmbCwgXCJcIik7XG4gICAgfVxuICB9XG4gIHJlbW92ZUFjdGl2ZVN0eWxlcygpIHtcbiAgICB0aGlzLmFjdGl2ZSAmJiAodGhpcy5hY3RpdmUgPSAhMSwgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShmbCkpLCB0aGlzLm11bHRpcGxlICYmIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUobWwpO1xuICB9XG59XG5jbGFzcyBVZyB7XG4gIGNvbnN0cnVjdG9yKHQgPSAhMSkge1xuICAgIHRoaXMuX211bHRpcGxlID0gdCwgdGhpcy5fc2VsZWN0aW9ucyA9IFtdO1xuICB9XG4gIHNlbGVjdCh0KSB7XG4gICAgdGhpcy5fbXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25zLnB1c2godCkgOiB0aGlzLl9zZWxlY3Rpb25zID0gW3RdO1xuICB9XG4gIGRlc2VsZWN0KHQpIHtcbiAgICBpZiAodGhpcy5fbXVsdGlwbGUpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9zZWxlY3Rpb25zLmZpbmRJbmRleChcbiAgICAgICAgKGkpID0+IHQgPT09IGlcbiAgICAgICk7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25zLnNwbGljZShlLCAxKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuX3NlbGVjdGlvbnMgPSBbXTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9zZWxlY3Rpb25zID0gW107XG4gIH1cbiAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uc1swXTtcbiAgfVxuICBnZXQgc2VsZWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9ucztcbiAgfVxuICBnZXQgbGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbnNbMF0gJiYgdGhpcy5zZWxlY3Rpb24ubGFiZWw7XG4gIH1cbiAgZ2V0IGxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9ucy5tYXAoKHQpID0+IHQubGFiZWwpLmpvaW4oXCIsIFwiKTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uc1swXSAmJiB0aGlzLnNlbGVjdGlvbi52YWx1ZTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zLm1hcCgodCkgPT4gdC52YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIFFvKHMpIHtcbiAgcmV0dXJuIHMuZmlsdGVyKCh0KSA9PiAhdC5kaXNhYmxlZCkuZXZlcnkoKHQpID0+IHQuc2VsZWN0ZWQpO1xufVxuY29uc3QgWGcgPSBcImRhdGEtdGUtc2VsZWN0LWZvcm0tb3V0bGluZS1yZWZcIiwgR2cgPSBcImRhdGEtdGUtc2VsZWN0LXdyYXBwZXItcmVmXCIsIHFnID0gXCJkYXRhLXRlLXNlbGVjdC1pbnB1dC1yZWZcIiwgWmcgPSBcImRhdGEtdGUtc2VsZWN0LWNsZWFyLWJ0bi1yZWZcIiwgUWcgPSBcImRhdGEtdGUtc2VsZWN0LWRyb3Bkb3duLWNvbnRhaW5lci1yZWZcIiwgSmcgPSBcImRhdGEtdGUtc2VsZWN0LWRyb3Bkb3duLXJlZlwiLCB0YiA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy13cmFwcGVyLXJlZlwiLCBlYiA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy1saXN0LXJlZlwiLCBpYiA9IFwiZGF0YS10ZS1zZWxlY3QtaW5wdXQtZmlsdGVyLXJlZlwiLCBFaCA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLXJlZlwiLCBzYiA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWFsbC1yZWZcIiwgbmIgPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi10ZXh0LXJlZlwiLCBvYiA9IFwiZGF0YS10ZS1mb3JtLWNoZWNrLWlucHV0XCIsIHJiID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tZ3JvdXAtcmVmXCIsIGFiID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tZ3JvdXAtbGFiZWwtcmVmXCIsIENoID0gXCJkYXRhLXRlLXNlbGVjdC1zZWxlY3RlZFwiLCBsYiA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbjwvc3ZnPlxuYCwgY2IgPSAocykgPT4ge1xuICBzLmNvZGUgPT09IFwiVGFiXCIgfHwgcy5jb2RlID09PSBcIkVzY1wiIHx8IHMucHJldmVudERlZmF1bHQoKTtcbn07XG5mdW5jdGlvbiBPcyhzLCB0LCBlLCBpLCBuKSB7XG4gIHQuc2VsZWN0U2l6ZSA9PT0gXCJkZWZhdWx0XCIgJiYgaC5hZGRDbGFzcyhzLCBlKSwgdC5zZWxlY3RTaXplID09PSBcInNtXCIgJiYgaC5hZGRDbGFzcyhzLCBpKSwgdC5zZWxlY3RTaXplID09PSBcImxnXCIgJiYgaC5hZGRDbGFzcyhzLCBuKTtcbn1cbmZ1bmN0aW9uIGhiKHMsIHQsIGUsIGksIG4pIHtcbiAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIG8uc2V0QXR0cmlidXRlKFwiaWRcIiwgcyksIG8uc2V0QXR0cmlidXRlKEdnLCBcIlwiKTtcbiAgY29uc3QgciA9ICQoXCJkaXZcIik7XG4gIHIuc2V0QXR0cmlidXRlKFhnLCBcIlwiKSwgaC5hZGRDbGFzcyhyLCBpLmZvcm1PdXRsaW5lKTtcbiAgY29uc3QgYSA9ICQoXCJpbnB1dFwiKSwgbCA9IHQuc2VsZWN0RmlsdGVyID8gXCJjb21ib2JveFwiIDogXCJsaXN0Ym94XCIsIHAgPSB0Lm11bHRpcGxlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIsIHUgPSB0LmRpc2FibGVkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gIGEuc2V0QXR0cmlidXRlKHFnLCBcIlwiKSwgaC5hZGRDbGFzcyhhLCBpLnNlbGVjdElucHV0KSwgT3MoXG4gICAgYSxcbiAgICB0LFxuICAgIGkuc2VsZWN0SW5wdXRTaXplRGVmYXVsdCxcbiAgICBpLnNlbGVjdElucHV0U2l6ZVNtLFxuICAgIGkuc2VsZWN0SW5wdXRTaXplTGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgaC5hZGRDbGFzcyhhLCBpLnNlbGVjdElucHV0V2hpdGUpLCBhLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0XCIpLCBhLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgbCksIGEuc2V0QXR0cmlidXRlKFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIiwgcCksIGEuc2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiLCB1KSwgYS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhhc3BvcHVwXCIsIFwidHJ1ZVwiKSwgYS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICExKSwgdC50YWJJbmRleCAmJiBhLnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIHQudGFiSW5kZXgpLCB0LmRpc2FibGVkICYmIGEuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIiksIHQuc2VsZWN0UGxhY2Vob2xkZXIgIT09IFwiXCIgJiYgYS5zZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiLCB0LnNlbGVjdFBsYWNlaG9sZGVyKSwgdC5zZWxlY3RWYWxpZGF0aW9uID8gKGguYWRkU3R5bGUoYSwge1xuICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJub25lXCIsXG4gICAgXCJjYXJldC1jb2xvclwiOiBcInRyYW5zcGFyZW50XCJcbiAgfSksIGguYWRkU3R5bGUociwgeyBjdXJzb3I6IFwicG9pbnRlclwiIH0pKSA6IGEuc2V0QXR0cmlidXRlKFwicmVhZG9ubHlcIiwgXCJ0cnVlXCIpLCB0LnNlbGVjdFZhbGlkYXRpb24gJiYgKGEuc2V0QXR0cmlidXRlKFwicmVxdWlyZWRcIiwgXCJ0cnVlXCIpLCBhLnNldEF0dHJpYnV0ZShcImFyaWEtcmVxdWlyZWRcIiwgXCJ0cnVlXCIpLCBhLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGNiKSk7XG4gIGNvbnN0IF8gPSAkKFwiZGl2XCIpO1xuICBoLmFkZENsYXNzKF8sIGkuc2VsZWN0VmFsaWRhdGlvblZhbGlkKTtcbiAgY29uc3QgZiA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgIGAke3Quc2VsZWN0VmFsaWRGZWVkYmFja31gXG4gICk7XG4gIF8uYXBwZW5kQ2hpbGQoZik7XG4gIGNvbnN0IGcgPSAkKFwiZGl2XCIpO1xuICBoLmFkZENsYXNzKGcsIGkuc2VsZWN0VmFsaWRhdGlvbkludmFsaWQpO1xuICBjb25zdCBtID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgYCR7dC5zZWxlY3RJbnZhbGlkRmVlZGJhY2t9YFxuICApO1xuICBnLmFwcGVuZENoaWxkKG0pO1xuICBjb25zdCBiID0gJChcInNwYW5cIik7XG4gIGIuc2V0QXR0cmlidXRlKFpnLCBcIlwiKSwgaC5hZGRDbGFzcyhiLCBpLnNlbGVjdENsZWFyQnRuKSwgT3MoXG4gICAgYixcbiAgICB0LFxuICAgIGkuc2VsZWN0Q2xlYXJCdG5EZWZhdWx0LFxuICAgIGkuc2VsZWN0Q2xlYXJCdG5TbSxcbiAgICBpLnNlbGVjdENsZWFyQnRuTGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgaC5hZGRDbGFzcyhiLCBpLnNlbGVjdENsZWFyQnRuV2hpdGUpO1xuICBjb25zdCB2ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCLinJVcIik7XG4gIGIuYXBwZW5kQ2hpbGQodiksIGIuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICBjb25zdCBUID0gJChcInNwYW5cIik7XG4gIHJldHVybiBoLmFkZENsYXNzKFQsIGkuc2VsZWN0QXJyb3cpLCBPcyhcbiAgICBULFxuICAgIHQsXG4gICAgaS5zZWxlY3RBcnJvd0RlZmF1bHQsXG4gICAgaS5zZWxlY3RBcnJvd1NtLFxuICAgIGkuc2VsZWN0QXJyb3dMZ1xuICApLCB0LnNlbGVjdEZvcm1XaGl0ZSAmJiBoLmFkZENsYXNzKFQsIGkuc2VsZWN0QXJyb3dXaGl0ZSksIFQuaW5uZXJIVE1MID0gbiB8fCBsYiwgci5hcHBlbmRDaGlsZChhKSwgZSAmJiAoaC5hZGRDbGFzcyhlLCBpLnNlbGVjdExhYmVsKSwgT3MoXG4gICAgZSxcbiAgICB0LFxuICAgIGkuc2VsZWN0TGFiZWxTaXplRGVmYXVsdCxcbiAgICBpLnNlbGVjdExhYmVsU2l6ZVNtLFxuICAgIGkuc2VsZWN0TGFiZWxTaXplTGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgaC5hZGRDbGFzcyhlLCBpLnNlbGVjdExhYmVsV2hpdGUpLCByLmFwcGVuZENoaWxkKGUpKSwgdC5zZWxlY3RWYWxpZGF0aW9uICYmIChyLmFwcGVuZENoaWxkKF8pLCByLmFwcGVuZENoaWxkKGcpKSwgdC5zZWxlY3RDbGVhckJ1dHRvbiAmJiByLmFwcGVuZENoaWxkKGIpLCByLmFwcGVuZENoaWxkKFQpLCBvLmFwcGVuZENoaWxkKHIpLCBvO1xufVxuZnVuY3Rpb24gdmwocywgdCwgZSwgaSwgbiwgbywgciwgYSkge1xuICBjb25zdCBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbC5zZXRBdHRyaWJ1dGUoUWcsIFwiXCIpLCBoLmFkZENsYXNzKGwsIGEuc2VsZWN0RHJvcGRvd25Db250YWluZXIpLCBsLnNldEF0dHJpYnV0ZShcImlkXCIsIGAke3N9YCksIGwuc3R5bGUud2lkdGggPSBgJHtlfXB4YDtcbiAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHAuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMCksIHAuc2V0QXR0cmlidXRlKEpnLCBcIlwiKSwgaC5hZGRDbGFzcyhwLCBhLmRyb3Bkb3duKTtcbiAgY29uc3QgdSA9ICQoXCJkaXZcIik7XG4gIHUuc2V0QXR0cmlidXRlKHRiLCBcIlwiKSwgaC5hZGRDbGFzcyh1LCBhLm9wdGlvbnNXcmFwcGVyKSwgaC5hZGRDbGFzcyh1LCBhLm9wdGlvbnNXcmFwcGVyU2Nyb2xsYmFyKSwgdS5zdHlsZS5tYXhIZWlnaHQgPSBgJHtpfXB4YDtcbiAgY29uc3QgXyA9IEFoKFxuICAgIG8sXG4gICAgbixcbiAgICB0LFxuICAgIGFcbiAgKTtcbiAgcmV0dXJuIHUuYXBwZW5kQ2hpbGQoXyksIHQuc2VsZWN0RmlsdGVyICYmIHAuYXBwZW5kQ2hpbGQoXG4gICAgZGIodC5zZWxlY3RTZWFyY2hQbGFjZWhvbGRlciwgYSlcbiAgKSwgcC5hcHBlbmRDaGlsZCh1KSwgciAmJiBwLmFwcGVuZENoaWxkKHIpLCBsLmFwcGVuZENoaWxkKHApLCBsO1xufVxuZnVuY3Rpb24gQWgocywgdCwgZSwgaSkge1xuICBjb25zdCBuID0gJChcImRpdlwiKTtcbiAgbi5zZXRBdHRyaWJ1dGUoZWIsIFwiXCIpLCBoLmFkZENsYXNzKG4sIGkub3B0aW9uc0xpc3QpO1xuICBsZXQgbztcbiAgcmV0dXJuIGUubXVsdGlwbGUgPyBvID0gcGIoXG4gICAgcyxcbiAgICB0LFxuICAgIGUsXG4gICAgaVxuICApIDogbyA9IHViKHMsIGUsIGkpLCBvLmZvckVhY2goKHIpID0+IHtcbiAgICBuLmFwcGVuZENoaWxkKHIpO1xuICB9KSwgbjtcbn1cbmZ1bmN0aW9uIGRiKHMsIHQpIHtcbiAgY29uc3QgZSA9ICQoXCJkaXZcIik7XG4gIGguYWRkQ2xhc3MoZSwgdC5pbnB1dEdyb3VwKTtcbiAgY29uc3QgaSA9ICQoXCJpbnB1dFwiKTtcbiAgcmV0dXJuIGkuc2V0QXR0cmlidXRlKGliLCBcIlwiKSwgaC5hZGRDbGFzcyhpLCB0LnNlbGVjdEZpbHRlcklucHV0KSwgaS5wbGFjZWhvbGRlciA9IHMsIGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInNlYXJjaGJveFwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dFwiKSwgZS5hcHBlbmRDaGlsZChpKSwgZTtcbn1cbmZ1bmN0aW9uIHViKHMsIHQsIGUpIHtcbiAgcmV0dXJuIHloKHMsIHQsIGUpO1xufVxuZnVuY3Rpb24gcGIocywgdCwgZSwgaSkge1xuICBsZXQgbiA9IG51bGw7XG4gIGUuc2VsZWN0QWxsICYmIChuID0gX2IoXG4gICAgdCxcbiAgICBzLFxuICAgIGUsXG4gICAgaVxuICApKTtcbiAgY29uc3QgbyA9IHloKHMsIGUsIGkpO1xuICByZXR1cm4gbiA/IFtuLCAuLi5vXSA6IG87XG59XG5mdW5jdGlvbiB5aChzLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSBbXTtcbiAgcmV0dXJuIHMuZm9yRWFjaCgobikgPT4ge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICBuLFxuICAgICAgXCJvcHRpb25zXCJcbiAgICApKSB7XG4gICAgICBjb25zdCByID0gYmIobiwgdCwgZSk7XG4gICAgICBpLnB1c2gocik7XG4gICAgfSBlbHNlXG4gICAgICBpLnB1c2god2gobiwgdCwgZSkpO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIF9iKHMsIHQsIGUsIGkpIHtcbiAgY29uc3QgbiA9IFFvKHQpLCBvID0gJChcImRpdlwiKTtcbiAgby5zZXRBdHRyaWJ1dGUoRWgsIFwiXCIpO1xuICBjb25zdCByID0gaS5zZWxlY3RBbGxPcHRpb24gfHwgaS5zZWxlY3RPcHRpb247XG4gIHJldHVybiBoLmFkZENsYXNzKG8sIHIpLCBvLnNldEF0dHJpYnV0ZShzYiwgXCJcIiksIGguYWRkU3R5bGUobywge1xuICAgIGhlaWdodDogYCR7ZS5zZWxlY3RPcHRpb25IZWlnaHR9cHhgXG4gIH0pLCBvLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIiksIG8uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBuKSwgbiAmJiBvLnNldEF0dHJpYnV0ZShDaCwgXCJcIiksIG8uYXBwZW5kQ2hpbGQoa2gocywgZSwgaSkpLCBzLnNldE5vZGUobyksIG87XG59XG5mdW5jdGlvbiB3aChzLCB0LCBlKSB7XG4gIGlmIChzLm5vZGUpXG4gICAgcmV0dXJuIHMubm9kZTtcbiAgY29uc3QgaSA9ICQoXCJkaXZcIik7XG4gIHJldHVybiBpLnNldEF0dHJpYnV0ZShFaCwgXCJcIiksIGguYWRkQ2xhc3MoaSwgZS5zZWxlY3RPcHRpb24pLCBoLmFkZFN0eWxlKGksIHtcbiAgICBoZWlnaHQ6IGAke3Quc2VsZWN0T3B0aW9uSGVpZ2h0fXB4YFxuICB9KSwgaC5zZXREYXRhQXR0cmlidXRlKGksIFwiaWRcIiwgcy5pZCksIGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIHMuc2VsZWN0ZWQpLCBpLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIiwgcy5kaXNhYmxlZCksIHMuc2VsZWN0ZWQgJiYgaS5zZXRBdHRyaWJ1dGUoQ2gsIFwiXCIpLCBzLmRpc2FibGVkICYmIGkuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXCIsICEwKSwgcy5oaWRkZW4gJiYgaC5hZGRDbGFzcyhpLCBcImhpZGRlblwiKSwgaS5hcHBlbmRDaGlsZChraChzLCB0LCBlKSksIHMuaWNvbiAmJiBpLmFwcGVuZENoaWxkKGdiKHMsIGUpKSwgcy5zZXROb2RlKGkpLCBpO1xufVxuZnVuY3Rpb24ga2gocywgdCwgZSkge1xuICBjb25zdCBpID0gJChcInNwYW5cIik7XG4gIGkuc2V0QXR0cmlidXRlKG5iLCBcIlwiKSwgaC5hZGRDbGFzcyhpLCBlLnNlbGVjdE9wdGlvblRleHQpO1xuICBjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocy5sYWJlbCk7XG4gIHJldHVybiB0Lm11bHRpcGxlICYmIGkuYXBwZW5kQ2hpbGQobWIocywgZSkpLCBpLmFwcGVuZENoaWxkKG4pLCAocy5zZWNvbmRhcnlUZXh0IHx8IHR5cGVvZiBzLnNlY29uZGFyeVRleHQgPT0gXCJudW1iZXJcIikgJiYgaS5hcHBlbmRDaGlsZChcbiAgICBmYihzLnNlY29uZGFyeVRleHQsIGUpXG4gICksIGk7XG59XG5mdW5jdGlvbiBmYihzLCB0KSB7XG4gIGNvbnN0IGUgPSAkKFwic3BhblwiKTtcbiAgaC5hZGRDbGFzcyhlLCB0LnNlbGVjdE9wdGlvblNlY29uZGFyeVRleHQpO1xuICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocyk7XG4gIHJldHVybiBlLmFwcGVuZENoaWxkKGkpLCBlO1xufVxuZnVuY3Rpb24gbWIocywgdCkge1xuICBjb25zdCBlID0gJChcImlucHV0XCIpO1xuICBlLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJjaGVja2JveFwiKSwgaC5hZGRDbGFzcyhlLCB0LmZvcm1DaGVja0lucHV0KSwgZS5zZXRBdHRyaWJ1dGUob2IsIFwiXCIpO1xuICBjb25zdCBpID0gJChcImxhYmVsXCIpO1xuICByZXR1cm4gcy5zZWxlY3RlZCAmJiBlLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgITApLCBzLmRpc2FibGVkICYmIGUuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgITApLCBlLmFwcGVuZENoaWxkKGkpLCBlO1xufVxuZnVuY3Rpb24gZ2IocywgdCkge1xuICBjb25zdCBlID0gJChcInNwYW5cIiksIGkgPSAkKFwiaW1nXCIpO1xuICByZXR1cm4gaC5hZGRDbGFzcyhpLCB0LnNlbGVjdE9wdGlvbkljb24pLCBpLnNyYyA9IHMuaWNvbiwgZS5hcHBlbmRDaGlsZChpKSwgZTtcbn1cbmZ1bmN0aW9uIGJiKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9ICQoXCJkaXZcIik7XG4gIGkuc2V0QXR0cmlidXRlKHJiLCBcIlwiKSwgaC5hZGRDbGFzcyhpLCBlLnNlbGVjdE9wdGlvbkdyb3VwKSwgaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZ3JvdXBcIiksIGkuc2V0QXR0cmlidXRlKFwiaWRcIiwgcy5pZCksIHMuaGlkZGVuICYmIGguYWRkQ2xhc3MoaSwgXCJoaWRkZW5cIik7XG4gIGNvbnN0IG4gPSAkKFwibGFiZWxcIik7XG4gIHJldHVybiBuLnNldEF0dHJpYnV0ZShhYiwgXCJcIiksIGguYWRkQ2xhc3MobiwgZS5zZWxlY3RPcHRpb25Hcm91cExhYmVsKSwgaC5hZGRTdHlsZShuLCB7IGhlaWdodDogYCR7dC5zZWxlY3RPcHRpb25IZWlnaHR9cHhgIH0pLCBuLnNldEF0dHJpYnV0ZShcImZvclwiLCBzLmlkKSwgbi50ZXh0Q29udGVudCA9IHMubGFiZWwsIGkuYXBwZW5kQ2hpbGQobiksIHMub3B0aW9ucy5mb3JFYWNoKChvKSA9PiB7XG4gICAgaS5hcHBlbmRDaGlsZCh3aChvLCB0LCBlKSk7XG4gIH0pLCBpO1xufVxuZnVuY3Rpb24gdmIocywgdCkge1xuICBjb25zdCBlID0gJChcImRpdlwiKTtcbiAgcmV0dXJuIGUudGV4dENvbnRlbnQgPSBzLCBoLmFkZENsYXNzKGUsIHQuc2VsZWN0TGFiZWwpLCBoLmFkZENsYXNzKGUsIHQuc2VsZWN0RmFrZVZhbHVlKSwgZTtcbn1cbmNvbnN0IG1vID0gXCJzZWxlY3RcIiwgeWkgPSBcInRlLnNlbGVjdFwiLCBYaSA9IGAuJHt5aX1gLCBUYiA9IGBjbG9zZSR7WGl9YCwgRWIgPSBgb3BlbiR7WGl9YCwgVGwgPSBgb3B0aW9uU2VsZWN0JHtYaX1gLCBFbCA9IGBvcHRpb25EZXNlbGVjdCR7WGl9YCwgQ2IgPSBgdmFsdWVDaGFuZ2Uke1hpfWAsIEFiID0gXCJjaGFuZ2VcIiwgQ2wgPSBcImRhdGEtdGUtc2VsZWN0LWluaXRcIiwgeGggPSBcImRhdGEtdGUtc2VsZWN0LW5vLXJlc3VsdHMtcmVmXCIsIEFsID0gXCJkYXRhLXRlLXNlbGVjdC1vcGVuXCIsIEogPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIHp0ID0gXCJkYXRhLXRlLWlucHV0LWZvY3VzZWRcIiwgZ28gPSBcImRhdGEtdGUtaW5wdXQtZGlzYWJsZWRcIiwgeWIgPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1sYWJlbC1yZWZcIiwgd2IgPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi1hbGwtcmVmXCIsIGJpID0gXCJkYXRhLXRlLXNlbGVjdC1zZWxlY3RlZFwiLCBrYiA9IFwiW2RhdGEtdGUtc2VsZWN0LWxhYmVsLXJlZl1cIiwgeWwgPSBcIltkYXRhLXRlLXNlbGVjdC1pbnB1dC1yZWZdXCIsIHhiID0gXCJbZGF0YS10ZS1zZWxlY3QtaW5wdXQtZmlsdGVyLXJlZl1cIiwgT2IgPSBcIltkYXRhLXRlLXNlbGVjdC1kcm9wZG93bi1yZWZdXCIsIFNiID0gXCJbZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy13cmFwcGVyLXJlZl1cIiwgd2wgPSBcIltkYXRhLXRlLXNlbGVjdC1vcHRpb25zLWxpc3QtcmVmXVwiLCBJYiA9IFwiW2RhdGEtdGUtc2VsZWN0LW9wdGlvbi1yZWZdXCIsIERiID0gXCJbZGF0YS10ZS1zZWxlY3QtY2xlYXItYnRuLXJlZl1cIiwgJGIgPSBcIltkYXRhLXRlLXNlbGVjdC1jdXN0b20tY29udGVudC1yZWZdXCIsIExiID0gYFske3hofV1gLCBrbCA9IFwiW2RhdGEtdGUtc2VsZWN0LWZvcm0tb3V0bGluZS1yZWZdXCIsIE5iID0gXCJbZGF0YS10ZS1zZWxlY3QtdG9nZ2xlXVwiLCBibyA9IFwiW2RhdGEtdGUtaW5wdXQtbm90Y2gtcmVmXVwiLCBNYiA9IHtcbiAgc2VsZWN0QXV0b1NlbGVjdDogITEsXG4gIHNlbGVjdENvbnRhaW5lcjogXCJib2R5XCIsXG4gIHNlbGVjdENsZWFyQnV0dG9uOiAhMSxcbiAgZGlzYWJsZWQ6ICExLFxuICBzZWxlY3REaXNwbGF5ZWRMYWJlbHM6IDUsXG4gIHNlbGVjdEZvcm1XaGl0ZTogITEsXG4gIG11bHRpcGxlOiAhMSxcbiAgc2VsZWN0T3B0aW9uc1NlbGVjdGVkTGFiZWw6IFwib3B0aW9ucyBzZWxlY3RlZFwiLFxuICBzZWxlY3RPcHRpb25IZWlnaHQ6IDM4LFxuICBzZWxlY3RBbGw6ICEwLFxuICBzZWxlY3RBbGxMYWJlbDogXCJTZWxlY3QgYWxsXCIsXG4gIHNlbGVjdFNlYXJjaFBsYWNlaG9sZGVyOiBcIlNlYXJjaC4uLlwiLFxuICBzZWxlY3RTaXplOiBcImRlZmF1bHRcIixcbiAgc2VsZWN0VmlzaWJsZU9wdGlvbnM6IDUsXG4gIHNlbGVjdEZpbHRlcjogITEsXG4gIHNlbGVjdEZpbHRlckRlYm91bmNlOiAzMDAsXG4gIHNlbGVjdE5vUmVzdWx0VGV4dDogXCJObyByZXN1bHRzXCIsXG4gIHNlbGVjdFZhbGlkYXRpb246ICExLFxuICBzZWxlY3RWYWxpZEZlZWRiYWNrOiBcIlZhbGlkXCIsXG4gIHNlbGVjdEludmFsaWRGZWVkYmFjazogXCJJbnZhbGlkXCIsXG4gIHNlbGVjdFBsYWNlaG9sZGVyOiBcIlwiXG59LCBSYiA9IHtcbiAgc2VsZWN0QXV0b1NlbGVjdDogXCJib29sZWFuXCIsXG4gIHNlbGVjdENvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdXR0b246IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlZDogXCJib29sZWFuXCIsXG4gIHNlbGVjdERpc3BsYXllZExhYmVsczogXCJudW1iZXJcIixcbiAgc2VsZWN0Rm9ybVdoaXRlOiBcImJvb2xlYW5cIixcbiAgbXVsdGlwbGU6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RPcHRpb25zU2VsZWN0ZWRMYWJlbDogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uSGVpZ2h0OiBcIm51bWJlclwiLFxuICBzZWxlY3RBbGw6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RBbGxMYWJlbDogXCJzdHJpbmdcIixcbiAgc2VsZWN0U2VhcmNoUGxhY2Vob2xkZXI6IFwic3RyaW5nXCIsXG4gIHNlbGVjdFNpemU6IFwic3RyaW5nXCIsXG4gIHNlbGVjdFZpc2libGVPcHRpb25zOiBcIm51bWJlclwiLFxuICBzZWxlY3RGaWx0ZXI6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RGaWx0ZXJEZWJvdW5jZTogXCJudW1iZXJcIixcbiAgc2VsZWN0Tm9SZXN1bHRUZXh0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RWYWxpZGF0aW9uOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0VmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgc2VsZWN0SW52YWxpZEZlZWRiYWNrOiBcInN0cmluZ1wiLFxuICBzZWxlY3RQbGFjZWhvbGRlcjogXCJzdHJpbmdcIlxufSwgUGIgPSB7XG4gIGRyb3Bkb3duOiBcInJlbGF0aXZlIG91dGxpbmUtbm9uZSBtaW4tdy1bMTAwcHhdIG0tMCBzY2FsZS15LVswLjhdIG9wYWNpdHktMCBiZy13aGl0ZSBzaGFkb3ctWzBfMnB4XzVweF8wX3JnYmEoMCwwLDAsMC4xNiksXzBfMnB4XzEwcHhfMF9yZ2JhKDAsMCwwLDAuMTIpXSB0cmFuc2l0aW9uIGR1cmF0aW9uLTIwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXRhLVt0ZS1zZWxlY3Qtb3Blbl06c2NhbGUtMTAwIGRhdGEtW3RlLXNlbGVjdC1vcGVuXTpvcGFjaXR5LTEwMCBkYXJrOmJnLXppbmMtNzAwXCIsXG4gIGZvcm1DaGVja0lucHV0OiBcInJlbGF0aXZlIGZsb2F0LWxlZnQgbXQtWzAuMTVyZW1dIG1yLVs4cHhdIGgtWzEuMTI1cmVtXSB3LVsxLjEyNXJlbV0gYXBwZWFyYW5jZS1ub25lIHJvdW5kZWQtWzAuMjVyZW1dIGJvcmRlci1bMC4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItbmV1dHJhbC0zMDAgZGFyazpib3JkZXItbmV1dHJhbC02MDAgb3V0bGluZS1ub25lIGJlZm9yZTpwb2ludGVyLWV2ZW50cy1ub25lIGJlZm9yZTphYnNvbHV0ZSBiZWZvcmU6aC1bMC44NzVyZW1dIGJlZm9yZTp3LVswLjg3NXJlbV0gYmVmb3JlOnNjYWxlLTAgYmVmb3JlOnJvdW5kZWQtZnVsbCBiZWZvcmU6YmctdHJhbnNwYXJlbnQgYmVmb3JlOm9wYWNpdHktMCBiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3RyYW5zcGFyZW50XSBiZWZvcmU6Y29udGVudC1bJyddIGNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgZGFyazpjaGVja2VkOmJvcmRlci1wcmltYXJ5IGNoZWNrZWQ6YmctcHJpbWFyeSBkYXJrOmNoZWNrZWQ6YmctcHJpbWFyeSBjaGVja2VkOmJlZm9yZTpvcGFjaXR5LVswLjE2XSBjaGVja2VkOmFmdGVyOmFic29sdXRlIGNoZWNrZWQ6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6YWZ0ZXI6YmxvY2sgY2hlY2tlZDphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmFmdGVyOmJnLXRyYW5zcGFyZW50IGNoZWNrZWQ6YWZ0ZXI6Y29udGVudC1bJyddIGhvdmVyOmN1cnNvci1wb2ludGVyIGhvdmVyOmJlZm9yZTpvcGFjaXR5LVswLjA0XSBob3ZlcjpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMCwwLDAsMC42KV0gZm9jdXM6c2hhZG93LW5vbmUgZm9jdXM6dHJhbnNpdGlvbi1bYm9yZGVyLWNvbG9yXzAuMnNdIGZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgZm9jdXM6YmVmb3JlOm9wYWNpdHktWzAuMTJdIGZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBkYXJrOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgyNTUsMjU1LDI1NSwwLjQpXSBmb2N1czpiZWZvcmU6dHJhbnNpdGlvbi1bYm94LXNoYWRvd18wLjJzLHRyYW5zZm9ybV8wLjJzXSBmb2N1czphZnRlcjphYnNvbHV0ZSBmb2N1czphZnRlcjp6LVsxXSBmb2N1czphZnRlcjpibG9jayBmb2N1czphZnRlcjpoLVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6dy1bMC44NzVyZW1dIGZvY3VzOmFmdGVyOnJvdW5kZWQtWzAuMTI1cmVtXSBmb2N1czphZnRlcjpjb250ZW50LVsnJ10gY2hlY2tlZDpmb2N1czpiZWZvcmU6c2NhbGUtMTAwIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBkYXJrOmNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBjaGVja2VkOmZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6aC1bMC44MTI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnctWzAuMzc1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdGF0ZS00NSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdW5kZWQtbm9uZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1bMC4xMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXQtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItc29saWQgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItd2hpdGUgY2hlY2tlZDpmb2N1czphZnRlcjpiZy10cmFuc3BhcmVudFwiLFxuICBmb3JtT3V0bGluZTogXCJyZWxhdGl2ZVwiLFxuICBpbml0aWFsaXplZDogXCJoaWRkZW5cIixcbiAgaW5wdXRHcm91cDogXCJmbGV4IGl0ZW1zLWNlbnRlciB3aGl0ZXNwYWNlLW5vd3JhcCBwLTIuNSB0ZXh0LWNlbnRlciB0ZXh0LWJhc2UgZm9udC1ub3JtYWwgbGVhZGluZy1bMS42XSB0ZXh0LWdyYXktNzAwIGRhcms6YmctemluYy04MDAgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6cGxhY2Vob2xkZXI6dGV4dC1ncmF5LTIwMFwiLFxuICBub1Jlc3VsdDogXCJmbGV4IGl0ZW1zLWNlbnRlciBweC00XCIsXG4gIG9wdGlvbnNMaXN0OiBcImxpc3Qtbm9uZSBtLTAgcC0wXCIsXG4gIG9wdGlvbnNXcmFwcGVyOiBcIm92ZXJmbG93LXktYXV0b1wiLFxuICBvcHRpb25zV3JhcHBlclNjcm9sbGJhcjogXCJbJjo6LXdlYmtpdC1zY3JvbGxiYXJdOnctMSBbJjo6LXdlYmtpdC1zY3JvbGxiYXJdOmgtMSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uXTpibG9jayBbJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uXTpoLTAgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbl06YmctdHJhbnNwYXJlbnQgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXTpiZy10cmFuc3BhcmVudCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOnJvdW5kZWQtbm9uZSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOiBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOnJvdW5kZWQtbCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJdOmgtWzUwcHhdIFsmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYl06YmctWyM5OTldIFsmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYl06cm91bmRlZFwiLFxuICBzZWxlY3RBcnJvdzogXCJhYnNvbHV0ZSByaWdodC0zIHRleHQtWzAuOHJlbV0gY3Vyc29yLXBvaW50ZXIgcGVlci1mb2N1czp0ZXh0LXByaW1hcnkgcGVlci1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTp0ZXh0LXByaW1hcnkgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLXZhbGlkOnRleHQtZ3JlZW4tNjAwIGdyb3VwLWRhdGEtW3RlLXdhcy12YWxpZGF0ZWRdL3ZhbGlkYXRpb246cGVlci1pbnZhbGlkOnRleHQtW3JnYigyMjAsNzYsMTAwKV0gdy01IGgtNVwiLFxuICBzZWxlY3RBcnJvd1doaXRlOiBcInRleHQtZ3JheS01MCBwZWVyLWZvY3VzOiF0ZXh0LXdoaXRlIHBlZXItZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06IXRleHQtd2hpdGVcIixcbiAgc2VsZWN0QXJyb3dEZWZhdWx0OiBcInRvcC0yXCIsXG4gIHNlbGVjdEFycm93TGc6IFwidG9wLVsxM3B4XVwiLFxuICBzZWxlY3RBcnJvd1NtOiBcInRvcC0xXCIsXG4gIHNlbGVjdENsZWFyQnRuOiBcImFic29sdXRlIHRvcC0yIHJpZ2h0LTkgdGV4dC1ibGFjayBjdXJzb3ItcG9pbnRlciBmb2N1czp0ZXh0LXByaW1hcnkgb3V0bGluZS1ub25lIGRhcms6dGV4dC1ncmF5LTIwMFwiLFxuICBzZWxlY3RDbGVhckJ0bldoaXRlOiBcIiF0ZXh0LWdyYXktNTBcIixcbiAgc2VsZWN0Q2xlYXJCdG5EZWZhdWx0OiBcInRvcC0yIHRleHQtYmFzZVwiLFxuICBzZWxlY3RDbGVhckJ0bkxnOiBcInRvcC1bMTFweF0gdGV4dC1iYXNlXCIsXG4gIHNlbGVjdENsZWFyQnRuU206IFwidG9wLTEgdGV4dC1bMC44cmVtXVwiLFxuICBzZWxlY3REcm9wZG93bkNvbnRhaW5lcjogXCJ6LVsxMDcwXVwiLFxuICBzZWxlY3RGYWtlVmFsdWU6IFwidHJhbnNmb3JtLW5vbmUgaGlkZGVuIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06YmxvY2tcIixcbiAgc2VsZWN0RmlsdGVySW5wdXQ6IFwicmVsYXRpdmUgbS0wIGJsb2NrIHctZnVsbCBtaW4tdy0wIGZsZXgtYXV0byByb3VuZGVkIGJvcmRlciBib3JkZXItc29saWQgYm9yZGVyLWdyYXktMzAwIGJnLXRyYW5zcGFyZW50IGJnLWNsaXAtcGFkZGluZyBweC0zIHB5LTEuNSB0ZXh0LWJhc2UgZm9udC1ub3JtYWwgdGV4dC1ncmF5LTcwMCB0cmFuc2l0aW9uIGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBmb2N1czpib3JkZXItcHJpbWFyeSBmb2N1czp0ZXh0LWdyYXktNzAwIGZvY3VzOnNoYWRvdy10ZS1wcmltYXJ5IGZvY3VzOm91dGxpbmUtbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwXCIsXG4gIHNlbGVjdElucHV0OiBcInBlZXIgYmxvY2sgbWluLWgtW2F1dG9dIHctZnVsbCByb3VuZGVkIGJvcmRlci0wIGJnLXRyYW5zcGFyZW50IG91dGxpbmUtbm9uZSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgZm9jdXM6cGxhY2Vob2xkZXI6b3BhY2l0eS0xMDAgZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpwbGFjZWhvbGRlcjpvcGFjaXR5LTEwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwIFsmOm5vdChbZGF0YS10ZS1pbnB1dC1wbGFjZWhvbGRlci1hY3RpdmVdKV06cGxhY2Vob2xkZXI6b3BhY2l0eS0wIGN1cnNvci1wb2ludGVyIGRhdGEtW3RlLWlucHV0LWRpc2FibGVkXTpiZy1bI2U5ZWNlZl0gZGF0YS1bdGUtaW5wdXQtZGlzYWJsZWRdOmN1cnNvci1kZWZhdWx0IGdyb3VwLWRhdGEtW3RlLXdhcy12YWxpZGF0ZWRdL3ZhbGlkYXRpb246bWItNCBkYXJrOmRhdGEtW3RlLWlucHV0LWRpc2FibGVkXTpiZy16aW5jLTYwMFwiLFxuICBzZWxlY3RJbnB1dFdoaXRlOiBcIiF0ZXh0LWdyYXktNTBcIixcbiAgc2VsZWN0SW5wdXRTaXplRGVmYXVsdDogXCJweS1bMC4zMnJlbV0gcHgtMyBsZWFkaW5nLVsxLjZdXCIsXG4gIHNlbGVjdElucHV0U2l6ZUxnOiBcInB5LVswLjMycmVtXSBweC0zIGxlYWRpbmctWzIuMTVdXCIsXG4gIHNlbGVjdElucHV0U2l6ZVNtOiBcInB5LVswLjMzcmVtXSBweC0zIHRleHQteHMgbGVhZGluZy1bMS41XVwiLFxuICBzZWxlY3RMYWJlbDogXCJwb2ludGVyLWV2ZW50cy1ub25lIGFic29sdXRlIHRvcC0wIGxlZnQtMyBtYi0wIG1heC13LVs5MCVdIG9yaWdpbi1bMF8wXSB0cnVuY2F0ZSB0ZXh0LWdyYXktNTAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLW91dCBwZWVyLWZvY3VzOnNjYWxlLVswLjhdIHBlZXItZm9jdXM6dGV4dC1wcmltYXJ5IHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpzY2FsZS1bMC44XSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwZWVyLWZvY3VzOnRleHQtZ3JheS0yMDAgZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpzY2FsZS1bMC44XSBkYXJrOnBlZXItZm9jdXM6dGV4dC1wcmltYXJ5XCIsXG4gIHNlbGVjdExhYmVsV2hpdGU6IFwiIXRleHQtZ3JheS01MFwiLFxuICBzZWxlY3RMYWJlbFNpemVEZWZhdWx0OiBcInB0LVswLjM3cmVtXSBsZWFkaW5nLVsxLjZdIHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVswLjlyZW1dIHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuOXJlbV0gZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuOXJlbV1cIixcbiAgc2VsZWN0TGFiZWxTaXplTGc6IFwicHQtWzAuMzdyZW1dIGxlYWRpbmctWzIuMTVdIHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVsxLjE1cmVtXSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVsxLjE1cmVtXSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMS4xNXJlbV1cIixcbiAgc2VsZWN0TGFiZWxTaXplU206IFwicHQtWzAuMzdyZW1dIHRleHQteHMgbGVhZGluZy1bMS41XSBwZWVyLWZvY3VzOi10cmFuc2xhdGUteS1bMC43NXJlbV0gcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC43NXJlbV0gZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuNzVyZW1dXCIsXG4gIHNlbGVjdE9wdGlvbjogXCJmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gdy1mdWxsIHB4LTQgdHJ1bmNhdGUgdGV4dC1ncmF5LTcwMCBiZy10cmFuc3BhcmVudCBzZWxlY3Qtbm9uZSBjdXJzb3ItcG9pbnRlciBkYXRhLVt0ZS1pbnB1dC1tdWx0aXBsZS1hY3RpdmVdOmJnLWJsYWNrLzUgaG92ZXI6WyY6bm90KFtkYXRhLXRlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdKV06YmctYmxhY2svNSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJnLWJsYWNrLzUgZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1zZWxlY3RlZF06ZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpiZy1ibGFjay81IGRhdGEtW3RlLXNlbGVjdC1zZWxlY3RlZF06ZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZGF0YS1bdGUtc2VsZWN0LXNlbGVjdGVkXTpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTp0ZXh0LWdyYXktNDAwIGRhdGEtW3RlLXNlbGVjdC1zZWxlY3RlZF06ZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06YmctdHJhbnNwYXJlbnQgZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1zZWxlY3RlZF06YmctYmxhY2svWzAuMDJdIGRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdOnRleHQtZ3JheS00MDAgZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZ3JvdXAtZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1yZWZdL29wdDpwbC03IGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOmhvdmVyOlsmOm5vdChbZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXSldOmJnLXdoaXRlLzMwIGRhcms6ZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpiZy13aGl0ZS8zMCBkYXJrOmRhdGEtW3RlLXNlbGVjdC1vcHRpb24tc2VsZWN0ZWRdOmRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ymctd2hpdGUvMzAgZGFyazpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTp0ZXh0LWdyYXktNDAwIGRhcms6ZGF0YS1bdGUtaW5wdXQtbXVsdGlwbGUtYWN0aXZlXTpiZy13aGl0ZS8zMFwiLFxuICBzZWxlY3RBbGxPcHRpb246IFwiXCIsXG4gIHNlbGVjdE9wdGlvbkdyb3VwOiBcImdyb3VwL29wdFwiLFxuICBzZWxlY3RPcHRpb25Hcm91cExhYmVsOiBcImZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIHctZnVsbCBweC00IHRydW5jYXRlIGJnLXRyYW5zcGFyZW50IHRleHQtYmxhY2svNTAgc2VsZWN0LW5vbmUgZGFyazp0ZXh0LWdyYXktMzAwXCIsXG4gIHNlbGVjdE9wdGlvbkljb246IFwidy03IGgtNyByb3VuZGVkLWZ1bGxcIixcbiAgc2VsZWN0T3B0aW9uU2Vjb25kYXJ5VGV4dDogXCJibG9jayB0ZXh0LVswLjhyZW1dIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktMzAwXCIsXG4gIHNlbGVjdE9wdGlvblRleHQ6IFwiZ3JvdXBcIixcbiAgc2VsZWN0VmFsaWRhdGlvblZhbGlkOiBcImhpZGRlbiBhYnNvbHV0ZSAtbXQtMyB3LWF1dG8gdGV4dC1zbSB0ZXh0LWdyZWVuLTYwMCBjdXJzb3ItcG9pbnRlciBncm91cC1kYXRhLVt0ZS13YXMtdmFsaWRhdGVkXS92YWxpZGF0aW9uOnBlZXItdmFsaWQ6YmxvY2tcIixcbiAgc2VsZWN0VmFsaWRhdGlvbkludmFsaWQ6IFwiaGlkZGVuIGFic29sdXRlIC1tdC0zIHctYXV0byB0ZXh0LXNtIHRleHQtW3JnYigyMjAsNzYsMTAwKV0gY3Vyc29yLXBvaW50ZXIgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLWludmFsaWQ6YmxvY2tcIlxufSwgQmIgPSB7XG4gIGRyb3Bkb3duOiBcInN0cmluZ1wiLFxuICBmb3JtQ2hlY2tJbnB1dDogXCJzdHJpbmdcIixcbiAgZm9ybU91dGxpbmU6IFwic3RyaW5nXCIsXG4gIGluaXRpYWxpemVkOiBcInN0cmluZ1wiLFxuICBpbnB1dEdyb3VwOiBcInN0cmluZ1wiLFxuICBub1Jlc3VsdDogXCJzdHJpbmdcIixcbiAgb3B0aW9uc0xpc3Q6IFwic3RyaW5nXCIsXG4gIG9wdGlvbnNXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBvcHRpb25zV3JhcHBlclNjcm9sbGJhcjogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3c6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEFycm93RGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3dMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0QXJyb3dTbTogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG46IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnRuRGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG5MZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0Q2xlYXJCdG5TbTogXCJzdHJpbmdcIixcbiAgc2VsZWN0RHJvcGRvd25Db250YWluZXI6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEZha2VWYWx1ZTogXCJzdHJpbmdcIixcbiAgc2VsZWN0RmlsdGVySW5wdXQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdElucHV0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnB1dFNpemVEZWZhdWx0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnB1dFNpemVMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0SW5wdXRTaXplU206IFwic3RyaW5nXCIsXG4gIHNlbGVjdExhYmVsOiBcInN0cmluZ1wiLFxuICBzZWxlY3RMYWJlbFNpemVEZWZhdWx0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RMYWJlbFNpemVMZzogXCJzdHJpbmdcIixcbiAgc2VsZWN0TGFiZWxTaXplU206IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbjogXCJzdHJpbmdcIixcbiAgc2VsZWN0QWxsT3B0aW9uOiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb25Hcm91cDogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uR3JvdXBMYWJlbDogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uSWNvbjogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uU2Vjb25kYXJ5VGV4dDogXCJzdHJpbmdcIixcbiAgc2VsZWN0T3B0aW9uVGV4dDogXCJzdHJpbmdcIlxufTtcbmNsYXNzIGtyIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9jb25maWcuc2VsZWN0UGxhY2Vob2xkZXIgJiYgIXRoaXMuX2NvbmZpZy5tdWx0aXBsZSAmJiB0aGlzLl9hZGRQbGFjZWhvbGRlck9wdGlvbigpLCB0aGlzLl9vcHRpb25zVG9SZW5kZXIgPSB0aGlzLl9nZXRPcHRpb25zVG9SZW5kZXIodCksIHRoaXMuX3BsYWluT3B0aW9ucyA9IHRoaXMuX2dldFBsYWluT3B0aW9ucyh0aGlzLl9vcHRpb25zVG9SZW5kZXIpLCB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0ID0gbnVsbCwgdGhpcy5fc2VsZWN0aW9uTW9kZWwgPSBuZXcgVWcodGhpcy5tdWx0aXBsZSksIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID0gLTEsIHRoaXMuX2FjdGl2ZU9wdGlvbiA9IG51bGwsIHRoaXMuX3dyYXBwZXJJZCA9IGV0KFwic2VsZWN0LXdyYXBwZXItXCIpLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcklkID0gZXQoXCJzZWxlY3QtZHJvcGRvd24tY29udGFpbmVyLVwiKSwgdGhpcy5fc2VsZWN0QWxsSWQgPSBldChcInNlbGVjdC1hbGwtXCIpLCB0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCA9IG51bGwsIHRoaXMuX2Ryb3Bkb3duSGVpZ2h0ID0gdGhpcy5fY29uZmlnLnNlbGVjdE9wdGlvbkhlaWdodCAqIHRoaXMuX2NvbmZpZy5zZWxlY3RWaXNpYmxlT3B0aW9ucywgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5faW5wdXQgPSBudWxsLCB0aGlzLl9sYWJlbCA9IGQubmV4dCh0aGlzLl9lbGVtZW50LCBrYilbMF0sIHRoaXMuX25vdGNoID0gbnVsbCwgdGhpcy5fZmFrZVZhbHVlID0gbnVsbCwgdGhpcy5faXNGYWtlVmFsdWVBY3RpdmUgPSAhMSwgdGhpcy5fY3VzdG9tQ29udGVudCA9IGQubmV4dChcbiAgICAgIHQsXG4gICAgICAkYlxuICAgIClbMF0sIHRoaXMuX3RvZ2dsZUJ1dHRvbiA9IG51bGwsIHRoaXMuX2VsZW1lbnRUb2dnbGUgPSBudWxsLCB0aGlzLl93cmFwcGVyID0gbnVsbCwgdGhpcy5faW5wdXRFbCA9IG51bGwsIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyID0gbnVsbCwgdGhpcy5fY29udGFpbmVyID0gbnVsbCwgdGhpcy5fc2VsZWN0QWxsT3B0aW9uID0gbnVsbCwgdGhpcy5faW5pdCgpLCB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbCwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX2FkZE11dGF0aW9uT2JzZXJ2ZXIoKSwgdGhpcy5fZWxlbWVudCAmJiBBLnNldERhdGEodCwgeWksIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gbW87XG4gIH1cbiAgZ2V0IGZpbHRlcklucHV0KCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXG4gICAgICB4YixcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyXG4gICAgKTtcbiAgfVxuICBnZXQgZHJvcGRvd24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShPYiwgdGhpcy5fZHJvcGRvd25Db250YWluZXIpO1xuICB9XG4gIGdldCBvcHRpb25zTGlzdCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFxuICAgICAgd2wsXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lclxuICAgICk7XG4gIH1cbiAgZ2V0IG9wdGlvbnNXcmFwcGVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXG4gICAgICBTYixcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyXG4gICAgKTtcbiAgfVxuICBnZXQgY2xlYXJCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShEYiwgdGhpcy5fd3JhcHBlcik7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlcmVkT3B0aW9uc0xpc3QgPyB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0IDogdGhpcy5fcGxhaW5PcHRpb25zO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnZhbHVlcyA6IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnZhbHVlO1xuICB9XG4gIGdldCBtdWx0aXBsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm11bHRpcGxlO1xuICB9XG4gIGdldCBoYXNTZWxlY3RBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbGUgJiYgdGhpcy5fY29uZmlnLnNlbGVjdEFsbDtcbiAgfVxuICBnZXQgaGFzU2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24gfHwgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9ucy5sZW5ndGggPiAwO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uTWIsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKFwibXVsdGlwbGVcIikgJiYgKHQubXVsdGlwbGUgPSAhMCksIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgJiYgKHQuZGlzYWJsZWQgPSAhMCksIHRoaXMuX2VsZW1lbnQudGFiSW5kZXggJiYgKHQudGFiSW5kZXggPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcInRhYkluZGV4XCIpKSwgSShtbywgdCwgUmIpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uUGIsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkobW8sIHQsIEJiKSwgdDtcbiAgfVxuICBfYWRkUGxhY2Vob2xkZXJPcHRpb24oKSB7XG4gICAgY29uc3QgdCA9IG5ldyBPcHRpb24oXCJcIiwgXCJcIiwgITAsICEwKTtcbiAgICB0LmhpZGRlbiA9ICEwLCB0LnNlbGVjdGVkID0gITAsIHRoaXMuX2VsZW1lbnQucHJlcGVuZCh0KTtcbiAgfVxuICBfZ2V0T3B0aW9uc1RvUmVuZGVyKHQpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgcmV0dXJuIHQuY2hpbGROb2Rlcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBpZiAobi5ub2RlTmFtZSA9PT0gXCJPUFRHUk9VUFwiKSB7XG4gICAgICAgIGNvbnN0IG8gPSB7XG4gICAgICAgICAgaWQ6IGV0KFwiZ3JvdXAtXCIpLFxuICAgICAgICAgIGxhYmVsOiBuLmxhYmVsLFxuICAgICAgICAgIGRpc2FibGVkOiBuLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpLFxuICAgICAgICAgIGhpZGRlbjogbi5oYXNBdHRyaWJ1dGUoXCJoaWRkZW5cIiksXG4gICAgICAgICAgb3B0aW9uczogW11cbiAgICAgICAgfTtcbiAgICAgICAgbi5jaGlsZE5vZGVzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgICBhLm5vZGVOYW1lID09PSBcIk9QVElPTlwiICYmIG8ub3B0aW9ucy5wdXNoKFxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlT3B0aW9uT2JqZWN0KGEsIG8pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSksIGUucHVzaChvKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBuLm5vZGVOYW1lID09PSBcIk9QVElPTlwiICYmIGUucHVzaCh0aGlzLl9jcmVhdGVPcHRpb25PYmplY3QobikpO1xuICAgIH0pLCBlO1xuICB9XG4gIF9nZXRQbGFpbk9wdGlvbnModCkge1xuICAgIGlmICghZC5maW5kT25lKFwib3B0Z3JvdXBcIiwgdGhpcy5fZWxlbWVudCkpXG4gICAgICByZXR1cm4gdDtcbiAgICBjb25zdCBpID0gW107XG4gICAgcmV0dXJuIHQuZm9yRWFjaCgobikgPT4ge1xuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuICAgICAgICBuLFxuICAgICAgICBcIm9wdGlvbnNcIlxuICAgICAgKSA/IG4ub3B0aW9ucy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgIGkucHVzaChyKTtcbiAgICAgIH0pIDogaS5wdXNoKG4pO1xuICAgIH0pLCBpO1xuICB9XG4gIF9jcmVhdGVPcHRpb25PYmplY3QodCwgZSA9IHt9KSB7XG4gICAgY29uc3QgaSA9IGV0KFwib3B0aW9uLVwiKSwgbiA9IGUuaWQgPyBlLmlkIDogbnVsbCwgbyA9IGUuZGlzYWJsZWQgPyBlLmRpc2FibGVkIDogITEsIHIgPSB0LnNlbGVjdGVkIHx8IHQuaGFzQXR0cmlidXRlKGJpKSwgYSA9IHQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgfHwgbywgbCA9IHQuaGFzQXR0cmlidXRlKFwiaGlkZGVuXCIpIHx8IGUgJiYgZS5oaWRkZW4sIHAgPSB0aGlzLm11bHRpcGxlLCB1ID0gdC52YWx1ZSwgXyA9IHQubGFiZWwsIGYgPSBoLmdldERhdGFBdHRyaWJ1dGUoXG4gICAgICB0LFxuICAgICAgXCJzZWxlY3RTZWNvbmRhcnlUZXh0XCJcbiAgICApLCBnID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwic2VsZWN0LWljb25cIik7XG4gICAgcmV0dXJuIG5ldyBibChcbiAgICAgIGksXG4gICAgICB0LFxuICAgICAgcCxcbiAgICAgIHUsXG4gICAgICBfLFxuICAgICAgcixcbiAgICAgIGEsXG4gICAgICBsLFxuICAgICAgZixcbiAgICAgIG4sXG4gICAgICBnXG4gICAgKTtcbiAgfVxuICBfZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucy5maWx0ZXIoKGUpID0+ICFlLmhpZGRlbik7XG4gICAgcmV0dXJuIHRoaXMuaGFzU2VsZWN0QWxsID8gW3RoaXMuX3NlbGVjdEFsbE9wdGlvbiwgLi4udF0gOiB0O1xuICB9XG4gIF9pbml0KCkge1xuICAgIHRoaXMuX3JlbmRlck1hdGVyaWFsV3JhcHBlcigpLCB0aGlzLl93cmFwcGVyID0gZC5maW5kT25lKGAjJHt0aGlzLl93cmFwcGVySWR9YCksIHRoaXMuX2lucHV0ID0gZC5maW5kT25lKHlsLCB0aGlzLl93cmFwcGVyKSwgdGhpcy5fY29uZmlnLmRpc2FibGVkICYmIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShnbywgXCJcIik7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NvbmZpZy5zZWxlY3RDb250YWluZXI7XG4gICAgdCA9PT0gXCJib2R5XCIgPyB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5ib2R5IDogdGhpcy5fY29udGFpbmVyID0gZC5maW5kT25lKHQpLCB0aGlzLl9pbml0T3V0bGluZUlucHV0KCksIHRoaXMuX3NldERlZmF1bHRTZWxlY3Rpb25zKCksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fYXBwZW5kRmFrZVZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCksIHRoaXMuX2JpbmRDb21wb25lbnRFdmVudHMoKSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgKHRoaXMuX3NlbGVjdEFsbE9wdGlvbiA9IHRoaXMuX2NyZWF0ZVNlbGVjdEFsbE9wdGlvbigpKSwgdGhpcy5fZHJvcGRvd25Db250YWluZXIgPSB2bChcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVySWQsXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9pbnB1dC5vZmZzZXRXaWR0aCxcbiAgICAgIHRoaXMuX2Ryb3Bkb3duSGVpZ2h0LFxuICAgICAgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLFxuICAgICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyLFxuICAgICAgdGhpcy5fY3VzdG9tQ29udGVudCxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpLCB0aGlzLl9saXN0ZW5Ub0ZvY3VzQ2hhbmdlKCk7XG4gIH1cbiAgX3JlbmRlck1hdGVyaWFsV3JhcHBlcigpIHtcbiAgICBjb25zdCB0ID0gaGIoXG4gICAgICB0aGlzLl93cmFwcGVySWQsXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9sYWJlbCxcbiAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICB0aGlzLl9jb25maWcuY3VzdG9tQXJyb3dcbiAgICApO1xuICAgIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodCwgdGhpcy5fZWxlbWVudCksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5pbml0aWFsaXplZCksIHQuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgX2luaXRPdXRsaW5lSW5wdXQoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgIGtsLFxuICAgICAgdGhpcy5fd3JhcHBlclxuICAgICk7XG4gICAgbmV3IFYoXG4gICAgICB0LFxuICAgICAge1xuICAgICAgICBpbnB1dEZvcm1XaGl0ZTogdGhpcy5fY29uZmlnLnNlbGVjdEZvcm1XaGl0ZVxuICAgICAgfSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLmluaXQoKSwgdGhpcy5fbm90Y2ggPSBkLmZpbmRPbmUoYm8sIHRoaXMuX3dyYXBwZXIpO1xuICB9XG4gIF9iaW5kQ29tcG9uZW50RXZlbnRzKCkge1xuICAgIHRoaXMuX2xpc3RlblRvQ29tcG9uZW50S2V5ZG93bigpLCB0aGlzLl9saXN0ZW5Ub1dyYXBwZXJDbGljaygpLCB0aGlzLl9saXN0ZW5Ub0NsZWFyQnRuQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9DbGVhckJ0bktleWRvd24oKTtcbiAgfVxuICBfc2V0RGVmYXVsdFNlbGVjdGlvbnMoKSB7XG4gICAgdGhpcy5vcHRpb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuc2VsZWN0ZWQgJiYgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHQpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0NvbXBvbmVudEtleWRvd24oKSB7XG4gICAgYy5vbih0aGlzLl93cmFwcGVyLCBcImtleWRvd25cIiwgdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKTtcbiAgfVxuICBfaGFuZGxlS2V5ZG93bih0KSB7XG4gICAgdGhpcy5faXNPcGVuICYmICF0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyID8gdGhpcy5faGFuZGxlT3BlbktleWRvd24odCkgOiB0aGlzLl9oYW5kbGVDbG9zZWRLZXlkb3duKHQpO1xuICB9XG4gIF9oYW5kbGVPcGVuS2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHQua2V5Q29kZSwgaSA9IGUgPT09IHdlIHx8IGUgPT09IFUgJiYgdC5hbHRLZXkgfHwgZSA9PT0ga2U7XG4gICAgaWYgKGUgPT09IGtlICYmIHRoaXMuX2NvbmZpZy5zZWxlY3RBdXRvU2VsZWN0ICYmICF0aGlzLm11bHRpcGxlICYmIHRoaXMuX2hhbmRsZUF1dG9TZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKSwgaSkge1xuICAgICAgdGhpcy5jbG9zZSgpLCB0aGlzLl9pbnB1dC5mb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGUpIHtcbiAgICAgIGNhc2UgejpcbiAgICAgICAgdGhpcy5fc2V0TmV4dE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVTpcbiAgICAgICAgdGhpcy5fc2V0UHJldmlvdXNPcHRpb25BY3RpdmUoKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRlOlxuICAgICAgICB0aGlzLl9zZXRGaXJzdE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRWU6XG4gICAgICAgIHRoaXMuX3NldExhc3RPcHRpb25BY3RpdmUoKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGl0OlxuICAgICAgICB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2FjdGl2ZU9wdGlvbiAmJiAodGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPT09IDAgPyB0aGlzLl9oYW5kbGVTZWxlY3RBbGwoKSA6IHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX2hhbmRsZUNsb3NlZEtleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0LmtleUNvZGU7XG4gICAgaWYgKGUgPT09IGl0ICYmIHQucHJldmVudERlZmF1bHQoKSwgKGUgPT09IGl0IHx8IGUgPT09IHogJiYgdC5hbHRLZXkgfHwgZSA9PT0geiAmJiB0aGlzLm11bHRpcGxlKSAmJiB0aGlzLm9wZW4oKSwgdGhpcy5tdWx0aXBsZSlcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIHo6XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVTpcbiAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgejpcbiAgICAgICAgICB0aGlzLl9zZXROZXh0T3B0aW9uQWN0aXZlKCksIHRoaXMuX2hhbmRsZVNlbGVjdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFU6XG4gICAgICAgICAgdGhpcy5fc2V0UHJldmlvdXNPcHRpb25BY3RpdmUoKSwgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVGU6XG4gICAgICAgICAgdGhpcy5fc2V0Rmlyc3RPcHRpb25BY3RpdmUoKSwgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRWU6XG4gICAgICAgICAgdGhpcy5fc2V0TGFzdE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9oYW5kbGVTZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9zY3JvbGxUb09wdGlvbih0KSB7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBlO1xuICAgIGNvbnN0IGkgPSB0aGlzLm9wdGlvbnMuZmlsdGVyKCh1KSA9PiAhdS5oaWRkZW4pO1xuICAgIHRoaXMuaGFzU2VsZWN0QWxsID8gZSA9IGkuaW5kZXhPZih0KSArIDEgOiBlID0gaS5pbmRleE9mKHQpO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9nZXROdW1iZXJPZkdyb3Vwc0JlZm9yZU9wdGlvbihlKSwgbyA9IGUgKyBuLCByID0gdGhpcy5vcHRpb25zV3JhcHBlciwgYSA9IHIub2Zmc2V0SGVpZ2h0LCBsID0gdGhpcy5fY29uZmlnLnNlbGVjdE9wdGlvbkhlaWdodCwgcCA9IHIuc2Nyb2xsVG9wO1xuICAgIGlmIChlID4gLTEpIHtcbiAgICAgIGNvbnN0IHUgPSBvICogbCwgXyA9IHUgKyBsID4gcCArIGE7XG4gICAgICB1IDwgcCA/IHIuc2Nyb2xsVG9wID0gdSA6IF8gPyByLnNjcm9sbFRvcCA9IHUgLSBhICsgbCA6IHIuc2Nyb2xsVG9wID0gcDtcbiAgICB9XG4gIH1cbiAgX2dldE51bWJlck9mR3JvdXBzQmVmb3JlT3B0aW9uKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLmZpbHRlcigocikgPT4gIXIuaGlkZGVuKSwgaSA9IHRoaXMuX29wdGlvbnNUb1JlbmRlci5maWx0ZXIoKHIpID0+ICFyLmhpZGRlbiksIG4gPSB0aGlzLmhhc1NlbGVjdEFsbCA/IHQgLSAxIDogdDtcbiAgICBsZXQgbyA9IDA7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPD0gbjsgcisrKVxuICAgICAgZVtyXS5ncm91cElkICYmIGlbb10gJiYgaVtvXS5pZCAmJiBlW3JdLmdyb3VwSWQgPT09IGlbb10uaWQgJiYgbysrO1xuICAgIHJldHVybiBvO1xuICB9XG4gIF9zZXROZXh0T3B0aW9uQWN0aXZlKCkge1xuICAgIGxldCB0ID0gdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggKyAxO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpO1xuICAgIGlmIChlW3RdKSB7XG4gICAgICBmb3IgKDsgZVt0XS5kaXNhYmxlZDsgKVxuICAgICAgICBpZiAodCArPSAxLCAhZVt0XSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl91cGRhdGVBY3RpdmVPcHRpb24oZVt0XSwgdCk7XG4gICAgfVxuICB9XG4gIF9zZXRQcmV2aW91c09wdGlvbkFjdGl2ZSgpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4IC0gMTtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKTtcbiAgICBpZiAoZVt0XSkge1xuICAgICAgZm9yICg7IGVbdF0uZGlzYWJsZWQ7IClcbiAgICAgICAgaWYgKHQgLT0gMSwgIWVbdF0pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlT3B0aW9uKGVbdF0sIHQpO1xuICAgIH1cbiAgfVxuICBfc2V0Rmlyc3RPcHRpb25BY3RpdmUoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCk7XG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlT3B0aW9uKGVbMF0sIDApO1xuICB9XG4gIF9zZXRMYXN0T3B0aW9uQWN0aXZlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpLCBlID0gdC5sZW5ndGggLSAxO1xuICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZU9wdGlvbih0W2VdLCBlKTtcbiAgfVxuICBfdXBkYXRlQWN0aXZlT3B0aW9uKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fYWN0aXZlT3B0aW9uO1xuICAgIGkgJiYgaS5yZW1vdmVBY3RpdmVTdHlsZXMoKSwgdC5zZXRBY3RpdmVTdHlsZXMoKSwgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPSBlLCB0aGlzLl9hY3RpdmVPcHRpb24gPSB0O1xuICB9XG4gIF9saXN0ZW5Ub1dyYXBwZXJDbGljaygpIHtcbiAgICBjLm9uKHRoaXMuX3dyYXBwZXIsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9DbGVhckJ0bkNsaWNrKCkge1xuICAgIGMub24odGhpcy5jbGVhckJ1dHRvbiwgXCJjbGlja1wiLCAodCkgPT4ge1xuICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpLCB0aGlzLl9oYW5kbGVDbGVhcigpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0NsZWFyQnRuS2V5ZG93bigpIHtcbiAgICBjLm9uKHRoaXMuY2xlYXJCdXR0b24sIFwia2V5ZG93blwiLCAodCkgPT4ge1xuICAgICAgdC5rZXlDb2RlID09PSBpdCAmJiAodGhpcy5faGFuZGxlQ2xlYXIoKSwgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQ2xlYXIoKSB7XG4gICAgaWYgKHRoaXMubXVsdGlwbGUpXG4gICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5jbGVhcigpLCB0aGlzLl9kZXNlbGVjdEFsbE9wdGlvbnModGhpcy5vcHRpb25zKSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb247XG4gICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5jbGVhcigpLCB0LmRlc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuX2Zha2VWYWx1ZS50ZXh0Q29udGVudCA9IFwiXCIsIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5fZW1pdFZhbHVlQ2hhbmdlRXZlbnQobnVsbCksIHRoaXMuX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpO1xuICB9XG4gIF9saXN0ZW5Ub09wdGlvbnNDbGljaygpIHtcbiAgICBjLm9uKHRoaXMub3B0aW9uc1dyYXBwZXIsIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIGlmICh0LnRhcmdldC5oYXNBdHRyaWJ1dGUoXG4gICAgICAgIHliXG4gICAgICApKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBpID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldCA6IGQuY2xvc2VzdCh0LnRhcmdldCwgSWIpO1xuICAgICAgaWYgKGkuaGFzQXR0cmlidXRlKHdiKSkge1xuICAgICAgICB0aGlzLl9oYW5kbGVTZWxlY3RBbGwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbyA9IGkuZGF0YXNldC50ZUlkLCByID0gdGhpcy5vcHRpb25zLmZpbmQoKGEpID0+IGEuaWQgPT09IG8pO1xuICAgICAgciAmJiAhci5kaXNhYmxlZCAmJiB0aGlzLl9oYW5kbGVTZWxlY3Rpb24ocik7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVNlbGVjdEFsbCgpIHtcbiAgICB0aGlzLl9zZWxlY3RBbGxPcHRpb24uc2VsZWN0ZWQgPyAodGhpcy5fZGVzZWxlY3RBbGxPcHRpb25zKHRoaXMub3B0aW9ucyksIHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5kZXNlbGVjdCgpKSA6ICh0aGlzLl9zZWxlY3RBbGxPcHRpb25zKHRoaXMub3B0aW9ucyksIHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5zZWxlY3QoKSksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5fZW1pdFZhbHVlQ2hhbmdlRXZlbnQodGhpcy52YWx1ZSksIHRoaXMuX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpO1xuICB9XG4gIF9zZWxlY3RBbGxPcHRpb25zKHQpIHtcbiAgICB0LmZvckVhY2goKGUpID0+IHtcbiAgICAgICFlLnNlbGVjdGVkICYmICFlLmRpc2FibGVkICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QoZSksIGUuc2VsZWN0KCkpO1xuICAgIH0pO1xuICB9XG4gIF9kZXNlbGVjdEFsbE9wdGlvbnModCkge1xuICAgIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5zZWxlY3RlZCAmJiAhZS5kaXNhYmxlZCAmJiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoZSksIGUuZGVzZWxlY3QoKSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVNlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5tdWx0aXBsZSA/ICh0aGlzLl9oYW5kbGVNdWx0aVNlbGVjdGlvbih0KSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKSkgOiB0aGlzLl9oYW5kbGVTaW5nbGVTZWxlY3Rpb24odCksIHRoaXMuX3VwZGF0ZUlucHV0VmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKTtcbiAgfVxuICBfaGFuZGxlQXV0b1NlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5fc2luZ2xlT3B0aW9uU2VsZWN0KHQpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCk7XG4gIH1cbiAgX2hhbmRsZVNpbmdsZVNlbGVjdGlvbih0KSB7XG4gICAgdGhpcy5fc2luZ2xlT3B0aW9uU2VsZWN0KHQpLCB0aGlzLmNsb3NlKCksIHRoaXMuX2lucHV0LmZvY3VzKCk7XG4gIH1cbiAgX3NpbmdsZU9wdGlvblNlbGVjdCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnNbMF07XG4gICAgZSAmJiBlICE9PSB0ICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdChlKSwgZS5kZXNlbGVjdCgpLCBlLm5vZGUuc2V0QXR0cmlidXRlKGJpLCAhMSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFbCwge1xuICAgICAgdmFsdWU6IGUudmFsdWVcbiAgICB9KSksICghZSB8fCBlICYmIHQgIT09IGUpICYmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QodCksIHQuc2VsZWN0KCksIHQubm9kZS5zZXRBdHRyaWJ1dGUoYmksICEwKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFRsLCB7XG4gICAgICB2YWx1ZTogdC52YWx1ZVxuICAgIH0pLCB0aGlzLl9lbWl0VmFsdWVDaGFuZ2VFdmVudCh0aGlzLnZhbHVlKSwgdGhpcy5fZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCkpO1xuICB9XG4gIF9oYW5kbGVNdWx0aVNlbGVjdGlvbih0KSB7XG4gICAgdC5zZWxlY3RlZCA/ICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdCh0KSwgdC5kZXNlbGVjdCgpLCB0Lm5vZGUuc2V0QXR0cmlidXRlKGJpLCAhMSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFbCwge1xuICAgICAgdmFsdWU6IHQudmFsdWVcbiAgICB9KSkgOiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHQpLCB0LnNlbGVjdCgpLCB0Lm5vZGUuc2V0QXR0cmlidXRlKGJpLCAhMCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBUbCwge1xuICAgICAgdmFsdWU6IHQudmFsdWVcbiAgICB9KSksIHRoaXMuX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KHRoaXMudmFsdWUpLCB0aGlzLl9lbWl0TmF0aXZlQ2hhbmdlRXZlbnQoKTtcbiAgfVxuICBfZW1pdFZhbHVlQ2hhbmdlRXZlbnQodCkge1xuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBDYiwgeyB2YWx1ZTogdCB9KTtcbiAgfVxuICBfZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCkge1xuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBBYik7XG4gIH1cbiAgX3VwZGF0ZUlucHV0VmFsdWUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5sYWJlbHMgOiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5sYWJlbDtcbiAgICBsZXQgZTtcbiAgICB0aGlzLm11bHRpcGxlICYmIHRoaXMuX2NvbmZpZy5zZWxlY3REaXNwbGF5ZWRMYWJlbHMgIT09IC0xICYmIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMubGVuZ3RoID4gdGhpcy5fY29uZmlnLnNlbGVjdERpc3BsYXllZExhYmVscyA/IGUgPSBgJHt0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zLmxlbmd0aH0gJHt0aGlzLl9jb25maWcuc2VsZWN0T3B0aW9uc1NlbGVjdGVkTGFiZWx9YCA6IGUgPSB0LCAhdGhpcy5tdWx0aXBsZSAmJiAhdGhpcy5faXNTZWxlY3Rpb25WYWxpZCh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24pID8gdGhpcy5faW5wdXQudmFsdWUgPSBcIlwiIDogdGhpcy5faXNMYWJlbEVtcHR5KHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbikgPyB0aGlzLl9pbnB1dC52YWx1ZSA9IFwiIFwiIDogZSA/IHRoaXMuX2lucHV0LnZhbHVlID0gZSA6IHRoaXMubXVsdGlwbGUgfHwgIXRoaXMuX29wdGlvbnNUb1JlbmRlclswXSA/IHRoaXMuX2lucHV0LnZhbHVlID0gXCJcIiA6IHRoaXMuX2lucHV0LnZhbHVlID0gdGhpcy5fb3B0aW9uc1RvUmVuZGVyWzBdLmxhYmVsO1xuICB9XG4gIF9pc1NlbGVjdGlvblZhbGlkKHQpIHtcbiAgICByZXR1cm4gISh0ICYmICh0LmRpc2FibGVkIHx8IHQudmFsdWUgPT09IFwiXCIpKTtcbiAgfVxuICBfaXNMYWJlbEVtcHR5KHQpIHtcbiAgICByZXR1cm4gISEodCAmJiB0LmxhYmVsID09PSBcIlwiKTtcbiAgfVxuICBfYXBwZW5kRmFrZVZhbHVlKCkge1xuICAgIGlmICghdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLl9tdWx0aXBsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uLmxhYmVsO1xuICAgIHRoaXMuX2Zha2VWYWx1ZSA9IHZiKHQsIHRoaXMuX2NsYXNzZXMpLCBkLmZpbmRPbmUoXG4gICAgICBrbCxcbiAgICAgIHRoaXMuX3dyYXBwZXJcbiAgICApLmFwcGVuZENoaWxkKHRoaXMuX2Zha2VWYWx1ZSk7XG4gIH1cbiAgX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKENsKSwgZSA9IHRoaXMuX2lucHV0LnZhbHVlICE9PSBcIlwiO1xuICAgIHRoaXMuX2xhYmVsICYmICh0ICYmIChlIHx8IHRoaXMuX2lzT3BlbiB8fCB0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSkgPyAodGhpcy5fbGFiZWwuc2V0QXR0cmlidXRlKEosIFwiXCIpLCB0aGlzLl9ub3RjaC5zZXRBdHRyaWJ1dGUoSiwgXCJcIikpIDogKHRoaXMuX2xhYmVsLnJlbW92ZUF0dHJpYnV0ZShKKSwgdGhpcy5fbm90Y2gucmVtb3ZlQXR0cmlidXRlKEosIFwiXCIpKSk7XG4gIH1cbiAgX3VwZGF0ZUxhYmVsUG9zaXRpb25XaGlsZUNsb3NpbmcoKSB7XG4gICAgdGhpcy5fbGFiZWwgJiYgKHRoaXMuX2lucHV0LnZhbHVlICE9PSBcIlwiIHx8IHRoaXMuX2lzRmFrZVZhbHVlQWN0aXZlID8gKHRoaXMuX2xhYmVsLnNldEF0dHJpYnV0ZShKLCBcIlwiKSwgdGhpcy5fbm90Y2guc2V0QXR0cmlidXRlKEosIFwiXCIpKSA6ICh0aGlzLl9sYWJlbC5yZW1vdmVBdHRyaWJ1dGUoSiksIHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZShKKSkpO1xuICB9XG4gIF91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpIHtcbiAgICB0aGlzLl9mYWtlVmFsdWUgJiYgKHRoaXMuX2lucHV0LnZhbHVlID09PSBcIlwiICYmIHRoaXMuX2Zha2VWYWx1ZS5pbm5lckhUTUwgIT09IFwiXCIgJiYgIXRoaXMuX2NvbmZpZy5zZWxlY3RQbGFjZWhvbGRlciA/ICh0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSA9ICEwLCB0aGlzLl9mYWtlVmFsdWUuc2V0QXR0cmlidXRlKEosIFwiXCIpKSA6ICh0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSA9ICExLCB0aGlzLl9mYWtlVmFsdWUucmVtb3ZlQXR0cmlidXRlKEopKSk7XG4gIH1cbiAgX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpIHtcbiAgICBpZiAoIXRoaXMuY2xlYXJCdXR0b24pXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnMubGVuZ3RoID4gMCA/IGguYWRkU3R5bGUodGhpcy5jbGVhckJ1dHRvbiwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSkgOiBoLmFkZFN0eWxlKHRoaXMuY2xlYXJCdXR0b24sIHsgZGlzcGxheTogXCJub25lXCIgfSk7XG4gIH1cbiAgX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9zZWxlY3RBbGxPcHRpb24uc2VsZWN0ZWQsIGUgPSBRbyh0aGlzLm9wdGlvbnMpO1xuICAgICFlICYmIHQgPyB0aGlzLl9zZWxlY3RBbGxPcHRpb24uZGVzZWxlY3QoKSA6IGUgJiYgIXQgJiYgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLnNlbGVjdCgpO1xuICB9XG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLl9pc09wZW4gPyB0aGlzLmNsb3NlKCkgOiB0aGlzLm9wZW4oKTtcbiAgfVxuICBvcGVuKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuZGlzYWJsZWQsIGUgPSBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRWIpO1xuICAgIHRoaXMuX2lzT3BlbiB8fCB0IHx8IGUuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5fb3BlbkRyb3Bkb3duKCksIHRoaXMuX3VwZGF0ZURyb3Bkb3duV2lkdGgoKSwgdGhpcy5fc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKSwgdGhpcy5fY29uZmlnLnNlbGVjdEZpbHRlciAmJiAoc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmZpbHRlcklucHV0LmZvY3VzKCk7XG4gICAgfSwgMCksIHRoaXMuX2xpc3RlblRvU2VsZWN0U2VhcmNoKCksIHRoaXMuX2xpc3RlblRvRHJvcGRvd25LZXlkb3duKCkpLCB0aGlzLl9saXN0ZW5Ub09wdGlvbnNDbGljaygpLCB0aGlzLl9saXN0ZW5Ub091dHNpZGVDbGljaygpLCB0aGlzLl9saXN0ZW5Ub1dpbmRvd1Jlc2l6ZSgpLCB0aGlzLl9pc09wZW4gPSAhMCwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl9zZXRJbnB1dEFjdGl2ZVN0eWxlcygpKTtcbiAgfVxuICBfb3BlbkRyb3Bkb3duKCkge1xuICAgIHRoaXMuX3BvcHBlciA9IHNlKHRoaXMuX2lucHV0LCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciwge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiLFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDFdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSksIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kcm9wZG93bkNvbnRhaW5lciksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kcm9wZG93bi5zZXRBdHRyaWJ1dGUoQWwsIFwiXCIpO1xuICAgIH0sIDApO1xuICB9XG4gIF91cGRhdGVEcm9wZG93bldpZHRoKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9pbnB1dC5vZmZzZXRXaWR0aDtcbiAgICBoLmFkZFN0eWxlKHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLCB7IHdpZHRoOiBgJHt0fXB4YCB9KTtcbiAgfVxuICBfc2V0Rmlyc3RBY3RpdmVPcHRpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCksIGUgPSB0aGlzLl9hY3RpdmVPcHRpb247XG4gICAgZSAmJiBlLnJlbW92ZUFjdGl2ZVN0eWxlcygpO1xuICAgIGNvbnN0IGkgPSB0aGlzLm11bHRpcGxlID8gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uc1swXSA6IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbjtcbiAgICBpID8gKHRoaXMuX2FjdGl2ZU9wdGlvbiA9IGksIGkuc2V0QWN0aXZlU3R5bGVzKCksIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID0gdC5maW5kSW5kZXgoXG4gICAgICAobikgPT4gbiA9PT0gaVxuICAgICkpIDogKHRoaXMuX2FjdGl2ZU9wdGlvbiA9IG51bGwsIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID0gLTEpO1xuICB9XG4gIF9zZXRJbnB1dEFjdGl2ZVN0eWxlcygpIHtcbiAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoenQsIFwiXCIpLCBkLmZpbmRPbmUoYm8sIHRoaXMuX3dyYXBwZXIpLnNldEF0dHJpYnV0ZShcbiAgICAgIHp0LFxuICAgICAgXCJcIlxuICAgICk7XG4gIH1cbiAgX2xpc3RlblRvV2luZG93UmVzaXplKCkge1xuICAgIGMub24od2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLl9oYW5kbGVXaW5kb3dSZXNpemUuYmluZCh0aGlzKSk7XG4gIH1cbiAgX2hhbmRsZVdpbmRvd1Jlc2l6ZSgpIHtcbiAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciAmJiB0aGlzLl91cGRhdGVEcm9wZG93bldpZHRoKCk7XG4gIH1cbiAgX2xpc3RlblRvU2VsZWN0U2VhcmNoKCkge1xuICAgIHRoaXMuZmlsdGVySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gdC50YXJnZXQudmFsdWUsIGkgPSB0aGlzLl9jb25maWcuc2VsZWN0RmlsdGVyRGVib3VuY2U7XG4gICAgICB0aGlzLl9kZWJvdW5jZUZpbHRlcihlLCBpKTtcbiAgICB9KTtcbiAgfVxuICBfZGVib3VuY2VGaWx0ZXIodCwgZSkge1xuICAgIHRoaXMuX2RlYm91bmNlVGltZW91dElkICYmIGNsZWFyVGltZW91dCh0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCksIHRoaXMuX2RlYm91bmNlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9maWx0ZXJPcHRpb25zKHQpO1xuICAgIH0sIGUpO1xuICB9XG4gIF9maWx0ZXJPcHRpb25zKHQpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyLmZvckVhY2goKG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICAgIG8sXG4gICAgICAgIFwib3B0aW9uc1wiXG4gICAgICApLCBhID0gIXIgJiYgby5sYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHQudG9Mb3dlckNhc2UoKSksIGwgPSB7fTtcbiAgICAgIHIgJiYgKGwubGFiZWwgPSBvLmxhYmVsLCBsLm9wdGlvbnMgPSB0aGlzLl9maWx0ZXIodCwgby5vcHRpb25zKSwgbC5vcHRpb25zLmxlbmd0aCA+IDAgJiYgZS5wdXNoKGwpKSwgYSAmJiBlLnB1c2gobyk7XG4gICAgfSk7XG4gICAgY29uc3QgaSA9IHRoaXMuX2NvbmZpZy5zZWxlY3ROb1Jlc3VsdFRleHQgIT09IFwiXCIsIG4gPSBlLmxlbmd0aCAhPT0gMDtcbiAgICBpZiAobilcbiAgICAgIHRoaXMuX3VwZGF0ZU9wdGlvbnNMaXN0VGVtcGxhdGUoZSksIHRoaXMuX3BvcHBlci5mb3JjZVVwZGF0ZSgpLCB0aGlzLl9maWx0ZXJlZE9wdGlvbnNMaXN0ID0gdGhpcy5fZ2V0UGxhaW5PcHRpb25zKGUpLCB0aGlzLmhhc1NlbGVjdEFsbCAmJiB0aGlzLl91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpO1xuICAgIGVsc2UgaWYgKCFuICYmIGkpIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLl9nZXROb1Jlc3VsdFRlbXBsYXRlKCk7XG4gICAgICB0aGlzLm9wdGlvbnNXcmFwcGVyLmlubmVySFRNTCA9IG87XG4gICAgfVxuICB9XG4gIF91cGRhdGVPcHRpb25zTGlzdFRlbXBsYXRlKHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKHdsLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcikgfHwgZC5maW5kT25lKExiLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciksIGkgPSBBaChcbiAgICAgIHQsXG4gICAgICB0aGlzLl9zZWxlY3RBbGxPcHRpb24sXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLm9wdGlvbnNXcmFwcGVyLnJlbW92ZUNoaWxkKGUpLCB0aGlzLm9wdGlvbnNXcmFwcGVyLmFwcGVuZENoaWxkKGkpO1xuICB9XG4gIF9nZXROb1Jlc3VsdFRlbXBsYXRlKCkge1xuICAgIHJldHVybiBgPGRpdiBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5ub1Jlc3VsdH1cIiAke3hofSBzdHlsZT1cImhlaWdodDogJHt0aGlzLl9jb25maWcuc2VsZWN0T3B0aW9uSGVpZ2h0fXB4XCI+JHt0aGlzLl9jb25maWcuc2VsZWN0Tm9SZXN1bHRUZXh0fTwvZGl2PmA7XG4gIH1cbiAgX2ZpbHRlcih0LCBlKSB7XG4gICAgY29uc3QgaSA9IHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gZS5maWx0ZXIoXG4gICAgICAobikgPT4gbi5sYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGkpXG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9Ecm9wZG93bktleWRvd24oKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuZHJvcGRvd24sXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIHRoaXMuX2hhbmRsZU9wZW5LZXlkb3duLmJpbmQodGhpcylcbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub091dHNpZGVDbGljaygpIHtcbiAgICB0aGlzLl9vdXRzaWRlQ2xpY2sgPSB0aGlzLl9oYW5kbGVPdXRTaWRlQ2xpY2suYmluZCh0aGlzKSwgYy5vbihkb2N1bWVudCwgXCJjbGlja1wiLCB0aGlzLl9vdXRzaWRlQ2xpY2spO1xuICB9XG4gIF9saXN0ZW5Ub0ZvY3VzQ2hhbmdlKHQgPSAhMCkge1xuICAgIGlmICh0ID09PSAhMSkge1xuICAgICAgYy5vZmYoXG4gICAgICAgIHRoaXMuX2lucHV0LFxuICAgICAgICBcImZvY3VzXCIsXG4gICAgICAgICgpID0+IHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZSh6dCwgXCJcIilcbiAgICAgICksIGMub2ZmKFxuICAgICAgICB0aGlzLl9pbnB1dCxcbiAgICAgICAgXCJibHVyXCIsXG4gICAgICAgICgpID0+IHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZSh6dClcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGMub24oXG4gICAgICB0aGlzLl9pbnB1dCxcbiAgICAgIFwiZm9jdXNcIixcbiAgICAgICgpID0+IHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZSh6dCwgXCJcIilcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5faW5wdXQsXG4gICAgICBcImJsdXJcIixcbiAgICAgICgpID0+IHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZSh6dClcbiAgICApO1xuICB9XG4gIF9oYW5kbGVPdXRTaWRlQ2xpY2sodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl93cmFwcGVyICYmIHRoaXMuX3dyYXBwZXIuY29udGFpbnModC50YXJnZXQpLCBpID0gdC50YXJnZXQgPT09IHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLCBuID0gdGhpcy5fZHJvcGRvd25Db250YWluZXIgJiYgdGhpcy5fZHJvcGRvd25Db250YWluZXIuY29udGFpbnModC50YXJnZXQpO1xuICAgIGxldCBvO1xuICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbiB8fCAodGhpcy5fZWxlbWVudFRvZ2dsZSA9IGQuZmluZChOYikpLCB0aGlzLl9lbGVtZW50VG9nZ2xlICYmIHRoaXMuX2VsZW1lbnRUb2dnbGUuZm9yRWFjaCgocikgPT4ge1xuICAgICAgY29uc3QgYSA9IGguZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgICAgcixcbiAgICAgICAgXCJzZWxlY3QtdG9nZ2xlXCJcbiAgICAgICk7XG4gICAgICAoYSA9PT0gdGhpcy5fZWxlbWVudC5pZCB8fCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhhKSkgJiYgKHRoaXMuX3RvZ2dsZUJ1dHRvbiA9IHIsIG8gPSB0aGlzLl90b2dnbGVCdXR0b24uY29udGFpbnModC50YXJnZXQpKTtcbiAgICB9KSwgIWUgJiYgIWkgJiYgIW4gJiYgIW8gJiYgdGhpcy5jbG9zZSgpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGNvbnN0IHQgPSBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVGIpLCBlID0gY24oXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lci5jaGlsZHJlblswXVxuICAgICk7XG4gICAgIXRoaXMuX2lzT3BlbiB8fCB0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXIgJiYgdGhpcy5oYXNTZWxlY3RBbGwgJiYgKHRoaXMuX3Jlc2V0RmlsdGVyU3RhdGUoKSwgdGhpcy5fdXBkYXRlT3B0aW9uc0xpc3RUZW1wbGF0ZSh0aGlzLl9vcHRpb25zVG9SZW5kZXIpLCB0aGlzLl9jb25maWcubXVsdGlwbGUgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKSksIHRoaXMuX3JlbW92ZURyb3Bkb3duRXZlbnRzKCksIHRoaXMuZHJvcGRvd24ucmVtb3ZlQXR0cmlidXRlKEFsKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoenQpLCB0aGlzLl9pbnB1dC5ibHVyKCksIGQuZmluZE9uZShibywgdGhpcy5fd3JhcHBlcikucmVtb3ZlQXR0cmlidXRlKFxuICAgICAgICB6dFxuICAgICAgKSwgdGhpcy5fbGFiZWwgJiYgIXRoaXMuaGFzU2VsZWN0aW9uICYmICh0aGlzLl9sYWJlbC5yZW1vdmVBdHRyaWJ1dGUoSiksIHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZShKLCBcIlwiKSwgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKEopLCB0aGlzLl9ub3RjaC5yZW1vdmVBdHRyaWJ1dGUoSikpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uV2hpbGVDbG9zaW5nKCk7XG4gICAgfSwgMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fY29udGFpbmVyICYmIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZHJvcGRvd25Db250YWluZXIpLCB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9pc09wZW4gPSAhMSwgYy5vZmYodGhpcy5kcm9wZG93biwgXCJ0cmFuc2l0aW9uZW5kXCIpO1xuICAgIH0sIGUpKTtcbiAgfVxuICBfcmVzZXRGaWx0ZXJTdGF0ZSgpIHtcbiAgICB0aGlzLmZpbHRlcklucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA9IG51bGw7XG4gIH1cbiAgX3JlbW92ZURyb3Bkb3duRXZlbnRzKCkge1xuICAgIGMub2ZmKGRvY3VtZW50LCBcImNsaWNrXCIsIHRoaXMuX291dHNpZGVDbGljayksIHRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXIgJiYgYy5vZmYodGhpcy5kcm9wZG93biwgXCJrZXlkb3duXCIpLCBjLm9mZih0aGlzLm9wdGlvbnNXcmFwcGVyLCBcImNsaWNrXCIpO1xuICB9XG4gIF9hZGRNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICB0aGlzLl93cmFwcGVyICYmICh0aGlzLl91cGRhdGVTZWxlY3Rpb25zKCksIHRoaXMuX3VwZGF0ZURpc2FibGVkU3RhdGUoKSk7XG4gICAgfSksIHRoaXMuX29ic2VydmVNdXRhdGlvbk9ic2VydmVyKCk7XG4gIH1cbiAgX3VwZGF0ZVNlbGVjdGlvbnMoKSB7XG4gICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyID0gdGhpcy5fZ2V0T3B0aW9uc1RvUmVuZGVyKHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9wbGFpbk9wdGlvbnMgPSB0aGlzLl9nZXRQbGFpbk9wdGlvbnModGhpcy5fb3B0aW9uc1RvUmVuZGVyKSwgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKSwgdGhpcy5fc2V0RGVmYXVsdFNlbGVjdGlvbnMoKSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpLCB0aGlzLmhhc1NlbGVjdEFsbCAmJiB0aGlzLl91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuZmlsdGVyICYmIHRoaXMuZmlsdGVySW5wdXQgJiYgdGhpcy5maWx0ZXJJbnB1dC52YWx1ZTtcbiAgICB0aGlzLl9pc09wZW4gJiYgIXQgPyAodGhpcy5fdXBkYXRlT3B0aW9uc0xpc3RUZW1wbGF0ZSh0aGlzLl9vcHRpb25zVG9SZW5kZXIpLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpKSA6IHRoaXMuX2lzT3BlbiAmJiB0ID8gKHRoaXMuX2ZpbHRlck9wdGlvbnModGhpcy5maWx0ZXJJbnB1dC52YWx1ZSksIHRoaXMuX3NldEZpcnN0QWN0aXZlT3B0aW9uKCkpIDogdGhpcy5fZHJvcGRvd25Db250YWluZXIgPSB2bChcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVySWQsXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9pbnB1dC5vZmZzZXRXaWR0aCxcbiAgICAgIHRoaXMuX2Ryb3Bkb3duSGVpZ2h0LFxuICAgICAgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLFxuICAgICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyLFxuICAgICAgdGhpcy5fY3VzdG9tQ29udGVudCxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICB9XG4gIF91cGRhdGVEaXNhYmxlZFN0YXRlKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoeWwsIHRoaXMuX3dyYXBwZXIpO1xuICAgIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPyAodGhpcy5fY29uZmlnLmRpc2FibGVkID0gITAsIHQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIiksIHQuc2V0QXR0cmlidXRlKGdvLCBcIlwiKSkgOiAodGhpcy5fY29uZmlnLmRpc2FibGVkID0gITEsIHQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksIHQucmVtb3ZlQXR0cmlidXRlKGdvKSk7XG4gIH1cbiAgX29ic2VydmVNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgJiYgdGhpcy5fbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIGF0dHJpYnV0ZXM6ICEwLFxuICAgICAgY2hpbGRMaXN0OiAhMCxcbiAgICAgIGNoYXJhY3RlckRhdGE6ICEwLFxuICAgICAgc3VidHJlZTogITBcbiAgICB9KTtcbiAgfVxuICBfZGlzY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyICYmICh0aGlzLl9tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKSwgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG51bGwpO1xuICB9XG4gIF9jcmVhdGVTZWxlY3RBbGxPcHRpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3NlbGVjdEFsbElkLCBlID0gbnVsbCwgaSA9ICEwLCBuID0gXCJzZWxlY3QtYWxsXCIsIG8gPSB0aGlzLl9jb25maWcuc2VsZWN0QWxsTGFiZWwsIHIgPSBRbyh0aGlzLm9wdGlvbnMpLCBhID0gITEsIGwgPSAhMSwgcCA9IG51bGwsIHUgPSBudWxsLCBfID0gbnVsbDtcbiAgICByZXR1cm4gbmV3IGJsKFxuICAgICAgdCxcbiAgICAgIGUsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIG8sXG4gICAgICByLFxuICAgICAgYSxcbiAgICAgIGwsXG4gICAgICBwLFxuICAgICAgdSxcbiAgICAgIF9cbiAgICApO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ29tcG9uZW50RXZlbnRzKCksIHRoaXMuX2Rlc3Ryb3lNYXRlcmlhbFNlbGVjdCgpLCB0aGlzLl9saXN0ZW5Ub0ZvY3VzQ2hhbmdlKCExKSwgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHlpKTtcbiAgfVxuICBfcmVtb3ZlQ29tcG9uZW50RXZlbnRzKCkge1xuICAgIGMub2ZmKHRoaXMuaW5wdXQsIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMud3JhcHBlciwgdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKSwgYy5vZmYodGhpcy5jbGVhckJ1dHRvbiwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5jbGVhckJ1dHRvbiwgXCJrZXlkb3duXCIpLCBjLm9mZih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgfVxuICBfZGVzdHJveU1hdGVyaWFsU2VsZWN0KCkge1xuICAgIHRoaXMuX2lzT3BlbiAmJiB0aGlzLmNsb3NlKCksIHRoaXMuX2Rlc3Ryb3lNYXRlcmlhbFRlbXBsYXRlKCk7XG4gIH1cbiAgX2Rlc3Ryb3lNYXRlcmlhbFRlbXBsYXRlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl93cmFwcGVyLnBhcmVudE5vZGUsIGUgPSBkLmZpbmQoXCJsYWJlbFwiLCB0aGlzLl93cmFwcGVyKTtcbiAgICB0LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpLCBlLmZvckVhY2goKGkpID0+IHtcbiAgICAgIHQuYXBwZW5kQ2hpbGQoaSk7XG4gICAgfSksIGUuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgaS5yZW1vdmVBdHRyaWJ1dGUoSik7XG4gICAgfSksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5pbml0aWFsaXplZCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKENsKSwgdC5yZW1vdmVDaGlsZCh0aGlzLl93cmFwcGVyKTtcbiAgfVxuICBzZXRWYWx1ZSh0KSB7XG4gICAgdGhpcy5vcHRpb25zLmZpbHRlcigoaSkgPT4gaS5zZWxlY3RlZCkuZm9yRWFjaCgoaSkgPT4gaS5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMSksIEFycmF5LmlzQXJyYXkodCkgPyB0LmZvckVhY2goKGkpID0+IHtcbiAgICAgIHRoaXMuX3NlbGVjdEJ5VmFsdWUoaSk7XG4gICAgfSkgOiB0aGlzLl9zZWxlY3RCeVZhbHVlKHQpLCB0aGlzLl91cGRhdGVTZWxlY3Rpb25zKCksIHRoaXMuX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KHRoaXMudmFsdWUpO1xuICB9XG4gIF9zZWxlY3RCeVZhbHVlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLmZpbmQoXG4gICAgICAoaSkgPT4gaS52YWx1ZSA9PT0gdFxuICAgICk7XG4gICAgcmV0dXJuIGUgPyAoZS5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMCwgITApIDogITE7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0gQS5nZXREYXRhKHRoaXMsIHlpKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcga3IodGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgeWkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IEhiID0gKHsgaW5wdXRJRDogcywgbGFiZWxUZXh0OiB0IH0sIGUpID0+IGA8ZGl2IGRhdGEtdGUtY2hpcHMtaW5wdXQtd3JhcHBlciBkYXRhLXRlLWlucHV0LXdyYXBwZXItaW5pdCBjbGFzcz1cIiR7ZS5jaGlwc0lucHV0V3JhcHBlcn1cIj5cbiAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBjbGFzcz1cIiR7ZS5jaGlwc0lucHV0fVwiXG4gICAgICAgICAgaWQ9XCIke3N9XCJcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIkV4YW1wbGUgbGFiZWxcIiAvPlxuICAgICAgICA8bGFiZWxcbiAgICAgICAgICBmb3I9XCIke3N9XCJcbiAgICAgICAgICBjbGFzcz1cIiR7ZS5jaGlwc0xhYmVsfVwiXG4gICAgICAgICAgPiR7dH1cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PmAsIFZiID0gKHsgdGV4dDogcywgaWNvblNWRzogdCB9LCBlKSA9PiBgPGRpdiBkYXRhLXRlLWNoaXAtaW5pdCBkYXRhLXRlLXJpcHBsZS1pbml0IGNsYXNzPVwiJHtlLmNoaXBFbGVtZW50fVwiPlxuICAgIDxzcGFuIGRhdGEtdGUtY2hpcC10ZXh0PiR7c308L3NwYW4+IFxuICAgICAgPHNwYW4gZGF0YS10ZS1jaGlwLWNsb3NlIGNsYXNzPVwiJHtlLmNoaXBDbG9zZUljb259XCI+XG4gICAgICAgICR7dH1cbiAgICAgIDwvc3Bhbj5cbiAgPC9kaXY+YCwgZW4gPSBcImNoaXBcIiwgV2IgPSBgdGUuJHtlbn1gLCBPaCA9IFwiZGF0YS10ZS1jaGlwLWNsb3NlXCIsIHZvID0gYFske09ofV1gLCBGYiA9IFwiZGVsZXRlLnRlLmNoaXBzXCIsIFliID0gXCJzZWxlY3QudGUuY2hpcFwiLCBqYiA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctMyBoLTNcIj4gPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk02IDE4TDE4IDZNNiA2bDEyIDEyXCIgLz48L3N2Zz4nLCBLYiA9IHtcbiAgdGV4dDogXCJzdHJpbmdcIixcbiAgY2xvc2VJY29uOiBcImJvb2xlYW5cIixcbiAgaW1nOiBcIm9iamVjdFwiLFxuICBpY29uU1ZHOiBcInN0cmluZ1wiXG59LCB6YiA9IHtcbiAgdGV4dDogXCJcIixcbiAgY2xvc2VJY29uOiAhMSxcbiAgaW1nOiB7IHBhdGg6IFwiXCIsIGFsdDogXCJcIiB9LFxuICBpY29uU1ZHOiBqYlxufSwgVWIgPSB7XG4gIGljb246IFwiZmxvYXQtcmlnaHQgcGwtWzhweF0gdGV4dC1bMTZweF0gb3BhY2l0eS1bLjUzXSBjdXJzb3ItcG9pbnRlciBmaWxsLVsjYWZhZmFmXSBob3Zlcjp0ZXh0LVsjOGI4YjhiXSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXRcIixcbiAgY2hpcEVsZW1lbnQ6IFwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIGgtWzMycHhdIGxlYWRpbmctbG9vc2UgcHktWzVweF0gcHgtWzEycHhdIG1yLTQgbXktWzVweF0gdGV4dC1bMTNweF0gZm9udC1ub3JtYWwgdGV4dC1bIzRmNGY0Zl0gY3Vyc29yLXBvaW50ZXIgYmctWyNlY2VmZjFdIGRhcms6dGV4dC13aGl0ZSBkYXJrOmJnLW5ldXRyYWwtNjAwIHJvdW5kZWQtWzE2cHhdIHRyYW5zaXRpb24tW29wYWNpdHldIGR1cmF0aW9uLTMwMCBlYXNlLWxpbmVhciBbd29yZC13cmFwOiBicmVhay13b3JkXSBzaGFkb3ctbm9uZSBub3JtYWwtY2FzZSBob3Zlcjohc2hhZG93LW5vbmUgYWN0aXZlOmJnLVsjY2FjZmQxXSBpbmxpbmUtYmxvY2sgZm9udC1tZWRpdW0gbGVhZGluZy1ub3JtYWwgdGV4dC1bIzRmNGY0Zl0gdGV4dC1jZW50ZXIgbm8tdW5kZXJsaW5lIGFsaWduLW1pZGRsZSBjdXJzb3ItcG9pbnRlciBzZWxlY3Qtbm9uZSBib3JkZXItWy4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItdHJhbnNwYXJlbnQgcHktMS41IHB4LTMgdGV4dC14cyByb3VuZGVkXCIsXG4gIGNoaXBDbG9zZUljb246IFwidy00IGZsb2F0LXJpZ2h0IHBsLVs4cHhdIHRleHQtWzE2cHhdIG9wYWNpdHktWy41M10gY3Vyc29yLXBvaW50ZXIgZmlsbC1bI2FmYWZhZl0gaG92ZXI6ZmlsbC1bIzhiOGI4Yl0gZGFyazpmaWxsLWdyYXktNDAwIGRhcms6aG92ZXI6ZmlsbC1ncmF5LTEwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXRcIlxufSwgWGIgPSB7XG4gIGljb246IFwic3RyaW5nXCIsXG4gIGNoaXBFbGVtZW50OiBcInN0cmluZ1wiLFxuICBjaGlwQ2xvc2VJY29uOiBcInN0cmluZ1wiXG59O1xuY2xhc3Mgdmkge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGVuO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2FwcGVuZENsb3NlSWNvbigpLCB0aGlzLl9oYW5kbGVEZWxldGUoKSwgdGhpcy5faGFuZGxlVGV4dENoaXAoKSwgdGhpcy5faGFuZGxlQ2xpY2tPbkNoaXAoKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbCwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiKTtcbiAgfVxuICBhcHBlbmRDaGlwKCkge1xuICAgIGNvbnN0IHsgdGV4dDogdCwgY2xvc2VJY29uOiBlLCBpY29uU1ZHOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHJldHVybiBWYih7IHRleHQ6IHQsIGNsb3NlSWNvbjogZSwgaWNvblNWRzogaSB9LCB0aGlzLl9jbGFzc2VzKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9hcHBlbmRDbG9zZUljb24odCA9IHRoaXMuX2VsZW1lbnQpIHtcbiAgICBpZiAoIShkLmZpbmQodm8sIHRoaXMuX2VsZW1lbnQpLmxlbmd0aCA+IDApICYmIHRoaXMuX29wdGlvbnMuY2xvc2VJY29uKSB7XG4gICAgICBjb25zdCBlID0gJChcInNwYW5cIik7XG4gICAgICBlLmNsYXNzTGlzdCA9IHRoaXMuX2NsYXNzZXMuaWNvbiwgZS5zZXRBdHRyaWJ1dGUoT2gpLCBlLmlubmVySFRNTCA9IHRoaXMuX29wdGlvbnMuaWNvblNWRywgdC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJiZWZvcmVlbmRcIiwgZSk7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVDbGlja09uQ2hpcCgpIHtcbiAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgdGV4dENvbnRlbnQ6IGUgfSA9IHQudGFyZ2V0LCBpID0ge307XG4gICAgICBpLnRhZyA9IGUudHJpbSgpLCBjLnRyaWdnZXIoWWIsIHsgZXZlbnQ6IHQsIG9iajogaSB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlRGVsZXRlKCkge1xuICAgIGQuZmluZChcbiAgICAgIHZvLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkubGVuZ3RoICE9PSAwICYmIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB2bywgKCkgPT4ge1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEZiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlVGV4dENoaXAoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5pbm5lclRleHQgPT09IFwiXCIgJiYgKHRoaXMuX2VsZW1lbnQuaW5uZXJUZXh0ID0gdGhpcy5fb3B0aW9ucy50ZXh0KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uemIsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEkoZW4sIGUsIEtiKSwgZTtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlViLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKGVuLCB0LCBYYiksIHQ7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIFdiKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBIaSA9IFwiY2hpcHNcIiwgR2kgPSBgZGF0YS10ZS0ke0hpfWAsIHhsID0gYHRlLiR7SGl9YCwgR2IgPSBgJHtHaX0taW5wdXQtaW5pdGAsIGJ0ID0gYCR7R2l9LWFjdGl2ZWAsIE9sID0gYCR7R2l9LWluaXRpYWxgLCBTaCA9IGAke0dpfS1wbGFjZWhvbGRlcmAsIHFiID0gYCR7R2l9LWlucHV0LXdyYXBwZXJgLCBKbyA9IFwiZGF0YS10ZS1jaGlwLWluaXRcIiwgSWggPSBcImRhdGEtdGUtY2hpcC1jbG9zZVwiLCBEaCA9IFwiZGF0YS10ZS1jaGlwLXRleHRcIiwgWmIgPSBgWyR7YnR9XWAsIHRyID0gYFske0pvfV1gLCBRYiA9IGAke3RyfSR7WmJ9YCwgVG8gPSBgWyR7SWh9XWAsIEpiID0gYFske3FifV1gLCB0diA9IGBbJHtEaH1dYCwgZXYgPSBgWyR7U2h9XWAsIGl2ID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLWxlYWRpbmctcmVmXCIsIHN2ID0gXCJkYXRhLXRlLWlucHV0LW5vdGNoLW1pZGRsZS1yZWZcIiwgbnYgPSBgWyR7aXZ9XWAsIG92ID0gYFske3N2fV1gLCBOZSA9IFwiZGF0YS10ZS1pbnB1dC1zdGF0ZS1hY3RpdmVcIiwgRW8gPSBcIltkYXRhLXRlLWlucHV0LW5vdGNoLXJlZl1cIiwgcnYgPSBcImFkZC50ZS5jaGlwc1wiLCBhdiA9IFwiYXJyb3dEb3duLnRlLmNoaXBzXCIsIGx2ID0gXCJhcnJvd0xlZnQudGUuY2hpcHNcIiwgY3YgPSBcImFycm93UmlnaHQudGUuY2hpcHNcIiwgaHYgPSBcImFycm93VXAudGUuY2hpcHNcIiwgU2wgPSBcImRlbGV0ZS50ZS5jaGlwc1wiLCBJbCA9IFwic2VsZWN0LnRlLmNoaXBzXCIsIGR2ID0ge1xuICBpbnB1dElEOiBcInN0cmluZ1wiLFxuICBwYXJlbnRTZWxlY3RvcjogXCJzdHJpbmdcIixcbiAgaW5pdGlhbFZhbHVlczogXCJhcnJheVwiLFxuICBlZGl0YWJsZTogXCJib29sZWFuXCIsXG4gIGxhYmVsVGV4dDogXCJzdHJpbmdcIixcbiAgaW5wdXRDbGFzc2VzOiBcIm9iamVjdFwiLFxuICBpbnB1dE9wdGlvbnM6IFwib2JqZWN0XCJcbn0sIHV2ID0ge1xuICBpbnB1dElEOiBldChcImNoaXBzLWlucHV0LVwiKSxcbiAgcGFyZW50U2VsZWN0b3I6IFwiXCIsXG4gIGluaXRpYWxWYWx1ZXM6IFt7IHRhZzogXCJpbml0MVwiIH0sIHsgdGFnOiBcImluaXQyXCIgfV0sXG4gIGVkaXRhYmxlOiAhMSxcbiAgbGFiZWxUZXh0OiBcIkV4YW1wbGUgbGFiZWxcIixcbiAgaW5wdXRDbGFzc2VzOiB7fSxcbiAgaW5wdXRPcHRpb25zOiB7fVxufSwgcHYgPSB7XG4gIG9wYWNpdHk6IFwib3BhY2l0eS0wXCIsXG4gIGlucHV0V3JhcHBlclBhZGRpbmc6IFwicC1bNXB4XVwiLFxuICB0cmFuc2l0aW9uOiBcInRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxKV1cIixcbiAgY29udGVudEVkaXRhYmxlOiBcIm91dGxpbmUtbm9uZSAhYm9yZGVyLVszcHhdICFib3JkZXItc29saWQgIWJvcmRlci1bI2IyYjNiNF1cIixcbiAgY2hpcHNJbnB1dFdyYXBwZXI6IFwicmVsYXRpdmUgZmxleCBpdGVtcy1jZW50ZXIgZmxleC13cmFwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxKV1cIixcbiAgY2hpcHNJbnB1dDogXCJwZWVyIGJsb2NrIG1pbi1oLVthdXRvXSB3LVsxNTBweF0gcm91bmRlZCBib3JkZXItMCBiZy10cmFuc3BhcmVudCBweS1bMC4zMnJlbV0gcHgtMyBsZWFkaW5nLVsxLjZdIG91dGxpbmUtbm9uZSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgZm9jdXM6cGxhY2Vob2xkZXI6b3BhY2l0eS0xMDAgZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpwbGFjZWhvbGRlcjpvcGFjaXR5LTEwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwIFsmOm5vdChbZGF0YS10ZS1pbnB1dC1wbGFjZWhvbGRlci1hY3RpdmVdKV06cGxhY2Vob2xkZXI6b3BhY2l0eS0wXCIsXG4gIGNoaXBzTGFiZWw6IFwicG9pbnRlci1ldmVudHMtbm9uZSBhYnNvbHV0ZSB0b3AtMCBsZWZ0LTMgbWItMCBtYXgtdy1bOTAlXSBvcmlnaW4tWzBfMF0gdHJ1bmNhdGUgcHQtWzAuMzdyZW1dIGxlYWRpbmctWzEuNl0gdGV4dC1ncmF5LTUwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1vdXQgcGVlci1mb2N1czotdHJhbnNsYXRlLXktWzAuOXJlbV0gcGVlci1mb2N1czpzY2FsZS1bMC44XSBwZWVyLWZvY3VzOnRleHQtcHJpbWFyeSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVswLjlyZW1dIHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpzY2FsZS1bMC44XSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwZWVyLWZvY3VzOnRleHQtZ3JheS0yMDBcIlxufSwgX3YgPSB7XG4gIG9wYWNpdHk6IFwic3RyaW5nXCIsXG4gIGlucHV0V3JhcHBlclBhZGRpbmc6IFwic3RyaW5nXCIsXG4gIHRyYW5zaXRpb246IFwic3RyaW5nXCIsXG4gIGNvbnRlbnRFZGl0YWJsZTogXCJzdHJpbmdcIixcbiAgY2hpcHNJbnB1dFdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGNoaXBzSW5wdXQ6IFwic3RyaW5nXCIsXG4gIGNoaXBzTGFiZWw6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBYQSBleHRlbmRzIHZpIHtcbiAgY29uc3RydWN0b3IoZSwgaSA9IHt9LCBuKSB7XG4gICAgc3VwZXIoZSwgaSk7XG4gICAgd3QodGhpcywgXCJfaGFuZGxlQmx1cklucHV0XCIsICh7IHRhcmdldDogZSB9KSA9PiB7XG4gICAgICBlLnZhbHVlLmxlbmd0aCA+IDAgJiYgdGhpcy5faGFuZGxlQ3JlYXRlQ2hpcChlLCBlLnZhbHVlKSwgdGhpcy5hbGxDaGlwcy5sZW5ndGggPiAwID8gKGUuc2V0QXR0cmlidXRlKGJ0LCBcIlwiKSwgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoTmUsIFwiXCIpLCBkLmZpbmRPbmUoXG4gICAgICAgIEVvLFxuICAgICAgICB0aGlzLmlucHV0LnBhcmVudE5vZGVcbiAgICAgICkuc2V0QXR0cmlidXRlKE5lLCBcIlwiKSwgdGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgICApKSA6IChlLnJlbW92ZUF0dHJpYnV0ZShidCksIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKE5lKSwgZC5maW5kT25lKFxuICAgICAgICBFbyxcbiAgICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlXG4gICAgICApLnJlbW92ZUF0dHJpYnV0ZShOZSksIHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICAgKSksIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoaSkgPT4gaS5yZW1vdmVBdHRyaWJ1dGUoYnQpKTtcbiAgICB9KTtcbiAgICB0aGlzLl9lbGVtZW50ID0gZSwgdGhpcy5faW5wdXRJbnN0YW5jZSA9IG51bGwsIHRoaXMuX2VsZW1lbnQgJiYgQS5zZXREYXRhKGUsIHhsLCB0aGlzKSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhpKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMobiksIHRoaXMubnVtYmVyQ2xpY2tzID0gMCwgdGhpcy5pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEhpO1xuICB9XG4gIGdldCBhY3RpdmVDaGlwKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoUWIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBpbnB1dCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFwiaW5wdXRcIiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IGFsbENoaXBzKCkge1xuICAgIHJldHVybiBkLmZpbmQodHIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBjaGlwc0lucHV0V3JhcHBlcigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKEpiLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9zZXRDaGlwc0NsYXNzKCksIHRoaXMuX2FwcGVuZElucHV0VG9FbGVtZW50KFNoKSwgdGhpcy5faGFuZGxlSW5pdGlhbFZhbHVlKCksIHRoaXMuX2hhbmRsZUlucHV0VGV4dCgpLCB0aGlzLl9oYW5kbGVLZXlib2FyZCgpLCB0aGlzLl9oYW5kbGVDaGlwc09uU2VsZWN0KCksIHRoaXMuX2hhbmRsZUVkaXRhYmxlKCksIHRoaXMuX2hhbmRsZUNoaXBzRm9jdXMoKSwgdGhpcy5faGFuZGxlQ2xpY2tzT25DaGlwcygpLCB0aGlzLl9pbnB1dEluc3RhbmNlLl9nZXRMYWJlbFdpZHRoKCksIHRoaXMuX2lucHV0SW5zdGFuY2UuX2FwcGx5Tm90Y2goKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbDtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXROb3RjaERhdGEoKSB7XG4gICAgdGhpcy5fbm90Y2hNaWRkbGUgPSBkLmZpbmRPbmUoXG4gICAgICBvdixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBkLmZpbmRPbmUoXG4gICAgICBudixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICB9XG4gIF9zZXRDaGlwc0NsYXNzKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKEdiLCBcIlwiKTtcbiAgfVxuICBfaGFuZGxlRGVsZXRlRXZlbnRzKGUpIHtcbiAgICBjb25zdCBbaV0gPSB0aGlzLmFsbENoaXBzLnNsaWNlKC0xKTtcbiAgICBpZiAodGhpcy5hY3RpdmVDaGlwID09PSBudWxsKVxuICAgICAgaS5yZW1vdmUoKSwgdGhpcy5faGFuZGxlRXZlbnRzKGUsIFNsKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmFsbENoaXBzLmZpbmRJbmRleCgoYSkgPT4gYSA9PT0gdGhpcy5hY3RpdmVDaGlwKSwgbyA9IHRoaXMuX2hhbmRsZUFjdGl2ZUNoaXBBZnRlclJlbW92ZShuKSwgciA9IFtdO1xuICAgICAgaWYgKHRoaXMuYWN0aXZlQ2hpcCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5hY3RpdmVDaGlwLnJlbW92ZSgpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgU2wpLCB0aGlzLm51bWJlckNsaWNrcyA9IG4sIG8uc2V0QXR0cmlidXRlKGJ0LCBcIlwiKSwgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGEuaGFzQXR0cmlidXRlKGJ0KSAmJiAoci5wdXNoKGEpLCByLmxlbmd0aCA+IDEgJiYgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChsKSA9PiBsLnJlbW92ZSgpKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX2hhbmRsZVVwRXZlbnRzKGUpIHtcbiAgICB0aGlzLm51bWJlckNsaWNrcyArPSAxLCB0aGlzLm51bWJlckNsaWNrcyA9PT0gdGhpcy5hbGxDaGlwcy5sZW5ndGggKyAxICYmICh0aGlzLm51bWJlckNsaWNrcyA9IDApLCB0aGlzLl9oYW5kbGVSaWdodEtleWJvYXJkQXJyb3codGhpcy5udW1iZXJDbGlja3MpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgY3YpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgaHYpO1xuICB9XG4gIF9oYW5kbGVEb3duRXZlbnRzKGUpIHtcbiAgICB0aGlzLm51bWJlckNsaWNrcyAtPSAxLCB0aGlzLm51bWJlckNsaWNrcyA8PSAwICYmICh0aGlzLm51bWJlckNsaWNrcyA9IHRoaXMuYWxsQ2hpcHMubGVuZ3RoKSwgdGhpcy5faGFuZGxlTGVmdEtleWJvYXJkQXJyb3codGhpcy5udW1iZXJDbGlja3MpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgbHYpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgYXYpO1xuICB9XG4gIF9rZXlib2FyZEV2ZW50cyhlKSB7XG4gICAgY29uc3QgeyB0YXJnZXQ6IGksIGtleUNvZGU6IG4sIGN0cmxLZXk6IG8gfSA9IGU7XG4gICAgaS52YWx1ZS5sZW5ndGggPiAwIHx8IHRoaXMuYWxsQ2hpcHMubGVuZ3RoID09PSAwIHx8IChuID09PSBvbSB8fCBuID09PSBybSA/IHRoaXMuX2hhbmRsZURlbGV0ZUV2ZW50cyhlKSA6IG4gPT09IHplIHx8IG4gPT09IFUgPyB0aGlzLl9oYW5kbGVVcEV2ZW50cyhlKSA6IG4gPT09IEtlIHx8IG4gPT09IHogPyB0aGlzLl9oYW5kbGVEb3duRXZlbnRzKGUpIDogbiA9PT0gNjUgJiYgbyAmJiB0aGlzLl9oYW5kbGVBZGRBY3RpdmVDbGFzcygpKTtcbiAgfVxuICBfaGFuZGxlS2V5Ym9hcmQoKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuaW5wdXQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIChlKSA9PiB0aGlzLl9rZXlib2FyZEV2ZW50cyhlKVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUVkaXRhYmxlKCkge1xuICAgIGNvbnN0IHsgZWRpdGFibGU6IGUgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgZSAmJiB0aGlzLmFsbENoaXBzLmZvckVhY2goKGkpID0+IHtcbiAgICAgIGMub24oaSwgXCJkYmxjbGlja1wiLCAobikgPT4ge1xuICAgICAgICBjb25zdCBvID0gZC5maW5kT25lKFRvLCBpKTtcbiAgICAgICAgaS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMuY29udGVudEVkaXRhYmxlLnNwbGl0KFwiIFwiKSksIGkuY29udGVudEVkaXRhYmxlID0gITAsIGkuZm9jdXMoKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaC5hZGRTdHlsZShvLCB7IGRpc3BsYXk6IFwibm9uZVwiIH0pO1xuICAgICAgICB9LCAyMDApLCBvLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSksIG4udGFyZ2V0LnRleHRDb250ZW50LCBjLnRyaWdnZXIoaSwgSWwsIHtcbiAgICAgICAgICBldmVudDogbixcbiAgICAgICAgICBhbGxDaGlwczogdGhpcy5hbGxDaGlwc1xuICAgICAgICB9KTtcbiAgICAgIH0pLCBjLm9uKGRvY3VtZW50LCBcImNsaWNrXCIsICh7IHRhcmdldDogbiB9KSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBkLmZpbmRPbmUoVG8sIGkpLCByID0gZC5maW5kT25lKHR2LCBpKSwgYSA9IG4gPT09IGksIGwgPSBpICYmIGkuY29udGFpbnMobik7XG4gICAgICAgICFhICYmICFsICYmIChpLmNvbnRlbnRFZGl0YWJsZSA9ICExLCBpLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5jb250ZW50RWRpdGFibGUuc3BsaXQoXCIgXCIpKSwgci50ZXh0Q29udGVudCAhPT0gXCJcIiAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBoLmFkZFN0eWxlKG8sIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCBvLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH0sIDE2MCkpLCByLnRleHRDb250ZW50ID09PSBcIlwiICYmIChzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH0sIDIwMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGkucmVtb3ZlKCk7XG4gICAgICAgIH0sIDMwMCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVJlbW92ZUFjdGl2ZUNsYXNzKCkge1xuICAgIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmVBdHRyaWJ1dGUoYnQpKTtcbiAgfVxuICBfaGFuZGxlQWRkQWN0aXZlQ2xhc3MoKSB7XG4gICAgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChlKSA9PiBlLnNldEF0dHJpYnV0ZShidCwgXCJcIikpO1xuICB9XG4gIF9oYW5kbGVSaWdodEtleWJvYXJkQXJyb3coZSkge1xuICAgIHRoaXMuX2hhbmRsZVJlbW92ZUFjdGl2ZUNsYXNzKCksIGUgPT09IDAgJiYgKGUgPSAxKSwgdGhpcy5faGFuZGxlQWRkQWN0aXZlQ2xhc3NXaXRoS2VieWJvYXJkKGUpO1xuICB9XG4gIF9oYW5kbGVMZWZ0S2V5Ym9hcmRBcnJvdyhlKSB7XG4gICAgdGhpcy5faGFuZGxlUmVtb3ZlQWN0aXZlQ2xhc3MoKSwgdGhpcy5faGFuZGxlQWRkQWN0aXZlQ2xhc3NXaXRoS2VieWJvYXJkKGUpO1xuICB9XG4gIF9oYW5kbGVBY3RpdmVDaGlwQWZ0ZXJSZW1vdmUoZSkge1xuICAgIGNvbnN0IGkgPSBlID09PSAwID8gMSA6IGUgLSAxO1xuICAgIHJldHVybiB0aGlzLmFsbENoaXBzW2ldO1xuICB9XG4gIF9oYW5kbGVDbGlja3NPbkNoaXBzKCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmFsbENoaXBzLmxlbmd0aCA9PT0gMCAmJiAodGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgICApLCB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShidCkpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgcmV0dXJuIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoaSkgPT4gZS5wdXNoKHsgdGFnOiBpLnRleHRDb250ZW50LnRyaW0oKSB9KSksIGU7XG4gIH1cbiAgX2hhbmRsZUV2ZW50cyhlLCBpKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2hhbmRsZVRleHRDb250ZW50KCksIG8gPSB0aGlzLmFsbENoaXBzLmZpbHRlcihcbiAgICAgIChyKSA9PiByLmhhc0F0dHJpYnV0ZShidCkgJiYgclxuICAgICk7XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGksIHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgYWxsQ2hpcHM6IHRoaXMuYWxsQ2hpcHMsXG4gICAgICBhcnJPZk9iamVjdHM6IG4sXG4gICAgICBhY3RpdmU6IG8sXG4gICAgICBhY3RpdmVPYmo6IHtcbiAgICAgICAgdGFnOiBvLmxlbmd0aCA8PSAwID8gXCJcIiA6IG9bMF0udGV4dENvbnRlbnQudHJpbSgpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNoaXBzRm9jdXMoKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsICh7IHRhcmdldDogeyBhdHRyaWJ1dGVzOiBlIH0gfSkgPT4ge1xuICAgICAgY29uc3QgaSA9IFsuLi5lXS5tYXAoKG4pID0+IG4ubmFtZSk7XG4gICAgICBpLmluY2x1ZGVzKEpvKSB8fCBpLmluY2x1ZGVzKEloKSB8fCBpLmluY2x1ZGVzKERoKSB8fCB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUluaXRpYWxWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5fYXBwZW5kSW5wdXRUb0VsZW1lbnQoT2wpLCB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShPbCkpIHtcbiAgICAgIGNvbnN0IHsgaW5pdGlhbFZhbHVlczogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIGUuZm9yRWFjaChcbiAgICAgICAgKHsgdGFnOiBpIH0pID0+IHRoaXMuX2hhbmRsZUNyZWF0ZUNoaXAodGhpcy5pbnB1dCwgaSlcbiAgICAgICksIGQuZmluZE9uZShcbiAgICAgICAgRW8sXG4gICAgICAgIHRoaXMuaW5wdXQucGFyZW50Tm9kZVxuICAgICAgKS5zZXRBdHRyaWJ1dGUoTmUsIFwiXCIpLCB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShidCwgXCJcIiksIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKE5lLCBcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5hbGxDaGlwcy5sZW5ndGggPiAwICYmICh0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgKSwgdGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy50cmFuc2l0aW9uLnNwbGl0KFwiIFwiKVxuICAgICkpO1xuICB9XG4gIF9oYW5kbGVLZXlzSW5wdXRUb0VsZW1lbnQoZSkge1xuICAgIGNvbnN0IHsga2V5Q29kZTogaSwgdGFyZ2V0OiBuIH0gPSBlO1xuICAgIGlmIChuLmhhc0F0dHJpYnV0ZShKbykpIHtcbiAgICAgIGNvbnN0IG8gPSBkLmZpbmRPbmUoVG8sIG4pO1xuICAgICAgaSA9PT0gaXQgJiYgKG4uY29udGVudEVkaXRhYmxlID0gITEsIG4uY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLmNvbnRlbnRFZGl0YWJsZS5zcGxpdChcIiBcIikpLCBuLnRleHRDb250ZW50ICE9PSBcIlwiID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGguYWRkU3R5bGUobywgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIG8uY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLm9wYWNpdHkuc3BsaXQoXCIgXCIpKTtcbiAgICAgIH0sIDE2MCkgOiBuLnRleHRDb250ZW50ID09PSBcIlwiICYmIChzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbi5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMub3BhY2l0eS5zcGxpdChcIiBcIikpO1xuICAgICAgfSwgMjAwKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG4ucmVtb3ZlKCk7XG4gICAgICB9LCAzMDApKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpID09PSBpdCkge1xuICAgICAgaWYgKG4udmFsdWUgPT09IFwiXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX2hhbmRsZUNyZWF0ZUNoaXAobiwgbi52YWx1ZSksIHRoaXMuX2hhbmRsZVJlbW92ZUFjdGl2ZUNsYXNzKCksIHRoaXMubnVtYmVyQ2xpY2tzID0gdGhpcy5hbGxDaGlwcy5sZW5ndGggKyAxLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgcnYpO1xuICAgIH1cbiAgICB0aGlzLmFsbENoaXBzLmxlbmd0aCA+IDAgPyAodGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICksIHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMudHJhbnNpdGlvbi5zcGxpdChcIiBcIilcbiAgICApKSA6IHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICApO1xuICB9XG4gIF9oYW5kbGVJbnB1dFRleHQoKSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcbiAgICAgIGV2LFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImtleXVwXCIsXG4gICAgICBlLFxuICAgICAgKGkpID0+IHRoaXMuX2hhbmRsZUtleXNJbnB1dFRvRWxlbWVudChpKVxuICAgICksIGMub24odGhpcy5pbnB1dCwgXCJibHVyXCIsIChpKSA9PiB0aGlzLl9oYW5kbGVCbHVySW5wdXQoaSkpO1xuICB9XG4gIF9hcHBlbmRJbnB1dFRvRWxlbWVudChlKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShlKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gSGIodGhpcy5fb3B0aW9ucywgdGhpcy5fY2xhc3Nlcyk7XG4gICAgdGhpcy5fZWxlbWVudC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgaSk7XG4gICAgY29uc3QgbiA9IGQuZmluZE9uZShcbiAgICAgIFwiW2RhdGEtdGUtY2hpcHMtaW5wdXQtd3JhcHBlcl1cIixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHRoaXMuX2lucHV0SW5zdGFuY2UgPSBuZXcgVihcbiAgICAgIG4sXG4gICAgICB0aGlzLl9vcHRpb25zLmlucHV0T3B0aW9ucyxcbiAgICAgIHRoaXMuX29wdGlvbnMuaW5wdXRDbGFzc2VzXG4gICAgKTtcbiAgfVxuICBfaGFuZGxlQ3JlYXRlQ2hpcChlLCBpKSB7XG4gICAgY29uc3QgbiA9ICQoXCJkaXZcIiksIG8gPSB2aS5nZXRJbnN0YW5jZShuKSwgciA9IG5ldyB2aShvLCB7IHRleHQ6IGkgfSwgdGhpcy5fY2xhc3Nlcyk7XG4gICAgdGhpcy5fb3B0aW9ucy5wYXJlbnRTZWxlY3RvciAhPT0gXCJcIiA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5fb3B0aW9ucy5wYXJlbnRTZWxlY3RvcikuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIHIuYXBwZW5kQ2hpcCgpKSA6IGUuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlYmVnaW5cIiwgci5hcHBlbmRDaGlwKCkpLCBlLnZhbHVlID0gXCJcIiwgZC5maW5kKHRyKS5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBsZXQgbCA9IHZpLmdldEluc3RhbmNlKGEpO1xuICAgICAgcmV0dXJuIGwgfHwgKGwgPSBuZXcgdmkoYSwge30sIHRoaXMuX2NsYXNzZXMpKSwgbC5pbml0KCk7XG4gICAgfSksIHRoaXMuX2hhbmRsZUVkaXRhYmxlKCk7XG4gIH1cbiAgX2hhbmRsZUNoaXBzT25TZWxlY3QoKSB7XG4gICAgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgKGkpID0+IHtcbiAgICAgICAgYy50cmlnZ2VyKGUsIElsLCB7XG4gICAgICAgICAgZXZlbnQ6IGksXG4gICAgICAgICAgYWxsQ2hpcHM6IHRoaXMuYWxsQ2hpcHNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQWRkQWN0aXZlQ2xhc3NXaXRoS2VieWJvYXJkKGUpIHtcbiAgICBsZXQgaTtcbiAgICB0aGlzLmFsbENoaXBzW2UgLSAxXSA9PT0gdm9pZCAwID8gaSA9IHRoaXMuYWxsQ2hpcHNbZSAtIDJdIDogaSA9IHRoaXMuYWxsQ2hpcHNbZSAtIDFdLCBpLnNldEF0dHJpYnV0ZShidCk7XG4gIH1cbiAgX2dldENvbmZpZyhlKSB7XG4gICAgY29uc3QgaSA9IHtcbiAgICAgIC4uLnV2LFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLmVcbiAgICB9O1xuICAgIHJldHVybiBJKEhpLCBpLCBkdiksIGk7XG4gIH1cbiAgX2dldENsYXNzZXMoZSkge1xuICAgIGNvbnN0IGkgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIGUgPSB7XG4gICAgICAuLi5wdixcbiAgICAgIC4uLmksXG4gICAgICAuLi5lXG4gICAgfSwgSShIaSwgZSwgX3YpLCBlO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZShlKSB7XG4gICAgcmV0dXJuIEEuZ2V0RGF0YShlLCB4bCk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UoZSwgaSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoZSkgfHwgbmV3IHRoaXMoZSwgdHlwZW9mIGkgPT0gXCJvYmplY3RcIiA/IGkgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgVXQgPSB7XG4gIHBsdWdpbnM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBjb2xvcjogXCJyZ2IoMTAyLDEwMiwxMDIpXCJcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sIHdpID0ge1xuICBsaW5lOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uVXQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjApXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgICB0ZW5zaW9uOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICB0b29sdGlwczoge1xuICAgICAgICBpbnRlcnNlY3Q6ICExLFxuICAgICAgICBtb2RlOiBcImluZGV4XCJcbiAgICAgIH0sXG4gICAgICBkYXRhc2V0czoge1xuICAgICAgICBib3JkZXJDb2xvcjogXCJyZWRcIlxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgc3RhY2tlZDogITEsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiYXI6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5VdCxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfSxcbiAgICAgIHRvb2x0aXBzOiB7XG4gICAgICAgIGludGVyc2VjdDogITEsXG4gICAgICAgIG1vZGU6IFwiaW5kZXhcIlxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwaWU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5VdCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGFyYzogeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIiB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRvdWdobnV0OiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uVXQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBhcmM6IHsgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2xhckFyZWE6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5VdCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGFyYzogeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIiB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJhZGFyOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uVXQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMlxuICAgICAgICB9LFxuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2F0dGVyOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uVXQsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoNTksIDExMiwgMjAyLCAwLjUpXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgICB0ZW5zaW9uOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICB0b29sdGlwczoge1xuICAgICAgICBpbnRlcnNlY3Q6ICExLFxuICAgICAgICBtb2RlOiBcImluZGV4XCJcbiAgICAgIH0sXG4gICAgICBkYXRhc2V0czoge1xuICAgICAgICBib3JkZXJDb2xvcjogXCJyZWRcIlxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgc3RhY2tlZDogITAsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgc3RhY2tlZDogITEsXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBidWJibGU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5VdCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH0sXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIGJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIGRyYXdCb3JkZXI6ICExLFxuICAgICAgICAgICAgemVyb0xpbmVDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2g6IFsyXSxcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDogWzJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgZm9udENvbG9yOiBcInJnYmEoMCwwLDAsIDAuNSlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBmdiA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIG12KHQpICYmICFndih0KTtcbn07XG5mdW5jdGlvbiBtdihzKSB7XG4gIHJldHVybiAhIXMgJiYgdHlwZW9mIHMgPT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGd2KHMpIHtcbiAgdmFyIHQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocyk7XG4gIHJldHVybiB0ID09PSBcIltvYmplY3QgUmVnRXhwXVwiIHx8IHQgPT09IFwiW29iamVjdCBEYXRlXVwiIHx8IFR2KHMpO1xufVxudmFyIGJ2ID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmZvciwgdnYgPSBidiA/IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpIDogNjAxMDM7XG5mdW5jdGlvbiBUdihzKSB7XG4gIHJldHVybiBzLiQkdHlwZW9mID09PSB2djtcbn1cbmZ1bmN0aW9uIEV2KHMpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocykgPyBbXSA6IHt9O1xufVxuZnVuY3Rpb24gWWkocywgdCkge1xuICByZXR1cm4gdC5jbG9uZSAhPT0gITEgJiYgdC5pc01lcmdlYWJsZU9iamVjdChzKSA/IGlpKEV2KHMpLCBzLCB0KSA6IHM7XG59XG5mdW5jdGlvbiBDdihzLCB0LCBlKSB7XG4gIHJldHVybiBzLmNvbmNhdCh0KS5tYXAoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBZaShpLCBlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBBdihzLCB0KSB7XG4gIGlmICghdC5jdXN0b21NZXJnZSlcbiAgICByZXR1cm4gaWk7XG4gIHZhciBlID0gdC5jdXN0b21NZXJnZShzKTtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUgOiBpaTtcbn1cbmZ1bmN0aW9uIHl2KHMpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpLmZpbHRlcihmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHQpO1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gRGwocykge1xuICByZXR1cm4gT2JqZWN0LmtleXMocykuY29uY2F0KHl2KHMpKTtcbn1cbmZ1bmN0aW9uICRoKHMsIHQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdCBpbiBzO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIHd2KHMsIHQpIHtcbiAgcmV0dXJuICRoKHMsIHQpICYmICEoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocywgdCkgJiYgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgdCkpO1xufVxuZnVuY3Rpb24ga3YocywgdCwgZSkge1xuICB2YXIgaSA9IHt9O1xuICByZXR1cm4gZS5pc01lcmdlYWJsZU9iamVjdChzKSAmJiBEbChzKS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICBpW25dID0gWWkoc1tuXSwgZSk7XG4gIH0pLCBEbCh0KS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICB3dihzLCBuKSB8fCAoJGgocywgbikgJiYgZS5pc01lcmdlYWJsZU9iamVjdCh0W25dKSA/IGlbbl0gPSBBdihuLCBlKShzW25dLCB0W25dLCBlKSA6IGlbbl0gPSBZaSh0W25dLCBlKSk7XG4gIH0pLCBpO1xufVxuZnVuY3Rpb24gaWkocywgdCwgZSkge1xuICBlID0gZSB8fCB7fSwgZS5hcnJheU1lcmdlID0gZS5hcnJheU1lcmdlIHx8IEN2LCBlLmlzTWVyZ2VhYmxlT2JqZWN0ID0gZS5pc01lcmdlYWJsZU9iamVjdCB8fCBmdiwgZS5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IFlpO1xuICB2YXIgaSA9IEFycmF5LmlzQXJyYXkodCksIG4gPSBBcnJheS5pc0FycmF5KHMpLCBvID0gaSA9PT0gbjtcbiAgcmV0dXJuIG8gPyBpID8gZS5hcnJheU1lcmdlKHMsIHQsIGUpIDoga3YocywgdCwgZSkgOiBZaSh0LCBlKTtcbn1cbmlpLmFsbCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheVwiKTtcbiAgcmV0dXJuIHQucmVkdWNlKGZ1bmN0aW9uKGksIG4pIHtcbiAgICByZXR1cm4gaWkoaSwgbiwgZSk7XG4gIH0sIHt9KTtcbn07XG52YXIgeHYgPSBpaSwgZXIgPSB4djtcbmNvbnN0ICRsID0gXCJjaGFydFwiLCBTcyA9IFwidGUuY2hhcnRcIiwgT3YgPSBcImNoYXJ0XCIsIENvID0gKHMsIHQsIGUpID0+IHtcbiAgY29uc3QgaSA9IChuLCBvLCByKSA9PiB7XG4gICAgY29uc3QgYSA9IG4uc2xpY2UoKTtcbiAgICByZXR1cm4gby5mb3JFYWNoKChsLCBwKSA9PiB7XG4gICAgICB0eXBlb2YgYVtwXSA+IFwidVwiID8gYVtwXSA9IHIuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoXG4gICAgICAgIGwsXG4gICAgICAgIHJcbiAgICAgICkgOiByLmlzTWVyZ2VhYmxlT2JqZWN0KGwpID8gYVtwXSA9IGVyKG5bcF0sIGwsIHIpIDogbi5pbmRleE9mKGwpID09PSAtMSAmJiBhLnB1c2gobCk7XG4gICAgfSksIGE7XG4gIH07XG4gIHJldHVybiBlcihlW3RdLCBzLCB7XG4gICAgYXJyYXlNZXJnZTogaVxuICB9KTtcbn0sIFN2ID0ge1xuICBkYXJrVGlja3NDb2xvcjogXCIjZmZmXCIsXG4gIGRhcmtMYWJlbENvbG9yOiBcIiNmZmZcIixcbiAgZGFya0dyaWRMaW5lc0NvbG9yOiBcIiM1NTVcIixcbiAgZGFya21vZGVPZmY6IFwidW5kZWZpbmVkXCIsXG4gIGRhcmtNb2RlOiBudWxsLFxuICBkYXJrQmdDb2xvcjogXCIjMjYyNjI2XCIsXG4gIGRhcmtCZ0NvbG9yTGlnaHQ6IFwiI2ZmZlwiLFxuICBvcHRpb25zOiBudWxsXG59LCBJdiA9IHtcbiAgZGFya1RpY2tzQ29sb3I6IFwic3RyaW5nXCIsXG4gIGRhcmtMYWJlbENvbG9yOiBcInN0cmluZ1wiLFxuICBkYXJrR3JpZExpbmVzQ29sb3I6IFwic3RyaW5nXCIsXG4gIGRhcmttb2RlT2ZmOiBcIihzdHJpbmd8bnVsbClcIixcbiAgZGFya01vZGU6IFwiKHN0cmluZ3xudWxsKVwiLFxuICBkYXJrQmdDb2xvcjogXCJzdHJpbmdcIixcbiAgZGFya0JnQ29sb3JMaWdodDogXCJzdHJpbmdcIixcbiAgb3B0aW9uczogXCIob2JqZWN0fG51bGwpXCJcbn07XG5jbGFzcyBMaCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkgPSB7fSwgbiA9IHt9KSB7XG4gICAgdGhpcy5fd2FpdEZvckNoYXJ0cyh0LCBlLCBpLCBuKTtcbiAgfVxuICBhc3luYyBfZ2V0Q2hhcnRqcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBDaGFydDogdCxcbiAgICAgIEFyY0VsZW1lbnQ6IGUsXG4gICAgICBMaW5lRWxlbWVudDogaSxcbiAgICAgIEJhckVsZW1lbnQ6IG4sXG4gICAgICBQb2ludEVsZW1lbnQ6IG8sXG4gICAgICBCYXJDb250cm9sbGVyOiByLFxuICAgICAgQnViYmxlQ29udHJvbGxlcjogYSxcbiAgICAgIERvdWdobnV0Q29udHJvbGxlcjogbCxcbiAgICAgIExpbmVDb250cm9sbGVyOiBwLFxuICAgICAgUGllQ29udHJvbGxlcjogdSxcbiAgICAgIFBvbGFyQXJlYUNvbnRyb2xsZXI6IF8sXG4gICAgICBSYWRhckNvbnRyb2xsZXI6IGYsXG4gICAgICBTY2F0dGVyQ29udHJvbGxlcjogZyxcbiAgICAgIENhdGVnb3J5U2NhbGU6IG0sXG4gICAgICBMaW5lYXJTY2FsZTogYixcbiAgICAgIExvZ2FyaXRobWljU2NhbGU6IHYsXG4gICAgICBSYWRpYWxMaW5lYXJTY2FsZTogVCxcbiAgICAgIFRpbWVTY2FsZTogeSxcbiAgICAgIFRpbWVTZXJpZXNTY2FsZTogQyxcbiAgICAgIERlY2ltYXRpb246IEUsXG4gICAgICBGaWxsZXI6IHcsXG4gICAgICBMZWdlbmQ6IGssXG4gICAgICBUaXRsZTogRCxcbiAgICAgIFRvb2x0aXA6IE8sXG4gICAgICBTdWJUaXRsZTogeFxuICAgIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2NoYXJ0LmVzLmpzXCIpLnRoZW4oKEwpID0+IEwuZik7XG4gICAgcmV0dXJuIHQucmVnaXN0ZXIoXG4gICAgICBlLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBvLFxuICAgICAgcixcbiAgICAgIGEsXG4gICAgICBsLFxuICAgICAgcCxcbiAgICAgIHUsXG4gICAgICBfLFxuICAgICAgZixcbiAgICAgIGcsXG4gICAgICBtLFxuICAgICAgYixcbiAgICAgIHYsXG4gICAgICBULFxuICAgICAgeSxcbiAgICAgIEMsXG4gICAgICBFLFxuICAgICAgdyxcbiAgICAgIGssXG4gICAgICBELFxuICAgICAgTyxcbiAgICAgIHhcbiAgICApLCB0O1xuICB9XG4gIGFzeW5jIF9nZXRDaGFydERhdGFMYWJlbHMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IGltcG9ydChcIi4vY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5lcy5qc1wiKTtcbiAgfVxuICBhc3luYyBfd2FpdEZvckNoYXJ0cyh0LCBlLCBpID0ge30sIG4gPSB7fSkge1xuICAgIGlmICh0aGlzLl9DaGFydGpzID0gYXdhaXQgdGhpcy5fZ2V0Q2hhcnRqcygpLCB0aGlzLl9DaGFydERhdGFMYWJlbHMgPSBhd2FpdCB0aGlzLl9nZXRDaGFydERhdGFMYWJlbHMoKSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2RhdGEgPSBlLCB0aGlzLl9vcHRpb25zID0gaSwgdGhpcy5fdHlwZSA9IGUudHlwZSwgdGhpcy5fY2FudmFzID0gbnVsbCwgdGhpcy5fY2hhcnQgPSBudWxsLCB0aGlzLl9kYXJrT3B0aW9ucyA9IHRoaXMuX2dldERhcmtDb25maWcobiksIHRoaXMuX2RhcmtNb2RlQ2xhc3NDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaHRtbFwiKSwgdGhpcy5fcHJldkNvbmZpZyA9IG51bGwsIHRoaXMuX29ic2VydmVyID0gbnVsbCwgdGhpcy5fZWxlbWVudCAmJiAoQS5zZXREYXRhKHQsIFNzLCB0aGlzKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBPdiksIHRoaXMuX2NoYXJ0Q29uc3RydWN0b3IoKSksIHRoaXMuX2RhcmtPcHRpb25zLmRhcmttb2RlT2ZmICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5fZGFya09wdGlvbnMuZGFya01vZGUgPT09IFwiZGFya1wiID8gXCJkYXJrXCIgOiB0aGlzLl9kYXJrT3B0aW9ucy5kYXJrTW9kZSA9PT0gXCJsaWdodFwiID8gXCJsaWdodFwiIDogdGhpcy5zeXN0ZW1Db2xvck1vZGU7XG4gICAgICB0aGlzLl9oYW5kbGVNb2RlKG8pLCB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29ic2VydmVyQ2FsbGJhY2suYmluZCh0aGlzKSksIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZGFya01vZGVDbGFzc0NvbnRhaW5lciwge1xuICAgICAgICBhdHRyaWJ1dGVzOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiAkbDtcbiAgfVxuICBnZXQgc3lzdGVtQ29sb3JNb2RlKCkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UudGhlbWUgfHwgKHRoaXMuX2RhcmtNb2RlQ2xhc3NDb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGFya1wiKSA/IFwiZGFya1wiIDogXCJsaWdodFwiKTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCksIEEucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBTcyksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIHVwZGF0ZSh0LCBlKSB7XG4gICAgdCAmJiAodGhpcy5fZGF0YSA9IHsgLi4udGhpcy5fZGF0YSwgLi4udCB9LCB0aGlzLl9jaGFydC5kYXRhID0gdGhpcy5fZGF0YSk7XG4gICAgY29uc3QgaSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgIGUsXG4gICAgICBcIm9wdGlvbnNcIlxuICAgICkgPyBlIDogeyBvcHRpb25zOiB7IC4uLmUgfSB9O1xuICAgIHRoaXMuX29wdGlvbnMgPSBlcih0aGlzLl9vcHRpb25zLCBpKSwgdGhpcy5fY2hhcnQub3B0aW9ucyA9IENvKFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX3R5cGUsXG4gICAgICB3aVxuICAgICkub3B0aW9ucywgdGhpcy5fY2hhcnQudXBkYXRlKCk7XG4gIH1cbiAgc2V0VGhlbWUodCkge1xuICAgIHQgIT09IFwiZGFya1wiICYmIHQgIT09IFwibGlnaHRcIiB8fCAhdGhpcy5fZGF0YSB8fCB0aGlzLl9oYW5kbGVNb2RlKHQpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldERhcmtDb25maWcodCkge1xuICAgIGxldCBlID0ge307XG4gICAgY29uc3QgaSA9IGguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgT2JqZWN0LmtleXMoaSkuZm9yRWFjaChcbiAgICAgIChwKSA9PiBwLnN0YXJ0c1dpdGgoXCJkYXJrXCIpICYmIChlW3BdID0gaVtwXSlcbiAgICApLCBlID0ge1xuICAgICAgLi4uU3YsXG4gICAgICAuLi5lXG4gICAgfTtcbiAgICBjb25zdCBuID0ge1xuICAgICAgeToge1xuICAgICAgICB0aWNrczoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtUaWNrc0NvbG9yXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrR3JpZExpbmVzQ29sb3JcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHg6IHtcbiAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrVGlja3NDb2xvclxuICAgICAgICB9LFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya0dyaWRMaW5lc0NvbG9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBvID0ge1xuICAgICAgcjoge1xuICAgICAgICB0aWNrczoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtUaWNrc0NvbG9yLFxuICAgICAgICAgIGJhY2tkcm9wQ29sb3I6IGUuZGFya0JnQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtHcmlkTGluZXNDb2xvclxuICAgICAgICB9LFxuICAgICAgICBwb2ludExhYmVsczoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtUaWNrc0NvbG9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBsID0ge1xuICAgICAgc2NhbGVzOiBbXCJwaWVcIiwgXCJkb3VnaG51dFwiLCBcInBvbGFyQXJlYVwiLCBcInJhZGFyXCJdLmluY2x1ZGVzKHRoaXMuX3R5cGUpID8gW1wicG9sYXJBcmVhXCIsIFwicmFkYXJcIl0uaW5jbHVkZXModGhpcy5fdHlwZSkgPyBvIDoge30gOiBuLFxuICAgICAgcGx1Z2luczoge1xuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgIGNvbG9yOiBlLmRhcmtMYWJlbENvbG9yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmUsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIC4uLmxcbiAgICAgIH0sXG4gICAgICAuLi50XG4gICAgfSwgSSgkbCwgdCwgSXYpLCB0O1xuICB9XG4gIF9jaGFydENvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVDYW52YXMoKTtcbiAgICAgIGNvbnN0IHQgPSBDbyh0aGlzLl9vcHRpb25zLCB0aGlzLl90eXBlLCB3aSksIGUgPSBbXTtcbiAgICAgIHQuZGF0YUxhYmVsc1BsdWdpbiAmJiBlLnB1c2godGhpcy5fQ2hhcnREYXRhTGFiZWxzLmRlZmF1bHQpLCB0aGlzLl9wcmV2Q29uZmlnID0gdCwgdGhpcy5fY2hhcnQgPSBuZXcgdGhpcy5fQ2hhcnRqcyh0aGlzLl9jYW52YXMsIHtcbiAgICAgICAgLi4udGhpcy5fZGF0YSxcbiAgICAgICAgLi4udCxcbiAgICAgICAgcGx1Z2luczogZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9jcmVhdGVDYW52YXMoKSB7XG4gICAgdGhpcy5fY2FudmFzIHx8ICh0aGlzLl9lbGVtZW50Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiID8gdGhpcy5fY2FudmFzID0gdGhpcy5fZWxlbWVudCA6ICh0aGlzLl9jYW52YXMgPSAkKFwiY2FudmFzXCIpLCB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcykpKTtcbiAgfVxuICBfaGFuZGxlTW9kZSh0KSB7XG4gICAgdCA9PT0gXCJkYXJrXCIgPyAodGhpcy5fY2hhbmdlRGF0YXNldEJvcmRlckNvbG9yKCksIHRoaXMudXBkYXRlKG51bGwsIHRoaXMuX2RhcmtPcHRpb25zLm9wdGlvbnMpKSA6ICh0aGlzLl9jaGFuZ2VEYXRhc2V0Qm9yZGVyQ29sb3IoITEpLCB0aGlzLl9wcmV2Q29uZmlnICYmIHRoaXMudXBkYXRlKG51bGwsIHRoaXMuX3ByZXZDb25maWcpKTtcbiAgfVxuICBfb2JzZXJ2ZXJDYWxsYmFjayh0KSB7XG4gICAgZm9yIChjb25zdCBlIG9mIHQpXG4gICAgICBlLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiICYmIHRoaXMuX2hhbmRsZU1vZGUodGhpcy5zeXN0ZW1Db2xvck1vZGUpO1xuICB9XG4gIF9jaGFuZ2VEYXRhc2V0Qm9yZGVyQ29sb3IodCA9ICEwKSB7XG4gICAgWy4uLnRoaXMuX2RhdGEuZGF0YS5kYXRhc2V0c10uZm9yRWFjaChcbiAgICAgIChlKSA9PiBbXCJwaWVcIiwgXCJkb3VnaG51dFwiLCBcInBvbGFyQXJlYVwiXS5pbmNsdWRlcyh0aGlzLl90eXBlKSAmJiAoZS5ib3JkZXJDb2xvciA9IHQgPyB0aGlzLl9kYXJrT3B0aW9ucy5kYXJrQmdDb2xvciA6IHRoaXMuX2RhcmtPcHRpb25zLmRhcmtCZ0NvbG9yTGlnaHQpXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUsIGkpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IG4gPSBBLmdldERhdGEodGhpcywgU3MpO1xuICAgICAgaWYgKCEoIW4gJiYgL2Rpc3Bvc2UvLnRlc3QodCkpKSB7XG4gICAgICAgIGlmICghbikge1xuICAgICAgICAgIGNvbnN0IG8gPSBlID8gQ28oZSwgaSwgd2kpIDogd2lbaV07XG4gICAgICAgICAgbiA9IG5ldyBMaCh0aGlzLCB7XG4gICAgICAgICAgICAuLi50LFxuICAgICAgICAgICAgLi4ub1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuW3RdID4gXCJ1XCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgICBuW3RdKGUsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIFNzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG4vKiFcbiAqIHBlcmZlY3Qtc2Nyb2xsYmFyIHYxLjUuM1xuICogQ29weXJpZ2h0IDIwMjEgSHl1bmplIEp1biwgTURCb290c3RyYXAgYW5kIENvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgTUlUXG4gKi9cbmZ1bmN0aW9uIE50KHMpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocyk7XG59XG5mdW5jdGlvbiBjdChzLCB0KSB7XG4gIGZvciAodmFyIGUgaW4gdCkge1xuICAgIHZhciBpID0gdFtlXTtcbiAgICB0eXBlb2YgaSA9PSBcIm51bWJlclwiICYmIChpID0gaSArIFwicHhcIiksIHMuc3R5bGVbZV0gPSBpO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gSXMocykge1xuICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHJldHVybiB0LmNsYXNzTmFtZSA9IHMsIHQ7XG59XG52YXIgTGwgPSB0eXBlb2YgRWxlbWVudCA8IFwidVwiICYmIChFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IpO1xuZnVuY3Rpb24gSnQocywgdCkge1xuICBpZiAoIUxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVsZW1lbnQgbWF0Y2hpbmcgbWV0aG9kIHN1cHBvcnRlZFwiKTtcbiAgcmV0dXJuIExsLmNhbGwocywgdCk7XG59XG5mdW5jdGlvbiBZZShzKSB7XG4gIHMucmVtb3ZlID8gcy5yZW1vdmUoKSA6IHMucGFyZW50Tm9kZSAmJiBzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocyk7XG59XG5mdW5jdGlvbiBObChzLCB0KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoXG4gICAgcy5jaGlsZHJlbixcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gSnQoZSwgdCk7XG4gICAgfVxuICApO1xufVxudmFyIGogPSB7XG4gIG1haW46IFwicHNcIixcbiAgcnRsOiBcInBzX19ydGxcIixcbiAgZWxlbWVudDoge1xuICAgIHRodW1iOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gXCJwc19fdGh1bWItXCIgKyBzO1xuICAgIH0sXG4gICAgcmFpbDogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwicHNfX3JhaWwtXCIgKyBzO1xuICAgIH0sXG4gICAgY29uc3VtaW5nOiBcInBzX19jaGlsZC0tY29uc3VtZVwiXG4gIH0sXG4gIHN0YXRlOiB7XG4gICAgZm9jdXM6IFwicHMtLWZvY3VzXCIsXG4gICAgY2xpY2tpbmc6IFwicHMtLWNsaWNraW5nXCIsXG4gICAgYWN0aXZlOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gXCJwcy0tYWN0aXZlLVwiICsgcztcbiAgICB9LFxuICAgIHNjcm9sbGluZzogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwicHMtLXNjcm9sbGluZy1cIiArIHM7XG4gICAgfVxuICB9XG59LCBOaCA9IHsgeDogbnVsbCwgeTogbnVsbCB9O1xuZnVuY3Rpb24gTWgocywgdCkge1xuICB2YXIgZSA9IHMuZWxlbWVudC5jbGFzc0xpc3QsIGkgPSBqLnN0YXRlLnNjcm9sbGluZyh0KTtcbiAgZS5jb250YWlucyhpKSA/IGNsZWFyVGltZW91dChOaFt0XSkgOiBlLmFkZChpKTtcbn1cbmZ1bmN0aW9uIFJoKHMsIHQpIHtcbiAgTmhbdF0gPSBzZXRUaW1lb3V0KFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHMuaXNBbGl2ZSAmJiBzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShqLnN0YXRlLnNjcm9sbGluZyh0KSk7XG4gICAgfSxcbiAgICBzLnNldHRpbmdzLnNjcm9sbGluZ1RocmVzaG9sZFxuICApO1xufVxuZnVuY3Rpb24gRHYocywgdCkge1xuICBNaChzLCB0KSwgUmgocywgdCk7XG59XG52YXIgcWkgPSBmdW5jdGlvbih0KSB7XG4gIHRoaXMuZWxlbWVudCA9IHQsIHRoaXMuaGFuZGxlcnMgPSB7fTtcbn0sIFBoID0geyBpc0VtcHR5OiB7IGNvbmZpZ3VyYWJsZTogITAgfSB9O1xucWkucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbih0LCBlKSB7XG4gIHR5cGVvZiB0aGlzLmhhbmRsZXJzW3RdID4gXCJ1XCIgJiYgKHRoaXMuaGFuZGxlcnNbdF0gPSBbXSksIHRoaXMuaGFuZGxlcnNbdF0ucHVzaChlKSwgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodCwgZSwgITEpO1xufTtcbnFpLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBpID0gdGhpcztcbiAgdGhpcy5oYW5kbGVyc1t0XSA9IHRoaXMuaGFuZGxlcnNbdF0uZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZSAmJiBuICE9PSBlID8gITAgOiAoaS5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgbiwgITEpLCAhMSk7XG4gIH0pO1xufTtcbnFpLnByb3RvdHlwZS51bmJpbmRBbGwgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgdCBpbiB0aGlzLmhhbmRsZXJzKVxuICAgIHRoaXMudW5iaW5kKHQpO1xufTtcblBoLmlzRW1wdHkuZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzID0gdGhpcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaGFuZGxlcnMpLmV2ZXJ5KFxuICAgIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBzLmhhbmRsZXJzW3RdLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocWkucHJvdG90eXBlLCBQaCk7XG52YXIgbGkgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG59O1xubGkucHJvdG90eXBlLmV2ZW50RWxlbWVudCA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSB0aGlzLmV2ZW50RWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gaS5lbGVtZW50ID09PSB0O1xuICB9KVswXTtcbiAgcmV0dXJuIGUgfHwgKGUgPSBuZXcgcWkodCksIHRoaXMuZXZlbnRFbGVtZW50cy5wdXNoKGUpKSwgZTtcbn07XG5saS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgdGhpcy5ldmVudEVsZW1lbnQodCkuYmluZChlLCBpKTtcbn07XG5saS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICB2YXIgbiA9IHRoaXMuZXZlbnRFbGVtZW50KHQpO1xuICBuLnVuYmluZChlLCBpKSwgbi5pc0VtcHR5ICYmIHRoaXMuZXZlbnRFbGVtZW50cy5zcGxpY2UodGhpcy5ldmVudEVsZW1lbnRzLmluZGV4T2YobiksIDEpO1xufTtcbmxpLnByb3RvdHlwZS51bmJpbmRBbGwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ldmVudEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0LnVuYmluZEFsbCgpO1xuICB9KSwgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG59O1xubGkucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gIHZhciBuID0gdGhpcy5ldmVudEVsZW1lbnQodCksIG8gPSBmdW5jdGlvbihyKSB7XG4gICAgbi51bmJpbmQoZSwgbyksIGkocik7XG4gIH07XG4gIG4uYmluZChlLCBvKTtcbn07XG5mdW5jdGlvbiBEcyhzKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KHMpO1xuICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gIHJldHVybiB0LmluaXRDdXN0b21FdmVudChzLCAhMSwgITEsIHZvaWQgMCksIHQ7XG59XG5mdW5jdGlvbiBmbihzLCB0LCBlLCBpLCBuKSB7XG4gIGkgPT09IHZvaWQgMCAmJiAoaSA9ICEwKSwgbiA9PT0gdm9pZCAwICYmIChuID0gITEpO1xuICB2YXIgbztcbiAgaWYgKHQgPT09IFwidG9wXCIpXG4gICAgbyA9IFtcbiAgICAgIFwiY29udGVudEhlaWdodFwiLFxuICAgICAgXCJjb250YWluZXJIZWlnaHRcIixcbiAgICAgIFwic2Nyb2xsVG9wXCIsXG4gICAgICBcInlcIixcbiAgICAgIFwidXBcIixcbiAgICAgIFwiZG93blwiXG4gICAgXTtcbiAgZWxzZSBpZiAodCA9PT0gXCJsZWZ0XCIpXG4gICAgbyA9IFtcbiAgICAgIFwiY29udGVudFdpZHRoXCIsXG4gICAgICBcImNvbnRhaW5lcldpZHRoXCIsXG4gICAgICBcInNjcm9sbExlZnRcIixcbiAgICAgIFwieFwiLFxuICAgICAgXCJsZWZ0XCIsXG4gICAgICBcInJpZ2h0XCJcbiAgICBdO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQSBwcm9wZXIgYXhpcyBzaG91bGQgYmUgcHJvdmlkZWRcIik7XG4gICR2KHMsIGUsIG8sIGksIG4pO1xufVxuZnVuY3Rpb24gJHYocywgdCwgZSwgaSwgbikge1xuICB2YXIgbyA9IGVbMF0sIHIgPSBlWzFdLCBhID0gZVsyXSwgbCA9IGVbM10sIHAgPSBlWzRdLCB1ID0gZVs1XTtcbiAgaSA9PT0gdm9pZCAwICYmIChpID0gITApLCBuID09PSB2b2lkIDAgJiYgKG4gPSAhMSk7XG4gIHZhciBfID0gcy5lbGVtZW50O1xuICBzLnJlYWNoW2xdID0gbnVsbCwgX1thXSA8IDEgJiYgKHMucmVhY2hbbF0gPSBcInN0YXJ0XCIpLCBfW2FdID4gc1tvXSAtIHNbcl0gLSAxICYmIChzLnJlYWNoW2xdID0gXCJlbmRcIiksIHQgJiYgKF8uZGlzcGF0Y2hFdmVudChEcyhcInBzLXNjcm9sbC1cIiArIGwpKSwgdCA8IDAgPyBfLmRpc3BhdGNoRXZlbnQoRHMoXCJwcy1zY3JvbGwtXCIgKyBwKSkgOiB0ID4gMCAmJiBfLmRpc3BhdGNoRXZlbnQoRHMoXCJwcy1zY3JvbGwtXCIgKyB1KSksIGkgJiYgRHYocywgbCkpLCBzLnJlYWNoW2xdICYmICh0IHx8IG4pICYmIF8uZGlzcGF0Y2hFdmVudChEcyhcInBzLVwiICsgbCArIFwiLXJlYWNoLVwiICsgcy5yZWFjaFtsXSkpO1xufVxuZnVuY3Rpb24gRihzKSB7XG4gIHJldHVybiBwYXJzZUludChzLCAxMCkgfHwgMDtcbn1cbmZ1bmN0aW9uIEx2KHMpIHtcbiAgcmV0dXJuIEp0KHMsIFwiaW5wdXQsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHwgSnQocywgXCJzZWxlY3QsW2NvbnRlbnRlZGl0YWJsZV1cIikgfHwgSnQocywgXCJ0ZXh0YXJlYSxbY29udGVudGVkaXRhYmxlXVwiKSB8fCBKdChzLCBcImJ1dHRvbixbY29udGVudGVkaXRhYmxlXVwiKTtcbn1cbmZ1bmN0aW9uIE52KHMpIHtcbiAgdmFyIHQgPSBOdChzKTtcbiAgcmV0dXJuIEYodC53aWR0aCkgKyBGKHQucGFkZGluZ0xlZnQpICsgRih0LnBhZGRpbmdSaWdodCkgKyBGKHQuYm9yZGVyTGVmdFdpZHRoKSArIEYodC5ib3JkZXJSaWdodFdpZHRoKTtcbn1cbnZhciBWZSA9IHtcbiAgaXNXZWJLaXQ6IHR5cGVvZiBkb2N1bWVudCA8IFwidVwiICYmIFwiV2Via2l0QXBwZWFyYW5jZVwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcbiAgc3VwcG9ydHNUb3VjaDogdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIChcIm9udG91Y2hzdGFydFwiIGluIHdpbmRvdyB8fCBcIm1heFRvdWNoUG9pbnRzXCIgaW4gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSxcbiAgc3VwcG9ydHNJZVBvaW50ZXI6IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyxcbiAgaXNDaHJvbWU6IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiAvQ2hyb21lL2kudGVzdChuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudClcbn07XG5mdW5jdGlvbiBIdChzKSB7XG4gIHZhciB0ID0gcy5lbGVtZW50LCBlID0gTWF0aC5mbG9vcih0LnNjcm9sbFRvcCksIGkgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBzLmNvbnRhaW5lcldpZHRoID0gTWF0aC5yb3VuZChpLndpZHRoKSwgcy5jb250YWluZXJIZWlnaHQgPSBNYXRoLnJvdW5kKGkuaGVpZ2h0KSwgcy5jb250ZW50V2lkdGggPSB0LnNjcm9sbFdpZHRoLCBzLmNvbnRlbnRIZWlnaHQgPSB0LnNjcm9sbEhlaWdodCwgdC5jb250YWlucyhzLnNjcm9sbGJhclhSYWlsKSB8fCAoTmwodCwgai5lbGVtZW50LnJhaWwoXCJ4XCIpKS5mb3JFYWNoKFxuICAgIGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBZZShuKTtcbiAgICB9XG4gICksIHQuYXBwZW5kQ2hpbGQocy5zY3JvbGxiYXJYUmFpbCkpLCB0LmNvbnRhaW5zKHMuc2Nyb2xsYmFyWVJhaWwpIHx8IChObCh0LCBqLmVsZW1lbnQucmFpbChcInlcIikpLmZvckVhY2goXG4gICAgZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIFllKG4pO1xuICAgIH1cbiAgKSwgdC5hcHBlbmRDaGlsZChzLnNjcm9sbGJhcllSYWlsKSksICFzLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWCAmJiBzLmNvbnRhaW5lcldpZHRoICsgcy5zZXR0aW5ncy5zY3JvbGxYTWFyZ2luT2Zmc2V0IDwgcy5jb250ZW50V2lkdGggPyAocy5zY3JvbGxiYXJYQWN0aXZlID0gITAsIHMucmFpbFhXaWR0aCA9IHMuY29udGFpbmVyV2lkdGggLSBzLnJhaWxYTWFyZ2luV2lkdGgsIHMucmFpbFhSYXRpbyA9IHMuY29udGFpbmVyV2lkdGggLyBzLnJhaWxYV2lkdGgsIHMuc2Nyb2xsYmFyWFdpZHRoID0gTWwoXG4gICAgcyxcbiAgICBGKHMucmFpbFhXaWR0aCAqIHMuY29udGFpbmVyV2lkdGggLyBzLmNvbnRlbnRXaWR0aClcbiAgKSwgcy5zY3JvbGxiYXJYTGVmdCA9IEYoXG4gICAgKHMubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgdC5zY3JvbGxMZWZ0KSAqIChzLnJhaWxYV2lkdGggLSBzLnNjcm9sbGJhclhXaWR0aCkgLyAocy5jb250ZW50V2lkdGggLSBzLmNvbnRhaW5lcldpZHRoKVxuICApKSA6IHMuc2Nyb2xsYmFyWEFjdGl2ZSA9ICExLCAhcy5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFkgJiYgcy5jb250YWluZXJIZWlnaHQgKyBzLnNldHRpbmdzLnNjcm9sbFlNYXJnaW5PZmZzZXQgPCBzLmNvbnRlbnRIZWlnaHQgPyAocy5zY3JvbGxiYXJZQWN0aXZlID0gITAsIHMucmFpbFlIZWlnaHQgPSBzLmNvbnRhaW5lckhlaWdodCAtIHMucmFpbFlNYXJnaW5IZWlnaHQsIHMucmFpbFlSYXRpbyA9IHMuY29udGFpbmVySGVpZ2h0IC8gcy5yYWlsWUhlaWdodCwgcy5zY3JvbGxiYXJZSGVpZ2h0ID0gTWwoXG4gICAgcyxcbiAgICBGKHMucmFpbFlIZWlnaHQgKiBzLmNvbnRhaW5lckhlaWdodCAvIHMuY29udGVudEhlaWdodClcbiAgKSwgcy5zY3JvbGxiYXJZVG9wID0gRihcbiAgICBlICogKHMucmFpbFlIZWlnaHQgLSBzLnNjcm9sbGJhcllIZWlnaHQpIC8gKHMuY29udGVudEhlaWdodCAtIHMuY29udGFpbmVySGVpZ2h0KVxuICApKSA6IHMuc2Nyb2xsYmFyWUFjdGl2ZSA9ICExLCBzLnNjcm9sbGJhclhMZWZ0ID49IHMucmFpbFhXaWR0aCAtIHMuc2Nyb2xsYmFyWFdpZHRoICYmIChzLnNjcm9sbGJhclhMZWZ0ID0gcy5yYWlsWFdpZHRoIC0gcy5zY3JvbGxiYXJYV2lkdGgpLCBzLnNjcm9sbGJhcllUb3AgPj0gcy5yYWlsWUhlaWdodCAtIHMuc2Nyb2xsYmFyWUhlaWdodCAmJiAocy5zY3JvbGxiYXJZVG9wID0gcy5yYWlsWUhlaWdodCAtIHMuc2Nyb2xsYmFyWUhlaWdodCksIE12KHQsIHMpLCBzLnNjcm9sbGJhclhBY3RpdmUgPyB0LmNsYXNzTGlzdC5hZGQoai5zdGF0ZS5hY3RpdmUoXCJ4XCIpKSA6ICh0LmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5hY3RpdmUoXCJ4XCIpKSwgcy5zY3JvbGxiYXJYV2lkdGggPSAwLCBzLnNjcm9sbGJhclhMZWZ0ID0gMCwgdC5zY3JvbGxMZWZ0ID0gcy5pc1J0bCA9PT0gITAgPyBzLmNvbnRlbnRXaWR0aCA6IDApLCBzLnNjcm9sbGJhcllBY3RpdmUgPyB0LmNsYXNzTGlzdC5hZGQoai5zdGF0ZS5hY3RpdmUoXCJ5XCIpKSA6ICh0LmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5hY3RpdmUoXCJ5XCIpKSwgcy5zY3JvbGxiYXJZSGVpZ2h0ID0gMCwgcy5zY3JvbGxiYXJZVG9wID0gMCwgdC5zY3JvbGxUb3AgPSAwKTtcbn1cbmZ1bmN0aW9uIE1sKHMsIHQpIHtcbiAgcmV0dXJuIHMuc2V0dGluZ3MubWluU2Nyb2xsYmFyTGVuZ3RoICYmICh0ID0gTWF0aC5tYXgodCwgcy5zZXR0aW5ncy5taW5TY3JvbGxiYXJMZW5ndGgpKSwgcy5zZXR0aW5ncy5tYXhTY3JvbGxiYXJMZW5ndGggJiYgKHQgPSBNYXRoLm1pbih0LCBzLnNldHRpbmdzLm1heFNjcm9sbGJhckxlbmd0aCkpLCB0O1xufVxuZnVuY3Rpb24gTXYocywgdCkge1xuICB2YXIgZSA9IHsgd2lkdGg6IHQucmFpbFhXaWR0aCB9LCBpID0gTWF0aC5mbG9vcihzLnNjcm9sbFRvcCk7XG4gIHQuaXNSdGwgPyBlLmxlZnQgPSB0Lm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIHMuc2Nyb2xsTGVmdCArIHQuY29udGFpbmVyV2lkdGggLSB0LmNvbnRlbnRXaWR0aCA6IGUubGVmdCA9IHMuc2Nyb2xsTGVmdCwgdC5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA/IGUuYm90dG9tID0gdC5zY3JvbGxiYXJYQm90dG9tIC0gaSA6IGUudG9wID0gdC5zY3JvbGxiYXJYVG9wICsgaSwgY3QodC5zY3JvbGxiYXJYUmFpbCwgZSk7XG4gIHZhciBuID0geyB0b3A6IGksIGhlaWdodDogdC5yYWlsWUhlaWdodCB9O1xuICB0LmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQgPyB0LmlzUnRsID8gbi5yaWdodCA9IHQuY29udGVudFdpZHRoIC0gKHQubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgcy5zY3JvbGxMZWZ0KSAtIHQuc2Nyb2xsYmFyWVJpZ2h0IC0gdC5zY3JvbGxiYXJZT3V0ZXJXaWR0aCAtIDkgOiBuLnJpZ2h0ID0gdC5zY3JvbGxiYXJZUmlnaHQgLSBzLnNjcm9sbExlZnQgOiB0LmlzUnRsID8gbi5sZWZ0ID0gdC5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBzLnNjcm9sbExlZnQgKyB0LmNvbnRhaW5lcldpZHRoICogMiAtIHQuY29udGVudFdpZHRoIC0gdC5zY3JvbGxiYXJZTGVmdCAtIHQuc2Nyb2xsYmFyWU91dGVyV2lkdGggOiBuLmxlZnQgPSB0LnNjcm9sbGJhcllMZWZ0ICsgcy5zY3JvbGxMZWZ0LCBjdCh0LnNjcm9sbGJhcllSYWlsLCBuKSwgY3QodC5zY3JvbGxiYXJYLCB7XG4gICAgbGVmdDogdC5zY3JvbGxiYXJYTGVmdCxcbiAgICB3aWR0aDogdC5zY3JvbGxiYXJYV2lkdGggLSB0LnJhaWxCb3JkZXJYV2lkdGhcbiAgfSksIGN0KHQuc2Nyb2xsYmFyWSwge1xuICAgIHRvcDogdC5zY3JvbGxiYXJZVG9wLFxuICAgIGhlaWdodDogdC5zY3JvbGxiYXJZSGVpZ2h0IC0gdC5yYWlsQm9yZGVyWVdpZHRoXG4gIH0pO1xufVxuZnVuY3Rpb24gUnYocykge1xuICBzLmVsZW1lbnQsIHMuZXZlbnQuYmluZChzLnNjcm9sbGJhclksIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSksIHMuZXZlbnQuYmluZChzLnNjcm9sbGJhcllSYWlsLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0LnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0IC0gcy5zY3JvbGxiYXJZUmFpbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AsIGkgPSBlID4gcy5zY3JvbGxiYXJZVG9wID8gMSA6IC0xO1xuICAgIHMuZWxlbWVudC5zY3JvbGxUb3AgKz0gaSAqIHMuY29udGFpbmVySGVpZ2h0LCBIdChzKSwgdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSksIHMuZXZlbnQuYmluZChzLnNjcm9sbGJhclgsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSksIHMuZXZlbnQuYmluZChzLnNjcm9sbGJhclhSYWlsLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSB0LnBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0IC0gcy5zY3JvbGxiYXJYUmFpbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LCBpID0gZSA+IHMuc2Nyb2xsYmFyWExlZnQgPyAxIDogLTE7XG4gICAgcy5lbGVtZW50LnNjcm9sbExlZnQgKz0gaSAqIHMuY29udGFpbmVyV2lkdGgsIEh0KHMpLCB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFB2KHMpIHtcbiAgUmwocywgW1xuICAgIFwiY29udGFpbmVyV2lkdGhcIixcbiAgICBcImNvbnRlbnRXaWR0aFwiLFxuICAgIFwicGFnZVhcIixcbiAgICBcInJhaWxYV2lkdGhcIixcbiAgICBcInNjcm9sbGJhclhcIixcbiAgICBcInNjcm9sbGJhclhXaWR0aFwiLFxuICAgIFwic2Nyb2xsTGVmdFwiLFxuICAgIFwieFwiLFxuICAgIFwic2Nyb2xsYmFyWFJhaWxcIlxuICBdKSwgUmwocywgW1xuICAgIFwiY29udGFpbmVySGVpZ2h0XCIsXG4gICAgXCJjb250ZW50SGVpZ2h0XCIsXG4gICAgXCJwYWdlWVwiLFxuICAgIFwicmFpbFlIZWlnaHRcIixcbiAgICBcInNjcm9sbGJhcllcIixcbiAgICBcInNjcm9sbGJhcllIZWlnaHRcIixcbiAgICBcInNjcm9sbFRvcFwiLFxuICAgIFwieVwiLFxuICAgIFwic2Nyb2xsYmFyWVJhaWxcIlxuICBdKTtcbn1cbmZ1bmN0aW9uIFJsKHMsIHQpIHtcbiAgdmFyIGUgPSB0WzBdLCBpID0gdFsxXSwgbiA9IHRbMl0sIG8gPSB0WzNdLCByID0gdFs0XSwgYSA9IHRbNV0sIGwgPSB0WzZdLCBwID0gdFs3XSwgdSA9IHRbOF0sIF8gPSBzLmVsZW1lbnQsIGYgPSBudWxsLCBnID0gbnVsbCwgbSA9IG51bGw7XG4gIGZ1bmN0aW9uIGIoeSkge1xuICAgIHkudG91Y2hlcyAmJiB5LnRvdWNoZXNbMF0gJiYgKHlbbl0gPSB5LnRvdWNoZXNbMF0ucGFnZVkpLCBfW2xdID0gZiArIG0gKiAoeVtuXSAtIGcpLCBNaChzLCBwKSwgSHQocyksIHkuc3RvcFByb3BhZ2F0aW9uKCksIHkudHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIikgJiYgeS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPiAxICYmIHkucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBmdW5jdGlvbiB2KCkge1xuICAgIFJoKHMsIHApLCBzW3VdLmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5jbGlja2luZyksIHMuZXZlbnQudW5iaW5kKHMub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgYik7XG4gIH1cbiAgZnVuY3Rpb24gVCh5LCBDKSB7XG4gICAgZiA9IF9bbF0sIEMgJiYgeS50b3VjaGVzICYmICh5W25dID0geS50b3VjaGVzWzBdLnBhZ2VZKSwgZyA9IHlbbl0sIG0gPSAoc1tpXSAtIHNbZV0pIC8gKHNbb10gLSBzW2FdKSwgQyA/IHMuZXZlbnQuYmluZChzLm93bmVyRG9jdW1lbnQsIFwidG91Y2htb3ZlXCIsIGIpIDogKHMuZXZlbnQuYmluZChzLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIGIpLCBzLmV2ZW50Lm9uY2Uocy5vd25lckRvY3VtZW50LCBcIm1vdXNldXBcIiwgdiksIHkucHJldmVudERlZmF1bHQoKSksIHNbdV0uY2xhc3NMaXN0LmFkZChqLnN0YXRlLmNsaWNraW5nKSwgeS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICBzLmV2ZW50LmJpbmQoc1tyXSwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oeSkge1xuICAgIFQoeSk7XG4gIH0pLCBzLmV2ZW50LmJpbmQoc1tyXSwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uKHkpIHtcbiAgICBUKHksICEwKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBCdihzKSB7XG4gIHZhciB0ID0gcy5lbGVtZW50LCBlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEp0KHQsIFwiOmhvdmVyXCIpO1xuICB9LCBpID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEp0KHMuc2Nyb2xsYmFyWCwgXCI6Zm9jdXNcIikgfHwgSnQocy5zY3JvbGxiYXJZLCBcIjpmb2N1c1wiKTtcbiAgfTtcbiAgZnVuY3Rpb24gbihvLCByKSB7XG4gICAgdmFyIGEgPSBNYXRoLmZsb29yKHQuc2Nyb2xsVG9wKTtcbiAgICBpZiAobyA9PT0gMCkge1xuICAgICAgaWYgKCFzLnNjcm9sbGJhcllBY3RpdmUpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChhID09PSAwICYmIHIgPiAwIHx8IGEgPj0gcy5jb250ZW50SGVpZ2h0IC0gcy5jb250YWluZXJIZWlnaHQgJiYgciA8IDApXG4gICAgICAgIHJldHVybiAhcy5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xuICAgIH1cbiAgICB2YXIgbCA9IHQuc2Nyb2xsTGVmdDtcbiAgICBpZiAociA9PT0gMCkge1xuICAgICAgaWYgKCFzLnNjcm9sbGJhclhBY3RpdmUpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChsID09PSAwICYmIG8gPCAwIHx8IGwgPj0gcy5jb250ZW50V2lkdGggLSBzLmNvbnRhaW5lcldpZHRoICYmIG8gPiAwKVxuICAgICAgICByZXR1cm4gIXMuc2V0dGluZ3Mud2hlZWxQcm9wYWdhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIHMuZXZlbnQuYmluZChzLm93bmVyRG9jdW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbihvKSB7XG4gICAgaWYgKCEoby5pc0RlZmF1bHRQcmV2ZW50ZWQgJiYgby5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBvLmRlZmF1bHRQcmV2ZW50ZWQpICYmICEoIWUoKSAmJiAhaSgpKSkge1xuICAgICAgdmFyIHIgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA6IHMub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgaWYgKHIudGFnTmFtZSA9PT0gXCJJRlJBTUVcIilcbiAgICAgICAgICByID0gci5jb250ZW50RG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAoOyByLnNoYWRvd1Jvb3Q7IClcbiAgICAgICAgICAgIHIgPSByLnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKEx2KHIpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gMCwgbCA9IDA7XG4gICAgICBzd2l0Y2ggKG8ud2hpY2gpIHtcbiAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICBvLm1ldGFLZXkgPyBhID0gLXMuY29udGVudFdpZHRoIDogby5hbHRLZXkgPyBhID0gLXMuY29udGFpbmVyV2lkdGggOiBhID0gLTMwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgIG8ubWV0YUtleSA/IGwgPSBzLmNvbnRlbnRIZWlnaHQgOiBvLmFsdEtleSA/IGwgPSBzLmNvbnRhaW5lckhlaWdodCA6IGwgPSAzMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICBvLm1ldGFLZXkgPyBhID0gcy5jb250ZW50V2lkdGggOiBvLmFsdEtleSA/IGEgPSBzLmNvbnRhaW5lcldpZHRoIDogYSA9IDMwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgIG8ubWV0YUtleSA/IGwgPSAtcy5jb250ZW50SGVpZ2h0IDogby5hbHRLZXkgPyBsID0gLXMuY29udGFpbmVySGVpZ2h0IDogbCA9IC0zMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICBvLnNoaWZ0S2V5ID8gbCA9IHMuY29udGFpbmVySGVpZ2h0IDogbCA9IC1zLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICBsID0gcy5jb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgbCA9IC1zLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICBsID0gcy5jb250ZW50SGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgIGwgPSAtcy5jb250ZW50SGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHMuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxYICYmIGEgIT09IDAgfHwgcy5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFkgJiYgbCAhPT0gMCB8fCAodC5zY3JvbGxUb3AgLT0gbCwgdC5zY3JvbGxMZWZ0ICs9IGEsIEh0KHMpLCBuKGEsIGwpICYmIG8ucHJldmVudERlZmF1bHQoKSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIEh2KHMpIHtcbiAgdmFyIHQgPSBzLmVsZW1lbnQ7XG4gIGZ1bmN0aW9uIGUociwgYSkge1xuICAgIHZhciBsID0gTWF0aC5mbG9vcih0LnNjcm9sbFRvcCksIHAgPSB0LnNjcm9sbFRvcCA9PT0gMCwgdSA9IGwgKyB0Lm9mZnNldEhlaWdodCA9PT0gdC5zY3JvbGxIZWlnaHQsIF8gPSB0LnNjcm9sbExlZnQgPT09IDAsIGYgPSB0LnNjcm9sbExlZnQgKyB0Lm9mZnNldFdpZHRoID09PSB0LnNjcm9sbFdpZHRoLCBnO1xuICAgIHJldHVybiBNYXRoLmFicyhhKSA+IE1hdGguYWJzKHIpID8gZyA9IHAgfHwgdSA6IGcgPSBfIHx8IGYsIGcgPyAhcy5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uIDogITA7XG4gIH1cbiAgZnVuY3Rpb24gaShyKSB7XG4gICAgdmFyIGEgPSByLmRlbHRhWCwgbCA9IC0xICogci5kZWx0YVk7XG4gICAgcmV0dXJuICh0eXBlb2YgYSA+IFwidVwiIHx8IHR5cGVvZiBsID4gXCJ1XCIpICYmIChhID0gLTEgKiByLndoZWVsRGVsdGFYIC8gNiwgbCA9IHIud2hlZWxEZWx0YVkgLyA2KSwgci5kZWx0YU1vZGUgJiYgci5kZWx0YU1vZGUgPT09IDEgJiYgKGEgKj0gMTAsIGwgKj0gMTApLCBhICE9PSBhICYmIGwgIT09IGwgJiYgKGEgPSAwLCBsID0gci53aGVlbERlbHRhKSwgci5zaGlmdEtleSA/IFstbCwgLWFdIDogW2EsIGxdO1xuICB9XG4gIGZ1bmN0aW9uIG4ociwgYSwgbCkge1xuICAgIGlmICghVmUuaXNXZWJLaXQgJiYgdC5xdWVyeVNlbGVjdG9yKFwic2VsZWN0OmZvY3VzXCIpKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGlmICghdC5jb250YWlucyhyKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKHZhciBwID0gcjsgcCAmJiBwICE9PSB0OyApIHtcbiAgICAgIGlmIChwLmNsYXNzTGlzdC5jb250YWlucyhqLmVsZW1lbnQuY29uc3VtaW5nKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgdmFyIHUgPSBOdChwKTtcbiAgICAgIGlmIChsICYmIHUub3ZlcmZsb3dZLm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIF8gPSBwLnNjcm9sbEhlaWdodCAtIHAuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAoXyA+IDAgJiYgKHAuc2Nyb2xsVG9wID4gMCAmJiBsIDwgMCB8fCBwLnNjcm9sbFRvcCA8IF8gJiYgbCA+IDApKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChhICYmIHUub3ZlcmZsb3dYLm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIGYgPSBwLnNjcm9sbFdpZHRoIC0gcC5jbGllbnRXaWR0aDtcbiAgICAgICAgaWYgKGYgPiAwICYmIChwLnNjcm9sbExlZnQgPiAwICYmIGEgPCAwIHx8IHAuc2Nyb2xsTGVmdCA8IGYgJiYgYSA+IDApKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIHAgPSBwLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBmdW5jdGlvbiBvKHIpIHtcbiAgICB2YXIgYSA9IGkociksIGwgPSBhWzBdLCBwID0gYVsxXTtcbiAgICBpZiAoIW4oci50YXJnZXQsIGwsIHApKSB7XG4gICAgICB2YXIgdSA9ICExO1xuICAgICAgcy5zZXR0aW5ncy51c2VCb3RoV2hlZWxBeGVzID8gcy5zY3JvbGxiYXJZQWN0aXZlICYmICFzLnNjcm9sbGJhclhBY3RpdmUgPyAocCA/IHQuc2Nyb2xsVG9wIC09IHAgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQgOiB0LnNjcm9sbFRvcCArPSBsICogcy5zZXR0aW5ncy53aGVlbFNwZWVkLCB1ID0gITApIDogcy5zY3JvbGxiYXJYQWN0aXZlICYmICFzLnNjcm9sbGJhcllBY3RpdmUgJiYgKGwgPyB0LnNjcm9sbExlZnQgKz0gbCAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCA6IHQuc2Nyb2xsTGVmdCAtPSBwICogcy5zZXR0aW5ncy53aGVlbFNwZWVkLCB1ID0gITApIDogKHQuc2Nyb2xsVG9wIC09IHAgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQsIHQuc2Nyb2xsTGVmdCArPSBsICogcy5zZXR0aW5ncy53aGVlbFNwZWVkKSwgSHQocyksIHUgPSB1IHx8IGUobCwgcCksIHUgJiYgIXIuY3RybEtleSAmJiAoci5zdG9wUHJvcGFnYXRpb24oKSwgci5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICB9XG4gIH1cbiAgdHlwZW9mIHdpbmRvdy5vbndoZWVsIDwgXCJ1XCIgPyBzLmV2ZW50LmJpbmQodCwgXCJ3aGVlbFwiLCBvKSA6IHR5cGVvZiB3aW5kb3cub25tb3VzZXdoZWVsIDwgXCJ1XCIgJiYgcy5ldmVudC5iaW5kKHQsIFwibW91c2V3aGVlbFwiLCBvKTtcbn1cbmZ1bmN0aW9uIFZ2KHMpIHtcbiAgaWYgKCFWZS5zdXBwb3J0c1RvdWNoICYmICFWZS5zdXBwb3J0c0llUG9pbnRlcilcbiAgICByZXR1cm47XG4gIHZhciB0ID0gcy5lbGVtZW50O1xuICBmdW5jdGlvbiBlKG0sIGIpIHtcbiAgICB2YXIgdiA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApLCBUID0gdC5zY3JvbGxMZWZ0LCB5ID0gTWF0aC5hYnMobSksIEMgPSBNYXRoLmFicyhiKTtcbiAgICBpZiAoQyA+IHkpIHtcbiAgICAgIGlmIChiIDwgMCAmJiB2ID09PSBzLmNvbnRlbnRIZWlnaHQgLSBzLmNvbnRhaW5lckhlaWdodCB8fCBiID4gMCAmJiB2ID09PSAwKVxuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFkgPT09IDAgJiYgYiA+IDAgJiYgVmUuaXNDaHJvbWU7XG4gICAgfSBlbHNlIGlmICh5ID4gQyAmJiAobSA8IDAgJiYgVCA9PT0gcy5jb250ZW50V2lkdGggLSBzLmNvbnRhaW5lcldpZHRoIHx8IG0gPiAwICYmIFQgPT09IDApKVxuICAgICAgcmV0dXJuICEwO1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBmdW5jdGlvbiBpKG0sIGIpIHtcbiAgICB0LnNjcm9sbFRvcCAtPSBiLCB0LnNjcm9sbExlZnQgLT0gbSwgSHQocyk7XG4gIH1cbiAgdmFyIG4gPSB7fSwgbyA9IDAsIHIgPSB7fSwgYSA9IG51bGw7XG4gIGZ1bmN0aW9uIGwobSkge1xuICAgIHJldHVybiBtLnRhcmdldFRvdWNoZXMgPyBtLnRhcmdldFRvdWNoZXNbMF0gOiBtO1xuICB9XG4gIGZ1bmN0aW9uIHAobSkge1xuICAgIHJldHVybiBtLnBvaW50ZXJUeXBlICYmIG0ucG9pbnRlclR5cGUgPT09IFwicGVuXCIgJiYgbS5idXR0b25zID09PSAwID8gITEgOiAhIShtLnRhcmdldFRvdWNoZXMgJiYgbS50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PT0gMSB8fCBtLnBvaW50ZXJUeXBlICYmIG0ucG9pbnRlclR5cGUgIT09IFwibW91c2VcIiAmJiBtLnBvaW50ZXJUeXBlICE9PSBtLk1TUE9JTlRFUl9UWVBFX01PVVNFKTtcbiAgfVxuICBmdW5jdGlvbiB1KG0pIHtcbiAgICBpZiAocChtKSkge1xuICAgICAgdmFyIGIgPSBsKG0pO1xuICAgICAgbi5wYWdlWCA9IGIucGFnZVgsIG4ucGFnZVkgPSBiLnBhZ2VZLCBvID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCksIGEgIT09IG51bGwgJiYgY2xlYXJJbnRlcnZhbChhKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gXyhtLCBiLCB2KSB7XG4gICAgaWYgKCF0LmNvbnRhaW5zKG0pKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAodmFyIFQgPSBtOyBUICYmIFQgIT09IHQ7ICkge1xuICAgICAgaWYgKFQuY2xhc3NMaXN0LmNvbnRhaW5zKGouZWxlbWVudC5jb25zdW1pbmcpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB2YXIgeSA9IE50KFQpO1xuICAgICAgaWYgKHYgJiYgeS5vdmVyZmxvd1kubWF0Y2goLyhzY3JvbGx8YXV0bykvKSkge1xuICAgICAgICB2YXIgQyA9IFQuc2Nyb2xsSGVpZ2h0IC0gVC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGlmIChDID4gMCAmJiAoVC5zY3JvbGxUb3AgPiAwICYmIHYgPCAwIHx8IFQuc2Nyb2xsVG9wIDwgQyAmJiB2ID4gMCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgaWYgKGIgJiYgeS5vdmVyZmxvd1gubWF0Y2goLyhzY3JvbGx8YXV0bykvKSkge1xuICAgICAgICB2YXIgRSA9IFQuc2Nyb2xsV2lkdGggLSBULmNsaWVudFdpZHRoO1xuICAgICAgICBpZiAoRSA+IDAgJiYgKFQuc2Nyb2xsTGVmdCA+IDAgJiYgYiA8IDAgfHwgVC5zY3JvbGxMZWZ0IDwgRSAmJiBiID4gMCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgVCA9IFQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGZ1bmN0aW9uIGYobSkge1xuICAgIGlmIChwKG0pKSB7XG4gICAgICB2YXIgYiA9IGwobSksIHYgPSB7IHBhZ2VYOiBiLnBhZ2VYLCBwYWdlWTogYi5wYWdlWSB9LCBUID0gdi5wYWdlWCAtIG4ucGFnZVgsIHkgPSB2LnBhZ2VZIC0gbi5wYWdlWTtcbiAgICAgIGlmIChfKG0udGFyZ2V0LCBULCB5KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaShULCB5KSwgbiA9IHY7XG4gICAgICB2YXIgQyA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpLCBFID0gQyAtIG87XG4gICAgICBFID4gMCAmJiAoci54ID0gVCAvIEUsIHIueSA9IHkgLyBFLCBvID0gQyksIGUoVCwgeSkgJiYgbS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnKCkge1xuICAgIHMuc2V0dGluZ3Muc3dpcGVFYXNpbmcgJiYgKGNsZWFySW50ZXJ2YWwoYSksIGEgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFyLnggJiYgIXIueSkge1xuICAgICAgICBjbGVhckludGVydmFsKGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMoci54KSA8IDAuMDEgJiYgTWF0aC5hYnMoci55KSA8IDAuMDEpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFzLmVsZW1lbnQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaShyLnggKiAzMCwgci55ICogMzApLCByLnggKj0gMC44LCByLnkgKj0gMC44O1xuICAgIH0sIDEwKSk7XG4gIH1cbiAgVmUuc3VwcG9ydHNUb3VjaCA/IChzLmV2ZW50LmJpbmQodCwgXCJ0b3VjaHN0YXJ0XCIsIHUpLCBzLmV2ZW50LmJpbmQodCwgXCJ0b3VjaG1vdmVcIiwgZiksIHMuZXZlbnQuYmluZCh0LCBcInRvdWNoZW5kXCIsIGcpKSA6IFZlLnN1cHBvcnRzSWVQb2ludGVyICYmICh3aW5kb3cuUG9pbnRlckV2ZW50ID8gKHMuZXZlbnQuYmluZCh0LCBcInBvaW50ZXJkb3duXCIsIHUpLCBzLmV2ZW50LmJpbmQodCwgXCJwb2ludGVybW92ZVwiLCBmKSwgcy5ldmVudC5iaW5kKHQsIFwicG9pbnRlcnVwXCIsIGcpKSA6IHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAocy5ldmVudC5iaW5kKHQsIFwiTVNQb2ludGVyRG93blwiLCB1KSwgcy5ldmVudC5iaW5kKHQsIFwiTVNQb2ludGVyTW92ZVwiLCBmKSwgcy5ldmVudC5iaW5kKHQsIFwiTVNQb2ludGVyVXBcIiwgZykpKTtcbn1cbnZhciBXdiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGhhbmRsZXJzOiBbXCJjbGljay1yYWlsXCIsIFwiZHJhZy10aHVtYlwiLCBcImtleWJvYXJkXCIsIFwid2hlZWxcIiwgXCJ0b3VjaFwiXSxcbiAgICBtYXhTY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gICAgbWluU2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICAgIHNjcm9sbGluZ1RocmVzaG9sZDogMWUzLFxuICAgIHNjcm9sbFhNYXJnaW5PZmZzZXQ6IDAsXG4gICAgc2Nyb2xsWU1hcmdpbk9mZnNldDogMCxcbiAgICBzdXBwcmVzc1Njcm9sbFg6ICExLFxuICAgIHN1cHByZXNzU2Nyb2xsWTogITEsXG4gICAgc3dpcGVFYXNpbmc6ICEwLFxuICAgIHVzZUJvdGhXaGVlbEF4ZXM6ICExLFxuICAgIHdoZWVsUHJvcGFnYXRpb246ICEwLFxuICAgIHdoZWVsU3BlZWQ6IDFcbiAgfTtcbn0sIEZ2ID0ge1xuICBcImNsaWNrLXJhaWxcIjogUnYsXG4gIFwiZHJhZy10aHVtYlwiOiBQdixcbiAga2V5Ym9hcmQ6IEJ2LFxuICB3aGVlbDogSHYsXG4gIHRvdWNoOiBWdlxufSwgWmkgPSBmdW5jdGlvbih0LCBlKSB7XG4gIHZhciBpID0gdGhpcztcbiAgaWYgKGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAodCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkpLCAhdCB8fCAhdC5ub2RlTmFtZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBlbGVtZW50IGlzIHNwZWNpZmllZCB0byBpbml0aWFsaXplIFBlcmZlY3RTY3JvbGxiYXJcIik7XG4gIHRoaXMuZWxlbWVudCA9IHQsIHQuY2xhc3NMaXN0LmFkZChqLm1haW4pLCB0aGlzLnNldHRpbmdzID0gV3YoKTtcbiAgZm9yICh2YXIgbiBpbiBlKVxuICAgIHRoaXMuc2V0dGluZ3Nbbl0gPSBlW25dO1xuICB0aGlzLmNvbnRhaW5lcldpZHRoID0gbnVsbCwgdGhpcy5jb250YWluZXJIZWlnaHQgPSBudWxsLCB0aGlzLmNvbnRlbnRXaWR0aCA9IG51bGwsIHRoaXMuY29udGVudEhlaWdodCA9IG51bGw7XG4gIHZhciBvID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuY2xhc3NMaXN0LmFkZChqLnN0YXRlLmZvY3VzKTtcbiAgfSwgciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmNsYXNzTGlzdC5yZW1vdmUoai5zdGF0ZS5mb2N1cyk7XG4gIH07XG4gIHRoaXMuaXNSdGwgPSBOdCh0KS5kaXJlY3Rpb24gPT09IFwicnRsXCIsIHRoaXMuaXNSdGwgPT09ICEwICYmIHQuY2xhc3NMaXN0LmFkZChqLnJ0bCksIHRoaXMuaXNOZWdhdGl2ZVNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwID0gdC5zY3JvbGxMZWZ0LCB1ID0gbnVsbDtcbiAgICByZXR1cm4gdC5zY3JvbGxMZWZ0ID0gLTEsIHUgPSB0LnNjcm9sbExlZnQgPCAwLCB0LnNjcm9sbExlZnQgPSBwLCB1O1xuICB9KCksIHRoaXMubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ID0gdGhpcy5pc05lZ2F0aXZlU2Nyb2xsID8gdC5zY3JvbGxXaWR0aCAtIHQuY2xpZW50V2lkdGggOiAwLCB0aGlzLmV2ZW50ID0gbmV3IGxpKCksIHRoaXMub3duZXJEb2N1bWVudCA9IHQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCwgdGhpcy5zY3JvbGxiYXJYUmFpbCA9IElzKGouZWxlbWVudC5yYWlsKFwieFwiKSksIHQuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJYUmFpbCksIHRoaXMuc2Nyb2xsYmFyWCA9IElzKGouZWxlbWVudC50aHVtYihcInhcIikpLCB0aGlzLnNjcm9sbGJhclhSYWlsLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsYmFyWCksIHRoaXMuc2Nyb2xsYmFyWC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKSwgdGhpcy5ldmVudC5iaW5kKHRoaXMuc2Nyb2xsYmFyWCwgXCJmb2N1c1wiLCBvKSwgdGhpcy5ldmVudC5iaW5kKHRoaXMuc2Nyb2xsYmFyWCwgXCJibHVyXCIsIHIpLCB0aGlzLnNjcm9sbGJhclhBY3RpdmUgPSBudWxsLCB0aGlzLnNjcm9sbGJhclhXaWR0aCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWExlZnQgPSBudWxsO1xuICB2YXIgYSA9IE50KHRoaXMuc2Nyb2xsYmFyWFJhaWwpO1xuICB0aGlzLnNjcm9sbGJhclhCb3R0b20gPSBwYXJzZUludChhLmJvdHRvbSwgMTApLCBpc05hTih0aGlzLnNjcm9sbGJhclhCb3R0b20pID8gKHRoaXMuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPSAhMSwgdGhpcy5zY3JvbGxiYXJYVG9wID0gRihhLnRvcCkpIDogdGhpcy5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA9ICEwLCB0aGlzLnJhaWxCb3JkZXJYV2lkdGggPSBGKGEuYm9yZGVyTGVmdFdpZHRoKSArIEYoYS5ib3JkZXJSaWdodFdpZHRoKSwgY3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIHRoaXMucmFpbFhNYXJnaW5XaWR0aCA9IEYoYS5tYXJnaW5MZWZ0KSArIEYoYS5tYXJnaW5SaWdodCksIGN0KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogXCJcIiB9KSwgdGhpcy5yYWlsWFdpZHRoID0gbnVsbCwgdGhpcy5yYWlsWFJhdGlvID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZUmFpbCA9IElzKGouZWxlbWVudC5yYWlsKFwieVwiKSksIHQuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJZUmFpbCksIHRoaXMuc2Nyb2xsYmFyWSA9IElzKGouZWxlbWVudC50aHVtYihcInlcIikpLCB0aGlzLnNjcm9sbGJhcllSYWlsLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsYmFyWSksIHRoaXMuc2Nyb2xsYmFyWS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKSwgdGhpcy5ldmVudC5iaW5kKHRoaXMuc2Nyb2xsYmFyWSwgXCJmb2N1c1wiLCBvKSwgdGhpcy5ldmVudC5iaW5kKHRoaXMuc2Nyb2xsYmFyWSwgXCJibHVyXCIsIHIpLCB0aGlzLnNjcm9sbGJhcllBY3RpdmUgPSBudWxsLCB0aGlzLnNjcm9sbGJhcllIZWlnaHQgPSBudWxsLCB0aGlzLnNjcm9sbGJhcllUb3AgPSBudWxsO1xuICB2YXIgbCA9IE50KHRoaXMuc2Nyb2xsYmFyWVJhaWwpO1xuICB0aGlzLnNjcm9sbGJhcllSaWdodCA9IHBhcnNlSW50KGwucmlnaHQsIDEwKSwgaXNOYU4odGhpcy5zY3JvbGxiYXJZUmlnaHQpID8gKHRoaXMuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA9ICExLCB0aGlzLnNjcm9sbGJhcllMZWZ0ID0gRihsLmxlZnQpKSA6IHRoaXMuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA9ICEwLCB0aGlzLnNjcm9sbGJhcllPdXRlcldpZHRoID0gdGhpcy5pc1J0bCA/IE52KHRoaXMuc2Nyb2xsYmFyWSkgOiBudWxsLCB0aGlzLnJhaWxCb3JkZXJZV2lkdGggPSBGKGwuYm9yZGVyVG9wV2lkdGgpICsgRihsLmJvcmRlckJvdHRvbVdpZHRoKSwgY3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIHRoaXMucmFpbFlNYXJnaW5IZWlnaHQgPSBGKGwubWFyZ2luVG9wKSArIEYobC5tYXJnaW5Cb3R0b20pLCBjdCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6IFwiXCIgfSksIHRoaXMucmFpbFlIZWlnaHQgPSBudWxsLCB0aGlzLnJhaWxZUmF0aW8gPSBudWxsLCB0aGlzLnJlYWNoID0ge1xuICAgIHg6IHQuc2Nyb2xsTGVmdCA8PSAwID8gXCJzdGFydFwiIDogdC5zY3JvbGxMZWZ0ID49IHRoaXMuY29udGVudFdpZHRoIC0gdGhpcy5jb250YWluZXJXaWR0aCA/IFwiZW5kXCIgOiBudWxsLFxuICAgIHk6IHQuc2Nyb2xsVG9wIDw9IDAgPyBcInN0YXJ0XCIgOiB0LnNjcm9sbFRvcCA+PSB0aGlzLmNvbnRlbnRIZWlnaHQgLSB0aGlzLmNvbnRhaW5lckhlaWdodCA/IFwiZW5kXCIgOiBudWxsXG4gIH0sIHRoaXMuaXNBbGl2ZSA9ICEwLCB0aGlzLnNldHRpbmdzLmhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBGdltwXShpKTtcbiAgfSksIHRoaXMubGFzdFNjcm9sbFRvcCA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApLCB0aGlzLmxhc3RTY3JvbGxMZWZ0ID0gdC5zY3JvbGxMZWZ0LCB0aGlzLmV2ZW50LmJpbmQodGhpcy5lbGVtZW50LCBcInNjcm9sbFwiLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIGkub25TY3JvbGwocCk7XG4gIH0pLCBIdCh0aGlzKTtcbn07XG5aaS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaXNBbGl2ZSAmJiAodGhpcy5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgPSB0aGlzLmlzTmVnYXRpdmVTY3JvbGwgPyB0aGlzLmVsZW1lbnQuc2Nyb2xsV2lkdGggLSB0aGlzLmVsZW1lbnQuY2xpZW50V2lkdGggOiAwLCBjdCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSwgY3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcImJsb2NrXCIgfSksIHRoaXMucmFpbFhNYXJnaW5XaWR0aCA9IEYoTnQodGhpcy5zY3JvbGxiYXJYUmFpbCkubWFyZ2luTGVmdCkgKyBGKE50KHRoaXMuc2Nyb2xsYmFyWFJhaWwpLm1hcmdpblJpZ2h0KSwgdGhpcy5yYWlsWU1hcmdpbkhlaWdodCA9IEYoTnQodGhpcy5zY3JvbGxiYXJZUmFpbCkubWFyZ2luVG9wKSArIEYoTnQodGhpcy5zY3JvbGxiYXJZUmFpbCkubWFyZ2luQm90dG9tKSwgY3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcIm5vbmVcIiB9KSwgY3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcIm5vbmVcIiB9KSwgSHQodGhpcyksIGZuKHRoaXMsIFwidG9wXCIsIDAsICExLCAhMCksIGZuKHRoaXMsIFwibGVmdFwiLCAwLCAhMSwgITApLCBjdCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6IFwiXCIgfSksIGN0KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJcIiB9KSk7XG59O1xuWmkucHJvdG90eXBlLm9uU2Nyb2xsID0gZnVuY3Rpb24odCkge1xuICB0aGlzLmlzQWxpdmUgJiYgKEh0KHRoaXMpLCBmbih0aGlzLCBcInRvcFwiLCB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wIC0gdGhpcy5sYXN0U2Nyb2xsVG9wKSwgZm4oXG4gICAgdGhpcyxcbiAgICBcImxlZnRcIixcbiAgICB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCAtIHRoaXMubGFzdFNjcm9sbExlZnRcbiAgKSwgdGhpcy5sYXN0U2Nyb2xsVG9wID0gTWF0aC5mbG9vcih0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKSwgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0KTtcbn07XG5aaS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmlzQWxpdmUgJiYgKHRoaXMuZXZlbnQudW5iaW5kQWxsKCksIFllKHRoaXMuc2Nyb2xsYmFyWCksIFllKHRoaXMuc2Nyb2xsYmFyWSksIFllKHRoaXMuc2Nyb2xsYmFyWFJhaWwpLCBZZSh0aGlzLnNjcm9sbGJhcllSYWlsKSwgdGhpcy5yZW1vdmVQc0NsYXNzZXMoKSwgdGhpcy5lbGVtZW50ID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJYID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJYUmFpbCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWVJhaWwgPSBudWxsLCB0aGlzLmlzQWxpdmUgPSAhMSk7XG59O1xuWmkucHJvdG90eXBlLnJlbW92ZVBzQ2xhc3NlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5lbGVtZW50LmNsYXNzTmFtZS5zcGxpdChcIiBcIikuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gIXQubWF0Y2goL15wcyhbLV9dLit8KSQvKTtcbiAgfSkuam9pbihcIiBcIik7XG59O1xuY29uc3QgQW8gPSBcInBlcmZlY3RTY3JvbGxiYXJcIiwgWXYgPSBcInBlcmZlY3Qtc2Nyb2xsYmFyXCIsICRzID0gXCJ0ZS5wZXJmZWN0U2Nyb2xsYmFyXCIsIFN0ID0gXCJ0ZVwiLCBJdCA9IFwicHNcIiwgeW8gPSBbXG4gIHsgdGU6IGBzY3JvbGxYLiR7U3R9LiR7SXR9YCwgcHM6IFwicHMtc2Nyb2xsLXhcIiB9LFxuICB7IHRlOiBgc2Nyb2xsWS4ke1N0fS4ke0l0fWAsIHBzOiBcInBzLXNjcm9sbC15XCIgfSxcbiAgeyB0ZTogYHNjcm9sbFVwLiR7U3R9LiR7SXR9YCwgcHM6IFwicHMtc2Nyb2xsLXVwXCIgfSxcbiAgeyB0ZTogYHNjcm9sbERvd24uJHtTdH0uJHtJdH1gLCBwczogXCJwcy1zY3JvbGwtZG93blwiIH0sXG4gIHsgdGU6IGBzY3JvbGxMZWZ0LiR7U3R9LiR7SXR9YCwgcHM6IFwicHMtc2Nyb2xsLWxlZnRcIiB9LFxuICB7IHRlOiBgc2Nyb2xsUmlnaHQuJHtTdH0uJHtJdH1gLCBwczogXCJwcy1zY3JvbGwtcmlnaHRcIiB9LFxuICB7IHRlOiBgc2Nyb2xsWEVuZC4ke1N0fS4ke0l0fWAsIHBzOiBcInBzLXgtcmVhY2gtZW5kXCIgfSxcbiAgeyB0ZTogYHNjcm9sbFlFbmQuJHtTdH0uJHtJdH1gLCBwczogXCJwcy15LXJlYWNoLWVuZFwiIH0sXG4gIHsgdGU6IGBzY3JvbGxYU3RhcnQuJHtTdH0uJHtJdH1gLCBwczogXCJwcy14LXJlYWNoLXN0YXJ0XCIgfSxcbiAgeyB0ZTogYHNjcm9sbFlTdGFydC4ke1N0fS4ke0l0fWAsIHBzOiBcInBzLXktcmVhY2gtc3RhcnRcIiB9XG5dLCBqdiA9IHtcbiAgaGFuZGxlcnM6IFtcImNsaWNrLXJhaWxcIiwgXCJkcmFnLXRodW1iXCIsIFwia2V5Ym9hcmRcIiwgXCJ3aGVlbFwiLCBcInRvdWNoXCJdLFxuICB3aGVlbFNwZWVkOiAxLFxuICB3aGVlbFByb3BhZ2F0aW9uOiAhMCxcbiAgc3dpcGVFYXNpbmc6ICEwLFxuICBtaW5TY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gIG1heFNjcm9sbGJhckxlbmd0aDogbnVsbCxcbiAgc2Nyb2xsaW5nVGhyZXNob2xkOiAxZTMsXG4gIHVzZUJvdGhXaGVlbEF4ZXM6ICExLFxuICBzdXBwcmVzc1Njcm9sbFg6ICExLFxuICBzdXBwcmVzc1Njcm9sbFk6ICExLFxuICBzY3JvbGxYTWFyZ2luT2Zmc2V0OiAwLFxuICBzY3JvbGxZTWFyZ2luT2Zmc2V0OiAwLFxuICBwb3NpdGlvblJpZ2h0OiAhMFxufSwgS3YgPSB7XG4gIGhhbmRsZXJzOiBcIihzdHJpbmd8YXJyYXkpXCIsXG4gIHdoZWVsU3BlZWQ6IFwibnVtYmVyXCIsXG4gIHdoZWVsUHJvcGFnYXRpb246IFwiYm9vbGVhblwiLFxuICBzd2lwZUVhc2luZzogXCJib29sZWFuXCIsXG4gIG1pblNjcm9sbGJhckxlbmd0aDogXCIobnVtYmVyfG51bGwpXCIsXG4gIG1heFNjcm9sbGJhckxlbmd0aDogXCIobnVtYmVyfG51bGwpXCIsXG4gIHNjcm9sbGluZ1RocmVzaG9sZDogXCJudW1iZXJcIixcbiAgdXNlQm90aFdoZWVsQXhlczogXCJib29sZWFuXCIsXG4gIHN1cHByZXNzU2Nyb2xsWDogXCJib29sZWFuXCIsXG4gIHN1cHByZXNzU2Nyb2xsWTogXCJib29sZWFuXCIsXG4gIHNjcm9sbFhNYXJnaW5PZmZzZXQ6IFwibnVtYmVyXCIsXG4gIHNjcm9sbFlNYXJnaW5PZmZzZXQ6IFwibnVtYmVyXCIsXG4gIHBvc2l0aW9uUmlnaHQ6IFwiYm9vbGVhblwiXG59LCB6diA9IHtcbiAgcHM6IFwiZ3JvdXAvcHMgb3ZlcmZsb3ctaGlkZGVuIFtvdmVyZmxvdy1hbmNob3I6bm9uZV0gdG91Y2gtbm9uZVwiLFxuICByYWlsWDogXCJncm91cC94IGFic29sdXRlIGJvdHRvbS0wIGgtWzAuOTM3NXJlbV0gaGlkZGVuIG9wYWNpdHktMCB0cmFuc2l0aW9uLVtiYWNrZ3JvdW5kLWNvbG9yLF9vcGFjaXR5XSBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgei1bMTAzNV0gZ3JvdXAtWyYucHMtLWFjdGl2ZS14XS9wczpibG9jayBncm91cC1ob3Zlci9wczpvcGFjaXR5LTYwIGdyb3VwLWZvY3VzL3BzOm9wYWNpdHktNjAgZ3JvdXAtWyYucHMtLXNjcm9sbGluZy14XS9wczpvcGFjaXR5LTYwIGhvdmVyOiFvcGFjaXR5LTkwIGZvY3VzOiFvcGFjaXR5LTkwIFsmLnBzLS1jbGlja2luZ106IW9wYWNpdHktOTAgb3V0bGluZS1ub25lXCIsXG4gIHJhaWxYQ29sb3JzOiBcImdyb3VwLVsmLnBzLS1hY3RpdmUteF0vcHM6YmctdHJhbnNwYXJlbnQgaG92ZXI6IWJnLVsjZWVlXSBmb2N1czohYmctWyNlZWVdIFsmLnBzLS1jbGlja2luZ106IWJnLVsjZWVlXSBkYXJrOmhvdmVyOiFiZy1bIzU1NV0gZGFyazpmb2N1czohYmctWyM1NTVdIGRhcms6WyYucHMtLWNsaWNraW5nXTohYmctWyM1NTVdXCIsXG4gIHJhaWxYVGh1bWI6IFwiYWJzb2x1dGUgYm90dG9tLTAuNSByb3VuZGVkLW1kIGgtMS41IGdyb3VwLWZvY3VzL3BzOm9wYWNpdHktMTAwIGdyb3VwLWFjdGl2ZS9wczpvcGFjaXR5LTEwMCBbdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yXy4yc19saW5lYXIsX2hlaWdodF8uMnNfZWFzZS1pbi1vdXRdIGdyb3VwLWhvdmVyL3g6aC1bMTFweF0gZ3JvdXAtZm9jdXMveDpoLVswLjY4NzVyZW1dIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veDpiZy1bIzk5OV0gZ3JvdXAtWyYucHMtLWNsaWNraW5nXS94OmgtWzExcHhdIG91dGxpbmUtbm9uZVwiLFxuICByYWlsWFRodW1iQ29sb3JzOiBcImJnLVsjYWFhXSBncm91cC1ob3Zlci94OmJnLVsjOTk5XSBncm91cC1mb2N1cy94OmJnLVsjOTk5XVwiLFxuICByYWlsWTogXCJncm91cC95IGFic29sdXRlIHJpZ2h0LTAgdy1bMC45Mzc1cmVtXSBoaWRkZW4gb3BhY2l0eS0wIHRyYW5zaXRpb24tW2JhY2tncm91bmQtY29sb3IsX29wYWNpdHldIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSB6LVsxMDM1XSBncm91cC1bJi5wcy0tYWN0aXZlLXldL3BzOmJsb2NrIGdyb3VwLWhvdmVyL3BzOm9wYWNpdHktNjAgZ3JvdXAtZm9jdXMvcHM6b3BhY2l0eS02MCBncm91cC1bJi5wcy0tc2Nyb2xsaW5nLXldL3BzOm9wYWNpdHktNjAgaG92ZXI6IW9wYWNpdHktOTAgZm9jdXM6IW9wYWNpdHktOTAgWyYucHMtLWNsaWNraW5nXTohb3BhY2l0eS05MCBvdXRsaW5lLW5vbmVcIixcbiAgcmFpbFlDb2xvcnM6IFwiZ3JvdXAtWyYucHMtLWFjdGl2ZS15XS9wczpiZy10cmFuc3BhcmVudCBob3ZlcjohYmctWyNlZWVdIGZvY3VzOiFiZy1bI2VlZV0gWyYucHMtLWNsaWNraW5nXTohYmctWyNlZWVdIGRhcms6aG92ZXI6IWJnLVsjNTU1XSBkYXJrOmZvY3VzOiFiZy1bIzU1NV0gZGFyazpbJi5wcy0tY2xpY2tpbmddOiFiZy1bIzU1NV1cIixcbiAgcmFpbFlUaHVtYjogXCJhYnNvbHV0ZSByaWdodC0wLjUgcm91bmRlZC1tZCB3LTEuNSBncm91cC1mb2N1cy9wczpvcGFjaXR5LTEwMCBncm91cC1hY3RpdmUvcHM6b3BhY2l0eS0xMDAgW3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvcl8uMnNfbGluZWFyLF93aWR0aF8uMnNfZWFzZS1pbi1vdXQsX29wYWNpdHldIGdyb3VwLWhvdmVyL3k6dy1bMTFweF0gZ3JvdXAtZm9jdXMveTp3LVswLjY4NzVyZW1dIGdyb3VwLVsmLnBzLS1jbGlja2luZ10veTp3LVsxMXB4XSBvdXRsaW5lLW5vbmVcIixcbiAgcmFpbFlUaHVtYkNvbG9yczogXCJiZy1bI2FhYV0gZ3JvdXAtaG92ZXIveTpiZy1bIzk5OV0gZ3JvdXAtZm9jdXMveTpiZy1bIzk5OV0gZ3JvdXAtWyYucHMtLWNsaWNraW5nXS95OmJnLVsjOTk5XVwiXG59LCBVdiA9IHtcbiAgcHM6IFwic3RyaW5nXCIsXG4gIHJhaWxYOiBcInN0cmluZ1wiLFxuICByYWlsWENvbG9yczogXCJzdHJpbmdcIixcbiAgcmFpbFhUaHVtYjogXCJzdHJpbmdcIixcbiAgcmFpbFhUaHVtYkNvbG9yczogXCJzdHJpbmdcIixcbiAgcmFpbFk6IFwic3RyaW5nXCIsXG4gIHJhaWxZQ29sb3JzOiBcInN0cmluZ1wiLFxuICByYWlsWVRodW1iOiBcInN0cmluZ1wiLFxuICByYWlsWVRodW1iQ29sb3JzOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgeHIge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkgPSB7fSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5wZXJmZWN0U2Nyb2xsYmFyID0gbnVsbCwgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsLCB0aGlzLl9wc0NsYXNzZXMgPSBbXG4gICAgICB7XG4gICAgICAgIHBzOiBcInBzX19yYWlsLXhcIixcbiAgICAgICAgdGU6IHRoaXMuX2NsYXNzZXMucmFpbFgsXG4gICAgICAgIHRlQ29sb3I6IHRoaXMuX2NsYXNzZXMucmFpbFhDb2xvcnNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBzOiBcInBzX19yYWlsLXlcIixcbiAgICAgICAgdGU6IHRoaXMuX2NsYXNzZXMucmFpbFksXG4gICAgICAgIHRlQ29sb3I6IHRoaXMuX2NsYXNzZXMucmFpbFlDb2xvcnNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBzOiBcInBzX190aHVtYi14XCIsXG4gICAgICAgIHRlOiB0aGlzLl9jbGFzc2VzLnJhaWxYVGh1bWIsXG4gICAgICAgIHRlQ29sb3I6IHRoaXMuX2NsYXNzZXMucmFpbFhUaHVtYkNvbG9yc1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHM6IFwicHNfX3RodW1iLXlcIixcbiAgICAgICAgdGU6IHRoaXMuX2NsYXNzZXMucmFpbFlUaHVtYixcbiAgICAgICAgdGVDb2xvcjogdGhpcy5fY2xhc3Nlcy5yYWlsWVRodW1iQ29sb3JzXG4gICAgICB9XG4gICAgXSwgdGhpcy5fZWxlbWVudCAmJiAoQS5zZXREYXRhKHQsICRzLCB0aGlzKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBZdikpLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gQW87XG4gIH1cbiAgZ2V0IHJhaWxYKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXCIucHNfX3JhaWwteFwiLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgcmFpbFkoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcIi5wc19fcmFpbC15XCIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBlLmhhbmRsZXJzICE9PSB2b2lkIDAgJiYgKGUuaGFuZGxlcnMgPSBlLmhhbmRsZXJzLnNwbGl0KFwiIFwiKSksIHQgPSB7XG4gICAgICAuLi5qdixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgSShBbywgdCwgS3YpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uenYsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoQW8sIHQsIFV2KSwgdDtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9vcHRpb25zLnBvc2l0aW9uUmlnaHQgJiYgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpLCBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgJHMpLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fZGF0YUF0dHJPcHRpb25zID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMucGVyZmVjdFNjcm9sbGJhci5kZXN0cm95KCksIHRoaXMucmVtb3ZlRXZlbnQoeW8pLCB0aGlzLnBlcmZlY3RTY3JvbGxiYXIgPSBudWxsO1xuICB9XG4gIGluaXQoKSB7XG4gICAgaWYgKHRoaXMucGVyZmVjdFNjcm9sbGJhciA9IG5ldyBaaSh0aGlzLl9lbGVtZW50LCB0aGlzLl9vcHRpb25zKSwgdGhpcy5fYWRkUGVyZmVjdFNjcm9sbGJhclN0eWxlcygpLCB0aGlzLl91cGRhdGVTY3JvbGxQb3NpdGlvbigpLCB0aGlzLnBlcmZlY3RTY3JvbGxiYXIudXBkYXRlKCksIHRoaXMuX2luaXRFdmVudHMoeW8pLCB0aGlzLl9vcHRpb25zLnBvc2l0aW9uUmlnaHQpIHtcbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdCA9IHtcbiAgICAgICAgYXR0cmlidXRlczogITAsXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wiY2xhc3NcIiwgXCJjbGFzc05hbWVcIl1cbiAgICAgIH07XG4gICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2VsZW1lbnQsIHQpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlU2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgY29uc3QgdCA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShcImhlaWdodFwiKSwgZSA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShcIndpZHRoXCIpO1xuICAgIHRoaXMucmFpbFggJiYgKHRoaXMucmFpbFguc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoY2FsYygtMTAwJSArICR7dGhpcy5fY2FuVHJhbnNmb3JtKHQpID8gdCA6IFwiMHB4XCJ9KSlgKSwgdGhpcy5yYWlsWSAmJiAodGhpcy5yYWlsWS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWChjYWxjKC0xMDAlICsgJHt0aGlzLl9jYW5UcmFuc2Zvcm0oZSkgPyBlIDogXCIwcHhcIn0pKWApO1xuICB9XG4gIF9jYW5UcmFuc2Zvcm0odCkge1xuICAgIHJldHVybiB0ICYmIHQuaW5jbHVkZXMoXCJweFwiKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVyZmVjdFNjcm9sbGJhci51cGRhdGUoKTtcbiAgfVxuICBfaW5pdEV2ZW50cyh0ID0gW10pIHtcbiAgICB0LmZvckVhY2goXG4gICAgICAoeyBwczogZSwgdGU6IGkgfSkgPT4gYy5vbihcbiAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgZSxcbiAgICAgICAgKG4pID0+IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBpLCB7IGU6IG4gfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIF9hZGRQZXJmZWN0U2Nyb2xsYmFyU3R5bGVzKCkge1xuICAgIHRoaXMuX3BzQ2xhc3Nlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gZC5maW5kT25lKGAuJHt0LnBzfWAsIHRoaXMuX2VsZW1lbnQpO1xuICAgICAgaC5hZGRDbGFzcyhlLCB0LnRlKSwgaC5hZGRDbGFzcyhlLCB0LnRlQ29sb3IpO1xuICAgIH0pLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucHMpLCBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIFwicHNcIik7XG4gIH1cbiAgcmVtb3ZlRXZlbnQodCkge1xuICAgIGxldCBlID0gW107XG4gICAgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAoZSA9IHlvLmZpbHRlcigoeyB0ZTogaSB9KSA9PiBpID09PSB0KSksIGUuZm9yRWFjaCgoeyBwczogaSwgdGU6IG4gfSkgPT4ge1xuICAgICAgYy5vZmYodGhpcy5fZWxlbWVudCwgaSksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIG4pO1xuICAgIH0pO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGUgPSBBLmdldERhdGEodGhpcywgJHMpO1xuICAgICAgY29uc3QgaSA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFlICYmIC9kaXNwb3NlfGhpZGUvLnRlc3QodCkpICYmIChlIHx8IChlID0gbmV3IHhyKHRoaXMsIGkpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgJHMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IEJoID0geHIsIFh2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1zZWxlY3QtcmVmXCIsIEd2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1wYWdpbmF0aW9uLW5hdi1yZWZcIiwgcXYgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXBhZ2luYXRpb24tcmlnaHQtcmVmXCIsIFp2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1wYWdpbmF0aW9uLWxlZnQtcmVmXCIsIFF2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1wYWdpbmF0aW9uLXN0YXJ0LXJlZlwiLCBKdiA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcGFnaW5hdGlvbi1lbmQtcmVmXCIsIHRUID0gKHtcbiAgdGV4dDogcyxcbiAgZW50cmllczogdCxcbiAgZW50cmllc09wdGlvbnM6IGUsXG4gIGZ1bGxQYWdpbmF0aW9uOiBpLFxuICByb3dzVGV4dDogbixcbiAgYWxsVGV4dDogbyxcbiAgcGFnaW5hdGlvblN0YXJ0SWNvblRlbXBsYXRlOiByLFxuICBwYWdpbmF0aW9uTGVmdEljb25UZW1wbGF0ZTogYSxcbiAgcGFnaW5hdGlvblJpZ2h0SWNvblRlbXBsYXRlOiBsLFxuICBwYWdpbmF0aW9uRW5kSWNvblRlbXBsYXRlOiBwLFxuICBjbGFzc2VzOiB1XG59LCBfLCBmKSA9PiB7XG4gIGNvbnN0IGcgPSBlLm1hcCgobSkgPT4gbSA9PT0gXCJBbGxcIiA/IGA8b3B0aW9uIHZhbHVlPVwiJHttfVwiICR7bSA9PT0gdCA/IFwic2VsZWN0ZWRcIiA6IFwiXCJ9PiR7b308L29wdGlvbj5gIDogYDxvcHRpb24gdmFsdWU9XCIke219XCIgJHttID09PSB0ID8gXCJzZWxlY3RlZFwiIDogXCJcIn0+JHttfTwvb3B0aW9uPmApLmpvaW4oYFxuYCk7XG4gIHJldHVybiBgXG48ZGl2IGNsYXNzPVwiJHt1LnBhZ2luYXRpb259ICR7ZiA/IGAke3UucGFnaW5hdGlvbkJvcmRlcmVkfWAgOiBcIlwifSAke3UuYm9yZGVyQ29sb3J9ICR7dS5jb2xvcn1cIj5cbiAgPGRpdiBjbGFzcz1cIiR7dS5zZWxlY3RJdGVtc1dyYXBwZXJ9XCI+ICBcbiAgICA8cCBjbGFzcz1cIiR7dS5wYWdpbmF0aW9uUm93c1RleHR9ICR7XyA/IGAke3UubG9hZGluZ1BhZ2luYXRpb25Sb3dzVGV4dH1gIDogXCJcIn1cIj4ke259PC9wPlxuICAgIDxkaXYgY2xhc3M9XCIke3Uuc2VsZWN0V3JhcHBlcn0gJHtfID8gYCR7dS5sb2FkaW5nUGFnaW5hdGlvblNlbGVjdFdyYXBwZXJ9YCA6IFwiXCJ9XCI+XG4gICAgICA8c2VsZWN0IG5hbWU9XCJlbnRyaWVzXCJcbiAgICAgICAgJHtfID8gXCJkaXNhYmxlZFwiIDogXCJcIn0gY2xhc3M9XCJzZWxlY3RcIiAke1h2fT5cbiAgICAgICAgJHtnfVxuICAgICAgPC9zZWxlY3Q+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiJHt1LnBhZ2luYXRpb25OYXZ9ICR7XyA/IGAke3UubG9hZGluZ1BhZ2luYXRpb25OYXZ9YCA6IFwiXCJ9XCIgJHtHdn0+XG4gICR7c31cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCIke3UucGFnaW5hdGlvbkJ1dHRvbnNXcmFwcGVyfVwiPlxuICAgICR7aSA/IGA8YnV0dG9uIGRhdGEtdGUtcmlwcGxlLWluaXQgZGF0YS10ZS1yaXBwbGUtY29sb3I9XCJkYXJrXCIgY2xhc3M9XCIke3UucGFnaW5hdGlvblN0YXJ0QnV0dG9ufVwiICR7UXZ9PlxuICAgICAgICAgICAke3J9XG4gICAgICAgICAgPC9idXR0b24+YCA6IFwiXCJ9XG4gICAgPGJ1dHRvbiBkYXRhLXRlLXJpcHBsZS1pbml0IGRhdGEtdGUtcmlwcGxlLWNvbG9yPVwiZGFya1wiIGNsYXNzPVwiJHt1LnBhZ2luYXRpb25MZWZ0QnV0dG9ufVwiICR7WnZ9PlxuICAgICAgJHthfVxuICA8L2J1dHRvbj5cbiAgICA8YnV0dG9uIGRhdGEtdGUtcmlwcGxlLWluaXQgZGF0YS10ZS1yaXBwbGUtY29sb3I9XCJkYXJrXCIgY2xhc3M9XCIke3UucGFnaW5hdGlvblJpZ2h0QnV0dG9ufVwiICR7cXZ9PlxuICAgICAgJHtsfVxuICA8L2J1dHRvbj5cbiAgICAke2kgPyBgPGJ1dHRvbiBkYXRhLXRlLXJpcHBsZS1pbml0IGRhdGEtdGUtcmlwcGxlLWNvbG9yPVwiZGFya1wiIGNsYXNzPVwiJHt1LnBhZ2luYXRpb25FbmRCdXR0b259XCIgJHtKdn0+XG4gICAgICAgICAgICR7cH1cbiAgICAgICAgICA8L2J1dHRvbj5gIDogXCJcIn1cbiAgPC9kaXY+XG48L2Rpdj5cbmA7XG59LCBlVCA9IFwiZGF0YS10ZS1kYXRhdGFibGUtc29ydC1pY29uLXJlZlwiLCBpVCA9IFwiZGF0YS10ZS1kYXRhdGFibGUtaGVhZGVyLWNoZWNrYm94LXJlZlwiLCBzVCA9IChzLCB0LCBlLCBpLCBuLCBvLCByLCBhKSA9PiB7XG4gIGNvbnN0IGwgPSBlID8gYFxuICA8dGggc2NvcGU9XCJjb2xcIj5cbiAgICA8ZGl2IGNsYXNzPVwiJHthLmNoZWNrYm94SGVhZGVyV3JhcHBlcn1cIj5cbiAgICAgIDxpbnB1dFxuICAgICAgICBjbGFzcz1cIiR7YS5jaGVja2JveEhlYWRlcn1cIlxuICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICB2YWx1ZT1cIlwiXG4gICAgICAgICR7aVR9XG4gICAgICAgIC8+XG4gICAgPC9kaXY+XG4gIDwvdGg+XG4gIGAgOiAnPHRoIHNjb3BlPVwiY29sXCI+PC90aD4nLCBwID0gcy5tYXAoKHUsIF8pID0+IHtcbiAgICBjb25zdCBmID0gdS5maXhlZCA/IHMuZmlsdGVyKChnLCBtKSA9PiBnLmZpeGVkID09PSB1LmZpeGVkICYmIG0gPCBfKS5yZWR1Y2UoKGcsIG0pID0+IGcgKyBtLndpZHRoLCAwKSA6IG51bGw7XG4gICAgcmV0dXJuIGA8dGggY2xhc3M9XCIke2EuY29sdW1ufSAke2kgPyBgJHthLnRhYmxlQm9yZGVyZWR9YCA6IFwiXCJ9ICR7YS5ib3JkZXJDb2xvcn0gJHtuID8gYCR7YS5zbX1gIDogXCJcIn0gJHt1LmZpeGVkID8gYCR7YS5maXhlZEhlYWRlcn0gJHthLmNvbG9yfWAgOiBcIlwifSAke28gPyBgJHthLmxvYWRpbmdDb2x1bW59YCA6IFwiXCJ9XCIgc3R5bGU9XCIke3UuZml4ZWQgPyBgJHt1LmZpeGVkID09PSBcInJpZ2h0XCIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIn06ICR7Zn1weDtgIDogXCJcIn1cIiBzY29wZT1cImNvbFwiPiR7dS5zb3J0ID8gYDxkaXYgY2xhc3M9XCIke2Euc29ydEljb25XcmFwcGVyfVwiPjxzcGFuIGNsYXNzPVwiJHthLnNvcnRJY29ufSAke28gPyBcImludmlzaWJsZVwiIDogXCJcIn1cIiBkYXRhLXRlLXNvcnQ9XCIke3UuZmllbGR9XCIgJHtlVH0+JHtyfTwvc3Bhbj5gIDogXCJcIn0gPHNwYW4gY2xhc3M9XCIke3Uuc29ydCA/IFwiXCIgOiBcInBsLVsxOHB4XVwifVwiPiR7dS5sYWJlbH08L3NwYW4+PC9kaXY+PC90aD5gO1xuICB9KTtcbiAgcmV0dXJuIFt0ID8gbCA6IFwiXCIsIC4uLnBdLmpvaW4oYFxuYCk7XG59LCBuVCA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcm93LXJlZlwiLCBvVCA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcm93LWNoZWNrYm94LXJlZlwiLCByVCA9IFwiZGF0YS10ZS1kYXRhdGFibGUtY2VsbC1yZWZcIiwgYVQgPSAoe1xuICByb3dzOiBzLFxuICBjb2x1bW5zOiB0LFxuICBub0ZvdW5kTWVzc2FnZTogZSxcbiAgZWRpdDogaSxcbiAgc2VsZWN0YWJsZTogbixcbiAgbG9hZGluZzogbyxcbiAgYm9yZGVyZWQ6IHIsXG4gIGJvcmRlcmxlc3M6IGEsXG4gIHN0cmlwZWQ6IGwsXG4gIGhvdmVyOiBwLFxuICBzbTogdSxcbiAgY2xhc3NlczogX1xufSkgPT4ge1xuICBjb25zdCBmID0gcy5tYXAoKGcpID0+IHtcbiAgICBjb25zdCBtID0gYFxuICAgICAgPHRkIGRhdGEtdGUtZmllbGQ9XCJjaGVja2JveFwiIGNsYXNzPVwiJHtyID8gYCR7Xy50YWJsZUJvcmRlcmVkfSAke18uYm9yZGVyQ29sb3J9YCA6IFwiXCJ9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke18uY2hlY2tib3hSb3dXcmFwcGVyfVwiPlxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgY2xhc3M9XCIke18uY2hlY2tib3hSb3d9XCJcbiAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICB2YWx1ZT1cIlwiXG4gICAgICAgICAgICBkYXRhLXRlLXJvdy1pbmRleD1cIiR7Zy5yb3dJbmRleH1cIiAgJHtvVH0vPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvdGQ+YCwgYiA9IHQubWFwKCh2LCBUKSA9PiB7XG4gICAgICBjb25zdCB5ID0ge307XG4gICAgICBpZiAodi53aWR0aCAmJiAoeVtcIm1pbi13aWR0aFwiXSA9IGAke3Yud2lkdGggLSAxfXB4YCwgeVtcIm1heC13aWR0aFwiXSA9IGAke3Yud2lkdGh9cHhgLCB5LndpZHRoID0gYCR7di53aWR0aH1weGApLCB2LmZpeGVkKSB7XG4gICAgICAgIGNvbnN0IEUgPSB0LmZpbHRlcigodywgaykgPT4gdy5maXhlZCA9PT0gdi5maXhlZCAmJiBrIDwgVCkucmVkdWNlKCh3LCBrKSA9PiB3ICsgay53aWR0aCwgMCk7XG4gICAgICAgIHlbdi5maXhlZCA9PT0gXCJyaWdodFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCJdID0gYCR7RX1weGA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYDx0ZCBzdHlsZT1cIiR7T2JqZWN0LmtleXMoeSkubWFwKChFKSA9PiBgJHtFfTogJHt5W0VdfWApLmpvaW4oXCI7IFwiKX1cIiBjbGFzcz1cIiR7Xy5yb3dJdGVtfSAke18uYm9yZGVyQ29sb3J9ICR7aSA/IGAke18uZWRpdH1gIDogXCJcIn0gJHtyID8gYCR7Xy50YWJsZUJvcmRlcmVkfWAgOiBcIlwifSAke3UgPyBgJHtfLnNtfWAgOiBcIlwifSAke3YuZml4ZWQgPyBgJHtfLmZpeGVkSGVhZGVyfSAke18uY29sb3J9YCA6IFwiXCJ9XCIgJHtyVH0gZGF0YS10ZS1maWVsZD1cIiR7di5maWVsZH1cIiAke2kgJiYgJ2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIid9PiR7Z1t2LmZpZWxkXX08L3RkPmA7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgICByZXR1cm4gYDx0ciBzY29wZT1cInJvd1wiIGNsYXNzPVwiJHtfLnJvd30gJHtfLmJvcmRlckNvbG9yfSAke18ucm93QW5pbWF0aW9ufSAke2wgPyBgJHtfLnN0cmlwZWR9YCA6IFwiXCJ9ICR7YSA/IGAke18uYm9yZGVybGVzc31gIDogXCJcIn0gJHtwID8gYCR7Xy5ob3ZlclJvd31gIDogXCJcIn1cIiBkYXRhLXRlLWluZGV4PVwiJHtnLnJvd0luZGV4fVwiICR7blR9PiR7biA/IG0gOiBcIlwifSR7Yn08L3RyPmA7XG4gIH0pO1xuICByZXR1cm4gcy5sZW5ndGggPiAwIHx8IG8gPyBmLmpvaW4oYFxuYCkgOiBgPHRyIGNsYXNzPVwiJHtfLm5vRm91bmRNZXNzYWdlV3JhcHBlcn0gJHtfLmJvcmRlckNvbG9yfVwiPjx0ZCBjbGFzcz1cIiR7Xy5ub0ZvdW5kTWVzc2FnZX1cIj4ke2V9PC90ZD48L3RyPmA7XG59LCBsVCA9IFwiZGF0YS10ZS1kYXRhdGFibGUtaW5uZXItcmVmXCIsIGNUID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1oZWFkZXItcmVmXCIsIFBsID0gKHtcbiAgY29sdW1uczogcyxcbiAgcm93czogdCxcbiAgbm9Gb3VuZE1lc3NhZ2U6IGUsXG4gIGVkaXQ6IGksXG4gIG11bHRpOiBuLFxuICBzZWxlY3RhYmxlOiBvLFxuICBsb2FkaW5nOiByLFxuICBsb2FkaW5nTWVzc2FnZTogYSxcbiAgcGFnaW5hdGlvbjogbCxcbiAgYm9yZGVyZWQ6IHAsXG4gIGJvcmRlcmxlc3M6IHUsXG4gIHN0cmlwZWQ6IF8sXG4gIGhvdmVyOiBmLFxuICBmaXhlZEhlYWRlcjogZyxcbiAgc206IG0sXG4gIHNvcnRJY29uVGVtcGxhdGU6IGIsXG4gIGNsYXNzZXM6IHZcbn0pID0+IHtcbiAgY29uc3QgVCA9IGFUKHtcbiAgICByb3dzOiB0LFxuICAgIGNvbHVtbnM6IHMsXG4gICAgbm9Gb3VuZE1lc3NhZ2U6IGUsXG4gICAgZWRpdDogaSxcbiAgICBsb2FkaW5nOiByLFxuICAgIHNlbGVjdGFibGU6IG8sXG4gICAgYm9yZGVyZWQ6IHAsXG4gICAgYm9yZGVybGVzczogdSxcbiAgICBzdHJpcGVkOiBfLFxuICAgIGhvdmVyOiBmLFxuICAgIHNtOiBtLFxuICAgIGNsYXNzZXM6IHZcbiAgfSksIHkgPSBzVChcbiAgICBzLFxuICAgIG8sXG4gICAgbixcbiAgICBwLFxuICAgIG0sXG4gICAgcixcbiAgICBiLFxuICAgIHZcbiAgKTtcbiAgcmV0dXJuIHsgdGFibGU6IGBcbjxkaXYgY2xhc3M9XCIke3YuY29sb3J9XCIgJHtsVH0+XG4gIDx0YWJsZSBjbGFzcz1cIiR7di50YWJsZX1cIj5cbiAgICA8dGhlYWQgY2xhc3M9XCIke3YudGFibGVIZWFkZXJ9ICR7cCA/IGAke3YudGFibGVCb3JkZXJlZH1gIDogXCJcIn0gJHt1ID8gYCR7di5ib3JkZXJsZXNzfWAgOiBcIlwifSAke3YuYm9yZGVyQ29sb3J9XCIgJHtjVH0+XG4gICAgICA8dHI+XG4gICAgICAgICR7eX1cbiAgICAgIDwvdHI+XG4gICAgPC90aGVhZD5cbiAgICA8dGJvZHkgY2xhc3M9XCIke2cgPyBgJHt2LmZpeGVkSGVhZGVyQm9keX1gIDogXCJcIn1cIj5cbiAgICAgICR7ciA/IFwiXCIgOiBUfVxuICAgIDwvdGJvZHk+XG4gIDwvdGFibGU+XG48L2Rpdj5cbiR7ciA/IGBcbiAgPGRpdiBjbGFzcz1cIiR7di5sb2FkaW5nSXRlbXNXcmFwcGVyfVwiPlxuICAgIDxkaXYgY2xhc3M9XCIke3YubG9hZGluZ1Byb2dyZXNzQmFyV3JhcHBlcn1cIj5cbiAgICAgIDxkaXYgY2xhc3M9XCIke3YubG9hZGluZ1Byb2dyZXNzQmFyfVwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjxwIGNsYXNzPVwiJHt2LmxvYWRpbmdNZXNzYWdlfVwiPiR7YX08L3A+XG5gIDogXCJcIn1cbiR7bC5lbmFibGUgPyB0VChsLCByLCBwKSA6IFwiXCJ9XG4gIGAsIHJvd3M6IFQsIGNvbHVtbjogeSB9O1xufSwgaFQgPSAoeyByb3dzOiBzLCBmaWVsZDogdCwgb3JkZXI6IGUgfSkgPT4gcy5zb3J0KChuLCBvKSA9PiB7XG4gIGxldCByID0gblt0XSwgYSA9IG9bdF07XG4gIHJldHVybiB0eXBlb2YgciA9PSBcInN0cmluZ1wiICYmIChyID0gci50b0xvd2VyQ2FzZSgpKSwgdHlwZW9mIGEgPT0gXCJzdHJpbmdcIiAmJiAoYSA9IGEudG9Mb3dlckNhc2UoKSksIHIgPCBhID8gZSA9PT0gXCJkZXNjXCIgPyAxIDogLTEgOiByID4gYSA/IGUgPT09IFwiZGVzY1wiID8gLTEgOiAxIDogMDtcbn0pLCBkVCA9IChzLCB0LCBlKSA9PiB7XG4gIGlmICghdClcbiAgICByZXR1cm4gcztcbiAgY29uc3QgaSA9IChuKSA9PiB7XG4gICAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcmV0dXJuIG8uaW5uZXJIVE1MID0gbiwgbiA9IG8udGV4dENvbnRlbnQgfHwgby5pbm5lclRleHQgfHwgXCJcIiwgbi50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkubWF0Y2godC50b0xvd2VyQ2FzZSgpKTtcbiAgfTtcbiAgcmV0dXJuIHMuZmlsdGVyKChuKSA9PiB7XG4gICAgaWYgKGUgJiYgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBpKG5bZV0pO1xuICAgIGxldCBvID0gT2JqZWN0LnZhbHVlcyhuKTtcbiAgICByZXR1cm4gZSAmJiBBcnJheS5pc0FycmF5KGUpICYmIChvID0gT2JqZWN0LmtleXMobikuZmlsdGVyKChyKSA9PiBlLmluY2x1ZGVzKHIpKS5tYXAoKHIpID0+IG5bcl0pKSwgby5maWx0ZXIoKHIpID0+IGkocikpLmxlbmd0aCA+IDA7XG4gIH0pO1xufSwgQmwgPSAoeyByb3dzOiBzLCBlbnRyaWVzOiB0LCBhY3RpdmVQYWdlOiBlIH0pID0+IHtcbiAgY29uc3QgaSA9IGUgKiB0O1xuICByZXR1cm4gcy5zbGljZShpLCBpICsgTnVtYmVyKHQpKTtcbn0sIFZpID0gXCJkYXRhdGFibGVcIiwgZ3QgPSBgZGF0YS10ZS0ke1ZpfWAsIGtpID0gYHRlLiR7Vml9YCwgQW4gPSBgLiR7a2l9YCwgdVQgPSBgWyR7Z3R9LWlubmVyLXJlZl1gLCB3byA9IGBbJHtndH0tY2VsbC1yZWZdYCwgcFQgPSBgWyR7Z3R9LWhlYWRlci1yZWZdYCwgX1QgPSBgWyR7Z3R9LWhlYWRlci1jaGVja2JveC1yZWZdYCwgZlQgPSBgWyR7Z3R9LXBhZ2luYXRpb24tcmlnaHQtcmVmXWAsIG1UID0gYFske2d0fS1wYWdpbmF0aW9uLWxlZnQtcmVmXWAsIGdUID0gYFske2d0fS1wYWdpbmF0aW9uLXN0YXJ0LXJlZl1gLCBiVCA9IGBbJHtndH0tcGFnaW5hdGlvbi1lbmQtcmVmXWAsIHZUID0gYFske2d0fS1wYWdpbmF0aW9uLW5hdi1yZWZdYCwgVFQgPSBgWyR7Z3R9LXNlbGVjdC1yZWZdYCwga28gPSBgWyR7Z3R9LXNvcnQtaWNvbi1yZWZdYCwgVGkgPSBgWyR7Z3R9LXJvdy1yZWZdYCwgeG8gPSBgWyR7Z3R9LXJvdy1jaGVja2JveC1yZWZdYCwgRVQgPSBgc2VsZWN0Um93cyR7QW59YCwgSGwgPSBgcmVuZGVyJHtBbn1gLCBDVCA9IGByb3dDbGljayR7QW59YCwgQVQgPSBgdXBkYXRlJHtBbn1gLCB5VCA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk00LjUgMTAuNUwxMiAzbTAgMGw3LjUgNy41TTEyIDN2MThcIiAvPlxuPC9zdmc+YCwgd1QgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTguNzUgMTkuNWwtNy41LTcuNSA3LjUtNy41bS02IDE1TDUuMjUgMTJsNy41LTcuNVwiIC8+XG48L3N2Zz5gLCBrVCA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xNS43NSAxOS41TDguMjUgMTJsNy41LTcuNVwiIC8+XG48L3N2Zz5gLCB4VCA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk04LjI1IDQuNWw3LjUgNy41LTcuNSA3LjVcIiAvPlxuPC9zdmc+YCwgT1QgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTEuMjUgNC41bDcuNSA3LjUtNy41IDcuNW0tNi0xNWw3LjUgNy41LTcuNSA3LjVcIi8+XG48L3N2Zz5gLCBTVCA9IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNTAwXCIsIElUID0gXCJib3JkZXItbm9uZVwiLCBEVCA9IFwicmVsYXRpdmUgZmxvYXQtbGVmdCAtbWwtWzEuNXJlbV0gbXItWzZweF0gbXQtWzAuMTVyZW1dIGgtWzEuMTI1cmVtXSB3LVsxLjEyNXJlbV0gYXBwZWFyYW5jZS1ub25lIHJvdW5kZWQtWzAuMjVyZW1dIGJvcmRlci1bMC4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItbmV1dHJhbC0zMDAgb3V0bGluZS1ub25lIGJlZm9yZTpwb2ludGVyLWV2ZW50cy1ub25lIGJlZm9yZTphYnNvbHV0ZSBiZWZvcmU6aC1bMC44NzVyZW1dIGJlZm9yZTp3LVswLjg3NXJlbV0gYmVmb3JlOnNjYWxlLTAgYmVmb3JlOnJvdW5kZWQtZnVsbCBiZWZvcmU6YmctdHJhbnNwYXJlbnQgYmVmb3JlOm9wYWNpdHktMCBiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3RyYW5zcGFyZW50XSBiZWZvcmU6Y29udGVudC1bJyddIGNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgY2hlY2tlZDpiZy1wcmltYXJ5IGNoZWNrZWQ6YmVmb3JlOm9wYWNpdHktWzAuMTZdIGNoZWNrZWQ6YWZ0ZXI6YWJzb2x1dGUgY2hlY2tlZDphZnRlcjotbXQtcHggY2hlY2tlZDphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDphZnRlcjpibG9jayBjaGVja2VkOmFmdGVyOmgtWzAuODEyNXJlbV0gY2hlY2tlZDphZnRlcjp3LVswLjM3NXJlbV0gY2hlY2tlZDphZnRlcjpyb3RhdGUtNDUgY2hlY2tlZDphZnRlcjpib3JkZXItWzAuMTI1cmVtXSBjaGVja2VkOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXNvbGlkIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXdoaXRlIGNoZWNrZWQ6YWZ0ZXI6YmctdHJhbnNwYXJlbnQgY2hlY2tlZDphZnRlcjpjb250ZW50LVsnJ10gaG92ZXI6Y3Vyc29yLXBvaW50ZXIgaG92ZXI6YmVmb3JlOm9wYWNpdHktWzAuMDRdIGhvdmVyOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBmb2N1czpzaGFkb3ctbm9uZSBmb2N1czp0cmFuc2l0aW9uLVtib3JkZXItY29sb3JfMC4yc10gZm9jdXM6YmVmb3JlOnNjYWxlLTEwMCBmb2N1czpiZWZvcmU6b3BhY2l0eS1bMC4xMl0gZm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDAsMCwwLDAuNildIGZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGZvY3VzOmFmdGVyOmFic29sdXRlIGZvY3VzOmFmdGVyOnotWzFdIGZvY3VzOmFmdGVyOmJsb2NrIGZvY3VzOmFmdGVyOmgtWzAuODc1cmVtXSBmb2N1czphZnRlcjp3LVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6cm91bmRlZC1bMC4xMjVyZW1dIGZvY3VzOmFmdGVyOmNvbnRlbnQtWycnXSBjaGVja2VkOmZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgY2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnRyYW5zaXRpb24tW2JveC1zaGFkb3dfMC4ycyx0cmFuc2Zvcm1fMC4yc10gY2hlY2tlZDpmb2N1czphZnRlcjotbXQtcHggY2hlY2tlZDpmb2N1czphZnRlcjptbC1bMC4yNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6cm91bmRlZC1ub25lIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItbC0wIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXQtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJnLXRyYW5zcGFyZW50IGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGRhcms6Y2hlY2tlZDpib3JkZXItcHJpbWFyeSBkYXJrOmNoZWNrZWQ6YmctcHJpbWFyeSBkYXJrOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgyNTUsMjU1LDI1NSwwLjQpXSBkYXJrOmNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBkYXJrOmJvcmRlci1uZXV0cmFsLTQwMFwiLCAkVCA9IFwibWItWzAuMTI1cmVtXSBtaW4taC1bMS41cmVtXSBwbC1bMS41cmVtXSBtbC0zIGZsZXggaXRlbXMtY2VudGVyXCIsIExUID0gXCJyZWxhdGl2ZSBmbG9hdC1sZWZ0IC1tbC1bMS41cmVtXSBtci1bNnB4XSBtdC1bMC4xNXJlbV0gaC1bMS4xMjVyZW1dIHctWzEuMTI1cmVtXSBhcHBlYXJhbmNlLW5vbmUgcm91bmRlZC1bMC4yNXJlbV0gYm9yZGVyLVswLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci1uZXV0cmFsLTMwMCBvdXRsaW5lLW5vbmUgYmVmb3JlOnBvaW50ZXItZXZlbnRzLW5vbmUgYmVmb3JlOmFic29sdXRlIGJlZm9yZTpoLVswLjg3NXJlbV0gYmVmb3JlOnctWzAuODc1cmVtXSBiZWZvcmU6c2NhbGUtMCBiZWZvcmU6cm91bmRlZC1mdWxsIGJlZm9yZTpiZy10cmFuc3BhcmVudCBiZWZvcmU6b3BhY2l0eS0wIGJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfdHJhbnNwYXJlbnRdIGJlZm9yZTpjb250ZW50LVsnJ10gY2hlY2tlZDpib3JkZXItcHJpbWFyeSBjaGVja2VkOmJnLXByaW1hcnkgY2hlY2tlZDpiZWZvcmU6b3BhY2l0eS1bMC4xNl0gY2hlY2tlZDphZnRlcjphYnNvbHV0ZSBjaGVja2VkOmFmdGVyOi1tdC1weCBjaGVja2VkOmFmdGVyOm1sLVswLjI1cmVtXSBjaGVja2VkOmFmdGVyOmJsb2NrIGNoZWNrZWQ6YWZ0ZXI6aC1bMC44MTI1cmVtXSBjaGVja2VkOmFmdGVyOnctWzAuMzc1cmVtXSBjaGVja2VkOmFmdGVyOnJvdGF0ZS00NSBjaGVja2VkOmFmdGVyOmJvcmRlci1bMC4xMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmFmdGVyOmJvcmRlci10LTAgY2hlY2tlZDphZnRlcjpib3JkZXItc29saWQgY2hlY2tlZDphZnRlcjpib3JkZXItd2hpdGUgY2hlY2tlZDphZnRlcjpiZy10cmFuc3BhcmVudCBjaGVja2VkOmFmdGVyOmNvbnRlbnQtWycnXSBob3ZlcjpjdXJzb3ItcG9pbnRlciBob3ZlcjpiZWZvcmU6b3BhY2l0eS1bMC4wNF0gaG92ZXI6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDAsMCwwLDAuNildIGZvY3VzOnNoYWRvdy1ub25lIGZvY3VzOnRyYW5zaXRpb24tW2JvcmRlci1jb2xvcl8wLjJzXSBmb2N1czpiZWZvcmU6c2NhbGUtMTAwIGZvY3VzOmJlZm9yZTpvcGFjaXR5LVswLjEyXSBmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMCwwLDAsMC42KV0gZm9jdXM6YmVmb3JlOnRyYW5zaXRpb24tW2JveC1zaGFkb3dfMC4ycyx0cmFuc2Zvcm1fMC4yc10gZm9jdXM6YWZ0ZXI6YWJzb2x1dGUgZm9jdXM6YWZ0ZXI6ei1bMV0gZm9jdXM6YWZ0ZXI6YmxvY2sgZm9jdXM6YWZ0ZXI6aC1bMC44NzVyZW1dIGZvY3VzOmFmdGVyOnctWzAuODc1cmVtXSBmb2N1czphZnRlcjpyb3VuZGVkLVswLjEyNXJlbV0gZm9jdXM6YWZ0ZXI6Y29udGVudC1bJyddIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNjYWxlLTEwMCBjaGVja2VkOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfIzNiNzFjYV0gY2hlY2tlZDpmb2N1czpiZWZvcmU6dHJhbnNpdGlvbi1bYm94LXNoYWRvd18wLjJzLHRyYW5zZm9ybV8wLjJzXSBjaGVja2VkOmZvY3VzOmFmdGVyOi1tdC1weCBjaGVja2VkOmZvY3VzOmFmdGVyOm1sLVswLjI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOmgtWzAuODEyNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjp3LVswLjM3NXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpyb3RhdGUtNDUgY2hlY2tlZDpmb2N1czphZnRlcjpyb3VuZGVkLW5vbmUgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItWzAuMTI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXNvbGlkIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXdoaXRlIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpib3JkZXItbmV1dHJhbC02MDAgZGFyazpjaGVja2VkOmJvcmRlci1wcmltYXJ5IGRhcms6Y2hlY2tlZDpiZy1wcmltYXJ5IGRhcms6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDI1NSwyNTUsMjU1LDAuNCldIGRhcms6Y2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGRhcms6Ym9yZGVyLW5ldXRyYWwtNDAwXCIsIE5UID0gXCJtYi1bMC4xMjVyZW1dIG1pbi1oLVsxLjVyZW1dIHBsLVsxLjVyZW1dIG1sLTMgZmxleCBpdGVtcy1jZW50ZXJcIiwgTVQgPSBcImJnLXdoaXRlIGRhcms6YmctbmV1dHJhbC04MDBcIiwgUlQgPSBcInB5LTQgcGwtMSB0ZXh0LWNsaXAgb3ZlcmZsb3ctaGlkZGVuIHRleHQtWyMyMTI1MjldIGRhcms6dGV4dC13aGl0ZVwiLCBQVCA9IFwiZm9jdXM6b3V0bGluZS1ub25lXCIsIEJUID0gXCJzdGlja3kgdG9wLTAgei0zMFwiLCBIVCA9IFwic3RpY2t5IHotMTAgYmctaW5oZXJpdFwiLCBWVCA9IFwiaG92ZXI6YmctbmV1dHJhbC0xMDAgZGFyazpob3ZlcjpiZy1uZXV0cmFsLTcwMFwiLCBXVCA9IFwicG9pbnRlci1ldmVudHMtbm9uZSBjdXJzb3Itbm9uZSB0ZXh0LW5ldXRyYWwtNDAwIGRhcms6dGV4dC1uZXV0cmFsLTMwMFwiLCBGVCA9IFwiaC1bMnB4XSByZWxhdGl2ZSB3LWZ1bGwgb3ZlcmZsb3ctaGlkZGVuXCIsIFlUID0gXCJ0ZXh0LWNlbnRlciB0ZXh0LW5ldXRyYWwtNTAwIGZvbnQtbGlnaCB0ZXh0LXNtIG15LTQgZGFyazp0ZXh0LW5ldXRyYWwtNDAwXCIsIGpUID0gXCJ0ZXh0LW5ldXRyYWwtNTAwIGRhcms6dGV4dC1uZXV0cmFsLTMwMFwiLCBLVCA9IFwidGV4dC1uZXV0cmFsLTUwMCBkYXJrOnRleHQtbmV1dHJhbC0zMDBcIiwgelQgPSBcInBvaW50ZXItZXZlbnRzLW5vbmUgY3Vyc29yLW5vbmVcIiwgVVQgPSBcImgtZnVsbCB3LVs0NSVdIGJnLXByaW1hcnktNDAwIGRhcms6YmctcHJpbWFyeS02MDBcIiwgWFQgPSBcImgtZnVsbCBhbmltYXRlLVtwcm9ncmVzc18zc19lYXNlLWluLW91dF9pbmZpbml0ZV1cIiwgR1QgPSBcInBsLTIgcHktMyBmb250LWxpZ2h0IHRleHQtc20gZGFyazp0ZXh0LW5ldXRyYWwtMzAwXCIsIHFUID0gXCJib3JkZXItYlwiLCBaVCA9IFwiZmxleCBtZDpmbGV4LXJvdyBqdXN0aWZ5LWVuZCBpdGVtcy1jZW50ZXIgcHktMiBzcGFjZS14LTQgdGV4dC1zbSBmbGV4LWNvbCBsZWFkaW5nLVsxLjZdXCIsIFFUID0gXCJib3JkZXIgYm9yZGVyLXQtMFwiLCBKVCA9IFwib3JkZXItMSBteS0zIG1kOm9yZGVyLW5vbmUgbWQ6bXktMCBtZDpwci0xXCIsIHRFID0gXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBwLTIuNSB0ZXh0LXhzIGZvbnQtbWVkaXVtIHVwcGVyY2FzZSBsZWFkaW5nLW5vcm1hbCB0cmFuc2l0aW9uIGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBob3ZlcjpiZy1uZXV0cmFsLTEwMCBob3Zlcjp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6dGV4dC1wcmltYXJ5LTcwMCBkaXNhYmxlZDp0ZXh0LXNsYXRlLTMwMCBkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmhvdmVyOmJnLW5ldXRyYWwtNTAwIGRhcms6ZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpkaXNhYmxlZDp0ZXh0LW5ldXRyYWwtNjAwXCIsIGVFID0gXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBwLTIuNSBmb250LW1lZGl1bSB1cHBlcmNhc2UgbGVhZGluZy1ub3JtYWwgdHJhbnNpdGlvbiBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgaG92ZXI6YmctbmV1dHJhbC0xMDAgaG92ZXI6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTAgYWN0aXZlOnRleHQtcHJpbWFyeS03MDAgZGlzYWJsZWQ6dGV4dC1zbGF0ZS0zMDAgZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpob3ZlcjpiZy1uZXV0cmFsLTUwMCBkYXJrOmRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6ZGlzYWJsZWQ6dGV4dC1uZXV0cmFsLTYwMFwiLCBpRSA9IFwiZm9udC1ub3JtYWwgb3JkZXItMiBtYi0zIG1kOm9yZGVyLW5vbmUgbWQ6bWItMFwiLCBzRSA9IFwiaW5saW5lLWJsb2NrIHJvdW5kZWQgcC0yLjUgZm9udC1tZWRpdW0gdXBwZXJjYXNlIGxlYWRpbmctbm9ybWFsIHRyYW5zaXRpb24gZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGhvdmVyOmJnLW5ldXRyYWwtMTAwIGhvdmVyOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0wIGFjdGl2ZTp0ZXh0LXByaW1hcnktNzAwIGRpc2FibGVkOnRleHQtc2xhdGUtMzAwIGRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6aG92ZXI6YmctbmV1dHJhbC01MDAgZGFyazpkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmRpc2FibGVkOnRleHQtbmV1dHJhbC02MDBcIiwgbkUgPSBcImZvbnQtbGlnaHRcIiwgb0UgPSBcImlubGluZS1ibG9jayByb3VuZGVkIHAtMi41IGZvbnQtbWVkaXVtIHVwcGVyY2FzZSBsZWFkaW5nLW5vcm1hbCB0cmFuc2l0aW9uIGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBob3ZlcjpiZy1uZXV0cmFsLTEwMCBob3Zlcjp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6dGV4dC1wcmltYXJ5LTcwMCBkaXNhYmxlZDp0ZXh0LXNsYXRlLTMwMCBkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmhvdmVyOmJnLW5ldXRyYWwtNTAwIGRhcms6ZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpkaXNhYmxlZDp0ZXh0LW5ldXRyYWwtNjAwXCIsIHJFID0gXCJib3JkZXItYlwiLCBhRSA9IFwidHJhbnNpdGlvbiBlYXNlLWluLW91dCBkdXJhdGlvbi0zMDAgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIiwgbEUgPSBcIndoaXRlc3BhY2Utbm93cmFwIHRleHQtY2xpcCBvdmVyZmxvdy1hdXRvIHB4LVsxLjRyZW1dIHB5LTRcIiwgY0UgPSBcInJlbGF0aXZlXCIsIGhFID0gXCIhYmctbmV1dHJhbC0xMDAgZGFyazohYmctbmV1dHJhbC02MDBcIiwgZEUgPSBcImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtNCBvcmRlci0zIG1kOm9yZGVyLW5vbmVcIiwgdUUgPSBcInctWzcwcHhdXCIsIHBFID0gXCIhcHktMlwiLCBfRSA9IFwidy1bMTVweF0gaC1bMTBweF0gb3JpZ2luLWJvdHRvbSBmb250LWJsYWNrIG1yLTEgb3BhY2l0eS0wIHRleHQtbmV1dHJhbC01MDAgZ3JvdXAtaG92ZXI6b3BhY2l0eS0xMDAgdHJhbnNpdGlvbiBob3ZlcjplYXNlLWluLW91dCB0cmFuc2Zvcm0gZWFzZS1saW5lYXIgZHVyYXRpb24tMzAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhcms6dGV4dC1uZXV0cmFsLTQwMFwiLCBmRSA9IFwiZmxleCBmbGV4LXJvdyBncm91cFwiLCBtRSA9IFwiWyY6bnRoLWNoaWxkKG9kZCldOmJnLW5ldXRyYWwtNTAgWyY6bnRoLWNoaWxkKG9kZCldOmRhcms6YmctbmV1dHJhbC03MDBcIiwgZ0UgPSBcImJvcmRlclwiLCBiRSA9IFwiYm9yZGVyLWIgZm9udC1ub3JtYWwgcHgtWzEuNHJlbV1cIiwgdkUgPSBcInRleHQtbGVmdCB0ZXh0LXNtIGZvbnQtbGlnaHQgdy1mdWxsIGxlYWRpbmctWzEuNl1cIiwgVEUgPSB7XG4gIGJvcmRlcmVkOiBcImJvb2xlYW5cIixcbiAgYm9yZGVybGVzczogXCJib29sZWFuXCIsXG4gIGNsaWNrYWJsZVJvd3M6IFwiYm9vbGVhblwiLFxuICBkZWZhdWx0VmFsdWU6IFwic3RyaW5nXCIsXG4gIGVkaXQ6IFwiYm9vbGVhblwiLFxuICBlbnRyaWVzOiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBlbnRyaWVzT3B0aW9uczogXCJhcnJheVwiLFxuICBmdWxsUGFnaW5hdGlvbjogXCJib29sZWFuXCIsXG4gIGhvdmVyOiBcImJvb2xlYW5cIixcbiAgbG9hZGluZzogXCJib29sZWFuXCIsXG4gIGxvYWRpbmdNZXNzYWdlOiBcInN0cmluZ1wiLFxuICBtYXhXaWR0aDogXCIobnVsbHxudW1iZXJ8c3RyaW5nKVwiLFxuICBtYXhIZWlnaHQ6IFwiKG51bGx8bnVtYmVyfHN0cmluZylcIixcbiAgbXVsdGk6IFwiYm9vbGVhblwiLFxuICBub0ZvdW5kTWVzc2FnZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbjogXCJib29sZWFuXCIsXG4gIHNlbGVjdGFibGU6IFwiYm9vbGVhblwiLFxuICBzbTogXCJib29sZWFuXCIsXG4gIHNvcnRGaWVsZDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHNvcnRPcmRlcjogXCJzdHJpbmdcIixcbiAgZml4ZWRIZWFkZXI6IFwiYm9vbGVhblwiLFxuICBzdHJpcGVkOiBcImJvb2xlYW5cIixcbiAgcm93c1RleHQ6IFwic3RyaW5nXCIsXG4gIG9mVGV4dDogXCJzdHJpbmdcIixcbiAgYWxsVGV4dDogXCJzdHJpbmdcIixcbiAgZm9yY2VTb3J0OiBcImJvb2xlYW5cIixcbiAgc29ydEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvblN0YXJ0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uRW5kSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uTGVmdEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvblJpZ2h0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiXG59LCBFRSA9IHtcbiAgYm9yZGVyZWQ6ICExLFxuICBib3JkZXJsZXNzOiAhMSxcbiAgY2xpY2thYmxlUm93czogITEsXG4gIGRlZmF1bHRWYWx1ZTogXCItXCIsXG4gIGVkaXQ6ICExLFxuICBlbnRyaWVzOiAxMCxcbiAgZW50cmllc09wdGlvbnM6IFsxMCwgMjUsIDUwLCAyMDBdLFxuICBmaXhlZEhlYWRlcjogITEsXG4gIGZ1bGxQYWdpbmF0aW9uOiAhMSxcbiAgaG92ZXI6ICExLFxuICBsb2FkaW5nOiAhMSxcbiAgbG9hZGluZ01lc3NhZ2U6IFwiTG9hZGluZyByZXN1bHRzLi4uXCIsXG4gIG1heFdpZHRoOiBudWxsLFxuICBtYXhIZWlnaHQ6IG51bGwsXG4gIG11bHRpOiAhMSxcbiAgbm9Gb3VuZE1lc3NhZ2U6IFwiTm8gbWF0Y2hpbmcgcmVzdWx0cyBmb3VuZFwiLFxuICBwYWdpbmF0aW9uOiAhMCxcbiAgc2VsZWN0YWJsZTogITEsXG4gIHNtOiAhMSxcbiAgc29ydEZpZWxkOiBudWxsLFxuICBzb3J0T3JkZXI6IFwiYXNjXCIsXG4gIHN0cmlwZWQ6ICExLFxuICByb3dzVGV4dDogXCJSb3dzIHBlciBwYWdlOlwiLFxuICBvZlRleHQ6IFwib2ZcIixcbiAgYWxsVGV4dDogXCJBbGxcIixcbiAgZm9yY2VTb3J0OiAhMSxcbiAgc29ydEljb25UZW1wbGF0ZTogeVQsXG4gIHBhZ2luYXRpb25TdGFydEljb25UZW1wbGF0ZTogd1QsXG4gIHBhZ2luYXRpb25FbmRJY29uVGVtcGxhdGU6IE9ULFxuICBwYWdpbmF0aW9uTGVmdEljb25UZW1wbGF0ZToga1QsXG4gIHBhZ2luYXRpb25SaWdodEljb25UZW1wbGF0ZTogeFRcbn0sIENFID0ge1xuICBsYWJlbDogXCJzdHJpbmdcIixcbiAgZmllbGQ6IFwic3RyaW5nXCIsXG4gIGZpeGVkOiBcIihib29sZWFufHN0cmluZylcIixcbiAgZm9ybWF0OiBcIihmdW5jdGlvbnxudWxsKVwiLFxuICB3aWR0aDogXCIobnVtYmVyfG51bGwpXCIsXG4gIHNvcnQ6IFwiYm9vbGVhblwiLFxuICBjb2x1bW5JbmRleDogXCJudW1iZXJcIlxufSwgQUUgPSB7XG4gIGxhYmVsOiBcIlwiLFxuICBmaWVsZDogXCJcIixcbiAgZml4ZWQ6ICExLFxuICBmb3JtYXQ6IG51bGwsXG4gIHdpZHRoOiBudWxsLFxuICBzb3J0OiAhMCxcbiAgY29sdW1uSW5kZXg6IDBcbn0sIHlFID0ge1xuICB0YWJsZTogdkUsXG4gIHRhYmxlSGVhZGVyOiBiRSxcbiAgY29sdW1uOiBSVCxcbiAgcGFnaW5hdGlvbjogWlQsXG4gIHNlbGVjdFdyYXBwZXI6IHVFLFxuICBzY3JvbGw6IGNFLFxuICB0YWJsZUJvcmRlcmVkOiBnRSxcbiAgcGFnaW5hdGlvbkJvcmRlcmVkOiBRVCxcbiAgYm9yZGVybGVzczogSVQsXG4gIGNoZWNrYm94Um93V3JhcHBlcjogTlQsXG4gIGNoZWNrYm94Um93OiBMVCxcbiAgY2hlY2tib3hIZWFkZXJXcmFwcGVyOiAkVCxcbiAgY2hlY2tib3hIZWFkZXI6IERULFxuICByb3c6IHJFLFxuICByb3dJdGVtOiBsRSxcbiAgc3RyaXBlZDogbUUsXG4gIHNvcnRJY29uV3JhcHBlcjogZkUsXG4gIHNvcnRJY29uOiBfRSxcbiAgcGFnaW5hdGlvblJvd3NUZXh0OiBuRSxcbiAgcGFnaW5hdGlvbk5hdjogaUUsXG4gIHBhZ2luYXRpb25CdXR0b25zV3JhcHBlcjogSlQsXG4gIGhvdmVyUm93OiBWVCxcbiAgYm9yZGVyQ29sb3I6IFNULFxuICBjb2xvcjogTVQsXG4gIGZpeGVkSGVhZGVyOiBCVCxcbiAgZml4ZWRIZWFkZXJCb2R5OiBIVCxcbiAgc2VsZWN0YWJsZVJvdzogaEUsXG4gIHJvd0FuaW1hdGlvbjogYUUsXG4gIHNtOiBwRSxcbiAgZWRpdDogUFQsXG4gIHNlbGVjdEl0ZW1zV3JhcHBlcjogZEUsXG4gIHBhZ2luYXRpb25TdGFydEJ1dHRvbjogb0UsXG4gIHBhZ2luYXRpb25MZWZ0QnV0dG9uOiBlRSxcbiAgcGFnaW5hdGlvblJpZ2h0QnV0dG9uOiBzRSxcbiAgcGFnaW5hdGlvbkVuZEJ1dHRvbjogdEUsXG4gIGxvYWRpbmdJdGVtc1dyYXBwZXI6IEZULFxuICBsb2FkaW5nUHJvZ3Jlc3NCYXJXcmFwcGVyOiBYVCxcbiAgbG9hZGluZ1Byb2dyZXNzQmFyOiBVVCxcbiAgbG9hZGluZ01lc3NhZ2U6IFlULFxuICBsb2FkaW5nUGFnaW5hdGlvblJvd3NUZXh0OiBLVCxcbiAgbG9hZGluZ1BhZ2luYXRpb25TZWxlY3RXcmFwcGVyOiB6VCxcbiAgbG9hZGluZ1BhZ2luYXRpb25OYXY6IGpULFxuICBsb2FkaW5nQ29sdW1uOiBXVCxcbiAgbm9Gb3VuZE1lc3NhZ2VXcmFwcGVyOiBxVCxcbiAgbm9Gb3VuZE1lc3NhZ2U6IEdUXG59LCB3RSA9IHtcbiAgdGFibGU6IFwic3RyaW5nXCIsXG4gIHRhYmxlSGVhZGVyOiBcInN0cmluZ1wiLFxuICBjb2x1bW46IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb246IFwic3RyaW5nXCIsXG4gIHNlbGVjdFdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHNjcm9sbDogXCJzdHJpbmdcIixcbiAgdGFibGVCb3JkZXJlZDogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkJvcmRlcmVkOiBcInN0cmluZ1wiLFxuICBib3JkZXJsZXNzOiBcInN0cmluZ1wiLFxuICBjaGVja2JveFJvd1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGNoZWNrYm94Um93OiBcInN0cmluZ1wiLFxuICBjaGVja2JveEhlYWRlcldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGNoZWNrYm94SGVhZGVyOiBcInN0cmluZ1wiLFxuICByb3c6IFwic3RyaW5nXCIsXG4gIHJvd0l0ZW06IFwic3RyaW5nXCIsXG4gIHN0cmlwZWQ6IFwic3RyaW5nXCIsXG4gIHNvcnRJY29uV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgc29ydEljb246IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25Sb3dzVGV4dDogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbk5hdjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkJ1dHRvbnNXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBob3ZlclJvdzogXCJzdHJpbmdcIixcbiAgYm9yZGVyQ29sb3I6IFwic3RyaW5nXCIsXG4gIGNvbG9yOiBcInN0cmluZ1wiLFxuICBmaXhlZEhlYWRlcjogXCJzdHJpbmdcIixcbiAgZml4ZWRIZWFkZXJCb2R5OiBcInN0cmluZ1wiLFxuICBzZWxlY3RhYmxlUm93OiBcInN0cmluZ1wiLFxuICByb3dBbmltYXRpb246IFwic3RyaW5nXCIsXG4gIHNtOiBcInN0cmluZ1wiLFxuICBlZGl0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJdGVtc1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25TdGFydEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkxlZnRCdXR0b246IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25SaWdodEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkVuZEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ0l0ZW1zV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1Byb2dyZXNzQmFyV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1Byb2dyZXNzQmFyOiBcInN0cmluZ1wiLFxuICBsb2FkaW5nTWVzc2FnZTogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1BhZ2luYXRpb25Sb3dzVGV4dDogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1BhZ2luYXRpb25TZWxlY3RXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBsb2FkaW5nUGFnaW5hdGlvbk5hdjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ0NvbHVtbjogXCJzdHJpbmdcIixcbiAgbm9Gb3VuZE1lc3NhZ2VXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBub0ZvdW5kTWVzc2FnZTogXCJzdHJpbmdcIlxufTtcbmNsYXNzIEhoIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpID0ge30sIG4gPSB7fSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0T3B0aW9ucyhpKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMobiksIHRoaXMuX3NvcnRSZXZlcnNlID0gITEsIHRoaXMuX2FjdGl2ZVBhZ2UgPSAwLCB0aGlzLl9zZWFyY2ggPSBcIlwiLCB0aGlzLl9zZWFyY2hDb2x1bW4gPSBudWxsLCB0aGlzLl9wYWdpbmF0aW9uTGVmdCA9IG51bGwsIHRoaXMuX3BhZ2luYXRpb25SaWdodCA9IG51bGwsIHRoaXMuX3BhZ2luYXRpb25TdGFydCA9IG51bGwsIHRoaXMuX3BhZ2luYXRpb25FbmQgPSBudWxsLCB0aGlzLl9zZWxlY3QgPSBudWxsLCB0aGlzLl9zZWxlY3RJbnN0YW5jZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkID0gW10sIHRoaXMuX2NoZWNrYm94ZXMgPSBudWxsLCB0aGlzLl9oZWFkZXJDaGVja2JveCA9IG51bGwsIHRoaXMuX3Jvd3MgPSB0aGlzLl9nZXRSb3dzKGUucm93cyksIHRoaXMuX2NvbHVtbnMgPSB0aGlzLl9nZXRDb2x1bW5zKGUuY29sdW1ucyksIHRoaXMuX2VsZW1lbnQgJiYgKEEuc2V0RGF0YSh0LCBraSwgdGhpcyksIHRoaXMuX3BlcmZlY3RTY3JvbGxiYXIgPSBudWxsLCB0aGlzLl9zZXR1cCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gVmk7XG4gIH1cbiAgZ2V0IGNvbHVtbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbnMubWFwKCh0LCBlKSA9PiB7XG4gICAgICBsZXQgaSA9IHtcbiAgICAgICAgLi4uQUUsXG4gICAgICAgIGZpZWxkOiBgZmllbGRfJHtlfWAsXG4gICAgICAgIGNvbHVtbkluZGV4OiBlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBpLmxhYmVsID0gdCA6IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgKGkgPSB7XG4gICAgICAgIC4uLmksXG4gICAgICAgIC4uLnRcbiAgICAgIH0pLCBJKFwiY29sdW1uXCIsIGksIENFKSwgaTtcbiAgICB9KTtcbiAgfVxuICBnZXQgcm93cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm93cy5tYXAoKHQsIGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSB7XG4gICAgICAgIHJvd0luZGV4OiBlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0aGlzLmNvbHVtbnMuZm9yRWFjaCgobiwgbykgPT4ge1xuICAgICAgICB0W29dID09PSAwID8gaVtuLmZpZWxkXSA9IHRbb10gOiBpW24uZmllbGRdID0gdFtvXSB8fCB0aGlzLl9vcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH0pIDogdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0aGlzLmNvbHVtbnMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICB0W24uZmllbGRdID09PSAwID8gaVtuLmZpZWxkXSA9IHRbbi5maWVsZF0gOiBpW24uZmllbGRdID0gdFtuLmZpZWxkXSB8fCB0aGlzLl9vcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH0pLCBpO1xuICAgIH0pO1xuICB9XG4gIGdldCBzZWFyY2hSZXN1bHQoKSB7XG4gICAgcmV0dXJuIGRUKHRoaXMucm93cywgdGhpcy5fc2VhcmNoLCB0aGlzLl9zZWFyY2hDb2x1bW4pO1xuICB9XG4gIGdldCBjb21wdXRlZFJvd3MoKSB7XG4gICAgbGV0IHQgPSBbLi4udGhpcy5zZWFyY2hSZXN1bHRdO1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciAmJiAodCA9IGhUKHtcbiAgICAgIHJvd3M6IHQsXG4gICAgICBmaWVsZDogdGhpcy5fb3B0aW9ucy5zb3J0RmllbGQsXG4gICAgICBvcmRlcjogdGhpcy5fb3B0aW9ucy5zb3J0T3JkZXJcbiAgICB9KSksIHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbiAmJiAodGhpcy5fb3B0aW9ucy5lbnRyaWVzID09PSBcIkFsbFwiID8gdCA9IEJsKHtcbiAgICAgIHJvd3M6IHQsXG4gICAgICBlbnRyaWVzOiB0Lmxlbmd0aCxcbiAgICAgIGFjdGl2ZVBhZ2U6IHRoaXMuX2FjdGl2ZVBhZ2VcbiAgICB9KSA6IHQgPSBCbCh7XG4gICAgICByb3dzOiB0LFxuICAgICAgZW50cmllczogdGhpcy5fb3B0aW9ucy5lbnRyaWVzLFxuICAgICAgYWN0aXZlUGFnZTogdGhpcy5fYWN0aXZlUGFnZVxuICAgIH0pKSwgdDtcbiAgfVxuICBnZXQgcGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZW50cmllcyA9PT0gXCJBbGxcIiA/IDEgOiBNYXRoLmNlaWwodGhpcy5zZWFyY2hSZXN1bHQubGVuZ3RoIC8gdGhpcy5fb3B0aW9ucy5lbnRyaWVzKTtcbiAgfVxuICBnZXQgbmF2aWdhdGlvblRleHQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2FjdGl2ZVBhZ2UgKiB0aGlzLl9vcHRpb25zLmVudHJpZXM7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoUmVzdWx0Lmxlbmd0aCA9PT0gMCA/IGAwICR7dGhpcy5fb3B0aW9ucy5vZlRleHR9IDBgIDogdGhpcy5fb3B0aW9ucy5lbnRyaWVzID09PSBcIkFsbFwiID8gYDEgLSAke3RoaXMuc2VhcmNoUmVzdWx0Lmxlbmd0aH0gJHt0aGlzLl9vcHRpb25zLm9mVGV4dH0gJHt0aGlzLnNlYXJjaFJlc3VsdC5sZW5ndGh9YCA6IGAke3QgKyAxfSAtICR7dGhpcy5jb21wdXRlZFJvd3MubGVuZ3RoICsgdH0gJHt0aGlzLl9vcHRpb25zLm9mVGV4dH0gJHt0aGlzLnNlYXJjaFJlc3VsdC5sZW5ndGh9YDtcbiAgfVxuICBnZXQgdGFibGVPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB0aGlzLl9jbGFzc2VzLFxuICAgICAgY29sdW1uczogdGhpcy5jb2x1bW5zLFxuICAgICAgcm93czogdGhpcy5jb21wdXRlZFJvd3MsXG4gICAgICBub0ZvdW5kTWVzc2FnZTogdGhpcy5fb3B0aW9ucy5ub0ZvdW5kTWVzc2FnZSxcbiAgICAgIGVkaXQ6IHRoaXMuX29wdGlvbnMuZWRpdCxcbiAgICAgIGxvYWRpbmc6IHRoaXMuX29wdGlvbnMubG9hZGluZyxcbiAgICAgIGxvYWRlckNsYXNzOiB0aGlzLl9vcHRpb25zLmxvYWRlckNsYXNzLFxuICAgICAgbG9hZGluZ01lc3NhZ2U6IHRoaXMuX29wdGlvbnMubG9hZGluZ01lc3NhZ2UsXG4gICAgICBzZWxlY3RhYmxlOiB0aGlzLl9vcHRpb25zLnNlbGVjdGFibGUsXG4gICAgICBtdWx0aTogdGhpcy5fb3B0aW9ucy5tdWx0aSxcbiAgICAgIGJvcmRlcmVkOiB0aGlzLl9vcHRpb25zLmJvcmRlcmVkLFxuICAgICAgYm9yZGVybGVzczogdGhpcy5fb3B0aW9ucy5ib3JkZXJsZXNzLFxuICAgICAgc3RyaXBlZDogdGhpcy5fb3B0aW9ucy5zdHJpcGVkLFxuICAgICAgaG92ZXI6IHRoaXMuX29wdGlvbnMuaG92ZXIsXG4gICAgICBmaXhlZEhlYWRlcjogdGhpcy5fb3B0aW9ucy5maXhlZEhlYWRlcixcbiAgICAgIHNtOiB0aGlzLl9vcHRpb25zLnNtLFxuICAgICAgc29ydEljb25UZW1wbGF0ZTogdGhpcy5fb3B0aW9ucy5zb3J0SWNvblRlbXBsYXRlLFxuICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICBlbmFibGU6IHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbixcbiAgICAgICAgdGV4dDogdGhpcy5uYXZpZ2F0aW9uVGV4dCxcbiAgICAgICAgZW50cmllczogdGhpcy5fb3B0aW9ucy5lbnRyaWVzLFxuICAgICAgICBlbnRyaWVzT3B0aW9uczogdGhpcy5fb3B0aW9ucy5lbnRyaWVzT3B0aW9ucyxcbiAgICAgICAgZnVsbFBhZ2luYXRpb246IHRoaXMuX29wdGlvbnMuZnVsbFBhZ2luYXRpb24sXG4gICAgICAgIHJvd3NUZXh0OiB0aGlzLl9vcHRpb25zLnJvd3NUZXh0LFxuICAgICAgICBvZlRleHQ6IHRoaXMuX29wdGlvbnMub2ZUZXh0LFxuICAgICAgICBhbGxUZXh0OiB0aGlzLl9vcHRpb25zLmFsbFRleHQsXG4gICAgICAgIHBhZ2luYXRpb25TdGFydEljb25UZW1wbGF0ZTogdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uU3RhcnRJY29uVGVtcGxhdGUsXG4gICAgICAgIHBhZ2luYXRpb25MZWZ0SWNvblRlbXBsYXRlOiB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb25MZWZ0SWNvblRlbXBsYXRlLFxuICAgICAgICBwYWdpbmF0aW9uUmlnaHRJY29uVGVtcGxhdGU6IHRoaXMuX29wdGlvbnMucGFnaW5hdGlvblJpZ2h0SWNvblRlbXBsYXRlLFxuICAgICAgICBwYWdpbmF0aW9uRW5kSWNvblRlbXBsYXRlOiB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb25FbmRJY29uVGVtcGxhdGUsXG4gICAgICAgIGNsYXNzZXM6IHRoaXMuX2NsYXNzZXNcbiAgICAgIH0sXG4gICAgICBmb3JjZVNvcnQ6IHRoaXMuX29wdGlvbnMuZm9yY2VTb3J0XG4gICAgfTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdXBkYXRlKHQsIGUgPSB7fSkge1xuICAgIHQgJiYgdC5yb3dzICYmICh0aGlzLl9yb3dzID0gdC5yb3dzKSwgdCAmJiB0LmNvbHVtbnMgJiYgKHRoaXMuX2NvbHVtbnMgPSB0LmNvbHVtbnMpLCB0aGlzLl9jbGVhckNsYXNzTGlzdChlKSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnMoeyAuLi50aGlzLl9vcHRpb25zLCAuLi5lIH0pLCB0aGlzLl9zZXR1cCgpLCB0aGlzLl9wZXJmb3JtU29ydCgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fc2VsZWN0SW5zdGFuY2UgJiYgdGhpcy5fc2VsZWN0SW5zdGFuY2UuZGlzcG9zZSgpLCBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwga2kpLCB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpLCB0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyLmRlc3Ryb3koKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgc2VhcmNoKHQsIGUpIHtcbiAgICB0aGlzLl9zZWFyY2ggPSB0LCB0aGlzLl9zZWFyY2hDb2x1bW4gPSBlLCB0aGlzLl9hY3RpdmVQYWdlID0gMCwgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCksIHRoaXMuX29wdGlvbnMubWF4SGVpZ2h0ICYmICh0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyLmVsZW1lbnQuc2Nyb2xsVG9wID0gMCwgdGhpcy5fcGVyZmVjdFNjcm9sbGJhci51cGRhdGUoKSk7XG4gIH1cbiAgc29ydCh0LCBlID0gXCJhc2NcIikge1xuICAgIHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID0gZSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHRoaXMuX29wdGlvbnMuc29ydEZpZWxkID0gdGhpcy5jb2x1bW5zLmZpbmQoXG4gICAgICAobikgPT4gbi5sYWJlbCA9PT0gdFxuICAgICkuZmllbGQgOiB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9IHQuZmllbGQ7XG4gICAgY29uc3QgaSA9IGQuZmluZE9uZShcbiAgICAgIGBbZGF0YS10ZS1zb3J0PVwiJHt0aGlzLl9vcHRpb25zLnNvcnRGaWVsZH1cIl1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgdGhpcy5fYWN0aXZlUGFnZSA9IDAsIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCksIHRoaXMuX3NldEFjdGl2ZVNvcnRJY29uKGkpO1xuICB9XG4gIHNldEFjdGl2ZVBhZ2UodCkge1xuICAgIHQgPCB0aGlzLnBhZ2VzICYmIHRoaXMuX2NoYW5nZUFjdGl2ZVBhZ2UodCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnlFLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKFZpLCB0LCB3RSksIHQ7XG4gIH1cbiAgX2NoYW5nZUFjdGl2ZVBhZ2UodCkge1xuICAgIHRoaXMuX2FjdGl2ZVBhZ2UgPSB0LCB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fcmVuZGVyUm93cygpO1xuICB9XG4gIF9jbGVhckNsYXNzTGlzdCh0KSB7XG4gICAgW1wiaG92ZXJcIiwgXCJib3JkZXJlZFwiLCBcImJvcmRlcmxlc3NcIiwgXCJzbVwiLCBcInN0cmlwZWRcIl0uZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdGhpcy5fb3B0aW9uc1tlXSAmJiAhdFtlXSAmJiBoLnJlbW92ZURhdGFBdHRyaWJ1dGUoYGRhdGEtdGUtJHtlfWApO1xuICAgIH0pO1xuICB9XG4gIF9lbWl0U2VsZWN0RXZlbnQoKSB7XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVULCB7XG4gICAgICBzZWxlY3RlZFJvd3M6IHRoaXMucm93cy5maWx0ZXIoXG4gICAgICAgICh0KSA9PiB0aGlzLl9zZWxlY3RlZC5pbmRleE9mKHQucm93SW5kZXgpICE9PSAtMVxuICAgICAgKSxcbiAgICAgIHNlbGVjdGVkSW5kZXhlczogdGhpcy5fc2VsZWN0ZWQsXG4gICAgICBhbGxTZWxlY3RlZDogdGhpcy5fc2VsZWN0ZWQubGVuZ3RoID09PSB0aGlzLnJvd3MubGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgX2dldFJvd3ModCA9IFtdKSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcInRib2R5XCIsIHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiBlID8gWy4uLmQuZmluZChcInRyXCIsIGUpLm1hcCgobikgPT4gZC5maW5kKFwidGRcIiwgbikubWFwKChvKSA9PiBvLmlubmVySFRNTCkpLCAuLi50XSA6IHQ7XG4gIH1cbiAgX2dldENvbHVtbnModCA9IFtdKSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcInRoZWFkXCIsIHRoaXMuX2VsZW1lbnQpO1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiB0O1xuICAgIGNvbnN0IGkgPSBkLmZpbmRPbmUoXCJ0clwiLCBlKTtcbiAgICByZXR1cm4gWy4uLmQuZmluZChcInRoXCIsIGkpLm1hcCgobykgPT4gKHtcbiAgICAgIGxhYmVsOiBvLmlubmVySFRNTCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXMobylcbiAgICB9KSksIC4uLnRdO1xuICB9XG4gIF9nZXRDU1NWYWx1ZSh0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0IDogYCR7dH1weGA7XG4gIH1cbiAgX2dldE9wdGlvbnModCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5FRSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gSShWaSwgZSwgVEUpLCBlO1xuICB9XG4gIF9zZXRBY3RpdmVSb3dzKCkge1xuICAgIGQuZmluZChUaSwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdGhpcy5fc2VsZWN0ZWQuaW5jbHVkZXMoaC5nZXREYXRhQXR0cmlidXRlKHQsIFwiaW5kZXhcIikpID8gaC5hZGRDbGFzcyh0LCBgYWN0aXZlICR7dGhpcy5fY2xhc3Nlcy5zZWxlY3RhYmxlUm93fWApIDogaC5yZW1vdmVDbGFzcyh0LCBgYWN0aXZlICR7dGhpcy5fY2xhc3Nlcy5zZWxlY3RhYmxlUm93fWApO1xuICAgIH0pO1xuICB9XG4gIF9zZXRFbnRyaWVzKHQpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0T3B0aW9ucyh7XG4gICAgICAuLi50aGlzLl9vcHRpb25zLFxuICAgICAgZW50cmllczogdC50YXJnZXQudmFsdWVcbiAgICB9KSwgdGhpcy5fYWN0aXZlUGFnZSA+IHRoaXMucGFnZXMgLSAxICYmICh0aGlzLl9hY3RpdmVQYWdlID0gdGhpcy5wYWdlcyAtIDEpLCB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fcmVuZGVyUm93cygpO1xuICB9XG4gIF9zZXRTZWxlY3RlZCgpIHtcbiAgICBkLmZpbmQoeG8sIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goXG4gICAgICAodCkgPT4ge1xuICAgICAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwicm93SW5kZXhcIik7XG4gICAgICAgIHQuY2hlY2tlZCA9IHRoaXMuX3NlbGVjdGVkLmluY2x1ZGVzKGUpO1xuICAgICAgfVxuICAgICksIHRoaXMuX3NldEFjdGl2ZVJvd3MoKTtcbiAgfVxuICBfc2V0QWN0aXZlU29ydEljb24odCkge1xuICAgIGQuZmluZChrbywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID09PSBcImRlc2NcIiAmJiBlID09PSB0ID8gMTgwIDogMDtcbiAgICAgIGguc3R5bGUoZSwge1xuICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoJHtpfWRlZylgXG4gICAgICB9KSwgZSA9PT0gdCAmJiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA/IGguYWRkQ2xhc3MoZSwgXCJvcGFjaXR5LTEwMFwiKSA6IGgucmVtb3ZlQ2xhc3MoZSwgXCJvcGFjaXR5LTEwMFwiKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXAoKSB7XG4gICAgdGhpcy5fcmVuZGVyVGFibGUoKSwgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICYmIHRoaXMuX3NldHVwUGFnaW5hdGlvbigpLCB0aGlzLl9vcHRpb25zLmVkaXQgJiYgdGhpcy5fc2V0dXBFZGl0YWJsZSgpLCB0aGlzLl9vcHRpb25zLmNsaWNrYWJsZVJvd3MgJiYgdGhpcy5fc2V0dXBDbGlja2FibGVSb3dzKCksIHRoaXMuX29wdGlvbnMuc2VsZWN0YWJsZSAmJiB0aGlzLl9zZXR1cFNlbGVjdGFibGUoKSwgdGhpcy5fc2V0dXBTY3JvbGwoKSwgdGhpcy5fc2V0dXBTb3J0KCk7XG4gIH1cbiAgX3NldHVwQ2xpY2thYmxlUm93cygpIHtcbiAgICBkLmZpbmQoVGksIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGUodCwgXCJpbmRleFwiKTtcbiAgICAgIGguYWRkQ2xhc3ModCwgXCJjdXJzb3ItcG9pbnRlclwiKSwgYy5vbih0LCBcImNsaWNrXCIsIChpKSA9PiB7XG4gICAgICAgIGQubWF0Y2hlcyhpLnRhcmdldCwgeG8pIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBDVCwge1xuICAgICAgICAgIGluZGV4OiBlLFxuICAgICAgICAgIHJvdzogdGhpcy5yb3dzW2VdXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwRWRpdGFibGUoKSB7XG4gICAgZC5maW5kKFRpLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwiaW5kZXhcIik7XG4gICAgICBkLmZpbmQod28sIHQpLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgYy5vbihpLCBcImlucHV0XCIsIChuKSA9PiB0aGlzLl91cGRhdGVSb3cobiwgZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwU2Nyb2xsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUodVQsIHRoaXMuX2VsZW1lbnQpLCBlID0ge307XG4gICAgaWYgKHRoaXMuX29wdGlvbnMubWF4SGVpZ2h0ICYmIChlLm1heEhlaWdodCA9IHRoaXMuX2dldENTU1ZhbHVlKHRoaXMuX29wdGlvbnMubWF4SGVpZ2h0KSksIHRoaXMuX29wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDU1NWYWx1ZSh0aGlzLl9vcHRpb25zLm1heFdpZHRoKTtcbiAgICAgIGUubWF4V2lkdGggPSBpLCBoLnN0eWxlKHRoaXMuX2VsZW1lbnQsIHsgbWF4V2lkdGg6IGkgfSk7XG4gICAgfVxuICAgIGlmIChoLnN0eWxlKHQsIGUpLCBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMuc2Nyb2xsfWApLCB0aGlzLl9vcHRpb25zLmZpeGVkSGVhZGVyKSB7XG4gICAgICBsZXQgaSA9IGQuZmluZChwVCwgdGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLl9vcHRpb25zLnNlbGVjdGFibGUgJiYgKGkgPSBpLmZpbHRlcigobiwgbykgPT4gKGguYWRkQ2xhc3MoXG4gICAgICAgIG4sXG4gICAgICAgIGAke3RoaXMuX2NsYXNzZXMuZml4ZWRIZWFkZXJ9ICR7dGhpcy5fY2xhc3Nlcy5jb2xvcn1gXG4gICAgICApLCBvICE9PSAwKSkpLCBpLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgICAgaC5hZGRDbGFzcyhcbiAgICAgICAgICBuLFxuICAgICAgICAgIGAke3RoaXMuX2NsYXNzZXMuZml4ZWRIZWFkZXJ9ICR7dGhpcy5fY2xhc3Nlcy5jb2xvcn1gXG4gICAgICAgICksIHRoaXMuY29sdW1uc1tvXS5maXhlZCAmJiBoLmFkZENsYXNzKG4sIFwiIXotNDBcIik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcGVyZmVjdFNjcm9sbGJhciA9IG5ldyBCaCh0KTtcbiAgfVxuICBfc2V0dXBTb3J0KCkge1xuICAgIGQuZmluZChrbywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcInNvcnRcIiksIFtpXSA9IGQucGFyZW50cyh0LCBcInRoXCIpO1xuICAgICAgaWYgKHRoaXMuY29sdW1ucy5zb3J0KVxuICAgICAgICBoLmFkZENsYXNzKGksIFwiY3Vyc29yLXBvaW50ZXJcIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybjtcbiAgICAgIGUgPT09IHRoaXMuX29wdGlvbnMuc29ydEZpZWxkICYmIHRoaXMuX3NldEFjdGl2ZVNvcnRJY29uKHQpLCBjLm9uKGksIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9PT0gZSAmJiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9PT0gXCJhc2NcIiA/IHRoaXMuX29wdGlvbnMuc29ydE9yZGVyID0gXCJkZXNjXCIgOiB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9PT0gZSAmJiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9PT0gXCJkZXNjXCIgPyB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9IHRoaXMuX29wdGlvbnMuZm9yY2VTb3J0ID8gXCJhc2NcIiA6IG51bGwgOiB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9IFwiYXNjXCIsIHRoaXMuX29wdGlvbnMuc29ydEZpZWxkID0gZSwgdGhpcy5fYWN0aXZlUGFnZSA9IDAsIHRoaXMuX3BlcmZvcm1Tb3J0KCksIHRoaXMuX3NldEFjdGl2ZVNvcnRJY29uKHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3BlcmZvcm1Tb3J0KCkge1xuICAgIHRoaXMuX3RvZ2dsZURpc2FibGVTdGF0ZSgpLCB0aGlzLl9yZW5kZXJSb3dzKCk7XG4gIH1cbiAgX3NldHVwU2VsZWN0YWJsZSgpIHtcbiAgICB0aGlzLl9jaGVja2JveGVzID0gZC5maW5kKHhvLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5faGVhZGVyQ2hlY2tib3ggPSBkLmZpbmRPbmUoXG4gICAgICBfVCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5faGVhZGVyQ2hlY2tib3gsXG4gICAgICBcImlucHV0XCIsXG4gICAgICAodCkgPT4gdGhpcy5fdG9nZ2xlU2VsZWN0QWxsKHQpXG4gICAgKSwgdGhpcy5fY2hlY2tib3hlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwicm93SW5kZXhcIik7XG4gICAgICBjLm9uKFxuICAgICAgICB0LFxuICAgICAgICBcImlucHV0XCIsXG4gICAgICAgIChpKSA9PiB0aGlzLl90b2dnbGVTZWxlY3RSb3coaSwgZSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwUGFnaW5hdGlvbigpIHtcbiAgICB0aGlzLl9wYWdpbmF0aW9uUmlnaHQgPSBkLmZpbmRPbmUoXG4gICAgICBmVCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9wYWdpbmF0aW9uTGVmdCA9IGQuZmluZE9uZShcbiAgICAgIG1ULFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9wYWdpbmF0aW9uUmlnaHQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAoKSA9PiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKHRoaXMuX2FjdGl2ZVBhZ2UgKyAxKVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9wYWdpbmF0aW9uTGVmdCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgICgpID0+IHRoaXMuX2NoYW5nZUFjdGl2ZVBhZ2UodGhpcy5fYWN0aXZlUGFnZSAtIDEpXG4gICAgKSwgdGhpcy5fb3B0aW9ucy5mdWxsUGFnaW5hdGlvbiAmJiAodGhpcy5fcGFnaW5hdGlvblN0YXJ0ID0gZC5maW5kT25lKFxuICAgICAgZ1QsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fcGFnaW5hdGlvbkVuZCA9IGQuZmluZE9uZShcbiAgICAgIGJULFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9wYWdpbmF0aW9uU3RhcnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAoKSA9PiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKDApXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX3BhZ2luYXRpb25FbmQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAoKSA9PiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKHRoaXMucGFnZXMgLSAxKVxuICAgICkpLCB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fc2V0dXBQYWdpbmF0aW9uU2VsZWN0KCk7XG4gIH1cbiAgX3NldHVwUGFnaW5hdGlvblNlbGVjdCgpIHtcbiAgICB0aGlzLl9zZWxlY3QgPSBkLmZpbmRPbmUoVFQsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9zZWxlY3RJbnN0YW5jZSA9IG5ldyBrcih0aGlzLl9zZWxlY3QpLCBjLm9uKFxuICAgICAgdGhpcy5fc2VsZWN0LFxuICAgICAgXCJ2YWx1ZUNoYW5nZS50ZS5zZWxlY3RcIixcbiAgICAgICh0KSA9PiB0aGlzLl9zZXRFbnRyaWVzKHQpXG4gICAgKTtcbiAgfVxuICBfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uICYmIChjLm9mZih0aGlzLl9wYWdpbmF0aW9uUmlnaHQsIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuX3BhZ2luYXRpb25MZWZ0LCBcImNsaWNrXCIpLCBjLm9mZih0aGlzLl9zZWxlY3QsIFwidmFsdWVDaGFuZ2UudGUuc2VsZWN0XCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIChjLm9mZih0aGlzLl9wYWdpbmF0aW9uU3RhcnQsIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuX3BhZ2luYXRpb25FbmQsIFwiY2xpY2tcIikpKSwgdGhpcy5fb3B0aW9ucy5lZGl0ICYmIGQuZmluZCh3bywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5vZmYodCwgXCJpbnB1dFwiKTtcbiAgICB9KSwgdGhpcy5fb3B0aW9ucy5jbGlja2FibGVSb3dzICYmIGQuZmluZChUaSwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5vZmYodCwgXCJjbGlja1wiKTtcbiAgICB9KSwgZC5maW5kKGtvLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBbZV0gPSBkLnBhcmVudHModCwgXCJ0aFwiKTtcbiAgICAgIGMub2ZmKGUsIFwiY2xpY2tcIik7XG4gICAgfSksIHRoaXMuX29wdGlvbnMuc2VsZWN0YWJsZSAmJiAoYy5vZmYodGhpcy5faGVhZGVyQ2hlY2tib3gsIFwiaW5wdXRcIiksIHRoaXMuX2NoZWNrYm94ZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgYy5vZmYodCwgXCJpbnB1dFwiKTtcbiAgICB9KSk7XG4gIH1cbiAgX3JlbmRlclRhYmxlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuaW5uZXJIVE1MID0gUGwodGhpcy50YWJsZU9wdGlvbnMpLnRhYmxlLCB0aGlzLl9mb3JtYXRDZWxscygpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgSGwpO1xuICB9XG4gIF9yZW5kZXJSb3dzKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXCJ0Ym9keVwiLCB0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uKSB7XG4gICAgICBjb25zdCBlID0gZC5maW5kT25lKFxuICAgICAgICB2VCxcbiAgICAgICAgdGhpcy5fZWxlbWVudFxuICAgICAgKTtcbiAgICAgIGUuaW5uZXJUZXh0ID0gdGhpcy5uYXZpZ2F0aW9uVGV4dDtcbiAgICB9XG4gICAgdC5pbm5lckhUTUwgPSBQbCh0aGlzLnRhYmxlT3B0aW9ucykucm93cywgdGhpcy5fZm9ybWF0Q2VsbHMoKSwgdGhpcy5fb3B0aW9ucy5lZGl0ICYmIHRoaXMuX3NldHVwRWRpdGFibGUoKSwgdGhpcy5fb3B0aW9ucy5zZWxlY3RhYmxlICYmICh0aGlzLl9zZXR1cFNlbGVjdGFibGUoKSwgdGhpcy5fc2V0U2VsZWN0ZWQoKSksIHRoaXMuX29wdGlvbnMuY2xpY2thYmxlUm93cyAmJiB0aGlzLl9zZXR1cENsaWNrYWJsZVJvd3MoKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEhsKTtcbiAgfVxuICBfZm9ybWF0Q2VsbHMoKSB7XG4gICAgZC5maW5kKFRpLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjb25zdCBpID0gaC5nZXREYXRhQXR0cmlidXRlKGUsIFwiaW5kZXhcIik7XG4gICAgICBkLmZpbmQod28sIGUpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgY29uc3QgciA9IGguZ2V0RGF0YUF0dHJpYnV0ZShvLCBcImZpZWxkXCIpLCBhID0gdGhpcy5jb2x1bW5zLmZpbmQoKGwpID0+IGwuZmllbGQgPT09IHIpO1xuICAgICAgICBhICYmIGEuZm9ybWF0ICE9PSBudWxsICYmIGEuZm9ybWF0KG8sIHRoaXMucm93c1tpXVtyXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfdG9nZ2xlRGlzYWJsZVN0YXRlKCkge1xuICAgIHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbiAhPT0gITEgJiYgKHRoaXMuX2FjdGl2ZVBhZ2UgPT09IDAgfHwgdGhpcy5fb3B0aW9ucy5sb2FkaW5nID8gKHRoaXMuX3BhZ2luYXRpb25MZWZ0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIHRoaXMuX3BhZ2luYXRpb25TdGFydC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSkgOiAodGhpcy5fcGFnaW5hdGlvbkxlZnQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksIHRoaXMuX29wdGlvbnMuZnVsbFBhZ2luYXRpb24gJiYgdGhpcy5fcGFnaW5hdGlvblN0YXJ0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSwgdGhpcy5fYWN0aXZlUGFnZSA9PT0gdGhpcy5wYWdlcyAtIDEgfHwgdGhpcy5fb3B0aW9ucy5sb2FkaW5nIHx8IHRoaXMucGFnZXMgPT09IDAgPyAodGhpcy5fcGFnaW5hdGlvblJpZ2h0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIHRoaXMuX3BhZ2luYXRpb25FbmQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIikpIDogKHRoaXMuX3BhZ2luYXRpb25SaWdodC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSwgdGhpcy5fb3B0aW9ucy5mdWxsUGFnaW5hdGlvbiAmJiB0aGlzLl9wYWdpbmF0aW9uRW5kLnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSk7XG4gIH1cbiAgX3RvZ2dsZVNlbGVjdEFsbCh0KSB7XG4gICAgdC50YXJnZXQuY2hlY2tlZCA/IHRoaXMuX3NlbGVjdGVkID0gdGhpcy5yb3dzLm1hcCgoZSkgPT4gZS5yb3dJbmRleCkgOiB0aGlzLl9zZWxlY3RlZCA9IFtdLCB0aGlzLl9zZXRTZWxlY3RlZCgpLCB0aGlzLl9lbWl0U2VsZWN0RXZlbnQoKTtcbiAgfVxuICBfdG9nZ2xlU2VsZWN0Um93KHQsIGUpIHtcbiAgICB0LnRhcmdldC5jaGVja2VkID8gdGhpcy5fb3B0aW9ucy5tdWx0aSAmJiAhdGhpcy5fc2VsZWN0ZWQuaW5jbHVkZXMoZSkgPyB0aGlzLl9zZWxlY3RlZCA9IFsuLi50aGlzLl9zZWxlY3RlZCwgZV0gOiAodGhpcy5fc2VsZWN0ZWQgPSBbZV0sIHRoaXMuX2NoZWNrYm94ZXMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgaSAhPT0gdC50YXJnZXQgJiYgKGkuY2hlY2tlZCA9ICExKTtcbiAgICB9KSkgOiB0aGlzLl9zZWxlY3RlZCA9IHRoaXMuX3NlbGVjdGVkLmZpbHRlcigoaSkgPT4gaSAhPT0gZSksIHRoaXMuX29wdGlvbnMubXVsdGkgJiYgIXQudGFyZ2V0LmNoZWNrZWQgJiYgKHRoaXMuX2hlYWRlckNoZWNrYm94LmNoZWNrZWQgPSAhMSksIHRoaXMuX3NldEFjdGl2ZVJvd3MoKSwgdGhpcy5fZW1pdFNlbGVjdEV2ZW50KCk7XG4gIH1cbiAgX3VwZGF0ZVJvdyh0LCBlKSB7XG4gICAgY29uc3QgaSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LnRhcmdldCwgXCJmaWVsZFwiKSwgbiA9IHQudGFyZ2V0LnRleHRDb250ZW50LCBvID0gdGhpcy5fcm93c1tlXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuICAgICAgY29uc3QgYSA9IHRoaXMuY29sdW1ucy5maW5kKChsKSA9PiBsLmZpZWxkID09PSBpKS5jb2x1bW5JbmRleDtcbiAgICAgIG9bYV0gPSBuO1xuICAgIH0gZWxzZVxuICAgICAgb1tpXSA9IG47XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEFULCB7XG4gICAgICByb3dzOiB0aGlzLl9yb3dzLFxuICAgICAgY29sdW1uczogdGhpcy5fY29sdW1uc1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSwgaSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgbiA9IEEuZ2V0RGF0YSh0aGlzLCBraSk7XG4gICAgICBjb25zdCBvID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIW4gJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChuIHx8IChuID0gbmV3IEhoKHRoaXMsIG8sIGUpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIG5bdF0oZSwgaSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIGtpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBWbCA9IFwicmF0aW5nXCIsIHNuID0gXCJ0ZS5yYXRpbmdcIiwga0UgPSBcImRhdGEtdGUtcmF0aW5nLWluaXRcIiwgeEUgPSBcIltkYXRhLXRlLXJhdGluZy1pY29uLXJlZl1cIiwgY2kgPSBgLiR7c259YCwgT0UgPSBcIkFycm93TGVmdFwiLCBTRSA9IFwiQXJyb3dSaWdodFwiLCBJRSA9IHtcbiAgdG9vbHRpcDogXCJzdHJpbmdcIixcbiAgdmFsdWU6IFwiKHN0cmluZ3xudW1iZXIpXCIsXG4gIHJlYWRvbmx5OiBcImJvb2xlYW5cIixcbiAgYWZ0ZXI6IFwic3RyaW5nXCIsXG4gIGJlZm9yZTogXCJzdHJpbmdcIixcbiAgZHluYW1pYzogXCJib29sZWFuXCIsXG4gIGFjdGl2ZTogXCJzdHJpbmdcIlxufSwgREUgPSB7XG4gIHRvb2x0aXA6IFwidG9wXCIsXG4gIHZhbHVlOiBcIlwiLFxuICByZWFkb25seTogITEsXG4gIGFmdGVyOiBcIlwiLFxuICBiZWZvcmU6IFwiXCIsXG4gIGR5bmFtaWM6ICExLFxuICBhY3RpdmU6IFwiZmlsbC1jdXJyZW50XCJcbn0sIFdsID0gYG9uU2VsZWN0JHtjaX1gLCAkRSA9IGBvbkhvdmVyJHtjaX1gLCBGbCA9IGBrZXl1cCR7Y2l9YCwgWWwgPSBgZm9jdXNvdXQke2NpfWAsIGpsID0gYGtleWRvd24ke2NpfWAsIEtsID0gYG1vdXNlZG93biR7Y2l9YDtcbmNsYXNzIEdBIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9pY29ucyA9IGQuZmluZCh4RSwgdGhpcy5fZWxlbWVudCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2luZGV4ID0gLTEsIHRoaXMuX3NhdmVkSW5kZXggPSBudWxsLCB0aGlzLl9vcmlnaW5hbENsYXNzTGlzdCA9IFtdLCB0aGlzLl9vcmlnaW5hbEljb25zID0gW10sIHRoaXMuX2ZuID0ge30sIHRoaXMuX3Rvb2x0aXBzID0gW10sIHRoaXMuX2VsZW1lbnQgJiYgKEEuc2V0RGF0YSh0LCBzbiwgdGhpcyksIHRoaXMuX2luaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFZsO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHNuKSwgdGhpcy5fb3B0aW9ucy5yZWFkb25seSB8fCAoYy5vZmYodGhpcy5fZWxlbWVudCwgRmwpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBZbCksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIGpsKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLl9mbi5tb3VzZWxlYXZlKSwgdGhpcy5faWNvbnMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgYy5vZmYodCwgS2wpLCB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIHRoaXMuX2ZuLm1vdXNlZW50ZXJbZV0pLCBoLnJlbW92ZUNsYXNzKHQsIFwiY3Vyc29yLXBvaW50ZXJcIik7XG4gICAgfSksIHRoaXMuX3Rvb2x0aXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtFKSwgdC5kaXNwb3NlKCk7XG4gICAgfSksIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHQucmVtb3ZlQXR0cmlidXRlKFwidGFiSW5kZXhcIikpKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9vcHRpb25zLnJlYWRvbmx5IHx8ICh0aGlzLl9iaW5kTW91c2VFbnRlcigpLCB0aGlzLl9iaW5kTW91c2VMZWF2ZSgpLCB0aGlzLl9iaW5kTW91c2VEb3duKCksIHRoaXMuX2JpbmRLZXlEb3duKCksIHRoaXMuX2JpbmRLZXlVcCgpLCB0aGlzLl9iaW5kRm9jdXNMb3N0KCksIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGguYWRkQ2xhc3ModCwgXCJjdXJzb3ItcG9pbnRlclwiKTtcbiAgICB9KSksIHRoaXMuX29wdGlvbnMuZHluYW1pYyAmJiAodGhpcy5fc2F2ZU9yaWdpbmFsQ2xhc3NMaXN0KCksIHRoaXMuX3NhdmVPcmlnaW5hbEljb25zKCkpLCB0aGlzLl9zZXRDdXN0b21UZXh0KCksIHRoaXMuX3NldFRvb2xUaXBzKCksIHRoaXMuX29wdGlvbnMudmFsdWUgJiYgKHRoaXMuX2luZGV4ID0gdGhpcy5fb3B0aW9ucy52YWx1ZSAtIDEsIHRoaXMuX3VwZGF0ZVJhdGluZyh0aGlzLl9pbmRleCkpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uREUsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoVmwsIHQsIElFKSwgdDtcbiAgfVxuICBfYmluZE1vdXNlRW50ZXIoKSB7XG4gICAgdGhpcy5fZm4ubW91c2VlbnRlciA9IFtdLCB0aGlzLl9pY29ucy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICB0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibW91c2VlbnRlclwiLFxuICAgICAgICAvLyB0aGlzLl9mbi5tb3VzZWVudGVyW2ldIGlzIG5lZWRlZCB0byBjcmVhdGUgcmVmZXJlbmNlIGFuZCB1bnBpbiBldmVudHMgYWZ0ZXIgY2FsbCBkaXNwb3NlXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICB0aGlzLl9mbi5tb3VzZWVudGVyW2VdID0gKGkpID0+IHtcbiAgICAgICAgICB0aGlzLl9pbmRleCA9IHRoaXMuX2ljb25zLmluZGV4T2YoaS50YXJnZXQpLCB0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5faW5kZXgpLCB0aGlzLl90cmlnZ2VyRXZlbnRzKHQsICRFKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZE1vdXNlTGVhdmUoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJtb3VzZWxlYXZlXCIsXG4gICAgICAvLyB0aGlzLl9mbi5tb3VzZWxlYXZlIGlzIG5lZWRlZCB0byBjcmVhdGUgcmVmZXJlbmNlIGFuZCB1bnBpbiBldmVudHMgYWZ0ZXIgY2FsbCBkaXNwb3NlXG4gICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgIHRoaXMuX2ZuLm1vdXNlbGVhdmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3NhdmVkSW5kZXggIT09IG51bGwgPyAodGhpcy5fdXBkYXRlUmF0aW5nKHRoaXMuX3NhdmVkSW5kZXgpLCB0aGlzLl9pbmRleCA9IHRoaXMuX3NhdmVkSW5kZXgpIDogdGhpcy5fb3B0aW9ucy52YWx1ZSA/ICh0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5fb3B0aW9ucy52YWx1ZSAtIDEpLCB0aGlzLl9pbmRleCA9IHRoaXMuX29wdGlvbnMudmFsdWUgLSAxKSA6ICh0aGlzLl9pbmRleCA9IC0xLCB0aGlzLl9jbGVhclJhdGluZygpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9iaW5kTW91c2VEb3duKCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGMub24odCwgS2wsICgpID0+IHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudE91dGxpbmUoXCJub25lXCIpLCB0aGlzLl9zYXZlZEluZGV4ID0gdGhpcy5faW5kZXgsIHRoaXMuX3RyaWdnZXJFdmVudHModCwgV2wpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRLZXlEb3duKCkge1xuICAgIHRoaXMuX2VsZW1lbnQudGFiSW5kZXggPSAwLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGpsLFxuICAgICAgKHQpID0+IHRoaXMuX3VwZGF0ZUFmdGVyS2V5RG93bih0KVxuICAgICk7XG4gIH1cbiAgX2JpbmRLZXlVcCgpIHtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIEZsLFxuICAgICAgKCkgPT4gdGhpcy5fc2V0RWxlbWVudE91dGxpbmUoXCJhdXRvXCIpXG4gICAgKTtcbiAgfVxuICBfYmluZEZvY3VzTG9zdCgpIHtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFlsLFxuICAgICAgKCkgPT4gdGhpcy5fc2V0RWxlbWVudE91dGxpbmUoXCJub25lXCIpXG4gICAgKTtcbiAgfVxuICBfc2V0RWxlbWVudE91dGxpbmUodCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3V0bGluZSA9IHQ7XG4gIH1cbiAgX3RyaWdnZXJFdmVudHModCwgZSkge1xuICAgIGMudHJpZ2dlcih0LCBlLCB7XG4gICAgICB2YWx1ZTogdGhpcy5faW5kZXggKyAxXG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZUFmdGVyS2V5RG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2ljb25zLmxlbmd0aCAtIDEsIGkgPSB0aGlzLl9pbmRleDtcbiAgICB0LmtleSA9PT0gU0UgJiYgdGhpcy5faW5kZXggPCBlICYmICh0aGlzLl9pbmRleCArPSAxKSwgdC5rZXkgPT09IE9FICYmIHRoaXMuX2luZGV4ID4gLTEgJiYgKHRoaXMuX2luZGV4IC09IDEpLCBpICE9PSB0aGlzLl9pbmRleCAmJiAodGhpcy5fc2F2ZWRJbmRleCA9IHRoaXMuX2luZGV4LCB0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5fc2F2ZWRJbmRleCksIHRoaXMuX3RyaWdnZXJFdmVudHModGhpcy5faWNvbnNbdGhpcy5fc2F2ZWRJbmRleF0sIFdsKSk7XG4gIH1cbiAgX3VwZGF0ZVJhdGluZyh0KSB7XG4gICAgdGhpcy5fY2xlYXJSYXRpbmcoKSwgdGhpcy5fb3B0aW9ucy5keW5hbWljICYmIHRoaXMuX3Jlc3RvcmVPcmlnaW5hbEljb24odCksIHRoaXMuX2ljb25zLmZvckVhY2goKGUsIGkpID0+IHtcbiAgICAgIGkgPD0gdCAmJiBoLmFkZENsYXNzKGUucXVlcnlTZWxlY3RvcihcInN2Z1wiKSwgdGhpcy5fb3B0aW9ucy5hY3RpdmUpO1xuICAgIH0pO1xuICB9XG4gIF9jbGVhclJhdGluZygpIHtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICBjb25zdCBpID0gdC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpO1xuICAgICAgdGhpcy5fb3B0aW9ucy5keW5hbWljICYmICh0LmNsYXNzTGlzdCA9IHRoaXMuX29yaWdpbmFsQ2xhc3NMaXN0W2VdLCBpLmlubmVySFRNTCA9IHRoaXMuX29yaWdpbmFsSWNvbnNbZV0pLCBoLnJlbW92ZUNsYXNzKGksIHRoaXMuX29wdGlvbnMuYWN0aXZlKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0VG9vbFRpcHMoKSB7XG4gICAgdGhpcy5faWNvbnMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcInRvZ2dsZVwiKTtcbiAgICAgIHQudGl0bGUgJiYgIWkgJiYgKGguc2V0RGF0YUF0dHJpYnV0ZSh0LCBcInRvZ2dsZVwiLCBcInRvb2x0aXBcIiksIHRoaXMuX3Rvb2x0aXBzW2VdID0gbmV3IHJpKHQsIHtcbiAgICAgICAgcGxhY2VtZW50OiB0aGlzLl9vcHRpb25zLnRvb2x0aXBcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0Q3VzdG9tVGV4dCgpIHtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwiYWZ0ZXJcIiksIGkgPSBoLmdldERhdGFBdHRyaWJ1dGUodCwgXCJiZWZvcmVcIik7XG4gICAgICBlICYmIHQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYWZ0ZXJFbmRcIiwgZSksIGkgJiYgdC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVCZWdpblwiLCBpKTtcbiAgICB9KTtcbiAgfVxuICBfc2F2ZU9yaWdpbmFsQ2xhc3NMaXN0KCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LmNsYXNzTGlzdC52YWx1ZTtcbiAgICAgIHRoaXMuX29yaWdpbmFsQ2xhc3NMaXN0LnB1c2goZSk7XG4gICAgfSk7XG4gIH1cbiAgX3NhdmVPcmlnaW5hbEljb25zKCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIikuaW5uZXJIVE1MO1xuICAgICAgdGhpcy5fb3JpZ2luYWxJY29ucy5wdXNoKGUpO1xuICAgIH0pO1xuICB9XG4gIF9yZXN0b3JlT3JpZ2luYWxJY29uKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fb3JpZ2luYWxDbGFzc0xpc3RbdF0sIGkgPSB0aGlzLl9vcmlnaW5hbEljb25zW3RdO1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIGlmIChvIDw9IHQpIHtcbiAgICAgICAgY29uc3QgciA9IG4ucXVlcnlTZWxlY3RvcihcInN2Z1wiKTtcbiAgICAgICAgci5pbm5lckhUTUwgPSBpLCBuLmNsYXNzTGlzdCA9IGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEEuZ2V0RGF0YSh0LCBzbik7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgT28gPSBcInBvcGNvbmZpcm1cIiwgeGkgPSBcInRlLnBvcGNvbmZpcm1cIiwgVmggPSBgLiR7eGl9YCwgTEUgPSBgY2FuY2VsJHtWaH1gLCBORSA9IGBjb25maXJtJHtWaH1gLCBNRSA9IFwiW2RhdGEtdGUtcG9wY29uZmlybS1ib2R5XVwiLCBTbyA9IFwiZGF0YS10ZS1wb3Bjb25maXJtLXBvcG92ZXJcIiwgUkUgPSBcImRhdGEtdGUtcG9wY29uZmlybS1tb2RhbFwiLCB6bCA9IFwiZGF0YS10ZS1wb3Bjb25maXJtLWJhY2tkcm9wXCIsIFBFID0ge1xuICBwb3Bjb25maXJtTW9kZTogXCJzdHJpbmdcIixcbiAgbWVzc2FnZTogXCJzdHJpbmdcIixcbiAgY2FuY2VsVGV4dDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIG9rVGV4dDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHBvcGNvbmZpcm1JY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIGNhbmNlbExhYmVsOiBcIihudWxsfHN0cmluZylcIixcbiAgY29uZmlybUxhYmVsOiBcIihudWxsfHN0cmluZylcIixcbiAgcG9zaXRpb246IFwiKG51bGx8c3RyaW5nKVwiXG59LCBCRSA9IHtcbiAgcG9wY29uZmlybU1vZGU6IFwiaW5saW5lXCIsXG4gIG1lc3NhZ2U6IFwiQXJlIHlvdSBzdXJlP1wiLFxuICBjYW5jZWxUZXh0OiBcIkNhbmNlbFwiLFxuICBva1RleHQ6IFwiT0tcIixcbiAgcG9wY29uZmlybUljb25UZW1wbGF0ZTogXCJcIixcbiAgY2FuY2VsTGFiZWw6IFwiQ2FuY2VsXCIsXG4gIGNvbmZpcm1MYWJlbDogXCJDb25maXJtXCIsXG4gIHBvc2l0aW9uOiBcImJvdHRvbVwiXG59LCBIRSA9IHtcbiAgYmFja2Ryb3A6IFwic3RyaW5nXCIsXG4gIGJvZHk6IFwic3RyaW5nXCIsXG4gIGJ0bkNhbmNlbDogXCJzdHJpbmdcIixcbiAgYnRuQ29uZmlybTogXCJzdHJpbmdcIixcbiAgYnRuc0NvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgZmFkZTogXCJzdHJpbmdcIixcbiAgaWNvbjogXCJzdHJpbmdcIixcbiAgbWVzc2FnZTogXCJzdHJpbmdcIixcbiAgbWVzc2FnZVRleHQ6IFwic3RyaW5nXCIsXG4gIG1vZGFsOiBcInN0cmluZ1wiLFxuICBwb3BvdmVyOiBcInN0cmluZ1wiXG59LCBWRSA9IHtcbiAgYmFja2Ryb3A6IFwiaC1mdWxsIHctZnVsbCB6LVsxMDcwXSBmaXhlZCB0b3AtMCBsZWZ0LTAgYmctWyMwMDAwMDA2Nl0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIixcbiAgYm9keTogXCJwLVsxcmVtXSBiZy13aGl0ZSByb3VuZGVkLVswLjVyZW1dIG9wYWNpdHktMCBkYXJrOmJnLW5ldXRyYWwtNzAwXCIsXG4gIGJ0bkNhbmNlbDogXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBiZy1wcmltYXJ5LTEwMCBweC00IHBiLVs1cHhdIHB0LVs2cHhdIHRleHQteHMgZm9udC1tZWRpdW0gdXBwZXJjYXNlIGxlYWRpbmctbm9ybWFsIHRleHQtcHJpbWFyeS03MDAgdHJhbnNpdGlvbiBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgaG92ZXI6YmctcHJpbWFyeS1hY2NlbnQtMTAwIGZvY3VzOmJnLXByaW1hcnktYWNjZW50LTEwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0wIGFjdGl2ZTpiZy1wcmltYXJ5LWFjY2VudC0yMDBcIixcbiAgYnRuQ29uZmlybTogXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBiZy1wcmltYXJ5IHB4LTQgcGItWzVweF0gcHQtWzZweF0gdGV4dC14cyBmb250LW1lZGl1bSB1cHBlcmNhc2UgbGVhZGluZy1ub3JtYWwgdGV4dC13aGl0ZSBzaGFkb3ctWzBfNHB4XzlweF8tNHB4XyMzYjcxY2FdIHRyYW5zaXRpb24gZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGhvdmVyOmJnLXByaW1hcnktNjAwIGhvdmVyOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMyksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjIpXSBmb2N1czpiZy1wcmltYXJ5LTYwMCBmb2N1czpzaGFkb3ctWzBfOHB4XzlweF8tNHB4X3JnYmEoNTksMTEzLDIwMiwwLjMpLDBfNHB4XzE4cHhfMF9yZ2JhKDU5LDExMywyMDIsMC4yKV0gZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6YmctcHJpbWFyeS03MDAgYWN0aXZlOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMyksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjIpXSBkYXJrOnNoYWRvdy1bMF80cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuNSldIGRhcms6aG92ZXI6c2hhZG93LVswXzhweF85cHhfLTRweF9yZ2JhKDU5LDExMywyMDIsMC4yKSwwXzRweF8xOHB4XzBfcmdiYSg1OSwxMTMsMjAyLDAuMSldIGRhcms6Zm9jdXM6c2hhZG93LVswXzhweF85cHhfLTRweF9yZ2JhKDU5LDExMywyMDIsMC4yKSwwXzRweF8xOHB4XzBfcmdiYSg1OSwxMTMsMjAyLDAuMSldIGRhcms6YWN0aXZlOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMiksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjEpXVwiLFxuICBidG5zQ29udGFpbmVyOiBcImZsZXgganVzdGlmeS1lbmQgc3BhY2UteC0yXCIsXG4gIGZhZGU6IFwidHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVsxNTBtc10gZWFzZS1saW5lYXJcIixcbiAgaWNvbjogXCJwci0yXCIsXG4gIG1lc3NhZ2U6IFwiZmxleCBtYi0zXCIsXG4gIG1lc3NhZ2VUZXh0OiBcInRleHQtbmV1dHJhbC02MDAgZGFyazp0ZXh0LXdoaXRlXCIsXG4gIG1vZGFsOiBcImFic29sdXRlIHctWzMwMHB4XSB6LVsxMDgwXSBzaGFkb3ctc20gcm91bmRlZC1bMC41cmVtXVwiLFxuICBwb3BvdmVyOiBcInctWzMwMHB4XSBib3JkZXItMCByb3VuZGVkLVswLjVyZW1dIHotWzEwODBdIHNoYWRvdy1zbVwiXG59O1xuY2xhc3MgV2gge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jYW5jZWxCdXR0b24gPSBcIlwiLCB0aGlzLl9jb25maXJtQnV0dG9uID0gXCJcIiwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX3VpZCA9IHRoaXMuX2VsZW1lbnQuaWQgPyBgcG9wY29uZmlybS0ke3RoaXMuX2VsZW1lbnQuaWR9YCA6IGV0KFwicG9wY29uZmlybS1cIiksIHQgJiYgQS5zZXREYXRhKHQsIHhpLCB0aGlzKSwgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5vcGVuLmJpbmQodGhpcyksIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBPbztcbiAgfVxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoYCMke3RoaXMuX3VpZH1gKTtcbiAgfVxuICBnZXQgcG9wY29uZmlybUJvZHkoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcbiAgICAgIE1FLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgICh0aGlzLl9pc09wZW4gfHwgdGhpcy5jb250YWluZXIgIT09IG51bGwpICYmIHRoaXMuY2xvc2UoKSwgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHhpKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBvcGVuKCkge1xuICAgIHRoaXMuX2lzT3BlbiB8fCAodGhpcy5fb3B0aW9ucy5wb3Bjb25maXJtTW9kZSA9PT0gXCJpbmxpbmVcIiA/IHRoaXMuX29wZW5Qb3BvdmVyKHRoaXMuX2dldFBvcG92ZXJUZW1wbGF0ZSgpKSA6IHRoaXMuX29wZW5Nb2RhbCh0aGlzLl9nZXRNb2RhbFRlbXBsYXRlKCkpLCB0aGlzLl9oYW5kbGVDYW5jZWxCdXR0b25DbGljaygpLCB0aGlzLl9oYW5kbGVDb25maXJtQnV0dG9uQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9Fc2NhcGVLZXkoKSwgdGhpcy5fbGlzdGVuVG9PdXRzaWRlQ2xpY2soKSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2lzT3Blbikge1xuICAgICAgaWYgKHRoaXMuX3BvcHBlciAhPT0gbnVsbCB8fCBkLmZpbmRPbmUoYFske1NvfV1gKSAhPT0gbnVsbClcbiAgICAgICAgYy5vbihcbiAgICAgICAgICB0aGlzLnBvcGNvbmZpcm1Cb2R5LFxuICAgICAgICAgIFwidHJhbnNpdGlvbmVuZFwiLFxuICAgICAgICAgIHRoaXMuX2hhbmRsZVBvcGNvbmZpcm1UcmFuc2l0aW9uRW5kLmJpbmQodGhpcylcbiAgICAgICAgKSwgaC5yZW1vdmVDbGFzcyh0aGlzLnBvcGNvbmZpcm1Cb2R5LCBcIm9wYWNpdHktMTAwXCIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske3psfV1gXG4gICAgICAgICk7XG4gICAgICAgIGgucmVtb3ZlQ2xhc3ModGhpcy5wb3Bjb25maXJtQm9keSwgXCJvcGFjaXR5LTEwMFwiKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0KSwgdGhpcy5faXNPcGVuID0gITE7XG4gICAgICB9XG4gICAgICBjLm9mZihkb2N1bWVudCwgXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVPdXRzaWRlQ2xpY2suYmluZCh0aGlzKSksIGMub2ZmKGRvY3VtZW50LCBcImtleWRvd25cIiwgdGhpcy5faGFuZGxlRXNjYXBlS2V5LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlUG9wY29uZmlybVRyYW5zaXRpb25FbmQodCkge1xuICAgIGlmICh0LnRhcmdldCAhPT0gdGhpcy5wb3Bjb25maXJtQm9keSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKFxuICAgICAgYFske1NvfV1gXG4gICAgKTtcbiAgICBjLm9mZih0aGlzLnBvcGNvbmZpcm1Cb2R5LCBcInRyYW5zaXRpb25lbmRcIiksIHRoaXMuX2lzT3BlbiAmJiB0ICYmIHQucHJvcGVydHlOYW1lID09PSBcIm9wYWNpdHlcIiAmJiAodGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgZSAmJiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGUpLCB0aGlzLl9pc09wZW4gPSAhMSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0UG9wb3ZlclRlbXBsYXRlKCkge1xuICAgIGNvbnN0IHQgPSAkKFwiZGl2XCIpLCBlID0gdGhpcy5fZ2V0UG9wY29uZmlybVRlbXBsYXRlKCk7XG4gICAgcmV0dXJuIHQuc2V0QXR0cmlidXRlKFNvLCBcIlwiKSwgaC5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLnBvcG92ZXIpLCB0LmlkID0gdGhpcy5fdWlkLCB0LmlubmVySFRNTCA9IGUsIHQ7XG4gIH1cbiAgX2dldE1vZGFsVGVtcGxhdGUoKSB7XG4gICAgY29uc3QgdCA9ICQoXCJkaXZcIiksIGUgPSB0aGlzLl9nZXRQb3Bjb25maXJtVGVtcGxhdGUoKTtcbiAgICByZXR1cm4gdC5zZXRBdHRyaWJ1dGUoUkUsIFwiXCIpLCBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMubW9kYWx9YCksIHQuaWQgPSB0aGlzLl91aWQsIHQuaW5uZXJIVE1MID0gZSwgdDtcbiAgfVxuICBfZ2V0UG9wY29uZmlybVRlbXBsYXRlKCkge1xuICAgIHJldHVybiBgPGRpdiBkYXRhLXRlLXBvcGNvbmZpcm0tYm9keSBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5ib2R5fVwiPlxuICAgICAgPHAgY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMubWVzc2FnZX1cIj5cbiAgICAgICR7dGhpcy5fb3B0aW9ucy5wb3Bjb25maXJtSWNvblRlbXBsYXRlID8gYDxzcGFuIGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLmljb259XCI+JHt0aGlzLl9vcHRpb25zLnBvcGNvbmZpcm1JY29uVGVtcGxhdGV9PC9zcGFuPmAgOiBcIlwifVxuICAgICAgPHNwYW4gY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMubWVzc2FnZVRleHR9XCI+JHt0aGlzLl9vcHRpb25zLm1lc3NhZ2V9PC9zcGFuPlxuICAgICAgPC9wPlxuICAgICAgPGRpdiBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5idG5zQ29udGFpbmVyfVwiPlxuICAgICAgJHt0aGlzLl9vcHRpb25zLmNhbmNlbFRleHQgPyBgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS10ZS1yaXBwbGUtaW5pdCBkYXRhLXRlLXJpcHBsZS1jb2xvcj1cImxpZ2h0XCIgaWQ9XCJwb3Bjb25maXJtLWJ1dHRvbi1jYW5jZWxcIiBhcmlhLWxhYmVsPVwiJHt0aGlzLl9vcHRpb25zLmNhbmNlbExhYmVsfVwiXG4gICAgICAgIGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLmJ0bkNhbmNlbH1cIj4ke3RoaXMuX29wdGlvbnMuY2FuY2VsVGV4dH08L2J1dHRvbj5gIDogXCJcIn1cbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtdGUtcmlwcGxlLWluaXQgZGF0YS10ZS1yaXBwbGUtY29sb3I9XCJsaWdodFwiIGlkPVwicG9wY29uZmlybS1idXR0b24tY29uZmlybVwiXG4gICAgICBhcmlhLWxhYmVsPVwiJHt0aGlzLl9vcHRpb25zLmNvbmZpcm1MYWJlbH1cIlxuICAgICAgY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMuYnRuQ29uZmlybX1cIj4ke3RoaXMuX29wdGlvbnMub2tUZXh0ID8gdGhpcy5fb3B0aW9ucy5va1RleHQgOiBcIk9rXCJ9PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5gO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uQkUsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH0sIEkoT28sIHQsIFBFKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlZFLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKE9vLCB0LCBIRSksIHQ7XG4gIH1cbiAgX29wZW5Qb3BvdmVyKHQpIHtcbiAgICB0aGlzLl9wb3BwZXIgPSBzZSh0aGlzLl9lbGVtZW50LCB0LCB7XG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuX3RyYW5zbGF0ZVBvc2l0aW9uVmFsdWUoKSxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCA1XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGguYWRkQ2xhc3MoXG4gICAgICAgIHRoaXMucG9wY29uZmlybUJvZHksXG4gICAgICAgIGAke3RoaXMuX2NsYXNzZXMuZmFkZX0gb3BhY2l0eS0xMDBgXG4gICAgICApLCB0aGlzLl9pc09wZW4gPSAhMDtcbiAgICB9LCAwKTtcbiAgfVxuICBfb3Blbk1vZGFsKHQpIHtcbiAgICBjb25zdCBlID0gJChcImRpdlwiKTtcbiAgICBlLnNldEF0dHJpYnV0ZSh6bCwgXCJcIiksIGguYWRkQ2xhc3MoZSwgdGhpcy5fY2xhc3Nlcy5iYWNrZHJvcCksIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSksIGUuYXBwZW5kQ2hpbGQodCksIGguYWRkQ2xhc3ModGhpcy5wb3Bjb25maXJtQm9keSwgXCJvcGFjaXR5LTEwMFwiKSwgdGhpcy5faXNPcGVuID0gITA7XG4gIH1cbiAgX2hhbmRsZUNhbmNlbEJ1dHRvbkNsaWNrKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICB0aGlzLl9jYW5jZWxCdXR0b24gPSBkLmZpbmRPbmUoXG4gICAgICBcIiNwb3Bjb25maXJtLWJ1dHRvbi1jYW5jZWxcIixcbiAgICAgIHRcbiAgICApLCBlaS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMuX2NhbmNlbEJ1dHRvbiwgeyByaXBwbGVDb2xvcjogXCJsaWdodFwiIH0pLCB0aGlzLl9jYW5jZWxCdXR0b24gIT09IG51bGwgJiYgYy5vbih0aGlzLl9jYW5jZWxCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZSgpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgTEUpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVDb25maXJtQnV0dG9uQ2xpY2soKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY29udGFpbmVyO1xuICAgIHRoaXMuX2NvbmZpcm1CdXR0b24gPSBkLmZpbmRPbmUoXG4gICAgICBcIiNwb3Bjb25maXJtLWJ1dHRvbi1jb25maXJtXCIsXG4gICAgICB0XG4gICAgKSwgZWkuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLl9jb25maXJtQnV0dG9uLCB7IHJpcHBsZUNvbG9yOiBcImxpZ2h0XCIgfSksIGMub24odGhpcy5fY29uZmlybUJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlKCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBORSk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvRXNjYXBlS2V5KCkge1xuICAgIGMub24oZG9jdW1lbnQsIFwia2V5ZG93blwiLCB0aGlzLl9oYW5kbGVFc2NhcGVLZXkuYmluZCh0aGlzKSk7XG4gIH1cbiAgX2hhbmRsZUVzY2FwZUtleSh0KSB7XG4gICAgdC5rZXlDb2RlID09PSB3ZSAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgX2xpc3RlblRvT3V0c2lkZUNsaWNrKCkge1xuICAgIGMub24oZG9jdW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5faGFuZGxlT3V0c2lkZUNsaWNrLmJpbmQodGhpcykpO1xuICB9XG4gIF9oYW5kbGVPdXRzaWRlQ2xpY2sodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbnRhaW5lciwgaSA9IHQudGFyZ2V0ID09PSBlLCBuID0gZSAmJiBlLmNvbnRhaW5zKHQudGFyZ2V0KSwgbyA9IHQudGFyZ2V0ID09PSB0aGlzLl9lbGVtZW50LCByID0gdGhpcy5fZWxlbWVudCAmJiB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKHQudGFyZ2V0KTtcbiAgICAhaSAmJiAhbiAmJiAhbyAmJiAhciAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgX3RyYW5zbGF0ZVBvc2l0aW9uVmFsdWUoKSB7XG4gICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLnBvc2l0aW9uKSB7XG4gICAgICBjYXNlIFwidG9wIGxlZnRcIjpcbiAgICAgICAgcmV0dXJuIFwidG9wLWVuZFwiO1xuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICByZXR1cm4gXCJ0b3BcIjtcbiAgICAgIGNhc2UgXCJ0b3AgcmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIFwidG9wLXN0YXJ0XCI7XG4gICAgICBjYXNlIFwiYm90dG9tIGxlZnRcIjpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tLWVuZFwiO1xuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICByZXR1cm4gXCJib3R0b21cIjtcbiAgICAgIGNhc2UgXCJib3R0b20gcmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tLXN0YXJ0XCI7XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0XCI7XG4gICAgICBjYXNlIFwibGVmdCB0b3BcIjpcbiAgICAgICAgcmV0dXJuIFwibGVmdC1lbmRcIjtcbiAgICAgIGNhc2UgXCJsZWZ0IGJvdHRvbVwiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0LXN0YXJ0XCI7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgcmV0dXJuIFwicmlnaHRcIjtcbiAgICAgIGNhc2UgXCJyaWdodCB0b3BcIjpcbiAgICAgICAgcmV0dXJuIFwicmlnaHQtZW5kXCI7XG4gICAgICBjYXNlIFwicmlnaHQgYm90dG9tXCI6XG4gICAgICAgIHJldHVybiBcInJpZ2h0LXN0YXJ0XCI7XG4gICAgICBjYXNlIHZvaWQgMDpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJib3R0b21cIjtcbiAgICB9XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpID0gQS5nZXREYXRhKHRoaXMsIHhpKSwgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSkge1xuICAgICAgICBpZiAoIWkpXG4gICAgICAgICAgcmV0dXJuIG5ldyBXaCh0aGlzLCBuKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICAgIGlbdF0oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgeGkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IElvID0gXCJsaWdodGJveFwiLCBPaSA9IFwidGUubGlnaHRib3hcIiwgV0UgPSBgLiR7T2l9YCwgRkUgPSBcIi5kYXRhLWFwaVwiLCBNZSA9IGBjbGljayR7V0V9JHtGRX1gLCBGaCA9IFwiW2RhdGEtdGUtbGlnaHRib3gtaW5pdF1cIiwgWUUgPSBgJHtGaH0gaW1nOm5vdChbZGF0YS10ZS1saWdodGJveC1kaXNhYmxlZF0pYCwgVWwgPSBcImRhdGEtdGUtbGlnaHRib3gtY2FwdGlvblwiLCBqRSA9IFwiZGF0YS10ZS1saWdodGJveC1kaXNhYmxlZFwiLCBEdCA9IFwiZGF0YS10ZS1saWdodGJveC1hY3RpdmVcIiwgS0UgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTkuNSAxMmgtMTVtMCAwbDYuNzUgNi43NU00LjUgMTJsNi43NS02Ljc1XCIgLz5cbjwvc3ZnPlxuYCwgekUgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNC41IDEyaDE1bTAgMGwtNi43NS02Ljc1TTE5LjUgMTJsLTYuNzUgNi43NVwiIC8+XG48L3N2Zz5cbmAsIFVFID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0zLjc1IDMuNzV2NC41bTAtNC41aDQuNW0tNC41IDBMOSA5TTMuNzUgMjAuMjV2LTQuNW0wIDQuNWg0LjVtLTQuNSAwTDkgMTVNMjAuMjUgMy43NWgtNC41bTQuNSAwdjQuNW0wLTQuNUwxNSA5bTUuMjUgMTEuMjVoLTQuNW00LjUgMHYtNC41bTAgNC41TDE1IDE1XCIgLz5cbjwvc3ZnPlxuYCwgWEUgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTkgOVY0LjVNOSA5SDQuNU05IDlMMy43NSAzLjc1TTkgMTV2NC41TTkgMTVINC41TTkgMTVsLTUuMjUgNS4yNU0xNSA5aDQuNU0xNSA5VjQuNU0xNSA5bDUuMjUtNS4yNU0xNSAxNWg0LjVNMTUgMTV2NC41bTAtNC41bDUuMjUgNS4yNVwiIC8+XG48L3N2Zz5cbmAsIEdFID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0yMSAyMWwtNS4xOTctNS4xOTdtMCAwQTcuNSA3LjUgMCAxMDUuMTk2IDUuMTk2YTcuNSA3LjUgMCAwMDEwLjYwNyAxMC42MDd6TTEwLjUgNy41djZtMy0zaC02XCIgLz5cbjwvc3ZnPlxuYCwgcUUgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0yMSAyMWwtNS4xOTctNS4xOTdtMCAwQTcuNSA3LjUgMCAxMDUuMTk2IDUuMTk2YTcuNSA3LjUgMCAwMDEwLjYwNyAxMC42MDd6TTEzLjUgMTAuNWgtNlwiIC8+XG48L3N2Zz5cbmAsIFpFID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk02IDE4TDE4IDZNNiA2bDEyIDEyXCIgLz5cbjwvc3ZnPlxuYCwgUUUgPSB7XG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgem9vbUxldmVsOiBcIihudW1iZXJ8c3RyaW5nKVwiLFxuICBwcmV2SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBuZXh0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBzaG93RnVsbHNjcmVlbkljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgaGlkZUZ1bGxzY3JlZW5JY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHpvb21Jbkljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgY2xvc2VJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHpvb21PdXRJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHNwaW5uZXJDb250ZW50OiBcInN0cmluZ1wiXG59LCBKRSA9IHtcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgem9vbUxldmVsOiAxLFxuICBwcmV2SWNvblRlbXBsYXRlOiBLRSxcbiAgbmV4dEljb25UZW1wbGF0ZTogekUsXG4gIHNob3dGdWxsc2NyZWVuSWNvblRlbXBsYXRlOiBVRSxcbiAgaGlkZUZ1bGxzY3JlZW5JY29uVGVtcGxhdGU6IFhFLFxuICB6b29tSW5JY29uVGVtcGxhdGU6IEdFLFxuICB6b29tT3V0SWNvblRlbXBsYXRlOiBxRSxcbiAgY2xvc2VJY29uVGVtcGxhdGU6IFpFLFxuICBzcGlubmVyQ29udGVudDogXCJMb2FkaW5nLi4uXCJcbn0sIHQwID0ge1xuICBjYXB0aW9uOiBcInRleHQtd2hpdGUgdGV4dC1lbGxpcHNpcyBvdmVyZmxvdy1oaWRkZW4gd2hpdGVzcGFjZS1ub3dyYXAgbXgtWzEwcHhdIHRleHQtY2VudGVyXCIsXG4gIGNhcHRpb25XcmFwcGVyOiBcImZpeGVkIGxlZnQtMCBib3R0b20tMCB3LWZ1bGwgaC1bNTBweF0gZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIixcbiAgY2xvc2VCdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1bNTBweF0gaC1bNTBweF0gcHgtNCB0ZXh0LVsjYjNiM2IzXSB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXQgaG92ZXI6dGV4dC13aGl0ZSBmb2N1czp0ZXh0LXdoaXRlIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG91dGxpbmUtbm9uZVwiLFxuICBmdWxsc2NyZWVuQnRuOiBcImJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHctWzUwcHhdIGgtWzUwcHhdIHB4LTQgdGV4dC1bI2IzYjNiM10gdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0IGhvdmVyOnRleHQtd2hpdGUgZm9jdXM6dGV4dC13aGl0ZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBvdXRsaW5lLW5vbmVcIixcbiAgZ2FsbGVyeTogXCJpbnZpc2libGUgZml4ZWQgbGVmdC0wIHRvcC0wIHctZnVsbCBoLWZ1bGwgei1bMTEwMF0gcG9pbnRlci1ldmVudHMtbm9uZSBvcGFjaXR5LTAgYmctWyMwMDAwMDBlNl0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tWzQwMG1zXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBnYWxsZXJ5Q29udGVudDogXCJmaXhlZCB0b3AtWzUwcHhdIGxlZnQtWzUwcHhdIHctW2NhbGMoMTAwJS0xMDBweCldIGgtW2NhbGMoMTAwJS0xMDBweCldXCIsXG4gIGdhbGxlcnlDb3VudGVyOiBcImZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHB4LVsxMHB4XSBtYi0wIGgtZnVsbCB0ZXh0LVsjYjNiM2IzXVwiLFxuICBpbWc6IFwiYWJzb2x1dGUgbGVmdC0wIHRvcC0wIHctZnVsbCBtYXgtaC1mdWxsIGgtYXV0byBjdXJzb3ItcG9pbnRlciBwb2ludGVyLWV2ZW50cy1hdXRvXCIsXG4gIGltZ1dyYXBwZXI6IFwiYWJzb2x1dGUgdG9wLTAgbGVmdC0wIHctZnVsbCBoLWZ1bGwgb3BhY2l0eS0wIHRyYW5zZm9ybSBzY2FsZS1bMC4yNV0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tWzQwMG1zXSBlYXNlLW91dCBwb2ludGVyLWV2ZW50cy1ub25lIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6dHJhbnNmb3JtLW5vbmVcIixcbiAgbGVmdFRvb2xzOiBcImZsb2F0LWxlZnQgaC1mdWxsXCIsXG4gIGxvYWRlcjogXCJmaXhlZCBsZWZ0LTAgdG9wLTAgei1bMl0gdy1mdWxsIGgtZnVsbCB0ZXh0LW5ldXRyYWwtNTAgb3BhY2l0eS0xIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHBvaW50ZXItZXZlbnRzLW5vbmUgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVsxMDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIG5leHRCdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1mdWxsIGgtWzUwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRleHQtWyNiM2IzYjNdIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dCBob3Zlcjp0ZXh0LXdoaXRlIGZvY3VzOnRleHQtd2hpdGUgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgb3V0bGluZS1ub25lXCIsXG4gIG5leHRCdG5XcmFwcGVyOiBcImZpeGVkIHJpZ2h0LTAgdG9wLTAgdy1bNTBweF0gaC1mdWxsIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi1bNDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIHByZXZCdG46IFwiYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgdy1mdWxsIGgtWzUwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRleHQtWyNiM2IzYjNdIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dCBob3Zlcjp0ZXh0LXdoaXRlIGZvY3VzOnRleHQtd2hpdGUgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgb3V0bGluZS1ub25lXCIsXG4gIHByZXZCdG5XcmFwcGVyOiBcImZpeGVkIGxlZnQtMCB0b3AtMCB3LVs1MHB4XSBoLWZ1bGwgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLVs0MDBtc10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgcmlnaHRUb29sczogXCJmbG9hdC1yaWdodFwiLFxuICBzcGlubmVyOiBcImlubGluZS1ibG9jayBoLTggdy04IGFuaW1hdGUtW3NwaW5uZXItZ3Jvd18wLjc1c19saW5lYXJfaW5maW5pdGVdIHJvdW5kZWQtZnVsbCBiZy1jdXJyZW50IGFsaWduLVstMC4xMjVlbV0gbW90aW9uLXJlZHVjZTphbmltYXRlLVtzcGlubmVyLWdyb3dfMS41c19saW5lYXJfaW5maW5pdGVdXCIsXG4gIHNwaW5uZXJDb250ZW50OiBcIiFhYnNvbHV0ZSAhLW0tcHggIWgtcHggIXctcHggIW92ZXJmbG93LWhpZGRlbiAhd2hpdGVzcGFjZS1ub3dyYXAgIWJvcmRlci0wICFwLTAgIVtjbGlwOnJlY3QoMCwwLDAsMCldXCIsXG4gIHRvb2xiYXI6IFwiYWJzb2x1dGUgdG9wLTAgbGVmdC0wIHctZnVsbCBoLVs1MHB4XSB6LTIwIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi1bNDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIHZlcnRpY2FsOiBcImgtZnVsbCBtYXgtaC1mdWxsIHctYXV0b1wiLFxuICB6b29tQnRuOiBcImJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHctWzUwcHhdIGgtWzUwcHhdIHB4LTQgdGV4dC1bI2IzYjNiM10gdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0IGhvdmVyOnRleHQtd2hpdGUgZm9jdXM6dGV4dC13aGl0ZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBvdXRsaW5lLW5vbmVcIlxufSwgZTAgPSB7XG4gIGNhcHRpb246IFwic3RyaW5nXCIsXG4gIGNhcHRpb25XcmFwcGVyOiBcInN0cmluZ1wiLFxuICBjbG9zZUJ0bjogXCJzdHJpbmdcIixcbiAgZnVsbHNjcmVlbkJ0bjogXCJzdHJpbmdcIixcbiAgZ2FsbGVyeTogXCJzdHJpbmdcIixcbiAgZ2FsbGVyeUNvbnRlbnQ6IFwic3RyaW5nXCIsXG4gIGdhbGxlcnlDb3VudGVyOiBcInN0cmluZ1wiLFxuICBpbWc6IFwic3RyaW5nXCIsXG4gIGltZ1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGxlZnRUb29sczogXCJzdHJpbmdcIixcbiAgbG9hZGVyOiBcInN0cmluZ1wiLFxuICBuZXh0QnRuOiBcInN0cmluZ1wiLFxuICBuZXh0QnRuV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgcHJldkJ0bjogXCJzdHJpbmdcIixcbiAgcHJldkJ0bldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHJpZ2h0VG9vbHM6IFwic3RyaW5nXCIsXG4gIHNwaW5uZXI6IFwic3RyaW5nXCIsXG4gIHNwaW5uZXJDb250ZW50OiBcInN0cmluZ1wiLFxuICB0b29sYmFyOiBcInN0cmluZ1wiLFxuICB2ZXJ0aWNhbDogXCJzdHJpbmdcIixcbiAgem9vbUJ0bjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIG5uIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSBlLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZ2V0Q29udGFpbmVyKCksIHRoaXMuX2lkID0gYGxpZ2h0Ym94LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsIHRoaXMuX2FjdGl2ZUltZyA9IDAsIHRoaXMuX2ltYWdlcyA9IFtdLCB0aGlzLl96b29tID0gMSwgdGhpcy5fZ2FsbGVyeSA9IG51bGwsIHRoaXMuX2dhbGxlcnlUb29sYmFyID0gbnVsbCwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQgPSBudWxsLCB0aGlzLl9sb2FkZXIgPSBudWxsLCB0aGlzLl9pbWdDb3VudGVyID0gbnVsbCwgdGhpcy5fYW5pbWF0aW5nID0gITEsIHRoaXMuX2Z1bGxzY3JlZW4gPSAhMSwgdGhpcy5fem9vbUJ0biA9IG51bGwsIHRoaXMuX2Z1bGxzY3JlZW5CdG4gPSBudWxsLCB0aGlzLl90b29sc1RvZ2dsZVRpbWVyID0gMCwgdGhpcy5fbW91c2Vkb3duID0gITEsIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWCA9IDAsIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWSA9IDAsIHRoaXMuX29yaWdpbmFsUG9zaXRpb25YID0gMCwgdGhpcy5fb3JpZ2luYWxQb3NpdGlvblkgPSAwLCB0aGlzLl9wb3NpdGlvblggPSAwLCB0aGlzLl9wb3NpdGlvblkgPSAwLCB0aGlzLl96b29tVGltZXIgPSAwLCB0aGlzLl90YXBDb3VudGVyID0gMCwgdGhpcy5fdGFwVGltZSA9IDAsIHRoaXMuX3JpZ2h0QXJyb3cgPSBudWxsLCB0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyID0gbnVsbCwgdGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIgPSBudWxsLCB0aGlzLl9pbml0aWF0ZWQgPSAhMSwgdGhpcy5fbXVsdGl0b3VjaCA9ICExLCB0aGlzLl90b3VjaFpvb21Qb3NpdGlvbiA9IFtdLCB0aGlzLl9lbGVtZW50ICYmIChBLnNldERhdGEodCwgT2ksIHRoaXMpLCB0aGlzLmluaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIElvO1xuICB9XG4gIGdldCBhY3RpdmVJbWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUltZztcbiAgfVxuICBnZXQgY3VycmVudEltZygpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFxuICAgICAgYFske0R0fV1gLFxuICAgICAgdGhpcy5fZ2FsbGVyeUNvbnRlbnRcbiAgICApO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICAuLi5KRSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50aGlzLl9vcHRpb25zXG4gICAgfTtcbiAgICByZXR1cm4gSShJbywgdCwgUUUpLCB0O1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX2luaXRpYXRlZCB8fCAodGhpcy5fYXBwZW5kVGVtcGxhdGUoKSwgdGhpcy5faW5pdGlhdGVkID0gITApO1xuICB9XG4gIG9wZW4odCA9IDApIHtcbiAgICB0aGlzLl9nZXRJbWFnZXMoKSwgdGhpcy5fc2V0QWN0aXZlSW1nKHQpLCB0aGlzLl9zb3J0SW1hZ2VzKCksIHRoaXMuX3RyaWdnZXJFdmVudHMoXCJvcGVuXCIsIFwib3BlbmVkXCIpLCB0aGlzLl9sb2FkSW1hZ2VzKCkudGhlbigoZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzaXplSW1hZ2VzKGUpLCB0aGlzLl90b2dnbGVUZW1wbGF0ZSgpLCB0aGlzLl9hZGRFdmVudHMoKSwgdGhpcy5fZm9jdXNGdWxsc2NyZWVuQnRuKCk7XG4gICAgfSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5yZXNldCgpLCB0aGlzLl9yZW1vdmVFdmVudHMoKSwgdGhpcy5fdG9nZ2xlVGVtcGxhdGUoKSwgdGhpcy5fdHJpZ2dlckV2ZW50cyhcImNsb3NlXCIsIFwiY2xvc2VkXCIpO1xuICB9XG4gIHNsaWRlKHQgPSBcInJpZ2h0XCIpIHtcbiAgICB0aGlzLl9hbmltYXRpbmcgPT09ICEwIHx8IHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSB8fCAodGhpcy5fdHJpZ2dlckV2ZW50cyhcInNsaWRlXCIsIFwic2xpZGVkXCIpLCB0aGlzLl9iZWZvcmVTbGlkZUV2ZW50cygpLCB0ID09PSBcInJpZ2h0XCIgJiYgdGhpcy5fc2xpZGVIb3Jpem9udGFsbHkodCksIHQgPT09IFwibGVmdFwiICYmIHRoaXMuX3NsaWRlSG9yaXpvbnRhbGx5KHQpLCB0ID09PSBcImZpcnN0XCIgJiYgdGhpcy5fc2xpZGVUb1RhcmdldCh0KSwgdCA9PT0gXCJsYXN0XCIgJiYgdGhpcy5fc2xpZGVUb1RhcmdldCh0KSwgdGhpcy5fYWZ0ZXJTbGlkZUV2ZW50cygpKTtcbiAgfVxuICB6b29tSW4oKSB7XG4gICAgdGhpcy5fem9vbSA+PSAzIHx8ICh0aGlzLl90cmlnZ2VyRXZlbnRzKFwiem9vbUluXCIsIFwiem9vbWVkSW5cIiksIHRoaXMuX3pvb20gKz0gcGFyc2VGbG9hdCh0aGlzLm9wdGlvbnMuem9vbUxldmVsKSwgaC5zdHlsZSh0aGlzLmN1cnJlbnRJbWcucGFyZW50Tm9kZSwge1xuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHt0aGlzLl96b29tfSlgXG4gICAgfSksIHRoaXMuX3VwZGF0ZVpvb21CdG4oKSk7XG4gIH1cbiAgem9vbU91dCgpIHtcbiAgICB0aGlzLl96b29tIDw9IDEgfHwgKHRoaXMuX3RyaWdnZXJFdmVudHMoXCJ6b29tT3V0XCIsIFwiem9vbWVkT3V0XCIpLCB0aGlzLl96b29tIC09IHBhcnNlRmxvYXQodGhpcy5vcHRpb25zLnpvb21MZXZlbCksIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7dGhpcy5fem9vbX0pYFxuICAgIH0pLCB0aGlzLl91cGRhdGVab29tQnRuKCksIHRoaXMuX3VwZGF0ZUltZ1Bvc2l0aW9uKCkpO1xuICB9XG4gIHRvZ2dsZUZ1bGxzY3JlZW4oKSB7XG4gICAgdGhpcy5fZnVsbHNjcmVlbiA9PT0gITEgPyAodGhpcy5fZnVsbHNjcmVlbkJ0bi5zZXRBdHRyaWJ1dGUoRHQsIFwiXCIpLCB0aGlzLl9mdWxsc2NyZWVuQnRuLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5oaWRlRnVsbHNjcmVlbkljb25UZW1wbGF0ZSwgdGhpcy5fZ2FsbGVyeS5yZXF1ZXN0RnVsbHNjcmVlbiAmJiB0aGlzLl9nYWxsZXJ5LnJlcXVlc3RGdWxsc2NyZWVuKCksIHRoaXMuX2Z1bGxzY3JlZW4gPSAhMCkgOiAodGhpcy5fZnVsbHNjcmVlbkJ0bi5yZW1vdmVBdHRyaWJ1dGUoRHQpLCBkb2N1bWVudC5leGl0RnVsbHNjcmVlbiAmJiBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpLCB0aGlzLl9mdWxsc2NyZWVuID0gITEpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc3RvcmVEZWZhdWx0RnVsbHNjcmVlbigpLCB0aGlzLl9yZXN0b3JlRGVmYXVsdFBvc2l0aW9uKCksIHRoaXMuX3Jlc3RvcmVEZWZhdWx0Wm9vbSgpLCBjbGVhclRpbWVvdXQodGhpcy5fdG9vbHNUb2dnbGVUaW1lciksIGNsZWFyVGltZW91dCh0aGlzLl9kb3VibGVUYXBUaW1lcik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgTWUsXG4gICAgICBZRSxcbiAgICAgIHRoaXMudG9nZ2xlXG4gICAgKSwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQgJiYgdGhpcy5fcmVtb3ZlRXZlbnRzKCksIHRoaXMuX2dhbGxlcnkgJiYgdGhpcy5fZ2FsbGVyeS5yZW1vdmUoKSwgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIE9pKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnQwLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKElvLCB0LCBlMCksIHQ7XG4gIH1cbiAgX2dldEltYWdlcygpIHtcbiAgICBjb25zdCBlID0gZC5maW5kKFwiaW1nXCIsIHRoaXMuX2VsZW1lbnQpLmZpbHRlcihcbiAgICAgIChpKSA9PiAhaS5oYXNBdHRyaWJ1dGUoakUpXG4gICAgKTtcbiAgICB0aGlzLl9pbWFnZXMgPSBlO1xuICB9XG4gIF9nZXRDb250YWluZXIoKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gZC5maW5kT25lKHRoaXMub3B0aW9ucy5jb250YWluZXIpO1xuICB9XG4gIF9zZXRBY3RpdmVJbWcodCkge1xuICAgIHRoaXMuX2FjdGl2ZUltZyA9IHR5cGVvZiB0ID09IFwibnVtYmVyXCIgPyB0IDogdGhpcy5faW1hZ2VzLmluZGV4T2YodC50YXJnZXQpO1xuICB9XG4gIF9hcHBlbmRUZW1wbGF0ZSgpIHtcbiAgICB0aGlzLl9nYWxsZXJ5ID0gJChcImRpdlwiKSwgaC5hZGRDbGFzcyh0aGlzLl9nYWxsZXJ5LCBgJHt0aGlzLl9jbGFzc2VzLmdhbGxlcnl9YCksIHRoaXMuX2VsZW1lbnQuZGF0YXNldC5pZCA9IHRoaXMuX2lkLCB0aGlzLl9nYWxsZXJ5LmlkID0gdGhpcy5faWQsIHRoaXMuX2FwcGVuZExvYWRlcigpLCB0aGlzLl9hcHBlbmRUb29sYmFyKCksIHRoaXMuX2FwcGVuZENvbnRlbnQoKSwgdGhpcy5fYXBwZW5kQXJyb3dzKCksIHRoaXMuX2FwcGVuZENhcHRpb24oKSwgdGhpcy5fY29udGFpbmVyLmFwcGVuZCh0aGlzLl9nYWxsZXJ5KTtcbiAgfVxuICBfYXBwZW5kVG9vbGJhcigpIHtcbiAgICB0aGlzLl9nYWxsZXJ5VG9vbGJhciA9ICQoXCJkaXZcIiksIHRoaXMuX2ltZ0NvdW50ZXIgPSAkKFwicFwiKSwgdGhpcy5fZnVsbHNjcmVlbkJ0biA9ICQoXCJidXR0b25cIiksIHRoaXMuX3pvb21CdG4gPSAkKFwiYnV0dG9uXCIpO1xuICAgIGNvbnN0IHQgPSAkKFwiYnV0dG9uXCIpLCBlID0gJChcImRpdlwiKSwgaSA9ICQoXCJkaXZcIik7XG4gICAgaC5hZGRDbGFzcyh0aGlzLl9nYWxsZXJ5VG9vbGJhciwgYCR7dGhpcy5fY2xhc3Nlcy50b29sYmFyfWApLCBoLmFkZENsYXNzKHRoaXMuX2ltZ0NvdW50ZXIsIGAke3RoaXMuX2NsYXNzZXMuZ2FsbGVyeUNvdW50ZXJ9YCksIGguYWRkQ2xhc3ModGhpcy5fZnVsbHNjcmVlbkJ0biwgYCR7dGhpcy5fY2xhc3Nlcy5mdWxsc2NyZWVuQnRufWApLCBoLmFkZENsYXNzKHRoaXMuX3pvb21CdG4sIGAke3RoaXMuX2NsYXNzZXMuem9vbUluQnRufWApLCBoLmFkZENsYXNzKHRoaXMuX3pvb21CdG4sIHRoaXMuX2NsYXNzZXMuem9vbUJ0biksIGguYWRkQ2xhc3MoZSwgYCR7dGhpcy5fY2xhc3Nlcy5sZWZ0VG9vbHN9YCksIGguYWRkQ2xhc3MoaSwgYCR7dGhpcy5fY2xhc3Nlcy5yaWdodFRvb2xzfWApLCBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMuY2xvc2VCdG59YCksIHRoaXMuX2Z1bGxzY3JlZW5CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnNob3dGdWxsc2NyZWVuSWNvblRlbXBsYXRlLCB0LmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5jbG9zZUljb25UZW1wbGF0ZSwgdGhpcy5fem9vbUJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuem9vbUluSWNvblRlbXBsYXRlLCB0aGlzLl9mdWxsc2NyZWVuQnRuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJUb2dnbGUgZnVsbHNjcmVlblwiKSwgdGhpcy5fem9vbUJ0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiWm9vbSBpblwiKSwgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiQ2xvc2VcIiksIGMub24oXG4gICAgICB0aGlzLl9mdWxsc2NyZWVuQnRuLFxuICAgICAgTWUsXG4gICAgICAoKSA9PiB0aGlzLnRvZ2dsZUZ1bGxzY3JlZW4oKVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl96b29tQnRuLFxuICAgICAgTWUsXG4gICAgICAoKSA9PiB0aGlzLl90b2dnbGVab29tKClcbiAgICApLCBjLm9uKHQsIE1lLCAoKSA9PiB0aGlzLmNsb3NlKCkpLCBlLmFwcGVuZCh0aGlzLl9pbWdDb3VudGVyKSwgaS5hcHBlbmQodGhpcy5fZnVsbHNjcmVlbkJ0biksIGkuYXBwZW5kKHRoaXMuX3pvb21CdG4pLCBpLmFwcGVuZCh0KSwgdGhpcy5fZ2FsbGVyeVRvb2xiYXIuYXBwZW5kKGUpLCB0aGlzLl9nYWxsZXJ5VG9vbGJhci5hcHBlbmQoaSksIHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX2dhbGxlcnlUb29sYmFyKTtcbiAgfVxuICBfYXBwZW5kQ29udGVudCgpIHtcbiAgICB0aGlzLl9nYWxsZXJ5Q29udGVudCA9ICQoXCJkaXZcIiksIGguYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9nYWxsZXJ5Q29udGVudCxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMuZ2FsbGVyeUNvbnRlbnR9YFxuICAgICksIHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX2dhbGxlcnlDb250ZW50KTtcbiAgfVxuICBfYXBwZW5kTG9hZGVyKCkge1xuICAgIHRoaXMuX2xvYWRlciA9ICQoXCJkaXZcIik7XG4gICAgY29uc3QgdCA9ICQoXCJkaXZcIiksIGUgPSAkKFwic3BhblwiKTtcbiAgICBoLmFkZENsYXNzKHRoaXMuX2xvYWRlciwgYCR7dGhpcy5fY2xhc3Nlcy5sb2FkZXJ9YCksIGguYWRkQ2xhc3ModCwgYCR7dGhpcy5fY2xhc3Nlcy5zcGlubmVyfWApLCBoLmFkZENsYXNzKGUsIGAke3RoaXMuX2NsYXNzZXMuc3Bpbm5lckNvbnRlbnR9YCksIHQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInN0YXR1c1wiKSwgZS5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuc3Bpbm5lckNvbnRlbnQsIHQuYXBwZW5kKGUpLCB0aGlzLl9sb2FkZXIuYXBwZW5kKHQpLCB0aGlzLl9nYWxsZXJ5LmFwcGVuZCh0aGlzLl9sb2FkZXIpO1xuICB9XG4gIF9hcHBlbmRBcnJvd3MoKSB7XG4gICAgdGhpcy5fbGVmdEFycm93V3JhcHBlciA9ICQoXCJkaXZcIiksIGguYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5wcmV2QnRuV3JhcHBlcn1gXG4gICAgKTtcbiAgICBjb25zdCB0ID0gJChcImJ1dHRvblwiKTtcbiAgICB0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJQcmV2aW91c1wiKSwgaC5hZGRDbGFzcyh0LCBgJHt0aGlzLl9jbGFzc2VzLnByZXZCdG59YCksIGMub24odCwgTWUsICgpID0+IHRoaXMuc2xpZGUoXCJsZWZ0XCIpKSwgdGhpcy5fbGVmdEFycm93V3JhcHBlci5hcHBlbmQodCksIHRoaXMuX3JpZ2h0QXJyb3dXcmFwcGVyID0gJChcImRpdlwiKSwgaC5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX3JpZ2h0QXJyb3dXcmFwcGVyLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5uZXh0QnRuV3JhcHBlcn1gXG4gICAgKSwgdGhpcy5fcmlnaHRBcnJvdyA9ICQoXCJidXR0b25cIiksIHRoaXMuX3JpZ2h0QXJyb3cuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIk5leHRcIiksIGguYWRkQ2xhc3ModGhpcy5fcmlnaHRBcnJvdywgYCR7dGhpcy5fY2xhc3Nlcy5uZXh0QnRufWApLCBjLm9uKHRoaXMuX3JpZ2h0QXJyb3csIE1lLCAoKSA9PiB0aGlzLnNsaWRlKCkpLCB0aGlzLl9yaWdodEFycm93V3JhcHBlci5hcHBlbmQodGhpcy5fcmlnaHRBcnJvdyksIHRoaXMuX3JpZ2h0QXJyb3cuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLm5leHRJY29uVGVtcGxhdGUsIHQuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnByZXZJY29uVGVtcGxhdGUsIHRoaXMuX2dldEltYWdlcygpLCAhKHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSkgJiYgKHRoaXMuX2dhbGxlcnkuYXBwZW5kKHRoaXMuX2xlZnRBcnJvd1dyYXBwZXIpLCB0aGlzLl9nYWxsZXJ5LmFwcGVuZCh0aGlzLl9yaWdodEFycm93V3JhcHBlcikpO1xuICB9XG4gIF9hcHBlbmRDYXB0aW9uKCkge1xuICAgIGNvbnN0IHQgPSAkKFwiZGl2XCIpLCBlID0gJChcInBcIik7XG4gICAgZS5zZXRBdHRyaWJ1dGUoVWwsIFwiXCIpLCBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMuY2FwdGlvbldyYXBwZXJ9YCksIGguYWRkQ2xhc3MoZSwgYCR7dGhpcy5fY2xhc3Nlcy5jYXB0aW9ufWApLCB0LmFwcGVuZChlKSwgdGhpcy5fZ2FsbGVyeS5hcHBlbmQodCk7XG4gIH1cbiAgX3NvcnRJbWFnZXMoKSB7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLl9hY3RpdmVJbWc7IHQrKylcbiAgICAgIHRoaXMuX2ltYWdlcy5wdXNoKHRoaXMuX2ltYWdlcy5zaGlmdCgpKTtcbiAgfVxuICBhc3luYyBfbG9hZEltYWdlcygpIHtcbiAgICBjb25zdCB0ID0gW10sIGUgPSBbXTtcbiAgICB0aGlzLl9nYWxsZXJ5Q29udGVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgIGxldCBpID0gMDtcbiAgICByZXR1cm4gdGhpcy5faW1hZ2VzLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIHQucHVzaChcbiAgICAgICAgbmV3IFByb21pc2UoKHIpID0+IHtcbiAgICAgICAgICBjb25zdCBhID0gbmV3IEltYWdlKCksIGwgPSAkKFwiZGl2XCIpO1xuICAgICAgICAgIGguYWRkQ2xhc3MobCwgYCR7dGhpcy5fY2xhc3Nlcy5pbWdXcmFwcGVyfWApLCBoLmFkZENsYXNzKGEsIGAke3RoaXMuX2NsYXNzZXMuaW1nfWApLCB0aGlzLl9hZGRJbWdTdHlsZXMoYSwgbCwgaSwgbywgbiksIGwuYXBwZW5kKGEpLCB0aGlzLl9nYWxsZXJ5Q29udGVudC5hcHBlbmQobCksIGEub25sb2FkID0gciwgYS5zcmMgPSBuLmRhdGFzZXQudGVJbWcgfHwgbi5zcmMsIGUucHVzaChhKSwgaSArPSAxMDA7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pLCBhd2FpdCBQcm9taXNlLmFsbCh0KSwgZTtcbiAgfVxuICBfYWRkSW1nU3R5bGVzKHQsIGUsIGksIG4sIG8pIHtcbiAgICB0LmFsdCA9IG8uYWx0LCB0LmRyYWdnYWJsZSA9ICExLCBoLnN0eWxlKGUsIHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICBsZWZ0OiBgJHtpfSVgLFxuICAgICAgdG9wOiAwXG4gICAgfSksIChvLmRhdGFzZXQudGVDYXB0aW9uIHx8IG8uZGF0YXNldC50ZUNhcHRpb24gPT09IFwiXCIpICYmICh0LmRhdGFzZXQuY2FwdGlvbiA9IG8uZGF0YXNldC50ZUNhcHRpb24pLCBpID09PSAwID8gKG8ud2lkdGggPCBvLmhlaWdodCAmJiBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMudmVydGljYWx9YCksIGguc3R5bGUoZSwgeyBvcGFjaXR5OiAxIH0pLCB0LnNldEF0dHJpYnV0ZShEdCwgXCJcIikpIDogdC5yZW1vdmVBdHRyaWJ1dGUoRHQpLCBuID09PSB0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMSAmJiB0aGlzLl9pbWFnZXMubGVuZ3RoID4gMSAmJiBoLnN0eWxlKGUsIHsgbGVmdDogXCItMTAwJVwiIH0pO1xuICB9XG4gIF9yZXNpemVJbWFnZXModCkge1xuICAgIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdGhpcy5fY2FsY3VsYXRlSW1nU2l6ZShlKTtcbiAgICB9KTtcbiAgfVxuICBfY2FsY3VsYXRlSW1nU2l6ZSh0KSB7XG4gICAgdC53aWR0aCA+PSB0LmhlaWdodCA/ICh0LnN0eWxlLndpZHRoID0gXCIxMDAlXCIsIHQuc3R5bGUubWF4V2lkdGggPSBcIjEwMCVcIiwgdC5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIiwgdC5zdHlsZS50b3AgPSBgJHsodC5wYXJlbnROb2RlLm9mZnNldEhlaWdodCAtIHQuaGVpZ2h0KSAvIDJ9cHhgLCB0LnN0eWxlLmxlZnQgPSAwKSA6ICh0LnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiLCB0LnN0eWxlLm1heEhlaWdodCA9IFwiMTAwJVwiLCB0LnN0eWxlLndpZHRoID0gXCJhdXRvXCIsIHQuc3R5bGUubGVmdCA9IGAkeyh0LnBhcmVudE5vZGUub2Zmc2V0V2lkdGggLSB0LndpZHRoKSAvIDJ9cHhgLCB0LnN0eWxlLnRvcCA9IDApLCB0LndpZHRoID49IHQucGFyZW50Tm9kZS5vZmZzZXRXaWR0aCAmJiAodC5zdHlsZS53aWR0aCA9IGAke3QucGFyZW50Tm9kZS5vZmZzZXRXaWR0aH1weGAsIHQuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCIsIHQuc3R5bGUubGVmdCA9IDAsIHQuc3R5bGUudG9wID0gYCR7KHQucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQgLSB0LmhlaWdodCkgLyAyfXB4YCksIHQuaGVpZ2h0ID49IHQucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQgJiYgKHQuc3R5bGUuaGVpZ2h0ID0gYCR7dC5wYXJlbnROb2RlLm9mZnNldEhlaWdodH1weGAsIHQuc3R5bGUud2lkdGggPSBcImF1dG9cIiwgdC5zdHlsZS50b3AgPSAwLCB0LnN0eWxlLmxlZnQgPSBgJHsodC5wYXJlbnROb2RlLm9mZnNldFdpZHRoIC0gdC53aWR0aCkgLyAyfXB4YCksIHRoaXMuX3Bvc2l0aW9uWCA9IHBhcnNlRmxvYXQodC5zdHlsZS5sZWZ0KSB8fCAwLCB0aGlzLl9wb3NpdGlvblkgPSBwYXJzZUZsb2F0KHQuc3R5bGUudG9wKSB8fCAwO1xuICB9XG4gIF9vblJlc2l6ZSgpIHtcbiAgICB0aGlzLl9pbWFnZXMgPSBkLmZpbmQoXCJpbWdcIiwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQpLCB0aGlzLl9pbWFnZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdGhpcy5fY2FsY3VsYXRlSW1nU2l6ZSh0KTtcbiAgICB9KTtcbiAgfVxuICBfb25GdWxsc2NyZWVuQ2hhbmdlKCkge1xuICAgIChkb2N1bWVudC53ZWJraXRJc0Z1bGxTY3JlZW4gfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbiB8fCBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50KSA9PT0gdm9pZCAwICYmICh0aGlzLl9mdWxsc2NyZWVuID0gITEsIHRoaXMuX2Z1bGxzY3JlZW5CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnNob3dGdWxsc2NyZWVuSWNvblRlbXBsYXRlLCB0aGlzLl9mdWxsc2NyZWVuQnRuLnJlbW92ZUF0dHJpYnV0ZShEdCkpO1xuICB9XG4gIF9iZWZvcmVTbGlkZUV2ZW50cygpIHtcbiAgICB0aGlzLl9hbmltYXRpb25TdGFydCgpLCB0aGlzLl9yZXN0b3JlRGVmYXVsdFpvb20oKSwgdGhpcy5fcmVzdG9yZURlZmF1bHRQb3NpdGlvbigpLCB0aGlzLl9yZXNldERvdWJsZVRhcCgpO1xuICB9XG4gIF9zbGlkZUhvcml6b250YWxseSh0KSB7XG4gICAgdGhpcy5faW1hZ2VzID0gZC5maW5kKFwiaW1nXCIsIHRoaXMuX2dhbGxlcnlDb250ZW50KSwgdGhpcy5faW1hZ2VzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGxldCBpO1xuICAgICAgdCA9PT0gXCJyaWdodFwiID8gKGkgPSBwYXJzZUludChlLnBhcmVudE5vZGUuc3R5bGUubGVmdCwgMTApIC0gMTAwLCBpIDwgLTEwMCAmJiAoaSA9ICh0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMikgKiAxMDApKSA6IChpID0gcGFyc2VJbnQoZS5wYXJlbnROb2RlLnN0eWxlLmxlZnQsIDEwKSArIDEwMCwgaSA9PT0gKHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxKSAqIDEwMCAmJiAoaSA9IC0xMDApKSwgdGhpcy5fc2xpZGVJbWcoZSwgaSk7XG4gICAgfSksIHRoaXMuX3VwZGF0ZUFjdGl2ZUltZyh0KTtcbiAgfVxuICBfc2xpZGVJbWcodCwgZSkge1xuICAgIGUgPT09IDAgPyAodC5zZXRBdHRyaWJ1dGUoRHQsIFwiXCIpLCBoLnN0eWxlKHQucGFyZW50Tm9kZSwgeyBvcGFjaXR5OiAxLCB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIiB9KSkgOiAodC5yZW1vdmVBdHRyaWJ1dGUoRHQpLCBoLnN0eWxlKHQucGFyZW50Tm9kZSwge1xuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjI1KVwiXG4gICAgfSkpLCB0LnBhcmVudE5vZGUuc3R5bGUubGVmdCA9IGAke2V9JWA7XG4gIH1cbiAgX3NsaWRlVG9UYXJnZXQodCkge1xuICAgIHQgPT09IFwiZmlyc3RcIiAmJiB0aGlzLl9hY3RpdmVJbWcgPT09IDAgfHwgdCA9PT0gXCJsYXN0XCIgJiYgdGhpcy5fYWN0aXZlSW1nID09PSB0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMSB8fCAodGhpcy5yZXNldCgpLCB0aGlzLl9yZW1vdmVFdmVudHMoKSwgdGhpcy5fc2hvd0xvYWRlcigpLCB0aGlzLl9nZXRJbWFnZXMoKSwgdGhpcy5fYWN0aXZlSW1nID0gdCA9PT0gXCJmaXJzdFwiID8gMCA6IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxLCB0aGlzLl9zb3J0SW1hZ2VzKCksIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjI1KVwiLFxuICAgICAgb3BhY2l0eTogMFxuICAgIH0pLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2xvYWRJbWFnZXMoKS50aGVuKChlKSA9PiB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUltYWdlcyhlKSwgdGhpcy5fYWRkRXZlbnRzKCksIHRoaXMuX3VwZGF0ZUNhcHRpb24oKSwgdGhpcy5faGlkZUxvYWRlcigpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBoLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIixcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgfSk7XG4gICAgfSwgNDAwKSk7XG4gIH1cbiAgX3VwZGF0ZUFjdGl2ZUltZyh0KSB7XG4gICAgdCA9PT0gXCJyaWdodFwiICYmICh0aGlzLl9hY3RpdmVJbWcgPT09IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxID8gdGhpcy5fYWN0aXZlSW1nID0gMCA6IHRoaXMuX2FjdGl2ZUltZysrKSwgdCA9PT0gXCJsZWZ0XCIgJiYgKHRoaXMuX2FjdGl2ZUltZyA9PT0gMCA/IHRoaXMuX2FjdGl2ZUltZyA9IHRoaXMuX2ltYWdlcy5sZW5ndGggLSAxIDogdGhpcy5fYWN0aXZlSW1nLS0pO1xuICB9XG4gIF9hZnRlclNsaWRlRXZlbnRzKCkge1xuICAgIHRoaXMuX3VwZGF0ZUNvdW50ZXIoKSwgdGhpcy5fdXBkYXRlQ2FwdGlvbigpO1xuICB9XG4gIF91cGRhdGVDb3VudGVyKCkge1xuICAgIHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSB8fCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2ltZ0NvdW50ZXIuaW5uZXJIVE1MID0gYCR7dGhpcy5fYWN0aXZlSW1nICsgMX0gLyAke3RoaXMuX2ltYWdlcy5sZW5ndGh9YDtcbiAgICB9LCAyMDApO1xuICB9XG4gIF91cGRhdGVDYXB0aW9uKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbGV0IHQgPSB0aGlzLmN1cnJlbnRJbWcuYWx0O1xuICAgICAgKHRoaXMuY3VycmVudEltZy5kYXRhc2V0LmNhcHRpb24gfHwgdGhpcy5jdXJyZW50SW1nLmRhdGFzZXQuY2FwdGlvbiA9PT0gXCJcIikgJiYgKHQgPSB0aGlzLmN1cnJlbnRJbWcuZGF0YXNldC5jYXB0aW9uKSwgZC5maW5kT25lKFxuICAgICAgICBgWyR7VWx9XWAsXG4gICAgICAgIHRoaXMuX2dhbGxlcnlcbiAgICAgICkuaW5uZXJIVE1MID0gdDtcbiAgICB9LCAyMDApO1xuICB9XG4gIF90b2dnbGVUZW1wbGF0ZSgpIHtcbiAgICB0aGlzLl9nYWxsZXJ5LnN0eWxlLnZpc2liaWxpdHkgPT09IFwidmlzaWJsZVwiID8gKGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjI1KVwiXG4gICAgfSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5faGlkZUdhbGxlcnkoKSwgdGhpcy5fZW5hYmxlU2Nyb2xsKCksIHRoaXMuX3Nob3dMb2FkZXIoKTtcbiAgICB9LCAxMDApKSA6ICh0aGlzLl9zaG93R2FsbGVyeSgpLCB0aGlzLl9kaXNhYmxlU2Nyb2xsKCksIHRoaXMuX3VwZGF0ZUNvdW50ZXIoKSwgdGhpcy5fdXBkYXRlQ2FwdGlvbigpLCB0aGlzLl9zZXRUb29sc1RvZ2dsZVRpbW91dCgpLCB0aGlzLl9oaWRlTG9hZGVyKCkpO1xuICB9XG4gIF9zaG93TG9hZGVyKCkge1xuICAgIGguc3R5bGUodGhpcy5fbG9hZGVyLCB7IG9wYWNpdHk6IDEgfSk7XG4gIH1cbiAgX2hpZGVMb2FkZXIoKSB7XG4gICAgaC5zdHlsZSh0aGlzLl9sb2FkZXIsIHsgb3BhY2l0eTogMCB9KTtcbiAgfVxuICBfaGlkZUdhbGxlcnkoKSB7XG4gICAgaC5zdHlsZSh0aGlzLl9nYWxsZXJ5LCB7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgICB2aXNpYmlsaXR5OiBcImhpZGRlblwiXG4gICAgfSk7XG4gIH1cbiAgX3Nob3dHYWxsZXJ5KCkge1xuICAgIGguc3R5bGUodGhpcy5fZ2FsbGVyeSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwiaW5pdGlhbFwiLFxuICAgICAgdmlzaWJpbGl0eTogXCJ2aXNpYmxlXCJcbiAgICB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7IHRyYW5zZm9ybTogXCJzY2FsZSgxKVwiIH0pO1xuICAgIH0sIDUwKTtcbiAgfVxuICBfdG9nZ2xlWm9vbSgpIHtcbiAgICB0aGlzLl96b29tICE9PSAxID8gdGhpcy56b29tT3V0KCkgOiB0aGlzLnpvb21JbigpO1xuICB9XG4gIF91cGRhdGVab29tQnRuKCkge1xuICAgIHRoaXMuX3pvb20gPiAxID8gKHRoaXMuX3pvb21CdG4uc2V0QXR0cmlidXRlKER0LCBcIlwiKSwgdGhpcy5fem9vbUJ0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiWm9vbSBvdXRcIiksIHRoaXMuX3pvb21CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnpvb21PdXRJY29uVGVtcGxhdGUpIDogKHRoaXMuX3pvb21CdG4ucmVtb3ZlQXR0cmlidXRlKER0KSwgdGhpcy5fem9vbUJ0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiWm9vbSBpblwiKSwgdGhpcy5fem9vbUJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuem9vbUluSWNvblRlbXBsYXRlKTtcbiAgfVxuICBfdXBkYXRlSW1nUG9zaXRpb24oKSB7XG4gICAgdGhpcy5fem9vbSA9PT0gMSAmJiB0aGlzLl9yZXN0b3JlRGVmYXVsdFBvc2l0aW9uKCk7XG4gIH1cbiAgX2FkZEV2ZW50cygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKFwiaW1nXCIsIHRoaXMuX2dhbGxlcnlDb250ZW50KTtcbiAgICB0aGlzLl9vbldpbmRvd1RvdWNobW92ZSA9IHRoaXMuX29uV2luZG93VG91Y2htb3ZlLmJpbmQodGhpcyksIHRoaXMuX29uV2luZG93VG91Y2hzdGFydCA9IHRoaXMuX29uV2luZG93VG91Y2hzdGFydC5iaW5kKHRoaXMpLCB0aGlzLl9vbkltZ01vdXNlZG93biA9IHRoaXMuX29uTW91c2Vkb3duLmJpbmQodGhpcyksIHRoaXMuX29uSW1nTW91c2Vtb3ZlID0gdGhpcy5fb25Nb3VzZW1vdmUuYmluZCh0aGlzKSwgdGhpcy5fb25JbWdXaGVlbCA9IHRoaXMuX29uWm9vbS5iaW5kKHRoaXMpLCB0aGlzLl9vbkltZ01vdXNldXAgPSB0aGlzLl9vbk1vdXNldXAuYmluZCh0aGlzKSwgdGhpcy5fb25JbWdUb3VjaGVuZCA9IHRoaXMuX29uVG91Y2hlbmQuYmluZCh0aGlzKSwgdGhpcy5fb25JbWdEb3VibGVDbGljayA9IHRoaXMuX29uRG91YmxlQ2xpY2suYmluZCh0aGlzKSwgdGhpcy5fb25XaW5kb3dSZXNpemUgPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpLCB0aGlzLl9vbldpbmRvd0Z1bGxzY3JlZW5DaGFuZ2UgPSB0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UuYmluZCh0aGlzKSwgdGhpcy5fb25BbnlJbWdBY3Rpb24gPSB0aGlzLl9yZXNldFRvb2xzVG9nZ2xlci5iaW5kKHRoaXMpLCB0aGlzLl9vbkdhbGxlcnlDbGljayA9IHRoaXMuX29uQmFja2Ryb3BDbGljay5iaW5kKHRoaXMpLCB0aGlzLl9vbktleXVwRXZlbnQgPSB0aGlzLl9vbktleXVwLmJpbmQodGhpcyksIHRoaXMuX29uUmlnaHRBcnJvd0tleWRvd25FdmVudCA9IHRoaXMuX29uUmlnaHRBcnJvd0tleWRvd24uYmluZCh0aGlzKSwgdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bkV2ZW50ID0gdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bi5iaW5kKHRoaXMpLCB0LmZvckVhY2goKGUpID0+IHtcbiAgICAgIGMub24oZSwgXCJtb3VzZWRvd25cIiwgdGhpcy5fb25JbWdNb3VzZWRvd24sIHtcbiAgICAgICAgcGFzc2l2ZTogITBcbiAgICAgIH0pLCBjLm9uKGUsIFwidG91Y2hzdGFydFwiLCB0aGlzLl9vbkltZ01vdXNlZG93biwge1xuICAgICAgICBwYXNzaXZlOiAhMFxuICAgICAgfSksIGMub24oZSwgXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25JbWdNb3VzZW1vdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogITBcbiAgICAgIH0pLCBjLm9uKGUsIFwidG91Y2htb3ZlXCIsIHRoaXMuX29uSW1nTW91c2Vtb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6ICEwXG4gICAgICB9KSwgYy5vbihlLCBcIndoZWVsXCIsIHRoaXMuX29uSW1nV2hlZWwsIHsgcGFzc2l2ZTogITAgfSksIGMub24oZSwgXCJkYmxjbGlja1wiLCB0aGlzLl9vbkltZ0RvdWJsZUNsaWNrLCB7XG4gICAgICAgIHBhc3NpdmU6ICEwXG4gICAgICB9KTtcbiAgICB9KSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9vbldpbmRvd1RvdWNobW92ZSwge1xuICAgICAgcGFzc2l2ZTogITFcbiAgICB9KSwgYy5vbih3aW5kb3csIFwidG91Y2hzdGFydFwiLCB0aGlzLl9vbldpbmRvd1RvdWNoc3RhcnQpLCBjLm9uKHdpbmRvdywgXCJtb3VzZXVwXCIsIHRoaXMuX29uSW1nTW91c2V1cCksIGMub24od2luZG93LCBcInRvdWNoZW5kXCIsIHRoaXMuX29uSW1nVG91Y2hlbmQpLCBjLm9uKHdpbmRvdywgXCJyZXNpemVcIiwgdGhpcy5fb25XaW5kb3dSZXNpemUpLCBjLm9uKHdpbmRvdywgXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSksIGMub24od2luZG93LCBcImtleXVwXCIsIHRoaXMuX29uS2V5dXBFdmVudCksIGMub24od2luZG93LCBcImZ1bGxzY3JlZW5jaGFuZ2VcIiwgdGhpcy5fb25XaW5kb3dGdWxsc2NyZWVuQ2hhbmdlKSwgYy5vbih0aGlzLl9nYWxsZXJ5LCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkFueUltZ0FjdGlvbiksIGMub24odGhpcy5fZ2FsbGVyeSwgXCJjbGlja1wiLCB0aGlzLl9vbkdhbGxlcnlDbGljayksIGMub24oXG4gICAgICB0aGlzLl9yaWdodEFycm93LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICB0aGlzLl9vblJpZ2h0QXJyb3dLZXlkb3duRXZlbnRcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ0bixcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bkV2ZW50XG4gICAgKTtcbiAgfVxuICBfcmVtb3ZlRXZlbnRzKCkge1xuICAgIGQuZmluZChcImltZ1wiLCB0aGlzLl9nYWxsZXJ5Q29udGVudCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgYy5vZmYoZSwgXCJtb3VzZWRvd25cIiwgdGhpcy5fb25JbWdNb3VzZWRvd24pLCBjLm9mZihlLCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25JbWdNb3VzZWRvd24pLCBjLm9mZihlLCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkltZ01vdXNlbW92ZSksIGMub2ZmKGUsIFwidG91Y2htb3ZlXCIsIHRoaXMuX29uSW1nTW91c2Vtb3ZlKSwgYy5vZmYoZSwgXCJ3aGVlbFwiLCB0aGlzLl9vbkltZ1doZWVsKSwgYy5vZmYoZSwgXCJkYmxjbGlja1wiLCB0aGlzLl9vbkltZ0RvdWJsZUNsaWNrKTtcbiAgICB9KSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9vbldpbmRvd1RvdWNobW92ZSwge1xuICAgICAgcGFzc2l2ZTogITFcbiAgICB9KSwgYy5vZmYod2luZG93LCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25XaW5kb3dUb3VjaHN0YXJ0KSwgYy5vZmYod2luZG93LCBcIm1vdXNldXBcIiwgdGhpcy5fb25JbWdNb3VzZXVwKSwgYy5vZmYod2luZG93LCBcInRvdWNoZW5kXCIsIHRoaXMuX29uSW1nVG91Y2hlbmQpLCBjLm9mZih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX29uV2luZG93UmVzaXplKSwgYy5vZmYod2luZG93LCBcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX29uV2luZG93UmVzaXplKSwgYy5vZmYod2luZG93LCBcImtleXVwXCIsIHRoaXMuX29uS2V5dXBFdmVudCksIGMub2ZmKFxuICAgICAgd2luZG93LFxuICAgICAgXCJmdWxsc2NyZWVuY2hhbmdlXCIsXG4gICAgICB0aGlzLl9vbldpbmRvd0Z1bGxzY3JlZW5DaGFuZ2VcbiAgICApLCBjLm9mZih0aGlzLl9nYWxsZXJ5LCBcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkFueUltZ0FjdGlvbiksIGMub2ZmKHRoaXMuX2dhbGxlcnksIFwiY2xpY2tcIiwgdGhpcy5fb25HYWxsZXJ5Q2xpY2spLCBjLm9mZihcbiAgICAgIHRoaXMuX3JpZ2h0QXJyb3csXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIHRoaXMuX29uUmlnaHRBcnJvd0tleWRvd25FdmVudFxuICAgICksIGMub2ZmKFxuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ0bixcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgdGhpcy5fb25GdWxsc2NyZWVuQnRuS2V5ZG93bkV2ZW50XG4gICAgKTtcbiAgfVxuICBfb25Nb3VzZWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0LnRvdWNoZXMsIGkgPSBlID8gZVswXS5jbGllbnRYIDogdC5jbGllbnRYLCBuID0gZSA/IGVbMF0uY2xpZW50WSA6IHQuY2xpZW50WTtcbiAgICB0aGlzLl9vcmlnaW5hbFBvc2l0aW9uWCA9IHBhcnNlRmxvYXQodGhpcy5jdXJyZW50SW1nLnN0eWxlLmxlZnQpIHx8IDAsIHRoaXMuX29yaWdpbmFsUG9zaXRpb25ZID0gcGFyc2VGbG9hdCh0aGlzLmN1cnJlbnRJbWcuc3R5bGUudG9wKSB8fCAwLCB0aGlzLl9wb3NpdGlvblggPSB0aGlzLl9vcmlnaW5hbFBvc2l0aW9uWCwgdGhpcy5fcG9zaXRpb25ZID0gdGhpcy5fb3JpZ2luYWxQb3NpdGlvblksIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWCA9IGkgKiAoMSAvIHRoaXMuX3pvb20pIC0gdGhpcy5fcG9zaXRpb25YLCB0aGlzLl9tb3VzZWRvd25Qb3NpdGlvblkgPSBuICogKDEgLyB0aGlzLl96b29tKSAtIHRoaXMuX3Bvc2l0aW9uWSwgdGhpcy5fbW91c2Vkb3duID0gITAsIHQudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIgJiYgdC50b3VjaGVzLmxlbmd0aCA+IDEgJiYgKHRoaXMuX211bHRpdG91Y2ggPSAhMCwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSB0LnRvdWNoZXMpO1xuICB9XG4gIF9vbk1vdXNlbW92ZSh0KSB7XG4gICAgaWYgKCF0aGlzLl9tb3VzZWRvd24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHQudG91Y2hlcywgaSA9IGUgPyBlWzBdLmNsaWVudFggOiB0LmNsaWVudFgsIG4gPSBlID8gZVswXS5jbGllbnRZIDogdC5jbGllbnRZO1xuICAgIGlmIChlICYmIHRoaXMuX3Jlc2V0VG9vbHNUb2dnbGVyKCksICF0aGlzLl9tdWx0aXRvdWNoKVxuICAgICAgaWYgKHRoaXMuX3pvb20gIT09IDEpXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uWCA9IGkgKiAoMSAvIHRoaXMuX3pvb20pIC0gdGhpcy5fbW91c2Vkb3duUG9zaXRpb25YLCB0aGlzLl9wb3NpdGlvblkgPSBuICogKDEgLyB0aGlzLl96b29tKSAtIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWSwgaC5zdHlsZSh0aGlzLmN1cnJlbnRJbWcsIHtcbiAgICAgICAgICBsZWZ0OiBgJHt0aGlzLl9wb3NpdGlvblh9cHhgLFxuICAgICAgICAgIHRvcDogYCR7dGhpcy5fcG9zaXRpb25ZfXB4YFxuICAgICAgICB9KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5faW1hZ2VzLmxlbmd0aCA8PSAxKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25YID0gaSAqICgxIC8gdGhpcy5fem9vbSkgLSB0aGlzLl9tb3VzZWRvd25Qb3NpdGlvblgsIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLCB7IGxlZnQ6IGAke3RoaXMuX3Bvc2l0aW9uWH1weGAgfSk7XG4gICAgICB9XG4gIH1cbiAgX29uTW91c2V1cCh0KSB7XG4gICAgdGhpcy5fbW91c2Vkb3duID0gITEsIHRoaXMuX21vdmVJbWcodC50YXJnZXQpO1xuICB9XG4gIF9vblRvdWNoZW5kKHQpIHtcbiAgICB0aGlzLl9tb3VzZWRvd24gPSAhMSwgdGhpcy5fbXVsdGl0b3VjaCA/IHQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDAgJiYgKHRoaXMuX211bHRpdG91Y2ggPSAhMSwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSBbXSkgOiB0aGlzLl9tdWx0aXRvdWNoIHx8ICh0aGlzLl9jaGVja0RvdWJsZVRhcCh0KSwgdGhpcy5fbW92ZUltZyh0LnRhcmdldCkpO1xuICB9XG4gIF9jYWxjdWxhdGVUb3VjaFpvb20odCkge1xuICAgIGNvbnN0IGUgPSBNYXRoLmh5cG90KFxuICAgICAgdGhpcy5fdG91Y2hab29tUG9zaXRpb25bMV0ucGFnZVggLSB0aGlzLl90b3VjaFpvb21Qb3NpdGlvblswXS5wYWdlWCxcbiAgICAgIHRoaXMuX3RvdWNoWm9vbVBvc2l0aW9uWzFdLnBhZ2VZIC0gdGhpcy5fdG91Y2hab29tUG9zaXRpb25bMF0ucGFnZVlcbiAgICApLCBpID0gTWF0aC5oeXBvdChcbiAgICAgIHQudG91Y2hlc1sxXS5wYWdlWCAtIHQudG91Y2hlc1swXS5wYWdlWCxcbiAgICAgIHQudG91Y2hlc1sxXS5wYWdlWSAtIHQudG91Y2hlc1swXS5wYWdlWVxuICAgICksIG4gPSBNYXRoLmFicyhlIC0gaSksIG8gPSB0LnZpZXcuc2NyZWVuLndpZHRoO1xuICAgIG4gPiBvICogMC4wMyAmJiAoZSA8PSBpID8gdGhpcy56b29tSW4oKSA6IHRoaXMuem9vbU91dCgpLCB0aGlzLl90b3VjaFpvb21Qb3NpdGlvbiA9IHQudG91Y2hlcyk7XG4gIH1cbiAgX29uV2luZG93VG91Y2hzdGFydCh0KSB7XG4gICAgdC50b3VjaGVzLmxlbmd0aCA+IDEgJiYgKHRoaXMuX211bHRpdG91Y2ggPSAhMCwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSB0LnRvdWNoZXMpO1xuICB9XG4gIF9vbldpbmRvd1RvdWNobW92ZSh0KSB7XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnR5cGUgPT09IFwidG91Y2htb3ZlXCIgJiYgdC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEgJiYgdGhpcy5fY2FsY3VsYXRlVG91Y2hab29tKHQpO1xuICB9XG4gIF9vblJpZ2h0QXJyb3dLZXlkb3duKHQpIHtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSA5OlxuICAgICAgICBpZiAodC5zaGlmdEtleSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9mb2N1c0Z1bGxzY3JlZW5CdG4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIF9vbkZ1bGxzY3JlZW5CdG5LZXlkb3duKHQpIHtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSA5OlxuICAgICAgICBpZiAoIXQuc2hpZnRLZXkpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fZm9jdXNSaWdodEFycm93KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBfb25LZXl1cCh0KSB7XG4gICAgc3dpdGNoICh0aGlzLl9yZXNldFRvb2xzVG9nZ2xlcigpLCB0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIHRoaXMuc2xpZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM3OlxuICAgICAgICB0aGlzLnNsaWRlKFwibGVmdFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3OlxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzNjpcbiAgICAgICAgdGhpcy5zbGlkZShcImZpcnN0XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzU6XG4gICAgICAgIHRoaXMuc2xpZGUoXCJsYXN0XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIHRoaXMuem9vbUluKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0MDpcbiAgICAgICAgdGhpcy56b29tT3V0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBfZm9jdXNGdWxsc2NyZWVuQnRuKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ0bi5mb2N1cygpO1xuICAgIH0sIDEwMCk7XG4gIH1cbiAgX2ZvY3VzUmlnaHRBcnJvdygpIHtcbiAgICB0aGlzLl9yaWdodEFycm93LmZvY3VzKCk7XG4gIH1cbiAgX21vdmVJbWcodCkge1xuICAgIGlmICh0aGlzLl9tdWx0aXRvdWNoIHx8IHRoaXMuX3pvb20gIT09IDEgfHwgdCAhPT0gdGhpcy5jdXJyZW50SW1nIHx8IHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5fcG9zaXRpb25YIC0gdGhpcy5fb3JpZ2luYWxQb3NpdGlvblg7XG4gICAgZSA+IDAgPyB0aGlzLnNsaWRlKFwibGVmdFwiKSA6IGUgPCAwICYmIHRoaXMuc2xpZGUoKTtcbiAgfVxuICBfY2hlY2tEb3VibGVUYXAodCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9kb3VibGVUYXBUaW1lcik7XG4gICAgY29uc3QgaSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gdGhpcy5fdGFwVGltZTtcbiAgICB0aGlzLl90YXBDb3VudGVyID4gMCAmJiBpIDwgNTAwID8gKHRoaXMuX29uRG91YmxlQ2xpY2sodCksIHRoaXMuX2RvdWJsZVRhcFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl90YXBUaW1lID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCksIHRoaXMuX3RhcENvdW50ZXIgPSAwO1xuICAgIH0sIDMwMCkpIDogKHRoaXMuX3RhcENvdW50ZXIrKywgdGhpcy5fdGFwVGltZSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpKTtcbiAgfVxuICBfcmVzZXREb3VibGVUYXAoKSB7XG4gICAgdGhpcy5fdGFwVGltZSA9IDAsIHRoaXMuX3RhcENvdW50ZXIgPSAwLCBjbGVhclRpbWVvdXQodGhpcy5fZG91YmxlVGFwVGltZXIpO1xuICB9XG4gIF9vbkRvdWJsZUNsaWNrKHQpIHtcbiAgICB0aGlzLl9tdWx0aXRvdWNoIHx8ICh0LnRvdWNoZXMgfHwgdGhpcy5fc2V0TmV3UG9zaXRpb25Pblpvb21Jbih0KSwgdGhpcy5fem9vbSAhPT0gMSA/IHRoaXMuX3Jlc3RvcmVEZWZhdWx0Wm9vbSgpIDogdGhpcy56b29tSW4oKSk7XG4gIH1cbiAgX29uWm9vbSh0KSB7XG4gICAgaWYgKHQuZGVsdGFZID4gMClcbiAgICAgIHRoaXMuem9vbU91dCgpO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3pvb20gPj0gMylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fc2V0TmV3UG9zaXRpb25Pblpvb21Jbih0KSwgdGhpcy56b29tSW4oKTtcbiAgICB9XG4gIH1cbiAgX29uQmFja2Ryb3BDbGljayh0KSB7XG4gICAgdGhpcy5fcmVzZXRUb29sc1RvZ2dsZXIoKSwgdC50YXJnZXQudGFnTmFtZSA9PT0gXCJESVZcIiAmJiB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgX3NldE5ld1Bvc2l0aW9uT25ab29tSW4odCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl96b29tVGltZXIpLCB0aGlzLl9wb3NpdGlvblggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDIgLSB0Lm9mZnNldFggLSA1MCwgdGhpcy5fcG9zaXRpb25ZID0gd2luZG93LmlubmVySGVpZ2h0IC8gMiAtIHQub2Zmc2V0WSAtIDUwLCB0aGlzLmN1cnJlbnRJbWcuc3R5bGUudHJhbnNpdGlvbiA9IFwiYWxsIDAuNXMgZWFzZS1vdXRcIiwgdGhpcy5jdXJyZW50SW1nLnN0eWxlLmxlZnQgPSBgJHt0aGlzLl9wb3NpdGlvblh9cHhgLCB0aGlzLmN1cnJlbnRJbWcuc3R5bGUudG9wID0gYCR7dGhpcy5fcG9zaXRpb25ZfXB4YCwgdGhpcy5fem9vbVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRJbWcuc3R5bGUudHJhbnNpdGlvbiA9IFwibm9uZVwiO1xuICAgIH0sIDUwMCk7XG4gIH1cbiAgX3Jlc2V0VG9vbHNUb2dnbGVyKCkge1xuICAgIHRoaXMuX3Nob3dUb29scygpLCBjbGVhclRpbWVvdXQodGhpcy5fdG9vbHNUb2dnbGVUaW1lciksIHRoaXMuX3NldFRvb2xzVG9nZ2xlVGltb3V0KCk7XG4gIH1cbiAgX3NldFRvb2xzVG9nZ2xlVGltb3V0KCkge1xuICAgIHRoaXMuX3Rvb2xzVG9nZ2xlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2hpZGVUb29scygpLCBjbGVhclRpbWVvdXQodGhpcy5fdG9vbHNUb2dnbGVUaW1lcik7XG4gICAgfSwgNGUzKTtcbiAgfVxuICBfaGlkZVRvb2xzKCkge1xuICAgIGguc3R5bGUodGhpcy5fZ2FsbGVyeVRvb2xiYXIsIHsgb3BhY2l0eTogMCB9KSwgaC5zdHlsZSh0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyLCB7IG9wYWNpdHk6IDAgfSksIGguc3R5bGUodGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIsIHsgb3BhY2l0eTogMCB9KTtcbiAgfVxuICBfc2hvd1Rvb2xzKCkge1xuICAgIGguc3R5bGUodGhpcy5fZ2FsbGVyeVRvb2xiYXIsIHsgb3BhY2l0eTogMSB9KSwgaC5zdHlsZSh0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyLCB7IG9wYWNpdHk6IDEgfSksIGguc3R5bGUodGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIsIHsgb3BhY2l0eTogMSB9KTtcbiAgfVxuICBfZGlzYWJsZVNjcm9sbCgpIHtcbiAgICBoLmFkZENsYXNzKGRvY3VtZW50LmJvZHksIFwib3ZlcmZsb3cteS1oaWRkZW4gcmVsYXRpdmVcIiksIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ICYmIGguYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgXCJtZDpwci1bMTdweF1cIik7XG4gIH1cbiAgX2VuYWJsZVNjcm9sbCgpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGgucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgXCJvdmVyZmxvdy15LWhpZGRlbiByZWxhdGl2ZVwiKSwgaC5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCBcIm1kOnByLVsxN3B4XVwiKTtcbiAgICB9LCAzMDApO1xuICB9XG4gIF9hbmltYXRpb25TdGFydCgpIHtcbiAgICB0aGlzLl9hbmltYXRpbmcgPSAhMCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9hbmltYXRpbmcgPSAhMTtcbiAgICB9LCA0MDApO1xuICB9XG4gIF9yZXN0b3JlRGVmYXVsdFpvb20oKSB7XG4gICAgdGhpcy5fem9vbSAhPT0gMSAmJiAodGhpcy5fem9vbSA9IDEsIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7dGhpcy5fem9vbX0pYFxuICAgIH0pLCB0aGlzLl91cGRhdGVab29tQnRuKCksIHRoaXMuX3VwZGF0ZUltZ1Bvc2l0aW9uKCkpO1xuICB9XG4gIF9yZXN0b3JlRGVmYXVsdEZ1bGxzY3JlZW4oKSB7XG4gICAgdGhpcy5fZnVsbHNjcmVlbiAmJiB0aGlzLnRvZ2dsZUZ1bGxzY3JlZW4oKTtcbiAgfVxuICBfcmVzdG9yZURlZmF1bHRQb3NpdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fem9vbVRpbWVyKTtcbiAgICBjb25zdCB0ID0gdGhpcy5jdXJyZW50SW1nO1xuICAgIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHsgbGVmdDogMCwgdG9wOiAwIH0pLCBoLnN0eWxlKHRoaXMuY3VycmVudEltZywge1xuICAgICAgdHJhbnNpdGlvbjogXCJhbGwgMC41cyBlYXNlLW91dFwiLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH0pLCB0aGlzLl9jYWxjdWxhdGVJbWdTaXplKHQpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLCB7IHRyYW5zaXRpb246IFwibm9uZVwiIH0pO1xuICAgIH0sIDUwMCk7XG4gIH1cbiAgYXN5bmMgX3RyaWdnZXJFdmVudHModCwgZSkge1xuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgJHt0fS50ZS5saWdodGJveGApLCBlICYmIGF3YWl0IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke2V9LnRlLmxpZ2h0Ym94YCk7XG4gICAgfSwgNTA1KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgT2kpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29uc3QgZSA9IGQuY2xvc2VzdChcbiAgICAgICAgdC50YXJnZXQsXG4gICAgICAgIGAke0ZofWBcbiAgICAgICk7XG4gICAgICAobm4uZ2V0SW5zdGFuY2UoZSkgfHwgbmV3IG5uKGUpKS5vcGVuKHQpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0gQS5nZXREYXRhKHRoaXMsIE9pKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgbm4odGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgaTAgPSB7XG4gIGlzUmVxdWlyZWQ6IFwiVGhpcyBpcyByZXF1aXJlZFwiLFxuICBpc0VtYWlsOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIixcbiAgaXNMb25nZXJUaGFuOiBcIlRoaXMgZmllbGQgbXVzdCBiZSBsb25nZXIgdGhhbiB7bGVuZ3RofSBjaGFyYWN0ZXJzXCIsXG4gIGlzU2hvcnRlclRoYW46IFwiVGhpcyBmaWVsZCBtdXN0IGJlIHNob3J0ZXIgdGhhbiB7bGVuZ3RofSBjaGFyYWN0ZXJzXCIsXG4gIGlzQ2hlY2tlZDogXCJUaGlzIGlzIHJlcXVpcmVkXCIsXG4gIGlzUGhvbmU6IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgcGhvbmUgbnVtYmVyXCIsXG4gIGlzTnVtYmVyOiBcIkV4cGVjdGVkIHZhbHVlIHdpdGggdHlwZSBOdW1iZXJcIixcbiAgaXNTdHJpbmc6IFwiRXhwZWN0ZWQgdmFsdWUgd2l0aCB0eXBlIFN0cmluZ1wiLFxuICBpc0Jvb2xlYW46IFwiRXhwZWN0ZWQgdmFsdWUgd2l0aCB0eXBlIEJvb2xlYW5cIixcbiAgaXNEYXRlOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGRhdGVcIixcbiAgaXMxMmhGb3JtYXQ6IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgdGltZSBpbiAxMmggZm9ybWF0XCIsXG4gIGlzMjRoRm9ybWF0OiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIHRpbWUgaW4gMjRoIGZvcm1hdFwiXG59LCBzMCA9IHtcbiAgaXNSZXF1aXJlZDogKHMsIHQpID0+IChzID09IG51bGwgPyB2b2lkIDAgOiBzLnRyaW0oKSkgPyAhMCA6IHQsXG4gIGlzRW1haWw6IChzLCB0KSA9PiAvXlthLXpBLVowLTkuXyUrLV0rQFthLXpBLVowLTkuLV0rXFwuW2EtekEtWl17Mix9JC8udGVzdChzKSA/ICEwIDogdCxcbiAgaXNMb25nZXJUaGFuOiAocywgdCwgZSkgPT4gcy5sZW5ndGggPiBlID8gITAgOiB0LnJlcGxhY2UoXCJ7bGVuZ3RofVwiLCBlKSxcbiAgaXNTaG9ydGVyVGhhbjogKHMsIHQsIGUpID0+IHMubGVuZ3RoIDwgZSA/ICEwIDogdC5yZXBsYWNlKFwie2xlbmd0aH1cIiwgZSksXG4gIGlzQ2hlY2tlZDogKHMpID0+IHMgPyAhMCA6IFwiVGhpcyBpcyByZXF1aXJlZFwiLFxuICBpc1Bob25lOiAocywgdCkgPT4gcy5sZW5ndGggPT09IDkgPyAhMCA6IHQsXG4gIGlzTnVtYmVyOiAocywgdCkgPT4gcyAmJiAhaXNOYU4oTnVtYmVyKHMpKSA/ICEwIDogdCxcbiAgaXNTdHJpbmc6IChzLCB0KSA9PiB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gITAgOiB0LFxuICBpc0Jvb2xlYW46IChzLCB0KSA9PiB0eXBlb2YgcyA9PSBcImJvb2xlYW5cIiA/ICEwIDogdCxcbiAgaXNEYXRlOiAocywgdCkgPT4ge1xuICAgIGNvbnN0IGUgPSAvXihbMC05XXsxLDJ9KVxcLyhbMC05XXsxLDJ9KVxcLyhbMC05XXs0fSkkLztcbiAgICByZXR1cm4gcy5tYXRjaChlKSA/ICEwIDogdDtcbiAgfSxcbiAgaXMxMmhGb3JtYXQ6IChzLCB0KSA9PiB7XG4gICAgY29uc3QgZSA9IC9eKDA/WzEtOV18MVswLTJdKTpbMC01XVswLTldIFtBUGFwXVttTV0kLztcbiAgICByZXR1cm4gcy5tYXRjaChlKSA/ICEwIDogdDtcbiAgfSxcbiAgaXMyNGhGb3JtYXQ6IChzLCB0KSA9PiB7XG4gICAgY29uc3QgZSA9IC9eKD86WzAxXVxcZHwyWzAtM10pOlswLTVdWzAtOV0kLztcbiAgICByZXR1cm4gcy5tYXRjaChlKSA/ICEwIDogdDtcbiAgfVxufSwgRG8gPSBcInZhbGlkYXRpb25cIiwgaXIgPSBcInRlLnZhbGlkYXRpb25cIiwgeW4gPSBgLiR7aXJ9YCwgWWggPSBcImRhdGEtdGUtdmFsaWRhdGVcIiwgTHMgPSBcImRhdGEtdGUtdmFsaWRhdGVkXCIsIE5zID0gXCJkYXRhLXRlLXZhbGlkYXRpb24tc3RhdGVcIiwgTXMgPSBcImRhdGEtdGUtdmFsaWRhdGlvbi1mZWVkYmFja1wiLCAkbyA9IFwiZGF0YS10ZS12YWxpZC1mZWVkYmFja1wiLCBScyA9IFwiZGF0YS10ZS1pbnZhbGlkLWZlZWRiYWNrXCIsIFhsID0gXCJkYXRhLXRlLXZhbGlkYXRpb24tcnVsZXNldFwiLCBuMCA9IFwiZGF0YS10ZS1zdWJtaXQtYnRuLXJlZlwiLCBvMCA9IGBbJHtZaH1dYCwgcjAgPSBcIltkYXRhLXRlLWlucHV0LW5vdGNoLXJlZl0gZGl2XCIsIGEwID0gYFske24wfV1gLCBsMCA9IGB2YWxpZGF0ZWQke3lufWAsIGMwID0gYHZhbGlkJHt5bn1gLCBoMCA9IGBpbnZhbGlkJHt5bn1gLCBkMCA9IGBjaGFuZ2VkJHt5bn1gLCB1MCA9IHtcbiAgdmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgaW52YWxpZEZlZWRiYWNrOiBcInN0cmluZ1wiLFxuICBkaXNhYmxlRmVlZGJhY2s6IFwiYm9vbGVhblwiLFxuICBjdXN0b21SdWxlczogXCJvYmplY3RcIixcbiAgY3VzdG9tRXJyb3JNZXNzYWdlczogXCJvYmplY3RcIixcbiAgYWN0aXZlVmFsaWRhdGlvbjogXCJib29sZWFuXCIsXG4gIHN1Ym1pdENhbGxiYWNrOiBcIihmdW5jdGlvbnxudWxsKVwiXG59LCBHbCA9IHtcbiAgdmFsaWRGZWVkYmFjazogXCJMb29rcyBnb29kIVwiLFxuICBpbnZhbGlkRmVlZGJhY2s6IFwiU29tZXRoaW5nIGlzIHdyb25nIVwiLFxuICBkaXNhYmxlRmVlZGJhY2s6ICExLFxuICBjdXN0b21SdWxlczoge30sXG4gIGN1c3RvbUVycm9yTWVzc2FnZXM6IHt9LFxuICBhY3RpdmVWYWxpZGF0aW9uOiAhMSxcbiAgc3VibWl0Q2FsbGJhY2s6IG51bGxcbn0sIHAwID0ge1xuICAvLyBkZWZhdWx0IG5vdGNoXG4gIG5vdGNoTGVhZGluZ1ZhbGlkOiBcImJvcmRlci1bIzE0YTQ0ZF0gZGFyazpib3JkZXItWyMxNGE0NGRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bLTFweF8wXzBfIzE0YTQ0ZCxfMF8xcHhfMF8wXyMxNGE0NGQsXzBfLTFweF8wXzBfIzE0YTQ0ZF0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLVsjMTRhNDRkXVwiLFxuICBub3RjaE1pZGRsZVZhbGlkOiBcImJvcmRlci1bIzE0YTQ0ZF0gZGFyazpib3JkZXItWyMxNGE0NGRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMF8xcHhfMF8wXyMxNGE0NGRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1bIzE0YTQ0ZF1cIixcbiAgbm90Y2hUcmFpbGluZ1ZhbGlkOiBcImJvcmRlci1bIzE0YTQ0ZF0gZGFyazpib3JkZXItWyMxNGE0NGRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMXB4XzBfMF8jMTRhNDRkLF8wXy0xcHhfMF8wXyMxNGE0NGQsXzBfMXB4XzBfMF8jMTRhNDRkXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItWyMxNGE0NGRdXCIsXG4gIG5vdGNoTGVhZGluZ0ludmFsaWQ6IFwiYm9yZGVyLVsjZGM0YzY0XSBkYXJrOmJvcmRlci1bI2RjNGM2NF0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVstMXB4XzBfMF8jZGM0YzY0LF8wXzFweF8wXzBfI2RjNGM2NCxfMF8tMXB4XzBfMF8jZGM0YzY0XSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItWyNkYzRjNjRdXCIsXG4gIG5vdGNoTWlkZGxlSW52YWxpZDogXCJib3JkZXItWyNkYzRjNjRdIGRhcms6Ym9yZGVyLVsjZGM0YzY0XSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzBfMXB4XzBfMF8jZGM0YzY0XSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItWyNkYzRjNjRdXCIsXG4gIG5vdGNoVHJhaWxpbmdJbnZhbGlkOiBcImJvcmRlci1bI2RjNGM2NF0gZGFyazpib3JkZXItWyNkYzRjNjRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMXB4XzBfMF8jZGM0YzY0LF8wXy0xcHhfMF8wXyNkYzRjNjQsXzBfMXB4XzBfMF8jZGM0YzY0XSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItWyNkYzRjNjRdXCIsXG4gIC8vIGJhc2ljIGlucHV0c1xuICBiYXNpY0lucHV0VmFsaWQ6IFwiIWJvcmRlci1bIzE0YTQ0ZF0gZm9jdXM6IWJvcmRlci1bIzE0YTQ0ZF0gZm9jdXM6IXNoYWRvdy1baW5zZXRfMF8wXzBfMXB4XyMxNGE0NGRdXCIsXG4gIGJhc2ljSW5wdXRJbnZhbGlkOiBcIiFib3JkZXItWyNkYzRjNjRdIGZvY3VzOiFib3JkZXItWyNkYzRjNjRdIGZvY3VzOiFzaGFkb3ctW2luc2V0XzBfMF8wXzFweF8jZGM0YzY0XVwiLFxuICAvLyBjaGVja2JveFxuICBjaGVja2JveFZhbGlkOiBcImNoZWNrZWQ6IWJvcmRlci1bIzE0YTQ0ZF0gY2hlY2tlZDohYmctWyMxNGE0NGRdIGNoZWNrZWQ6YWZ0ZXI6IWJnLVsjMTRhNDRkXVwiLFxuICBjaGVja2JveEludmFsaWQ6IFwiY2hlY2tlZDohYm9yZGVyLVsjZGM0YzY0XSBjaGVja2VkOiFiZy1bI2RjNGM2NF0gY2hlY2tlZDphZnRlcjohYmctWyNkYzRjNjRdXCIsXG4gIHJhZGlvVmFsaWQ6IFwiY2hlY2tlZDohYm9yZGVyLVsjMTRhNDRkXSBjaGVja2VkOmFmdGVyOiFiZy1bIzE0YTQ0ZF1cIixcbiAgcmFkaW9JbnZhbGlkOiBcImNoZWNrZWQ6IWJvcmRlci1bI2RjNGM2NF0gY2hlY2tlZDphZnRlcjohYmctWyNkYzRjNjRdXCIsXG4gIC8vIGxhYmVsc1xuICBsYWJlbFZhbGlkOiBcIiF0ZXh0LVsjMTRhNDRkXVwiLFxuICBsYWJlbEludmFsaWQ6IFwiIXRleHQtWyNkYzRjNjRdXCIsXG4gIC8vIGZlZWRiYWNrXG4gIHZhbGlkRmVlZGJhY2s6IFwiYWJzb2x1dGUgdG9wLWZ1bGwgbGVmdC0wIG0tMSB3LWF1dG8gdGV4dC1zbSB0ZXh0LVsjMTRhNDRkXSBhbmltYXRlLVtmYWRlLWluXzAuM3NfYm90aF1cIixcbiAgaW52YWxpZEZlZWRiYWNrOiBcImFic29sdXRlIHRvcC1mdWxsIGxlZnQtMCBtLTEgdy1hdXRvIHRleHQtc20gdGV4dC1bI2RjNGM2NF0gYW5pbWF0ZS1bZmFkZS1pbl8wLjNzX2JvdGhdXCIsXG4gIC8vIGVsZW1lbnQgdmFsaWRhdGVkXG4gIGVsZW1lbnRWYWxpZGF0ZWQ6IFwibWItOFwiXG59LCBfMCA9IHtcbiAgbm90Y2hMZWFkaW5nVmFsaWQ6IFwic3RyaW5nXCIsXG4gIG5vdGNoTWlkZGxlVmFsaWQ6IFwic3RyaW5nXCIsXG4gIG5vdGNoVHJhaWxpbmdWYWxpZDogXCJzdHJpbmdcIixcbiAgbm90Y2hMZWFkaW5nSW52YWxpZDogXCJzdHJpbmdcIixcbiAgbm90Y2hNaWRkbGVJbnZhbGlkOiBcInN0cmluZ1wiLFxuICBub3RjaFRyYWlsaW5nSW52YWxpZDogXCJzdHJpbmdcIixcbiAgYmFzaWNJbnB1dFZhbGlkOiBcInN0cmluZ1wiLFxuICBiYXNpY0lucHV0SW52YWxpZDogXCJzdHJpbmdcIixcbiAgY2hlY2tib3hWYWxpZDogXCJzdHJpbmdcIixcbiAgY2hlY2tib3hJbnZhbGlkOiBcInN0cmluZ1wiLFxuICByYWRpb1ZhbGlkOiBcInN0cmluZ1wiLFxuICByYWRpb0ludmFsaWQ6IFwic3RyaW5nXCIsXG4gIGxhYmVsVmFsaWQ6IFwic3RyaW5nXCIsXG4gIGxhYmVsSW52YWxpZDogXCJzdHJpbmdcIixcbiAgdmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgaW52YWxpZEZlZWRiYWNrOiBcInN0cmluZ1wiLFxuICBlbGVtZW50VmFsaWRhdGVkOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgamggZXh0ZW5kcyBmdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2VsZW1lbnQgJiYgQS5zZXREYXRhKHQsIGlyLCB0aGlzKSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5faXNWYWxpZCA9ICEwLCB0aGlzLl9zaG91bGRBcHBseUlucHV0RXZlbnRzID0gITAsIHRoaXMuX3N1Ym1pdENhbGxiYWNrID0gbnVsbCwgdGhpcy5fZXJyb3JNZXNzYWdlcyA9IHtcbiAgICAgIC4uLmkwLFxuICAgICAgLi4udGhpcy5fY29uZmlnLmN1c3RvbUVycm9yTWVzc2FnZXNcbiAgICB9LCB0aGlzLl92YWxpZGF0aW9uRWxlbWVudHMgPSB0aGlzLl9nZXRWYWxpZGF0aW9uRWxlbWVudHMoKSwgdGhpcy5fdmFsaWRhdGlvbkVsZW1lbnRzLmZvckVhY2goKHsgZWxlbWVudDogbiwgaW5wdXQ6IG8gfSkgPT4ge1xuICAgICAgdGhpcy5fY3JlYXRlRmVlZGJhY2tXcmFwcGVyKG4sIG8pO1xuICAgIH0pLCB0aGlzLl92YWxpZGF0aW9uT2JzZXJ2ZXIgPSB0aGlzLl93YXRjaEZvclZhbGlkYXRpb25DaGFuZ2VzKCksIHRoaXMuX3ZhbGlkYXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuX2VsZW1lbnQsIHsgYXR0cmlidXRlczogITAgfSksIHRoaXMuX3N1Ym1pdEJ1dHRvbiA9IG51bGwsIHRoaXMuX2hhbmRsZVN1Ym1pdEJ1dHRvbigpLCB0aGlzLl92YWxpZGF0aW9uUmVzdWx0ID0gW107XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiB1MDtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIEdsO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gRG87XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgdmFyIHQ7XG4gICAgKHQgPSB0aGlzLl92YWxpZGF0aW9uT2JzZXJ2ZXIpID09IG51bGwgfHwgdC5kaXNjb25uZWN0KCksIHRoaXMuX3ZhbGlkYXRpb25PYnNlcnZlciA9IG51bGwsIHRoaXMuX3N1Ym1pdENhbGxiYWNrID0gbnVsbCwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoTHMpLCB0aGlzLl9yZW1vdmVJbnB1dEV2ZW50cygpLCB0aGlzLl9yZW1vdmVWYWxpZGF0aW9uVHJhY2VzKCksIHRoaXMuX3ZhbGlkYXRpb25SZXN1bHQgPSBbXSwgdGhpcy5fc3VibWl0QnV0dG9uICYmIGMub2ZmKHRoaXMuX3N1Ym1pdEJ1dHRvbiwgXCJjbGlja1wiKSwgdGhpcy5fY29uZmlnLmFjdGl2ZVZhbGlkYXRpb24gJiYgKHRoaXMuX3ZhbGlkYXRpb25FbGVtZW50cy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjb25zdCB7IGlucHV0OiBpIH0gPSBlO1xuICAgICAgYy5vZmYoaSwgXCJpbnB1dFwiKTtcbiAgICB9KSwgdGhpcy5fc2hvdWxkQXBwbHlJbnB1dEV2ZW50cyA9ICEwKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9yZW1vdmVWYWxpZGF0aW9uVHJhY2VzKCkge1xuICAgIHRoaXMuX3JlbW92ZUZlZWRiYWNrV3JhcHBlcigpLCB0aGlzLl92YWxpZGF0aW9uRWxlbWVudHMuZm9yRWFjaCgoeyBlbGVtZW50OiB0LCBjbGFzc2VzOiBlLCBpbml0aWFsSFRNTDogaSB9KSA9PiB7XG4gICAgICB0LmNsYXNzTmFtZSA9IGUsIHQuaW5uZXJIVE1MID0gaSwgdC5yZW1vdmVBdHRyaWJ1dGUoTnMpLCB0LnJlbW92ZUF0dHJpYnV0ZShScyksIHQucmVtb3ZlQXR0cmlidXRlKCRvKTtcbiAgICB9KSwgdGhpcy5fdmFsaWRhdGlvbkVsZW1lbnRzID0gW107XG4gIH1cbiAgX2dldFZhbGlkYXRpb25FbGVtZW50cygpIHtcbiAgICByZXR1cm4gZC5maW5kKFxuICAgICAgbzAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKS5tYXAoKGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSBkLmZpbmRPbmUoXCJpbnB1dFwiLCBlKSB8fCBkLmZpbmRPbmUoXCJ0ZXh0YXJlYVwiLCBlKSwgbiA9IGQuZmluZE9uZShcInNlbGVjdFwiLCBlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpLm5hbWUgfHwgaS5pZCB8fCAobiA9PSBudWxsID8gdm9pZCAwIDogbi5uYW1lKSB8fCBldChcInZhbGlkYXRpb24tXCIpLFxuICAgICAgICBlbGVtZW50OiBlLFxuICAgICAgICB0eXBlOiBlLmdldEF0dHJpYnV0ZShZaCksXG4gICAgICAgIGlucHV0OiBpLFxuICAgICAgICB2YWxpZEZlZWRiYWNrOiBlLmdldEF0dHJpYnV0ZSgkbyksXG4gICAgICAgIGludmFsaWRGZWVkYmFjazogZS5nZXRBdHRyaWJ1dGUoUnMpLFxuICAgICAgICBjbGFzc2VzOiBlLmNsYXNzTmFtZSxcbiAgICAgICAgaW5pdGlhbEhUTUw6IGUuaW5uZXJIVE1MLFxuICAgICAgICBydWxlc2V0OiBlLmdldEF0dHJpYnV0ZShYbClcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgX2NyZWF0ZUZlZWRiYWNrV3JhcHBlcih0LCBlKSB7XG4gICAgaWYgKHQucXVlcnlTZWxlY3RvckFsbChgWyR7TXN9XWApLmxlbmd0aCA+IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGkuc2V0QXR0cmlidXRlKE1zLCBcIlwiKSwgZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGkpO1xuICB9XG4gIF9yZW1vdmVGZWVkYmFja1dyYXBwZXIoKSB7XG4gICAgZC5maW5kKFxuICAgICAgYFske01zfV1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuICBfd2F0Y2hGb3JWYWxpZGF0aW9uQ2hhbmdlcygpIHtcbiAgICByZXR1cm4gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKGUpID0+IHtcbiAgICAgIGUuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBjb25zdCB7IGF0dHJpYnV0ZU5hbWU6IG4gfSA9IGk7XG4gICAgICAgIG4gPT09IExzICYmICh0aGlzLl9oYW5kbGVWYWxpZGF0aW9uKCksIHRoaXMuX2NvbmZpZy5hY3RpdmVWYWxpZGF0aW9uICYmIHRoaXMuX3Nob3VsZEFwcGx5SW5wdXRFdmVudHMgJiYgdGhpcy5fYXBwbHlJbnB1dEV2ZW50cygpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVWYWxpZGF0aW9uKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKExzKSAmJiAodGhpcy5fdmFsaWRhdGlvblJlc3VsdCA9IFtdLCB0aGlzLl9pc1ZhbGlkID0gITAsIHRoaXMuX3ZhbGlkYXRpb25FbGVtZW50cy5mb3JFYWNoKFxuICAgICAgKHQpID0+IHRoaXMuX3ZhbGlkYXRlU2luZ2xlRWxlbWVudCh0KVxuICAgICksIHRoaXMuX2VtaXRFdmVudHModGhpcy5faXNWYWxpZCksIHRoaXMuX3N1Ym1pdENhbGxiYWNrICYmIHRoaXMuX3N1Ym1pdENhbGxiYWNrKHRoaXMuX2lzVmFsaWQpKTtcbiAgfVxuICBfdmFsaWRhdGVTaW5nbGVFbGVtZW50KHQpIHtcbiAgICB2YXIgcDtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGUsIHR5cGU6IGksIGlucHV0OiBuLCBydWxlc2V0OiBvLCBpZDogciB9ID0gdDtcbiAgICBvICYmIHRoaXMuX3ZhbGlkYXRlQnlSdWxlc2V0KHQpO1xuICAgIGNvbnN0IGEgPSBlLmdldEF0dHJpYnV0ZShOcyk7XG4gICAgaWYgKGEgIT09IFwidmFsaWRcIiAmJiBhICE9PSBcImludmFsaWRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsID0gYS5yZXBsYWNlKFxuICAgICAgYS5jaGFyQXQoMCksXG4gICAgICBhLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpXG4gICAgKTtcbiAgICBpID09PSBcImlucHV0XCIgJiYgdGhpcy5fcmVzdHlsZU5vdGNoZXMoZSwgbCksIGkgPT09IFwiYmFzaWNcIiAmJiB0aGlzLl9yZXN0eWxlQmFzaWNJbnB1dHMobiwgbCksIChpID09PSBcImNoZWNrYm94XCIgfHwgaSA9PT0gXCJyYWRpb1wiKSAmJiB0aGlzLl9yZXN0eWxlQ2hlY2tib3hlcyhuLCBsLCBpKSwgdGhpcy5fcmVzdHlsZUxhYmVscyhlLCBsKSwgYSA9PT0gXCJpbnZhbGlkXCIgJiYgKHRoaXMuX2lzVmFsaWQgPSAhMSksIHRoaXMuX2NvbmZpZy5kaXNhYmxlRmVlZGJhY2sgfHwgdGhpcy5fYXBwbHlGZWVkYmFjayhlLCBhKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGQwLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBuYW1lOiByLFxuICAgICAgICByZXN1bHQ6IGEsXG4gICAgICAgIHZhbGlkYXRpb246IChwID0gdGhpcy5fdmFsaWRhdGlvblJlc3VsdFtyXSkgPT0gbnVsbCA/IHZvaWQgMCA6IHAudmFsaWRhdGlvblxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF92YWxpZGF0ZUJ5UnVsZXNldCh7IGVsZW1lbnQ6IHQsIHR5cGU6IGUsIGludmFsaWRGZWVkYmFjazogaSwgaW5wdXQ6IG4sIGlkOiBvIH0pIHtcbiAgICBjb25zdCByID0gdGhpcy5fZ2V0UnVsZXNldCh0KTtcbiAgICBpZiAoIXIubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSBlID09PSBcImNoZWNrYm94XCIgfHwgZSA9PT0gXCJyYWRpb1wiID8gbi5jaGVja2VkIDogbi52YWx1ZTtcbiAgICBsZXQgbCA9IFwiXCIsIHAgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHUgb2Ygcikge1xuICAgICAgY29uc3QgXyA9IHUuY2FsbGJhY2soXG4gICAgICAgIGEsXG4gICAgICAgIHRoaXMuX2Vycm9yTWVzc2FnZXNbdS5uYW1lXSB8fCB0aGlzLl9jb25maWcuaW52YWxpZEZlZWRiYWNrLFxuICAgICAgICB1LnBhcmFtZXRlclxuICAgICAgKTtcbiAgICAgIHAucHVzaCh7XG4gICAgICAgIHJlc3VsdDogXyA9PT0gITAsXG4gICAgICAgIG5hbWU6IHUubmFtZSxcbiAgICAgICAgZnVsbE5hbWU6IHUuZnVsbE5hbWVcbiAgICAgIH0pLCB0eXBlb2YgXyA9PSBcInN0cmluZ1wiICYmICFsICYmIChsID0gXyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl92YWxpZGF0aW9uUmVzdWx0W29dID0geyBlbGVtZW50OiB0LCB2YWxpZGF0aW9uOiBwIH0sICFsKSB7XG4gICAgICB0LnNldEF0dHJpYnV0ZShOcywgXCJ2YWxpZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdC5zZXRBdHRyaWJ1dGUoTnMsIFwiaW52YWxpZFwiKSwgaSB8fCB0LnNldEF0dHJpYnV0ZShScywgbCk7XG4gIH1cbiAgX2hhbmRsZUlucHV0Q2hhbmdlKHQpIHtcbiAgICB0aGlzLl92YWxpZGF0ZVNpbmdsZUVsZW1lbnQodCk7XG4gIH1cbiAgX2dldFJ1bGVzZXQodCkge1xuICAgIGNvbnN0IGkgPSB0LmdldEF0dHJpYnV0ZShYbCkuc3BsaXQoXCJ8XCIpO1xuICAgIGxldCBuID0gW107XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIC4uLnMwLFxuICAgICAgLi4udGhpcy5fY29uZmlnLmN1c3RvbVJ1bGVzXG4gICAgfTtcbiAgICByZXR1cm4gaS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICBjb25zdCBhID0gdGhpcy5fZ2V0UnVsZURhdGEociwgbyk7XG4gICAgICBhLmNhbGxiYWNrID8gbi5wdXNoKGEpIDogY29uc29sZS53YXJuKGBSdWxlICR7cn0gZG9lcyBub3QgZXhpc3RgKTtcbiAgICB9KSwgbjtcbiAgfVxuICBfZ2V0UnVsZURhdGEodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0LnNwbGl0KFwiKFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2FsbGJhY2s6IGVbaVswXV0sXG4gICAgICBwYXJhbWV0ZXI6IGlbMV0gPyBpWzFdLnNwbGl0KFwiKVwiKVswXSA6IG51bGwsXG4gICAgICBuYW1lOiBpWzBdLFxuICAgICAgZnVsbE5hbWU6IHRcbiAgICB9O1xuICB9XG4gIF9hcHBseUZlZWRiYWNrKHQsIGUpIHtcbiAgICBjb25zdCBpID0gZC5maW5kT25lKFxuICAgICAgYFske01zfV1gLFxuICAgICAgdFxuICAgICksIG4gPSB0LmdldEF0dHJpYnV0ZSgkbykgfHwgdGhpcy5fY29uZmlnLnZhbGlkRmVlZGJhY2ssIG8gPSB0LmdldEF0dHJpYnV0ZShScykgfHwgdGhpcy5fY29uZmlnLmludmFsaWRGZWVkYmFjaztcbiAgICBoLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMuZWxlbWVudFZhbGlkYXRlZCksIGkudGV4dENvbnRlbnQgPSBlID09PSBcInZhbGlkXCIgPyBuIDogbywgaS5jbGFzc05hbWUgPSB0aGlzLl9jbGFzc2VzW2UgPT09IFwidmFsaWRcIiA/IFwidmFsaWRGZWVkYmFja1wiIDogXCJpbnZhbGlkRmVlZGJhY2tcIl07XG4gIH1cbiAgX3Jlc3R5bGVDaGVja2JveGVzKHQsIGUsIGkpIHtcbiAgICBoLnJlbW92ZUNsYXNzKHQsIHRoaXMuX2NsYXNzZXMuY2hlY2tib3hWYWxpZCksIGgucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5jaGVja2JveEludmFsaWQpLCBoLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXNbYCR7aX0ke2V9YF0pO1xuICB9XG4gIF9yZXN0eWxlQmFzaWNJbnB1dHModCwgZSkge1xuICAgIGgucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5iYXNpY0lucHV0VmFsaWQpLCBoLnJlbW92ZUNsYXNzKHQsIHRoaXMuX2NsYXNzZXMuYmFzaWNJbnB1dEludmFsaWQpLCBoLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXNbYGJhc2ljSW5wdXQke2V9YF0pO1xuICB9XG4gIF9yZXN0eWxlTm90Y2hlcyh0LCBlKSB7XG4gICAgZC5maW5kKHIwLCB0KS5mb3JFYWNoKChuLCBvKSA9PiB7XG4gICAgICBsZXQgciA9IG8gPT09IDAgPyBcIm5vdGNoTGVhZGluZ1wiIDogbyA9PT0gMSA/IFwibm90Y2hNaWRkbGVcIiA6IFwibm90Y2hUcmFpbGluZ1wiO1xuICAgICAgbi5jbGFzc05hbWUgPSBcIlwiLCBoLmFkZENsYXNzKG4sIHBoW3JdKSwgciArPSBlLCBoLmFkZENsYXNzKG4sIHRoaXMuX2NsYXNzZXNbcl0pO1xuICAgIH0pO1xuICB9XG4gIF9yZXN0eWxlTGFiZWxzKHQsIGUpIHtcbiAgICBjb25zdCBpID0gZC5maW5kKFwibGFiZWxcIiwgdCk7XG4gICAgaS5sZW5ndGggJiYgaS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBoLnJlbW92ZUNsYXNzKG4sIHRoaXMuX2NsYXNzZXMubGFiZWxWYWxpZCksIGgucmVtb3ZlQ2xhc3MobiwgdGhpcy5fY2xhc3Nlcy5sYWJlbEludmFsaWQpLCBoLmFkZENsYXNzKG4sIHRoaXMuX2NsYXNzZXNbYGxhYmVsJHtlfWBdKTtcbiAgICB9KTtcbiAgfVxuICBfZW1pdEV2ZW50cyh0KSB7XG4gICAgaWYgKGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBsMCksIHQpIHtcbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBjMCwge1xuICAgICAgICB2YWx1ZTogdGhpcy5fdmFsaWRhdGlvblJlc3VsdFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBoMCwge1xuICAgICAgdmFsdWU6IHRoaXMuX3ZhbGlkYXRpb25SZXN1bHRcbiAgICB9KTtcbiAgfVxuICBfYXBwbHlJbnB1dEV2ZW50cygpIHtcbiAgICB0aGlzLl92YWxpZGF0aW9uRWxlbWVudHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgeyBpbnB1dDogZSwgZWxlbWVudDogaSB9ID0gdDtcbiAgICAgIGMub24oXG4gICAgICAgIGUsXG4gICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAgKCkgPT4gdGhpcy5faGFuZGxlSW5wdXRDaGFuZ2UodClcbiAgICAgICksIGMub24oXG4gICAgICAgIGksXG4gICAgICAgIFwidmFsdWVDaGFuZ2UudGUuc2VsZWN0XCIsXG4gICAgICAgICgpID0+IHRoaXMuX2RlbGF5ZWRJbnB1dENoYW5nZSh0KVxuICAgICAgKSwgYy5vbihcbiAgICAgICAgaSxcbiAgICAgICAgXCJpdGVtU2VsZWN0LnRlLmF1dG9jb21wbGV0ZVwiLFxuICAgICAgICAoKSA9PiB0aGlzLl9kZWxheWVkSW5wdXRDaGFuZ2UodClcbiAgICAgICk7XG4gICAgfSksIHRoaXMuX3Nob3VsZEFwcGx5SW5wdXRFdmVudHMgPSAhMTtcbiAgfVxuICBfcmVtb3ZlSW5wdXRFdmVudHMoKSB7XG4gICAgdGhpcy5fdmFsaWRhdGlvbkVsZW1lbnRzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgaW5wdXQ6IGUsIGVsZW1lbnQ6IGkgfSA9IHQ7XG4gICAgICBjLm9mZihcbiAgICAgICAgZSxcbiAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICAoKSA9PiB0aGlzLl9oYW5kbGVJbnB1dENoYW5nZSh0KVxuICAgICAgKSwgYy5vZmYoXG4gICAgICAgIGksXG4gICAgICAgIFwidmFsdWVDaGFuZ2UudGUuc2VsZWN0XCIsXG4gICAgICAgICgpID0+IHRoaXMuX2RlbGF5ZWRJbnB1dENoYW5nZSh0KVxuICAgICAgKSwgYy5vZmYoXG4gICAgICAgIGksXG4gICAgICAgIFwiaXRlbVNlbGVjdC50ZS5hdXRvY29tcGxldGVcIixcbiAgICAgICAgKCkgPT4gdGhpcy5fZGVsYXllZElucHV0Q2hhbmdlKHQpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIF9kZWxheWVkSW5wdXRDaGFuZ2UodCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5faGFuZGxlSW5wdXRDaGFuZ2UodCk7XG4gICAgfSwgMTApO1xuICB9XG4gIF9oYW5kbGVTdWJtaXRCdXR0b24oKSB7XG4gICAgdGhpcy5fc3VibWl0QnV0dG9uID0gZC5maW5kT25lKFxuICAgICAgYTAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fc3VibWl0QnV0dG9uICYmIGMub24oXG4gICAgICB0aGlzLl9zdWJtaXRCdXR0b24sXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlU3VibWl0QnV0dG9uQ2xpY2sodClcbiAgICApO1xuICB9XG4gIF9oYW5kbGVTdWJtaXRCdXR0b25DbGljayh0KSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKExzLCAhMCksIHRoaXMuX2NvbmZpZy5zdWJtaXRDYWxsYmFjaykge1xuICAgICAgdGhpcy5fc3VibWl0Q2FsbGJhY2sgPSAoZSkgPT4gdGhpcy5fY29uZmlnLnN1Ym1pdENhbGxiYWNrKHQsIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLkdsLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdCA/IHQgOiB7fVxuICAgIH0sIEkoRG8sIHQsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ucDAsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoRG8sIHQsIF8wKSwgdDtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIGlyKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gamguZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChlW3RdID09PSB2b2lkIDAgfHwgdC5zdGFydHNXaXRoKFwiX1wiKSB8fCB0ID09PSBcImNvbnN0cnVjdG9yXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFFpIHtcbiAgX2dldENvb3JkaW5hdGVzKHQpIHtcbiAgICBjb25zdCBbZV0gPSB0LnRvdWNoZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgIHk6IGUuY2xpZW50WVxuICAgIH07XG4gIH1cbiAgX2dldERpcmVjdGlvbih7IHg6IHQsIHk6IGUgfSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB7XG4gICAgICAgIGRpcmVjdGlvbjogdCA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgdmFsdWU6IE1hdGguYWJzKHQpXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICBkaXJlY3Rpb246IGUgPCAwID8gXCJ1cFwiIDogXCJkb3duXCIsXG4gICAgICAgIHZhbHVlOiBNYXRoLmFicyhlKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgX2dldE9yaWdpbih7IHg6IHQsIHk6IGUgfSwgeyB4OiBpLCB5OiBuIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdCAtIGksXG4gICAgICB5OiBlIC0gblxuICAgIH07XG4gIH1cbiAgX2dldERpc3RhbmNlQmV0d2VlblR3b1BvaW50cyh0LCBlLCBpLCBuKSB7XG4gICAgcmV0dXJuIE1hdGguaHlwb3QoZSAtIHQsIG4gLSBpKTtcbiAgfVxuICBfZ2V0TWlkUG9pbnQoeyB4MTogdCwgeDI6IGUsIHkxOiBpLCB5MjogbiB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICh0ICsgZSkgLyAyLFxuICAgICAgeTogKGkgKyBuKSAvIDJcbiAgICB9O1xuICB9XG4gIF9nZXRWZWN0b3JMZW5ndGgoeyB4MTogdCwgeDI6IGUsIHkxOiBpLCB5MjogbiB9KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgoZSAtIHQpICoqIDIgKyAobiAtIGkpICoqIDIpO1xuICB9XG4gIF9nZXRSaWdodE1vc3RUb3VjaCh0KSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGNvbnN0IGkgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgIHJldHVybiB0LmZvckVhY2goKG4pID0+IHtcbiAgICAgIG4uY2xpZW50WCA+IGkgJiYgKGUgPSBuKTtcbiAgICB9KSwgZTtcbiAgfVxuICBfZ2V0QW5nbGUodCwgZSwgaSwgbikge1xuICAgIHJldHVybiBNYXRoLmF0YW4yKG4gLSBlLCBpIC0gdCk7XG4gIH1cbiAgX2dldEFuZ3VsYXJEaXN0YW5jZSh0LCBlKSB7XG4gICAgcmV0dXJuIGUgLSB0O1xuICB9XG4gIF9nZXRDZW50ZXJYWSh7IHgxOiB0LCB4MjogZSwgeTE6IGksIHkyOiBuIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdCArIChlIC0gdCkgLyAyLFxuICAgICAgeTogaSArIChuIC0gaSkgLyAyXG4gICAgfTtcbiAgfVxuICBfZ2V0UGluY2hUb3VjaE9yaWdpbih0KSB7XG4gICAgY29uc3QgW2UsIGldID0gdCwgbiA9IHtcbiAgICAgIHgxOiBlLmNsaWVudFgsXG4gICAgICB4MjogaS5jbGllbnRYLFxuICAgICAgeTE6IGUuY2xpZW50WSxcbiAgICAgIHkyOiBpLmNsaWVudFlcbiAgICB9O1xuICAgIHJldHVybiBbdGhpcy5fZ2V0VmVjdG9yTGVuZ3RoKG4pLCB0aGlzLl9nZXRDZW50ZXJYWShuKV07XG4gIH1cbiAgX2dldFBvc2l0aW9uKHsgeDE6IHQsIHgyOiBlLCB5MTogaSwgeTI6IG4gfSkge1xuICAgIHJldHVybiB7IHgxOiB0LCB4MjogZSwgeTE6IGksIHkyOiBuIH07XG4gIH1cbn1cbmNvbnN0IExvID0gXCJwcmVzc1wiLCBmMCA9IFwicHJlc3N1cFwiLCBtMCA9IHtcbiAgdGltZTogXCJudW1iZXJcIixcbiAgcG9pbnRlcnM6IFwibnVtYmVyXCJcbn0sIGcwID0ge1xuICB0aW1lOiAyNTAsXG4gIHBvaW50ZXJzOiAxXG59O1xuY2xhc3MgYjAgZXh0ZW5kcyBRaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHN1cGVyKCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl90aW1lciA9IG51bGw7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIExvO1xuICB9XG4gIGhhbmRsZVRvdWNoU3RhcnQodCkge1xuICAgIGNvbnN0IHsgdGltZTogZSwgcG9pbnRlcnM6IGkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgdC50b3VjaGVzLmxlbmd0aCA9PT0gaSAmJiAodGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBMbywgeyB0b3VjaDogdCwgdGltZTogZSB9KSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGYwLCB7IHRvdWNoOiB0IH0pO1xuICAgIH0sIGUpKTtcbiAgfVxuICBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5nMCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gSShMbywgZSwgbTApLCBlO1xuICB9XG59XG5jb25zdCB2MCA9IFwic3dpcGVcIiwgVDAgPSB7XG4gIHRocmVzaG9sZDogXCJudW1iZXJcIixcbiAgZGlyZWN0aW9uOiBcInN0cmluZ1wiXG59LCBFMCA9IHtcbiAgdGhyZXNob2xkOiAxMCxcbiAgZGlyZWN0aW9uOiBcImFsbFwiXG59O1xuY2xhc3MgQzAge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpO1xuICB9XG4gIGhhbmRsZVRvdWNoU3RhcnQodCkge1xuICAgIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSB0aGlzLl9nZXRDb29yZGluYXRlcyh0KTtcbiAgfVxuICBoYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIGlmICghdGhpcy5fc3RhcnRQb3NpdGlvbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModCksIGkgPSB7XG4gICAgICB4OiBlLnggLSB0aGlzLl9zdGFydFBvc2l0aW9uLngsXG4gICAgICB5OiBlLnkgLSB0aGlzLl9zdGFydFBvc2l0aW9uLnlcbiAgICB9LCBuID0gdGhpcy5fZ2V0RGlyZWN0aW9uKGkpO1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmRpcmVjdGlvbiA9PT0gXCJhbGxcIikge1xuICAgICAgaWYgKG4ueS52YWx1ZSA8IHRoaXMuX29wdGlvbnMudGhyZXNob2xkICYmIG4ueC52YWx1ZSA8IHRoaXMuX29wdGlvbnMudGhyZXNob2xkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gbi55LnZhbHVlID4gbi54LnZhbHVlID8gbi55LmRpcmVjdGlvbiA6IG4ueC5kaXJlY3Rpb247XG4gICAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYHN3aXBlJHtyfWAsIHsgdG91Y2g6IHQgfSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcInN3aXBlXCIsIHsgdG91Y2g6IHQsIGRpcmVjdGlvbjogciB9KSwgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG8gPSB0aGlzLl9vcHRpb25zLmRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgfHwgdGhpcy5fb3B0aW9ucyA9PT0gXCJyaWdodFwiID8gXCJ4XCIgOiBcInlcIjtcbiAgICBuW29dLmRpcmVjdGlvbiA9PT0gdGhpcy5fb3B0aW9ucy5kaXJlY3Rpb24gJiYgbltvXS52YWx1ZSA+IHRoaXMuX29wdGlvbnMudGhyZXNob2xkICYmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYHN3aXBlJHtuW29dLmRpcmVjdGlvbn1gLCB7XG4gICAgICB0b3VjaDogdFxuICAgIH0pLCB0aGlzLl9zdGFydFBvc2l0aW9uID0gbnVsbCk7XG4gIH1cbiAgaGFuZGxlVG91Y2hFbmQoKSB7XG4gICAgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gIH1cbiAgX2dldENvb3JkaW5hdGVzKHQpIHtcbiAgICBjb25zdCBbZV0gPSB0LnRvdWNoZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgIHk6IGUuY2xpZW50WVxuICAgIH07XG4gIH1cbiAgX2dldERpcmVjdGlvbih0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHtcbiAgICAgICAgZGlyZWN0aW9uOiB0LnggPCAwID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIsXG4gICAgICAgIHZhbHVlOiBNYXRoLmFicyh0LngpXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICBkaXJlY3Rpb246IHQueSA8IDAgPyBcInVwXCIgOiBcImRvd25cIixcbiAgICAgICAgdmFsdWU6IE1hdGguYWJzKHQueSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5FMCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gSSh2MCwgZSwgVDApLCBlO1xuICB9XG59XG5jb25zdCBadCA9IFwicGFuXCIsIEEwID0gYCR7WnR9c3RhcnRgLCB5MCA9IGAke1p0fWVuZGAsIHcwID0gYCR7WnR9bW92ZWAsIGswID0gXCJsZWZ0XCIsIHgwID0gXCJyaWdodFwiLCBPMCA9IHtcbiAgdGhyZXNob2xkOiBcIm51bWJlclwiLFxuICBkaXJlY3Rpb246IFwic3RyaW5nXCIsXG4gIHBvaW50ZXJzOiBcIm51bWJlclwiXG59LCBTMCA9IHtcbiAgdGhyZXNob2xkOiAyMCxcbiAgZGlyZWN0aW9uOiBcImFsbFwiLFxuICBwb2ludGVyczogMVxufTtcbmNsYXNzIEkwIGV4dGVuZHMgUWkge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30pIHtcbiAgICBzdXBlcigpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fc3RhcnRUb3VjaCA9IG51bGw7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFp0O1xuICB9XG4gIGhhbmRsZVRvdWNoU3RhcnQodCkge1xuICAgIHRoaXMuX3N0YXJ0VG91Y2ggPSB0aGlzLl9nZXRDb29yZGluYXRlcyh0KSwgdGhpcy5fbW92ZWRUb3VjaCA9IHQsIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBBMCwgeyB0b3VjaDogdCB9KTtcbiAgfVxuICBoYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIHQudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIiAmJiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgeyB0aHJlc2hvbGQ6IGUsIGRpcmVjdGlvbjogaSB9ID0gdGhpcy5fb3B0aW9ucywgbiA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHQpLCBvID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModGhpcy5fbW92ZWRUb3VjaCksIHIgPSB0aGlzLl9nZXRPcmlnaW4obiwgdGhpcy5fc3RhcnRUb3VjaCksIGEgPSB0aGlzLl9nZXRPcmlnaW4obiwgbyksIGwgPSB0aGlzLl9nZXREaXJlY3Rpb24ociksIHAgPSB0aGlzLl9nZXREaXJlY3Rpb24oYSksIHsgeDogdSwgeTogXyB9ID0gbDtcbiAgICBpZiAoaSA9PT0gXCJhbGxcIiAmJiAoXy52YWx1ZSA+IGUgfHwgdS52YWx1ZSA+IGUpKSB7XG4gICAgICBjb25zdCBnID0gXy52YWx1ZSA+IHUudmFsdWUgPyBfLmRpcmVjdGlvbiA6IHUuZGlyZWN0aW9uO1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke1p0fSR7Z31gLCB7IHRvdWNoOiB0IH0pLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWnQsIHtcbiAgICAgICAgLi4uYSxcbiAgICAgICAgdG91Y2g6IHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBmID0gaSA9PT0gazAgfHwgaSA9PT0geDAgPyBcInhcIiA6IFwieVwiO1xuICAgIHBbZl0uZGlyZWN0aW9uID09PSBpICYmIGxbZl0udmFsdWUgPiBlICYmIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgJHtadH0ke2l9YCwge1xuICAgICAgdG91Y2g6IHQsXG4gICAgICBbZl06IG5bZl0gLSBvW2ZdXG4gICAgfSksIHRoaXMuX21vdmVkVG91Y2ggPSB0LCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdzAsIHsgdG91Y2g6IHQgfSk7XG4gIH1cbiAgaGFuZGxlVG91Y2hFbmQodCkge1xuICAgIHQudHlwZSA9PT0gXCJ0b3VjaGVuZFwiICYmIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fbW92ZWRUb3VjaCA9IG51bGwsIHRoaXMuX3N0YXJ0VG91Y2ggPSBudWxsLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgeTAsIHsgdG91Y2g6IHQgfSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLlMwLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBJKFp0LCBlLCBPMCksIGU7XG4gIH1cbn1cbmNvbnN0IFVlID0gXCJwaW5jaFwiLCBEMCA9IGAke1VlfWVuZGAsICQwID0gYCR7VWV9c3RhcnRgLCBMMCA9IGAke1VlfW1vdmVgLCBOMCA9IHtcbiAgdGhyZXNob2xkOiBcIm51bWJlclwiLFxuICBwb2ludGVyczogXCJudW1iZXJcIlxufSwgTTAgPSB7XG4gIHRocmVzaG9sZDogMTAsXG4gIHBvaW50ZXJzOiAyXG59O1xuY2xhc3MgUjAgZXh0ZW5kcyBRaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHN1cGVyKCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9zdGFydFRvdWNoID0gbnVsbCwgdGhpcy5fb3JpZ2luID0gbnVsbCwgdGhpcy5fdG91Y2ggPSBudWxsLCB0aGlzLl9tYXRoID0gbnVsbCwgdGhpcy5fcmF0aW8gPSBudWxsO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBVZTtcbiAgfVxuICBnZXQgaXNOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9zdGFydFRvdWNoID09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHRoaXMuX3RvdWNoID09IFwibnVtYmVyXCIgJiYgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICFpc05hTih0aGlzLl9zdGFydFRvdWNoKSAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgIWlzTmFOKHRoaXMuX3RvdWNoKTtcbiAgfVxuICBoYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICBpZiAodC50b3VjaGVzLmxlbmd0aCAhPT0gdGhpcy5fb3B0aW9ucy5wb2ludGVycylcbiAgICAgIHJldHVybjtcbiAgICB0LnR5cGUgPT09IFwidG91Y2hzdGFydFwiICYmIHQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBbZSwgaV0gPSB0aGlzLl9nZXRQaW5jaFRvdWNoT3JpZ2luKHQudG91Y2hlcyk7XG4gICAgdGhpcy5fdG91Y2ggPSBlLCB0aGlzLl9vcmlnaW4gPSBpLCB0aGlzLl9zdGFydFRvdWNoID0gdGhpcy5fdG91Y2gsIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCAkMCwge1xuICAgICAgdG91Y2g6IHQsXG4gICAgICByYXRpbzogdGhpcy5fcmF0aW8sXG4gICAgICBvcmlnaW46IHRoaXMuX29yaWdpblxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVRvdWNoTW92ZSh0KSB7XG4gICAgY29uc3QgeyB0aHJlc2hvbGQ6IGUsIHBvaW50ZXJzOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHQudG91Y2hlcy5sZW5ndGggPT09IGkgJiYgKHQudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIiAmJiB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX3RvdWNoID0gdGhpcy5fZ2V0UGluY2hUb3VjaE9yaWdpbih0LnRvdWNoZXMpWzBdLCB0aGlzLl9yYXRpbyA9IHRoaXMuX3RvdWNoIC8gdGhpcy5fc3RhcnRUb3VjaCwgdGhpcy5pc051bWJlciAmJiAodGhpcy5fb3JpZ2luLnggPiBlIHx8IHRoaXMuX29yaWdpbi55ID4gZSkgJiYgKHRoaXMuX3N0YXJ0VG91Y2ggPSB0aGlzLl90b3VjaCwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFVlLCB7XG4gICAgICB0b3VjaDogdCxcbiAgICAgIHJhdGlvOiB0aGlzLl9yYXRpbyxcbiAgICAgIG9yaWdpbjogdGhpcy5fb3JpZ2luXG4gICAgfSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBMMCwge1xuICAgICAgdG91Y2g6IHQsXG4gICAgICByYXRpbzogdGhpcy5fcmF0aW8sXG4gICAgICBvcmlnaW46IHRoaXMuX29yaWdpblxuICAgIH0pKSk7XG4gIH1cbiAgaGFuZGxlVG91Y2hFbmQodCkge1xuICAgIHRoaXMuaXNOdW1iZXIgJiYgKHRoaXMuX3N0YXJ0VG91Y2ggPSBudWxsLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRDAsIHtcbiAgICAgIHRvdWNoOiB0LFxuICAgICAgcmF0aW86IHRoaXMuX3JhdGlvLFxuICAgICAgb3JpZ2luOiB0aGlzLl9vcmlnaW5cbiAgICB9KSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLk0wLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBJKFVlLCBlLCBOMCksIGU7XG4gIH1cbn1cbmNvbnN0IE5vID0gXCJ0YXBcIiwgUDAgPSB7XG4gIGludGVydmFsOiBcIm51bWJlclwiLFxuICB0aW1lOiBcIm51bWJlclwiLFxuICB0YXBzOiBcIm51bWJlclwiLFxuICBwb2ludGVyczogXCJudW1iZXJcIlxufSwgQjAgPSB7XG4gIGludGVydmFsOiA1MDAsXG4gIHRpbWU6IDI1MCxcbiAgdGFwczogMSxcbiAgcG9pbnRlcnM6IDFcbn07XG5jbGFzcyBIMCBleHRlbmRzIFFpIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl90aW1lciA9IG51bGwsIHRoaXMuX3RhcENvdW50ID0gMDtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTm87XG4gIH1cbiAgaGFuZGxlVG91Y2hTdGFydCh0KSB7XG4gICAgY29uc3QgeyB4OiBlLCB5OiBpIH0gPSB0aGlzLl9nZXRDb29yZGluYXRlcyh0KSwgeyBpbnRlcnZhbDogbiwgdGFwczogbywgcG9pbnRlcnM6IHIgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgcmV0dXJuIHQudG91Y2hlcy5sZW5ndGggPT09IHIgJiYgKHRoaXMuX3RhcENvdW50ICs9IDEsIHRoaXMuX3RhcENvdW50ID09PSAxICYmICh0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fdGFwQ291bnQgPSAwO1xuICAgIH0sIG4pKSwgdGhpcy5fdGFwQ291bnQgPT09IG8gJiYgKGNsZWFyVGltZW91dCh0aGlzLl90aW1lciksIHRoaXMuX3RhcENvdW50ID0gMCwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIE5vLCB7XG4gICAgICB0b3VjaDogdCxcbiAgICAgIG9yaWdpbjoge1xuICAgICAgICB4OiBlLFxuICAgICAgICB5OiBpXG4gICAgICB9XG4gICAgfSkpKSwgdDtcbiAgfVxuICBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgfVxuICBoYW5kbGVUb3VjaE1vdmUoKSB7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLkIwLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBJKE5vLCBlLCBQMCksIGU7XG4gIH1cbn1cbmNvbnN0IFdpID0gXCJyb3RhdGVcIiwgVjAgPSBgJHtXaX1lbmRgLCBXMCA9IGAke1dpfXN0YXJ0YCwgRjAgPSB7XG4gIGFuZ2xlOiBcIm51bWJlclwiLFxuICBwb2ludGVyczogXCJudW1iZXJcIlxufSwgWTAgPSB7XG4gIGFuZ2xlOiAwLFxuICBwb2ludGVyczogMlxufTtcbmNsYXNzIGowIGV4dGVuZHMgUWkge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX29yaWdpbiA9IHt9O1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBXaTtcbiAgfVxuICBoYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICB0LnR5cGUgPT09IFwidG91Y2hzdGFydFwiICYmIHQucHJldmVudERlZmF1bHQoKSwgISh0LnRvdWNoZXMubGVuZ3RoIDwgMikgJiYgKHRoaXMuX3N0YXJ0VG91Y2ggPSB0LCB0aGlzLl9vcmlnaW4gPSB7fSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFcwLCB7IHRvdWNoOiB0IH0pKTtcbiAgfVxuICBoYW5kbGVUb3VjaE1vdmUodCkge1xuICAgIHQudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIiAmJiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IGUsIGk7XG4gICAgY29uc3QgbiA9IHQudG91Y2hlcztcbiAgICBpZiAobi5sZW5ndGggPT09IDEgJiYgdGhpcy5fb3B0aW9ucy5wb2ludGVycyA9PT0gMSkge1xuICAgICAgY29uc3QgeyBsZWZ0OiBvLCB0b3A6IHIsIHdpZHRoOiBhLCBoZWlnaHQ6IGwgfSA9IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBlID0ge1xuICAgICAgICB4OiBvICsgYSAvIDIsXG4gICAgICAgIHk6IHIgKyBsIC8gMlxuICAgICAgfSwgaSA9IG5bMF07XG4gICAgfSBlbHNlIGlmICh0LnRvdWNoZXMubGVuZ3RoID09PSAyICYmIHRoaXMuX29wdGlvbnMucG9pbnRlcnMgPT09IDIpIHtcbiAgICAgIGNvbnN0IFtvLCByXSA9IHQudG91Y2hlcywgYSA9IHtcbiAgICAgICAgeDE6IHIuY2xpZW50WCxcbiAgICAgICAgeDI6IG8uY2xpZW50WCxcbiAgICAgICAgeTE6IHIuY2xpZW50WSxcbiAgICAgICAgeTI6IG8uY2xpZW50WVxuICAgICAgfTtcbiAgICAgIGUgPSB0aGlzLl9nZXRNaWRQb2ludChhKSwgaSA9IHRoaXMuX2dldFJpZ2h0TW9zdFRvdWNoKHQudG91Y2hlcyk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jdXJyZW50QW5nbGUgPSB0aGlzLl9nZXRBbmdsZShcbiAgICAgIGUueCxcbiAgICAgIGUueSxcbiAgICAgIGkuY2xpZW50WCxcbiAgICAgIGkuY2xpZW50WVxuICAgICksIHRoaXMuX29yaWdpbi5pbml0aWFsQW5nbGUgPyAodGhpcy5fb3JpZ2luLmNoYW5nZSA9IHRoaXMuX2dldEFuZ3VsYXJEaXN0YW5jZShcbiAgICAgIHRoaXMuX29yaWdpbi5wcmV2aW91c0FuZ2xlLFxuICAgICAgdGhpcy5jdXJyZW50QW5nbGVcbiAgICApLCB0aGlzLl9vcmlnaW4uZGlzdGFuY2UgKz0gdGhpcy5fb3JpZ2luLmNoYW5nZSkgOiAodGhpcy5fb3JpZ2luLmluaXRpYWxBbmdsZSA9IHRoaXMuX29yaWdpbi5wcmV2aW91c0FuZ2xlID0gdGhpcy5jdXJyZW50QW5nbGUsIHRoaXMuX29yaWdpbi5kaXN0YW5jZSA9IHRoaXMuX29yaWdpbi5jaGFuZ2UgPSAwKSwgdGhpcy5fb3JpZ2luLnByZXZpb3VzQW5nbGUgPSB0aGlzLmN1cnJlbnRBbmdsZSwgdGhpcy5yb3RhdGUgPSB7XG4gICAgICBjdXJyZW50QW5nbGU6IHRoaXMuY3VycmVudEFuZ2xlLFxuICAgICAgZGlzdGFuY2U6IHRoaXMuX29yaWdpbi5kaXN0YW5jZSxcbiAgICAgIGNoYW5nZTogdGhpcy5fb3JpZ2luLmNoYW5nZVxuICAgIH0sIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBXaSwgeyAuLi50aGlzLnJvdGF0ZSwgdG91Y2g6IHQgfSk7XG4gIH1cbiAgaGFuZGxlVG91Y2hFbmQodCkge1xuICAgIHQudHlwZSA9PT0gXCJ0b3VjaGVuZFwiICYmIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fb3JpZ2luID0ge30sIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBWMCwgeyB0b3VjaDogdCB9KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uWTAsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEkoV2ksIGUsIEYwKSwgZTtcbiAgfVxufVxuY29uc3Qgc3IgPSBcInRvdWNoXCIsIE1vID0gYHRlLiR7c3J9YCwgSzAgPSB7XG4gIGV2ZW50OiBcInN0cmluZ1wiXG59LCB6MCA9IHtcbiAgZXZlbnQ6IFwic3dpcGVcIlxufTtcbmNsYXNzIEtoIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2V2ZW50ID0gdGhpcy5fb3B0aW9ucy5ldmVudCwgdGhpcy5zd2lwZSA9IHRoaXMuX2V2ZW50ID09PSBcInN3aXBlXCIgPyBuZXcgQzAodCwgZSkgOiBudWxsLCB0aGlzLnByZXNzID0gdGhpcy5fZXZlbnQgPT09IFwicHJlc3NcIiA/IG5ldyBiMCh0LCBlKSA6IG51bGwsIHRoaXMucGFuID0gdGhpcy5fZXZlbnQgPT09IFwicGFuXCIgPyBuZXcgSTAodCwgZSkgOiBudWxsLCB0aGlzLnBpbmNoID0gdGhpcy5fZXZlbnQgPT09IFwicGluY2hcIiA/IG5ldyBSMCh0LCBlKSA6IG51bGwsIHRoaXMudGFwID0gdGhpcy5fZXZlbnQgPT09IFwidGFwXCIgPyBuZXcgSDAodCwgZSkgOiBudWxsLCB0aGlzLnJvdGF0ZSA9IHRoaXMuX2V2ZW50ID09PSBcInJvdGF0ZVwiID8gbmV3IGowKHQsIGUpIDogbnVsbCwgdGhpcy5fdG91Y2hTdGFydEhhbmRsZXIgPSAoaSkgPT4gdGhpcy5faGFuZGxlVG91Y2hTdGFydChpKSwgdGhpcy5fdG91Y2hNb3ZlSGFuZGxlciA9IChpKSA9PiB0aGlzLl9oYW5kbGVUb3VjaE1vdmUoaSksIHRoaXMuX3RvdWNoRW5kSGFuZGxlciA9IChpKSA9PiB0aGlzLl9oYW5kbGVUb3VjaEVuZChpKSwgYy5vbih0aGlzLl9lbGVtZW50LCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fdG91Y2hTdGFydEhhbmRsZXIpLCBjLm9uKHRoaXMuX2VsZW1lbnQsIFwidG91Y2htb3ZlXCIsIHRoaXMuX3RvdWNoTW92ZUhhbmRsZXIpLCBjLm9uKHRoaXMuX2VsZW1lbnQsIFwidG91Y2hlbmRcIiwgdGhpcy5fdG91Y2hFbmRIYW5kbGVyKSwgdGhpcy5fZWxlbWVudCAmJiBBLnNldERhdGEodCwgTW8sIHRoaXMpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBzcjtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwidG91Y2hzdGFydFwiLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwidG91Y2htb3ZlXCIsIHRoaXMuX3RvdWNoTW92ZUhhbmRsZXIpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBcInRvdWNoZW5kXCIsIHRoaXMuX3RvdWNoRW5kSGFuZGxlciksIHRoaXMuc3dpcGUgPSBudWxsLCB0aGlzLnByZXNzID0gbnVsbCwgdGhpcy5wYW4gPSBudWxsLCB0aGlzLnBpbmNoID0gbnVsbCwgdGhpcy50YXAgPSBudWxsLCB0aGlzLnJvdGF0ZSA9IG51bGw7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLnowLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBJKHNyLCBlLCBLMCksIGU7XG4gIH1cbiAgX2hhbmRsZVRvdWNoU3RhcnQodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoU3RhcnQodCk7XG4gIH1cbiAgX2hhbmRsZVRvdWNoTW92ZSh0KSB7XG4gICAgdGhpc1t0aGlzLl9ldmVudF0uaGFuZGxlVG91Y2hNb3ZlICYmIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoTW92ZSh0KTtcbiAgfVxuICBfaGFuZGxlVG91Y2hFbmQodCkge1xuICAgIHRoaXNbdGhpcy5fZXZlbnRdLmhhbmRsZVRvdWNoRW5kKHQpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZSA9IEEuZ2V0RGF0YSh0aGlzLCBNbyk7XG4gICAgICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIWUgJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChlIHx8IChlID0gbmV3IEtoKHRoaXMsIGkpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIHJldHVybiBlW3RdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIEEuZ2V0RGF0YSh0LCBNbyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgbnIgPSBcInNtb290aFNjcm9sbFwiLCBTaSA9IGB0ZS4ke25yfWAsIE9yID0gYC4ke1NpfWAsIFUwID0ge1xuICBjb250YWluZXI6IFwic3RyaW5nXCIsXG4gIG9mZnNldDogXCJudW1iZXJcIixcbiAgZWFzaW5nOiBcInN0cmluZ1wiLFxuICBkdXJhdGlvbjogXCJudW1iZXJcIlxufSwgWDAgPSB7XG4gIGNvbnRhaW5lcjogXCJib2R5XCIsXG4gIG9mZnNldDogMCxcbiAgZWFzaW5nOiBcImxpbmVhclwiLFxuICBkdXJhdGlvbjogNTAwXG59LCBHMCA9IGBzY3JvbGxTdGFydCR7T3J9YCwgcTAgPSBgc2Nyb2xsRW5kJHtPcn1gLCBaMCA9IGBzY3JvbGxDYW5jZWwke09yfWA7XG5jbGFzcyB6aCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9ocmVmID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLCB0aGlzLmlzQ2FuY2VsID0gITEsIHRoaXMuX2VsZW1lbnQgJiYgKEEuc2V0RGF0YSh0LCBTaSwgdGhpcyksIHRoaXMuX3NldHVwKCkpO1xuICB9XG4gIC8vIGdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBucjtcbiAgfVxuICBnZXQgaXNXaW5kb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuY29udGFpbmVyID09PSBcImJvZHlcIjtcbiAgfVxuICBnZXQgY29udGFpbmVyVG9TY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNXaW5kb3cgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkLmZpbmRPbmUoXG4gICAgICB0aGlzLl9vcHRpb25zLmNvbnRhaW5lcixcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICAgICk7XG4gIH1cbiAgZ2V0IGVsRnJvbUhyZWZFeGlzdCgpIHtcbiAgICByZXR1cm4gISFkLmZpbmRPbmUodGhpcy5faHJlZiwgdGhpcy5jb250YWluZXJUb1Njcm9sbCk7XG4gIH1cbiAgZ2V0IG9mZnNldEZyb21FbCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jb250YWluZXJUb1Njcm9sbC5zY3JvbGxUb3AsIGUgPSBkLmZpbmRPbmUodGhpcy5faHJlZiwgdGhpcy5jb250YWluZXJUb1Njcm9sbCk7XG4gICAgaWYgKHRoaXMuaXNXaW5kb3cpXG4gICAgICByZXR1cm4gaC5vZmZzZXQoZSkudG9wIC0gdGhpcy5fb3B0aW9ucy5vZmZzZXQgKyB0O1xuICAgIGNvbnN0IGkgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnksIG4gPSB0aGlzLmNvbnRhaW5lclRvU2Nyb2xsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnk7XG4gICAgcmV0dXJuIGkgLSBuIC0gdGhpcy5fb3B0aW9ucy5vZmZzZXQgKyB0O1xuICB9XG4gIGdldCBlYXNpbmdGdW5jdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fb3B0aW9ucy5lYXNpbmcsIGUgPSBgX21vdGlvbiR7dFswXS50b1VwcGVyQ2FzZSgpfSR7dC5zbGljZSgxKX1gO1xuICAgIHJldHVybiB0aGlzW2VdID8gdGhpc1tlXSA6IHRoaXMuX21vdGlvbkxpbmVhcjtcbiAgfVxuICAvLyBwdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsIHRoaXMuX2hhbmRsZUNsaWNrKSwgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIFNpKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgY2FuY2VsU2Nyb2xsKCkge1xuICAgIHRoaXMuaXNDYW5jZWwgPSAhMDtcbiAgfVxuICAvLyBwcml2YXRlXG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5YMCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gSShuciwgZSwgVTApLCBlO1xuICB9XG4gIF9pblZpZXdwb3J0KCkge1xuICAgIGlmICh0aGlzLmlzV2luZG93KVxuICAgICAgcmV0dXJuICEwO1xuICAgIGNvbnN0IHQgPSB0aGlzLmNvbnRhaW5lclRvU2Nyb2xsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB0LnRvcCA+PSAwICYmIHQuYm90dG9tIDw9ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCk7XG4gIH1cbiAgX3NldHVwKCkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgdGhpcy5faHJlZiA8IFwidVwiLCBlID0gdGhpcy5faHJlZi5pbmNsdWRlcyhcIiNcIik7XG4gICAgdCAmJiBlICYmIHRoaXMuZWxGcm9tSHJlZkV4aXN0ICYmICh0aGlzLl9zY3JvbGxPbkNsaWNrRXZlbnQoKSwgdGhpcy5fcHJldmVudE5hdGl2ZVNjcm9sbCgpKTtcbiAgfVxuICBfc2Nyb2xsT25DbGlja0V2ZW50KCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCAodCkgPT4ge1xuICAgICAgdGhpcy5faGFuZGxlQ2xpY2sodCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNsaWNrKHQpIHtcbiAgICB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuaXNDYW5jZWwgPSAhMSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEcwKTtcbiAgICBjb25zdCBlID0gdGhpcy5jb250YWluZXJUb1Njcm9sbCwgaSA9IHRoaXMuY29udGFpbmVyVG9TY3JvbGwuc2Nyb2xsVG9wLCBuID0gdGhpcy5vZmZzZXRGcm9tRWwsIG8gPSAwLCByID0gMSAvIHRoaXMuX29wdGlvbnMuZHVyYXRpb24sIGEgPSA0LjI1LCBsID0gdGhpcy5lYXNpbmdGdW5jdGlvbjtcbiAgICB0aGlzLl9pblZpZXdwb3J0KCkgPyB0aGlzLl9zY3JvbGxPbk5leHRUaWNrKFxuICAgICAgZSxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgbyxcbiAgICAgIHIsXG4gICAgICBhLFxuICAgICAgbFxuICAgICkgOiAodGhpcy5fc2Nyb2xsT25OZXh0VGljayhcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICB0aGlzLmNvbnRhaW5lclRvU2Nyb2xsLm9mZnNldFRvcCxcbiAgICAgIG8sXG4gICAgICByLFxuICAgICAgYSxcbiAgICAgIGxcbiAgICApLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3Njcm9sbE9uTmV4dFRpY2soXG4gICAgICAgIGUsXG4gICAgICAgIGksXG4gICAgICAgIG4sXG4gICAgICAgIG8sXG4gICAgICAgIHIsXG4gICAgICAgIGEsXG4gICAgICAgIGxcbiAgICAgICksIHRoaXMuaXNDYW5jZWwgPSAhMTtcbiAgICB9LCB0aGlzLl9vcHRpb25zLmR1cmF0aW9uKSk7XG4gIH1cbiAgX3Njcm9sbE9uTmV4dFRpY2sodCwgZSwgaSwgbiwgbywgciwgYSkge1xuICAgIGNvbnN0IGwgPSBuIDwgMCwgcCA9IG4gPiAxLCB1ID0gbyA8PSAwO1xuICAgIGlmIChsIHx8IHAgfHwgdSB8fCB0aGlzLmlzQ2FuY2VsKSB7XG4gICAgICBpZiAodGhpcy5pc0NhbmNlbCkge1xuICAgICAgICB0aGlzLmlzSW5WaWV3cG9ydCAmJiAodGhpcy5pc0NhbmNlbCA9ICExKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFowKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHEwKSwgdC5zY3JvbGxUb3AgPSBpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0LnNjcm9sbFRvKHtcbiAgICAgIHRvcDogZSAtIChlIC0gaSkgKiBhKG4pXG4gICAgfSksIG4gKz0gbyAqIHIsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fc2Nyb2xsT25OZXh0VGljayhcbiAgICAgICAgdCxcbiAgICAgICAgZSxcbiAgICAgICAgaSxcbiAgICAgICAgbixcbiAgICAgICAgbyxcbiAgICAgICAgcixcbiAgICAgICAgYVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBfcHJldmVudERlZmF1bHQodCkge1xuICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfcHJldmVudE5hdGl2ZVNjcm9sbCgpIHtcbiAgICBsZXQgdCA9ICExO1xuICAgIHRyeSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0ZXN0XCIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYXNzaXZlXCIsIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IHQgPSAhMFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChuKSB7XG4gICAgICB0aGlzLl9zY3JvbGxFcnJvciA9IG47XG4gICAgfVxuICAgIGNvbnN0IGUgPSB0ID8geyBwYXNzaXZlOiAhMSB9IDogITEsIGkgPSBcIm9ud2hlZWxcIiBpbiAkKFwiZGl2XCIpID8gXCJ3aGVlbFwiIDogXCJtb3VzZXdoZWVsXCI7XG4gICAgdGhpcy5pc1dpbmRvdyAmJiAodGhpcy5fZGVsZXRlU2Nyb2xsT25TdGFydChlLCBpKSwgdGhpcy5fYWRkU2Nyb2xsT25FbmQoZSwgaSksIHRoaXMuX2FkZFNjcm9sbE9uQ2FuY2VsKGUsIGkpKTtcbiAgfVxuICBfZGVsZXRlU2Nyb2xsT25TdGFydCh0LCBlKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcInNjcm9sbFN0YXJ0LnRlLnNtb290aFNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihlLCB0aGlzLl9wcmV2ZW50RGVmYXVsdCwgdCksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX3ByZXZlbnREZWZhdWx0LCB0KTtcbiAgICB9KTtcbiAgfVxuICBfYWRkU2Nyb2xsT25FbmQodCwgZSkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJzY3JvbGxFbmQudGUuc21vb3RoU2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGUsIHRoaXMuX3ByZXZlbnREZWZhdWx0LCB0KSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fcHJldmVudERlZmF1bHQsIHQpO1xuICAgIH0pO1xuICB9XG4gIF9hZGRTY3JvbGxPbkNhbmNlbCh0LCBlKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcInNjcm9sbENhbmNlbC50ZS5zbW9vdGhTY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgdGhpcy5fcHJldmVudERlZmF1bHQsIHQpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9wcmV2ZW50RGVmYXVsdCwgdCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gTW90aW9uc1xuICAvLyBMaW5lYXJcbiAgX21vdGlvbkxpbmVhcih0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgLy8gRWFzZS1JblxuICBfbW90aW9uRWFzZUluUXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xuICB9XG4gIF9tb3Rpb25FYXNlSW5DdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfVxuICBfbW90aW9uRWFzZUluUXVhcnQodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0O1xuICB9XG4gIF9tb3Rpb25FYXNlSW5RdWludCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xuICB9XG4gIC8vIEVhc2UtSW4tT3V0XG4gIF9tb3Rpb25FYXNlSW5PdXRRdWFkKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0O1xuICB9XG4gIF9tb3Rpb25FYXNlSW5PdXRDdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgLz0gMC41LCB0IDwgMSA/IHQgKiB0ICogdCAvIDIgOiAodCAtPSAyLCAodCAqIHQgKiB0ICsgMikgLyAyKTtcbiAgfVxuICBfbW90aW9uRWFzZUluT3V0UXVhcnQodCkge1xuICAgIHJldHVybiB0IC89IDAuNSwgdCA8IDEgPyAwLjUgKiB0ICogdCAqIHQgKiB0IDogKHQgLT0gMiwgLSh0ICogdCAqIHQgKiB0IC0gMikgLyAyKTtcbiAgfVxuICBfbW90aW9uRWFzZUluT3V0UXVpbnQodCkge1xuICAgIHJldHVybiB0IC89IDAuNSwgdCA8IDEgPyB0ICogdCAqIHQgKiB0ICogdCAvIDIgOiAodCAtPSAyLCAodCAqIHQgKiB0ICogdCAqIHQgKyAyKSAvIDIpO1xuICB9XG4gIC8vIEVhc2UtT3V0XG4gIF9tb3Rpb25FYXNlT3V0UXVhZCh0KSB7XG4gICAgcmV0dXJuIC10ICogKHQgLSAyKTtcbiAgfVxuICBfbW90aW9uRWFzZU91dEN1YmljKHQpIHtcbiAgICByZXR1cm4gdC0tLCB0ICogdCAqIHQgKyAxO1xuICB9XG4gIF9tb3Rpb25FYXNlT3V0UXVhcnQodCkge1xuICAgIHJldHVybiB0LS0sIC0odCAqIHQgKiB0ICogdCAtIDEpO1xuICB9XG4gIF9tb3Rpb25FYXNlT3V0UXVpbnQodCkge1xuICAgIHJldHVybiB0LS0sIHQgKiB0ICogdCAqIHQgKiB0ICsgMTtcbiAgfVxuICAvLyBzdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIFNpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZSA9IEEuZ2V0RGF0YSh0aGlzLCBTaSk7XG4gICAgICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKGUgfHwgKGUgPSBuZXcgemgodGhpcywgaSkpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBxbCA9IFwibGF6eUxvYWRcIiwgUHMgPSBcInRlLmxhenlMb2FkXCIsIFEwID0gXCJbZGF0YS10ZS1sYXp5LWxvYWQtaW5pdF1cIiwgWmwgPSBcImRhdGEtdGUtbGF6eS1sb2FkXCIsIEowID0gXCJvbkxvYWQudGUubGF6eVwiLCB0QyA9IFwib25FcnJvci50ZS5sYXp5XCIsIFFsID0gW1wiaW1nXCIsIFwidmlkZW9cIl0sIGVDID0ge1xuICBsYXp5U3JjOiBcIihzdHJpbmd8bnVsbClcIixcbiAgbGF6eURlbGF5OiBcIm51bWJlclwiLFxuICBsYXp5QW5pbWF0aW9uOiBcInN0cmluZ1wiLFxuICBsYXp5T2Zmc2V0OiBcIm51bWJlclwiLFxuICBsYXp5UGxhY2Vob2xkZXI6IFwiKHN0cmluZ3x1bmRlZmluZWQpXCIsXG4gIGxhenlFcnJvcjogXCIoc3RyaW5nfHVuZGVmaW5lZClcIlxufSwgaUMgPSB7XG4gIGxhenlTcmM6IG51bGwsXG4gIGxhenlEZWxheTogNTAwLFxuICBsYXp5QW5pbWF0aW9uOiBcIltmYWRlLWluXzFzX2Vhc2UtaW4tb3V0XVwiLFxuICBsYXp5T2Zmc2V0OiAwXG59O1xuY2xhc3Mgb3Ige1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2VsZW1lbnQgJiYgQS5zZXREYXRhKHQsIFBzLCB0aGlzKSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5zY3JvbGxIYW5kbGVyID0gdGhpcy5fc2Nyb2xsSGFuZGxlci5iaW5kKHRoaXMpLCB0aGlzLmVycm9ySGFuZGxlciA9IHRoaXMuX3NldEVsZW1lbnRFcnJvci5iaW5kKHRoaXMpLCB0aGlzLl9jaGlsZHJlbkluc3RhbmNlcyA9IG51bGwsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gcWw7XG4gIH1cbiAgZ2V0IG9mZnNldFZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBnZXQgaW5WaWV3cG9ydCgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiB0LnkgPiAwICYmIHQueSA8IHdpbmRvdy5pbm5lckhlaWdodCAmJiB0aGlzLm9mZnNldFZhbHVlcy55ID49IHQueSAmJiB0aGlzLm9mZnNldFZhbHVlcy55IDw9IHQueSArIHQuaGVpZ2h0ICYmIHRoaXMub2Zmc2V0VmFsdWVzLnkgPD0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vZmZzZXRWYWx1ZXMudG9wICsgdGhpcy5fb3B0aW9ucy5sYXp5T2Zmc2V0IDw9IHdpbmRvdy5pbm5lckhlaWdodCAmJiB0aGlzLm9mZnNldFZhbHVlcy5ib3R0b20gPj0gMDtcbiAgfVxuICBnZXQgcGFyZW50KCkge1xuICAgIGNvbnN0IFt0XSA9IGQucGFyZW50cyhcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBRMFxuICAgICk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgZ2V0IG5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQubm9kZU5hbWU7XG4gIH1cbiAgZ2V0IGlzQ29udGFpbmVyKCkge1xuICAgIHJldHVybiAhZC5tYXRjaGVzKHRoaXMuX2VsZW1lbnQsIFFsKTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgUHMpLCB0aGlzLl9hbmltYXRpb24gJiYgKHRoaXMuX2FuaW1hdGlvbi5kaXNwb3NlKCksIHRoaXMuX2FuaW1hdGlvbiA9IG51bGwpLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fY2hpbGRyZW5JbnN0YW5jZXMgJiYgdGhpcy5fY2hpbGRyZW5JbnN0YW5jZXMuZm9yRWFjaCgodCkgPT4gdC5kaXNwb3NlKCkpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFpsLCBcIlwiKSwgdGhpcy5pc0NvbnRhaW5lcikge1xuICAgICAgdGhpcy5fc2V0dXBDb250YWluZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc2V0dXBFbGVtZW50KCk7XG4gIH1cbiAgX3NldHVwRWxlbWVudCgpIHtcbiAgICBjLm9uZSh0aGlzLl9lbGVtZW50LCBcImVycm9yXCIsIHRoaXMuZXJyb3JIYW5kbGVyKSwgdGhpcy5fb3B0aW9ucy5sYXp5UGxhY2Vob2xkZXIgJiYgdGhpcy5fc2V0UGxhY2Vob2xkZXIoKSwgdGhpcy5fYW5pbWF0aW9uID0gbmV3IHdyKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIGFuaW1hdGlvbjogYCR7dGhpcy5fb3B0aW9ucy5sYXp5QW5pbWF0aW9ufWAsXG4gICAgICBhbmltYXRpb25TdGFydDogXCJvbkxvYWRcIlxuICAgIH0pLCBjLm9uZSh0aGlzLl9lbGVtZW50LCBcImxvYWRcIiwgKCkgPT4gdGhpcy5fc2Nyb2xsSGFuZGxlcigpKSwgdGhpcy5wYXJlbnQgJiYgYy5vbih0aGlzLnBhcmVudCwgXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKSwgYy5vbih3aW5kb3csIFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlcik7XG4gIH1cbiAgX3Njcm9sbEhhbmRsZXIoKSB7XG4gICAgdGhpcy5pblZpZXdwb3J0ICYmICh0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9zZXRTcmMoKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoWmwpLCB0aGlzLl9yZW1vdmVBdHRycygpLCB0aGlzLl9hbmltYXRpb24uaW5pdCgpO1xuICAgIH0sIHRoaXMuX29wdGlvbnMubGF6eURlbGF5KSwgdGhpcy5wYXJlbnQgJiYgYy5vZmYodGhpcy5wYXJlbnQsIFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlciksIGMub2ZmKHdpbmRvdywgXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKSk7XG4gIH1cbiAgX3NldEVsZW1lbnRFcnJvcigpIHtcbiAgICAhdGhpcy5fb3B0aW9ucy5sYXp5RXJyb3IgfHwgdGhpcy5fZWxlbWVudC5zcmMgPT09IHRoaXMuX29wdGlvbnMubGF6eUVycm9yID8gdGhpcy5fZWxlbWVudC5hbHQgPSBcIjQwNCBub3QgZm91bmRcIiA6IHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwic3JjXCIsIHRoaXMuX29wdGlvbnMubGF6eUVycm9yKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRDKTtcbiAgfVxuICBfc2V0U3JjKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwic3JjXCIsIHRoaXMuX29wdGlvbnMubGF6eVNyYyksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBKMCk7XG4gIH1cbiAgX3NldFBsYWNlaG9sZGVyKCkge1xuICAgIHRoaXMubm9kZSA9PT0gXCJJTUdcIiA/IHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwic3JjXCIsIHRoaXMuX29wdGlvbnMubGF6eVBsYWNlaG9sZGVyKSA6IHRoaXMubm9kZSA9PT0gXCJWSURFT1wiICYmIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwicG9zdGVyXCIsIHRoaXMuX29wdGlvbnMubGF6eVBsYWNlaG9sZGVyKTtcbiAgfVxuICBfcmVtb3ZlQXR0cnMoKSB7XG4gICAgW1wic3JjXCIsIFwiZGVsYXlcIiwgXCJhbmltYXRpb25cIiwgXCJwbGFjZWhvbGRlclwiLCBcIm9mZnNldFwiLCBcImVycm9yXCJdLmZvckVhY2goXG4gICAgICAodCkgPT4ge1xuICAgICAgICBoLnJlbW92ZURhdGFBdHRyaWJ1dGUodGhpcy5fZWxlbWVudCwgYGxhenktJHt0fWApO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX3NldHVwQ29udGFpbmVyKCkge1xuICAgIHRoaXMuX2NoaWxkcmVuSW5zdGFuY2VzID0gZC5jaGlsZHJlbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBRbFxuICAgICkubWFwKCh0KSA9PiBuZXcgb3IodCwgdGhpcy5fb3B0aW9ucykpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5pQyxcbiAgICAgIC4uLnQsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpXG4gICAgfTtcbiAgICByZXR1cm4gSShxbCwgZSwgZUMpLCBlO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgUHMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBlID0gQS5nZXREYXRhKHRoaXMsIFBzKTtcbiAgICAgIGNvbnN0IGkgPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoZSB8fCAoZSA9IG5ldyBvcih0aGlzLCBpKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEpsID0gXCJjbGlwYm9hcmRcIiwgSWkgPSBcInRlLmNsaXBib2FyZFwiLCBzQyA9IGAuJHtJaX1gLCBuQyA9IHtcbiAgY2xpcGJvYXJkVGFyZ2V0OiBudWxsXG59LCBvQyA9IHtcbiAgY2xpcGJvYXJkVGFyZ2V0OiBcIm51bGx8c3RyaW5nXCJcbn0sIHJDID0gYGNvcHkke3NDfWA7XG5jbGFzcyBVaCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gZSwgdGhpcy5fZWxlbWVudCAmJiAoQS5zZXREYXRhKHQsIElpLCB0aGlzKSwgdGhpcy5faW5pdENvcHkgPSB0aGlzLl9pbml0Q29weS5iaW5kKHRoaXMpLCB0aGlzLl9zZXR1cCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gSmw7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLm5DLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRoaXMuX29wdGlvbnNcbiAgICB9O1xuICAgIHJldHVybiBJKEpsLCB0LCBvQyksIHQ7XG4gIH1cbiAgZ2V0IGNsaXBib2FyZFRhcmdldCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKHRoaXMub3B0aW9ucy5jbGlwYm9hcmRUYXJnZXQpO1xuICB9XG4gIGdldCBjb3B5VGV4dCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jbGlwYm9hcmRUYXJnZXQuaGFzQXR0cmlidXRlKFxuICAgICAgXCJkYXRhLXRlLWNsaXBib2FyZC10ZXh0XCJcbiAgICApLCBlID0gdGhpcy5jbGlwYm9hcmRUYXJnZXQudmFsdWUsIGkgPSB0aGlzLmNsaXBib2FyZFRhcmdldC50ZXh0Q29udGVudDtcbiAgICByZXR1cm4gdCA/IHRoaXMuY2xpcGJvYXJkVGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtdGUtY2xpcGJvYXJkLXRleHRcIikgOiBlIHx8IGk7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9pbml0Q29weSksIEEucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBJaSksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX3NldHVwKCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCB0aGlzLl9pbml0Q29weSk7XG4gIH1cbiAgX2luaXRDb3B5KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jcmVhdGVOZXdJbnB1dCgpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodCksIHRoaXMuX3NlbGVjdElucHV0KHQpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgckMsIHtcbiAgICAgIGNvcHlUZXh0OiB0aGlzLmNvcHlUZXh0XG4gICAgfSksIHQucmVtb3ZlKCk7XG4gIH1cbiAgX2NyZWF0ZU5ld0lucHV0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNsaXBib2FyZFRhcmdldC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIgPyBcInRleHRhcmVhXCIgOiBcImlucHV0XCIsIGUgPSAkKHQpO1xuICAgIHJldHVybiBlLnZhbHVlID0gdGhpcy5jb3B5VGV4dCwgaC5hZGRDbGFzcyhlLCBcIi1sZWZ0LVs5OTk5cHhdIGFic29sdXRlXCIpLCBlO1xuICB9XG4gIF9zZWxlY3RJbnB1dCh0KSB7XG4gICAgdC5zZWxlY3QoKSwgdC5mb2N1cygpLCB0LnNldFNlbGVjdGlvblJhbmdlKDAsIDk5OTk5KSwgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJjb3B5XCIpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGUgPSBBLmdldERhdGEodGhpcywgSWkpO1xuICAgICAgY29uc3QgaSA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmIChlIHx8IChlID0gbmV3IFVoKHRoaXMsIGkpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgSWkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IHJyID0gXCJpbmZpbml0ZVNjcm9sbFwiLCBCcyA9IGB0ZS4ke3JyfWAsIGFDID0ge1xuICBpbmZpbml0ZURpcmVjdGlvbjogXCJ5XCJcbn0sIGxDID0ge1xuICBpbmZpbml0ZURpcmVjdGlvbjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFhoIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9lbGVtZW50ICYmIEEuc2V0RGF0YSh0LCBCcywgdGhpcyksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuc2Nyb2xsSGFuZGxlciA9IHRoaXMuX3Njcm9sbEhhbmRsZXIuYmluZCh0aGlzKSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBycjtcbiAgfVxuICBnZXQgcmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBnZXQgY29uZGl0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50ID09PSB3aW5kb3cgPyBNYXRoLmFicyhcbiAgICAgIHdpbmRvdy5zY3JvbGxZICsgd2luZG93LmlubmVySGVpZ2h0IC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICkgPCAxIDogdGhpcy5fb3B0aW9ucy5pbmZpbml0ZURpcmVjdGlvbiA9PT0gXCJ4XCIgPyB0aGlzLnJlY3Qud2lkdGggKyB0aGlzLl9lbGVtZW50LnNjcm9sbExlZnQgKyAxMCA+PSB0aGlzLl9lbGVtZW50LnNjcm9sbFdpZHRoIDogTWF0aC5jZWlsKHRoaXMucmVjdC5oZWlnaHQgKyB0aGlzLl9lbGVtZW50LnNjcm9sbFRvcCkgPj0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gIH1cbiAgLy8gUHVibGljXG4gIGRpc3Bvc2UoKSB7XG4gICAgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKSwgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIEJzKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwic2Nyb2xsXCIsICgpID0+IHRoaXMuX3Njcm9sbEhhbmRsZXIoKSk7XG4gIH1cbiAgX3Njcm9sbEhhbmRsZXIoKSB7XG4gICAgdGhpcy5jb25kaXRpb24gJiYgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwiY29tcGxldGUudGUuaW5maW5pdGVTY3JvbGxcIiksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlcik7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLmFDLFxuICAgICAgLi4udGhpcy5fZWxlbWVudCAhPT0gd2luZG93ID8gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSA6IHt9LFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEkocnIsIGUsIGxDKSwgZTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIEJzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZSA9IEEuZ2V0RGF0YSh0aGlzLCBCcyk7XG4gICAgICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKGUgfHwgKGUgPSBuZXcgWGgodGhpcywgaSkpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjQyh7IGJhY2tkcm9wSUQ6IHMgfSwgdCkge1xuICBjb25zdCBlID0gJChcImRpdlwiKTtcbiAgcmV0dXJuIGguYWRkQ2xhc3MoXG4gICAgZSxcbiAgICBgJHt0LmJhY2tkcm9wfSAke3QuYmFja2Ryb3BDb2xvcn1gXG4gICksIGUuaWQgPSBzLCBlO1xufVxuY29uc3QgRmkgPSBcImxvYWRpbmdNYW5hZ2VtZW50XCIsIEhzID0gYHRlLiR7Rml9YCwgaEMgPSBcIltkYXRhLXRlLWxvYWRpbmctaWNvbi1yZWZdXCIsIGRDID0gXCJbZGF0YS10ZS1sb2FkaW5nLXRleHQtcmVmXVwiLCB1QyA9IGBzaG93LnRlLiR7Rml9YCwgcEMgPSB7XG4gIGJhY2tkcm9wOiBcIihudWxsfGJvb2xlYW4pXCIsXG4gIGJhY2tkcm9wSUQ6IFwiKG51bGx8c3RyaW5nfG51bWJlcilcIixcbiAgZGVsYXk6IFwiKG51bGx8bnVtYmVyKVwiLFxuICBsb2FkZXI6IFwiKG51bGx8c3RyaW5nfG51bWJlcilcIixcbiAgcGFyZW50U2VsZWN0b3I6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBsb2FkaW5nSWNvbjogXCJib29sZWFuXCIsXG4gIGxvYWRpbmdUZXh0OiBcImJvb2xlYW5cIixcbiAgc2Nyb2xsOiBcImJvb2xlYW5cIlxufSwgX0MgPSB7XG4gIGJhY2tkcm9wOiAhMCxcbiAgYmFja2Ryb3BJRDogbnVsbCxcbiAgZGVsYXk6IDAsXG4gIGxvYWRlcjogXCJcIixcbiAgcGFyZW50U2VsZWN0b3I6IG51bGwsXG4gIHNjcm9sbDogITAsXG4gIGxvYWRpbmdUZXh0OiAhMCxcbiAgbG9hZGluZ0ljb246ICEwXG59LCBmQyA9IHtcbiAgbG9hZGluZ1NwaW5uZXI6IFwiYWJzb2x1dGUgdG9wLVs1MCVdIGxlZnQtWzUwJV0gLXRyYW5zbGF0ZS14LVs1MCVdIC10cmFuc2xhdGUteS1bNTAlXSBmbGV4IGZsZXgtY29sIGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciB6LTQwXCIsXG4gIHNwaW5uZXJDb2xvcjogXCJ0ZXh0LXByaW1hcnkgZGFyazp0ZXh0LXByaW1hcnktNDAwXCIsXG4gIGJhY2tkcm9wOiBcInctZnVsbCBoLWZ1bGwgZml4ZWQgdG9wLTAgbGVmdC0wIGJvdHRvbS0wIHJpZ2h0LTAgei0zMFwiLFxuICBiYWNrZHJvcENvbG9yOiBcImJnLVtyZ2JhKDAsMCwwLDAuNCldXCJcbn0sIG1DID0ge1xuICBsb2FkaW5nU3Bpbm5lcjogXCJzdHJpbmdcIixcbiAgc3Bpbm5lckNvbG9yOiBcInN0cmluZ1wiLFxuICBiYWNrZHJvcDogXCJzdHJpbmdcIixcbiAgYmFja2Ryb3BDb2xvcjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIEdoIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9lbGVtZW50ICYmIEEuc2V0RGF0YSh0LCBIcywgdGhpcyksIHRoaXMuX2JhY2tkcm9wRWxlbWVudCA9IG51bGwsIHRoaXMuX3BhcmVudEVsZW1lbnQgPSBkLmZpbmRPbmUodGhpcy5fb3B0aW9ucy5wYXJlbnRTZWxlY3RvciksIHRoaXMuX2xvYWRpbmdJY29uID0gZC5maW5kT25lKFxuICAgICAgaEMsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fbG9hZGluZ1RleHQgPSBkLmZpbmRPbmUoXG4gICAgICBkQyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gRmk7XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2xvYWRpbmdJY29uLmNsb25lTm9kZSghMCksIGUgPSB0aGlzLl9sb2FkaW5nVGV4dC5jbG9uZU5vZGUoITApO1xuICAgIHRoaXMuX3JlbW92ZUVsZW1lbnRzT25TdGFydCgpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGguYWRkQ2xhc3MoXG4gICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgIGAke3RoaXMuX2NsYXNzZXMubG9hZGluZ1NwaW5uZXJ9ICR7dGhpcy5fY2xhc3Nlcy5zcGlubmVyQ29sb3J9YFxuICAgICAgKSwgdGhpcy5fc2V0QmFja2Ryb3AoKSwgdGhpcy5fc2V0TG9hZGluZ0ljb24odCksIHRoaXMuX3NldExvYWRpbmdUZXh0KGUpLCB0aGlzLl9zZXRTY3JvbGxPcHRpb24oKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHVDKTtcbiAgICB9LCB0aGlzLl9vcHRpb25zLmRlbGF5KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIEEucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBIcyksIGgucmVtb3ZlQ2xhc3MoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5sb2FkaW5nU3Bpbm5lcn0gJHt0aGlzLl9jbGFzc2VzLnNwaW5uZXJDb2xvcn1gXG4gICAgKTtcbiAgICBjb25zdCB0ID0gdGhpcy5fb3B0aW9ucy5kZWxheTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3JlbW92ZUJhY2tkcm9wKCksIHRoaXMuX2JhY2tkcm9wRWxlbWVudCA9IG51bGwsIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbDtcbiAgICB9LCB0KTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9zZXRCYWNrZHJvcCgpIHtcbiAgICBjb25zdCB7IGJhY2tkcm9wOiB0IH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHQgJiYgKHRoaXMuX2JhY2tkcm9wRWxlbWVudCA9IGNDKHRoaXMuX29wdGlvbnMsIHRoaXMuX2NsYXNzZXMpLCB0aGlzLl9wYXJlbnRFbGVtZW50ICE9PSBudWxsID8gKGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJhYnNvbHV0ZVwiKSwgaC5hZGRDbGFzcyh0aGlzLl9wYXJlbnRFbGVtZW50LCBcInJlbGF0aXZlXCIpLCBoLmFkZENsYXNzKHRoaXMuX2JhY2tkcm9wRWxlbWVudCwgXCJhYnNvbHV0ZVwiKSwgdGhpcy5fcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9iYWNrZHJvcEVsZW1lbnQpKSA6IChoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIFwiIWZpeGVkXCIpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2JhY2tkcm9wRWxlbWVudCksIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCkpKTtcbiAgfVxuICBfcmVtb3ZlQmFja2Ryb3AoKSB7XG4gICAgY29uc3QgeyBiYWNrZHJvcDogdCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICB0ICYmICh0aGlzLl9wYXJlbnRFbGVtZW50ICE9PSBudWxsID8gKGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJhYnNvbHV0ZVwiKSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9wYXJlbnRFbGVtZW50LCBcInJlbGF0aXZlXCIpLCB0aGlzLl9iYWNrZHJvcEVsZW1lbnQucmVtb3ZlKCkpIDogKHRoaXMuX2JhY2tkcm9wRWxlbWVudC5yZW1vdmUoKSwgdGhpcy5fZWxlbWVudC5yZW1vdmUoKSkpO1xuICB9XG4gIF9zZXRMb2FkaW5nSWNvbih0KSB7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLmxvYWRpbmdJY29uKSB7XG4gICAgICB0LnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHQpLCB0LmlkID0gdGhpcy5fb3B0aW9ucy5sb2FkZXI7XG4gIH1cbiAgX3NldExvYWRpbmdUZXh0KHQpIHtcbiAgICBpZiAoIXRoaXMuX29wdGlvbnMubG9hZGluZ1RleHQpIHtcbiAgICAgIHQucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQodCk7XG4gIH1cbiAgX3JlbW92ZUVsZW1lbnRzT25TdGFydCgpIHtcbiAgICB0aGlzLl9lbGVtZW50ICE9PSBudWxsICYmICh0aGlzLl9sb2FkaW5nSWNvbi5yZW1vdmUoKSwgdGhpcy5fbG9hZGluZ1RleHQucmVtb3ZlKCkpO1xuICB9XG4gIF9zZXRTY3JvbGxPcHRpb24oKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2Nyb2xsKSB7XG4gICAgICBpZiAodGhpcy5fcGFyZW50RWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICBoLmFkZENsYXNzKGRvY3VtZW50LmJvZHksIFwib3ZlcmZsb3ctYXV0b1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaC5hZGRDbGFzcyh0aGlzLl9wYXJlbnRFbGVtZW50LCBcIm92ZXJmbG93LWF1dG9cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9wYXJlbnRFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIGguYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgXCJvdmVyZmxvdy1oaWRkZW5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGguYWRkQ2xhc3ModGhpcy5fcGFyZW50RWxlbWVudCwgXCJvdmVyZmxvdy1oaWRkZW5cIik7XG4gICAgfVxuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5fQyxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gSShGaSwgZSwgcEMpLCBlO1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZkMsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoRmksIHQsIG1DKSwgdDtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIEhzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZSA9IEEuZ2V0RGF0YSh0aGlzLCBIcyk7XG4gICAgICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKGUgfHwgKGUgPSBuZXcgR2godGhpcywgaSkpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBnQyA9IChzKSA9PiB7XG4gIGNvbnN0IHQgPSAvXigwP1sxLTldfDFbMDEyXSkoOlswLTVdXFxkKSBbQVBhcF1bbU1dJC8sIGUgPSAvXihbMC05XXwwWzAtOV18MVswLTldfDJbMC0zXSk6WzAtNV1bMC05XSg6WzAtNV1bMC05XSk/JC87XG4gIHJldHVybiBzLm1hdGNoKHQpIHx8IHMubWF0Y2goZSk7XG59LCBiQyA9IChzKSA9PiBzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzKSA9PT0gXCJbb2JqZWN0IERhdGVdXCIgJiYgIWlzTmFOKHMpLCB2QyA9IChzKSA9PiBzLmdldE1vbnRoKCksIFRDID0gKHMpID0+IHMuZ2V0RnVsbFllYXIoKSwgRUMgPSAocykgPT4gcy5tYXRjaCgvW14oZG15KV17MSx9L2cpLCBDQyA9IChzLCB0LCBlLCBpKSA9PiB7XG4gIGxldCBuO1xuICBlWzBdICE9PSBlWzFdID8gbiA9IGVbMF0gKyBlWzFdIDogbiA9IGVbMF07XG4gIGNvbnN0IG8gPSBuZXcgUmVnRXhwKGBbJHtufV1gKSwgciA9IHMuc3BsaXQobyksIGEgPSB0LnNwbGl0KG8pLCBsID0gdC5pbmRleE9mKFwibW1tXCIpICE9PSAtMSwgcCA9IFtdO1xuICBmb3IgKGxldCBiID0gMDsgYiA8IGEubGVuZ3RoOyBiKyspXG4gICAgYVtiXS5pbmRleE9mKFwieXlcIikgIT09IC0xICYmIChwWzBdID0geyB2YWx1ZTogcltiXSwgZm9ybWF0OiBhW2JdIH0pLCBhW2JdLmluZGV4T2YoXCJtXCIpICE9PSAtMSAmJiAocFsxXSA9IHsgdmFsdWU6IHJbYl0sIGZvcm1hdDogYVtiXSB9KSwgYVtiXS5pbmRleE9mKFwiZFwiKSAhPT0gLTEgJiYgYVtiXS5sZW5ndGggPD0gMiAmJiAocFsyXSA9IHsgdmFsdWU6IHJbYl0sIGZvcm1hdDogYVtiXSB9KTtcbiAgbGV0IHU7XG4gIHQuaW5kZXhPZihcIm1tbW1cIikgIT09IC0xID8gdSA9IGkubW9udGhzRnVsbCA6IHUgPSBpLm1vbnRoc1Nob3J0O1xuICBjb25zdCBfID0gTnVtYmVyKHBbMF0udmFsdWUpLCBmID0gbCA/IEFDKHBbMV0udmFsdWUsIHUpIDogTnVtYmVyKHBbMV0udmFsdWUpIC0gMSwgZyA9IE51bWJlcihwWzJdLnZhbHVlKTtcbiAgcmV0dXJuIEN0KF8sIGYsIGcpO1xufSwgQUMgPSAocywgdCkgPT4gdC5maW5kSW5kZXgoKGUpID0+IGUgPT09IHMpLCB5QyA9IChzLCB0LCBlKSA9PiBgXG4gIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtlLnBpY2tlckljb259XCIgZGF0YS10ZS1kYXRlcGlja2VyLXRvZ2dsZS1idXR0b24tcmVmPlxuICAgICR7c31cbiAgPC9idXR0b24+XG4gIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtlLnBpY2tlckljb259XCIgZGF0YS10ZS10aW1lcGlja2VyLXRvZ2dsZS1idXR0b24tcmVmPlxuICAgICR7dH1cbiAgPC9idXR0b24+XG5gLCB3QyA9IChzLCB0KSA9PiBgXG4gIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHt0LnRvZ2dsZUJ1dHRvbn1cIiBkYXRhLXRlLWRhdGUtdGltZXBpY2tlci10b2dnbGUtcmVmPlxuICAgICR7c30gXG4gIDwvYnV0dG9uPlxuYCwgb24gPSBcImRhdGV0aW1lcGlja2VyXCIsIERpID0gYHRlLiR7b259YCwgU3IgPSBgLiR7RGl9YCwgcWggPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1pbml0XCIsIFpoID0gXCJkYXRhLXRlLXRpbWVwaWNrZXItaW5pdFwiLCBrQyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWhlYWRlclwiLCB4QyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNhbmNlbC1idXR0b24tcmVmXCIsIE9DID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItb2stYnV0dG9uLXJlZlwiLCBSbyA9IFwiZGF0YS10ZS10aW1lcGlja2VyLXdyYXBwZXJcIiwgdGMgPSBcImRhdGEtdGUtdGltZXBpY2tlci1jYW5jZWxcIiwgU0MgPSBcImRhdGEtdGUtdGltZXBpY2tlci1zdWJtaXRcIiwgSUMgPSBcImRhdGEtdGUtdGltZXBpY2tlci1jbGVhclwiLCBlYyA9IFwiZGF0YS10ZS1idXR0b25zLXRpbWVwaWNrZXJcIiwgREMgPSBcImRhdGEtdGUtZGF0ZS10aW1lcGlja2VyLXRvZ2dsZS1yZWZcIiwgJEMgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZlwiLCBMQyA9IFwiZGF0YS10ZS10aW1lcGlja2VyLXRvZ2dsZS1idXR0b24tcmVmXCIsIE5DID0gYFske1pofV1gLCBNQyA9IGBbJHtxaH1dYCwgUkMgPSBgWyR7REN9XWAsIFBDID0gYFske0xDfV1gLCBCQyA9IFwiW2RhdGEtdGUtaW5wdXQtbm90Y2gtcmVmXVwiLCBIQyA9IFwiW2RhdGEtdGUtZGF0ZS10aW1lcGlja2VyLXRvZ2dsZS1yZWZdXCIsIFZDID0gXCJbZGF0YS10ZS10aW1lcGlja2VyLWVsZW1lbnRzLXdyYXBwZXJdXCIsIFdDID0gXCJbZGF0YS10ZS10aW1lcGlja2VyLWNsb2NrLXdyYXBwZXJdXCIsIEZDID0gYG9wZW4ke1NyfWAsIFlDID0gYGNsb3NlJHtTcn1gLCBqQyA9IGBkYXRldGltZUNoYW5nZSR7U3J9YCwgaWMgPSBcImNsb3NlLnRlLmRhdGVwaWNrZXJcIiwgc2MgPSBcImlucHV0LnRlLnRpbWVwaWNrZXJcIiwgUmUgPSAkKFwiZGl2XCIpLCBuYyA9IHtcbiAgaW5saW5lOiAhMSxcbiAgdG9nZ2xlQnV0dG9uOiAhMCxcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgZGlzYWJsZWQ6ICExLFxuICBkaXNhYmxlUGFzdDogITEsXG4gIGRpc2FibGVGdXR1cmU6ICExLFxuICBkZWZhdWx0VGltZTogXCJcIixcbiAgZGVmYXVsdERhdGU6IFwiXCIsXG4gIHRpbWVwaWNrZXI6IHt9LFxuICBkYXRlcGlja2VyOiB7fSxcbiAgc2hvd0Zvcm1hdDogITEsXG4gIGRhdGVUaW1lcGlja2VyVG9nZ2xlSWNvblRlbXBsYXRlOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj5cbiAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNi43NSAyLjI1QS43NS43NSAwIDAxNy41IDN2MS41aDlWM0EuNzUuNzUgMCAwMTE4IDN2MS41aC43NWEzIDMgMCAwMTMgM3YxMS4yNWEzIDMgMCAwMS0zIDNINS4yNWEzIDMgMCAwMS0zLTNWNy41YTMgMyAwIDAxMy0zSDZWM2EuNzUuNzUgMCAwMS43NS0uNzV6bTEzLjUgOWExLjUgMS41IDAgMDAtMS41LTEuNUg1LjI1YTEuNSAxLjUgMCAwMC0xLjUgMS41djcuNWExLjUgMS41IDAgMDAxLjUgMS41aDEzLjVhMS41IDEuNSAwIDAwMS41LTEuNXYtNy41elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICA8L3N2Zz5gLFxuICBkYXRlcGlja2VyVG9nZ2xlSWNvblRlbXBsYXRlOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj5cbiAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNi43NSAyLjI1QS43NS43NSAwIDAxNy41IDN2MS41aDlWM0EuNzUuNzUgMCAwMTE4IDN2MS41aC43NWEzIDMgMCAwMTMgM3YxMS4yNWEzIDMgMCAwMS0zIDNINS4yNWEzIDMgMCAwMS0zLTNWNy41YTMgMyAwIDAxMy0zSDZWM2EuNzUuNzUgMCAwMS43NS0uNzV6bTEzLjUgOWExLjUgMS41IDAgMDAtMS41LTEuNUg1LjI1YTEuNSAxLjUgMCAwMC0xLjUgMS41djcuNWExLjUgMS41IDAgMDAxLjUgMS41aDEzLjVhMS41IDEuNSAwIDAwMS41LTEuNXYtNy41elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICA8L3N2Zz5gLFxuICB0aW1lcGlja2VyVG9nZ2xlSWNvblRlbXBsYXRlOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTIgNnY2aDQuNW00LjUgMGE5IDkgMCAxMS0xOCAwIDkgOSAwIDAxMTggMHpcIiAvPlxuICA8L3N2Zz5gXG59LCBLQyA9IHtcbiAgaW5saW5lOiBcImJvb2xlYW5cIixcbiAgdG9nZ2xlQnV0dG9uOiBcImJvb2xlYW5cIixcbiAgY29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBkaXNhYmxlZDogXCJib29sZWFuXCIsXG4gIGRpc2FibGVQYXN0OiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZUZ1dHVyZTogXCJib29sZWFuXCIsXG4gIGRlZmF1bHRUaW1lOiBcIihzdHJpbmd8ZGF0ZXxudW1iZXIpXCIsXG4gIGRlZmF1bHREYXRlOiBcIihzdHJpbmd8ZGF0ZXxudW1iZXIpXCIsXG4gIHRpbWVwaWNrZXI6IFwib2JqZWN0XCIsXG4gIGRhdGVwaWNrZXI6IFwib2JqZWN0XCIsXG4gIHNob3dGb3JtYXQ6IFwiYm9vbGVhblwiLFxuICBkYXRlVGltZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZTogXCJzdHJpbmdcIlxufSwgekMgPSB7XG4gIHRvZ2dsZUJ1dHRvbjogXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyIFsmPnN2Z106dy01IFsmPnN2Z106aC01IGFic29sdXRlIG91dGxpbmUtbm9uZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCByaWdodC0wLjUgdG9wLTEvMiAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgaG92ZXI6dGV4dC1wcmltYXJ5IGZvY3VzOnRleHQtcHJpbWFyeSBkYXJrOmhvdmVyOnRleHQtcHJpbWFyeS00MDAgZGFyazpmb2N1czp0ZXh0LXByaW1hcnktNDAwIGRhcms6dGV4dC1uZXV0cmFsLTIwMFwiLFxuICBwaWNrZXJJY29uOiBcIlsmPnN2Z106dy02IFsmPnN2Z106aC02IFsmPnN2Z106bXgtYXV0byBbJj5zdmddOnBvaW50ZXItZXZlbnRzLW5vbmUgdy0xLzIgcHgtMS41IHB5LVsxcHhdIHJvdW5kZWQtWzEwcHhdIG1pbi1oLVs0MHB4XSBjdXJzb3ItcG9pbnRlciBvdXRsaW5lLW5vbmUgYm9yZGVyLW5vbmUgdGV4dC13aGl0ZSBob3ZlcjpiZy1wcmltYXJ5LTYwMCBkYXJrOmhvdmVyOmJnLW5ldXRyYWwtNjAwXCIsXG4gIGJ1dHRvbnNDb250YWluZXI6IFwiZmxleCBqdXN0aWZ5LWV2ZW5seSBpdGVtcy1lbmQgYmctcHJpbWFyeSBkYXJrOmJnLXppbmMtODAwIGRhcms6ZGF0YS1bdGUtYnV0dG9ucy10aW1lcGlja2VyXTpiZy16aW5jLTcwMFwiLFxuICB0aW1lcGlja2VyOiB7fSxcbiAgZGF0ZXBpY2tlcjoge31cbn0sIFVDID0ge1xuICB0b2dnbGVCdXR0b246IFwic3RyaW5nXCIsXG4gIHBpY2tlckljb246IFwic3RyaW5nXCIsXG4gIGJ1dHRvbnNDb250YWluZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXI6IFwib2JqZWN0XCIsXG4gIGRhdGVwaWNrZXI6IFwib2JqZWN0XCJcbn07XG5jbGFzcyBRaCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5faW5wdXQgPSBkLmZpbmRPbmUoXCJpbnB1dFwiLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX3RpbWVwaWNrZXIgPSBudWxsLCB0aGlzLl9kYXRlcGlja2VyID0gbnVsbCwgdGhpcy5fZGF0ZVZhbHVlID0gdGhpcy5fb3B0aW9ucy5kZWZhdWx0RGF0ZSA/IHRoaXMuX29wdGlvbnMuZGVmYXVsdERhdGUgOiBcIlwiLCB0aGlzLl90aW1lVmFsdWUgPSB0aGlzLl9vcHRpb25zLmRlZmF1bHRUaW1lID8gdGhpcy5fb3B0aW9ucy5kZWZhdWx0VGltZSA6IFwiXCIsIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgPSAhMSwgdGhpcy5fZm9ybWF0ID0gdGhpcy5fb3B0aW9ucy5kYXRlcGlja2VyLmZvcm1hdCA/IHRoaXMuX29wdGlvbnMuZGF0ZXBpY2tlci5mb3JtYXQgOiBcImRkL21tL3l5eXlcIiwgdGhpcy5fY2FuY2VsID0gITEsIHRoaXMuX3Njcm9sbEJhciA9IG5ldyB0aSgpLCB0aGlzLl9lbGVtZW50ICYmIEEuc2V0RGF0YSh0LCBEaSwgdGhpcyksIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gb247XG4gIH1cbiAgZ2V0IHRvZ2dsZUJ1dHRvbigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFJDLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgbm90Y2goKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShCQywgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsIHRoaXMuX29wZW5EYXRlUGlja2VyKSwgYy5vZmYodGhpcy5faW5wdXQsIFwiaW5wdXRcIiwgdGhpcy5faGFuZGxlSW5wdXQpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIpLCBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgRGkpLCB0aGlzLl9yZW1vdmVUaW1lUGlja2VyKCksIHRoaXMuX3JlbW92ZURhdGVwaWNrZXIoKSwgdGhpcy50b2dnbGVCdXR0b24ucmVtb3ZlKCksIHRoaXMuX29wdGlvbnMgPSBuYywgdGhpcy5fdGltZXBpY2tlciA9IG51bGwsIHRoaXMuX2RhdGVwaWNrZXIgPSBudWxsLCB0aGlzLl9kYXRlVmFsdWUgPSBudWxsLCB0aGlzLl90aW1lVmFsdWUgPSBudWxsLCB0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0ID0gbnVsbDtcbiAgfVxuICB1cGRhdGUodCA9IHt9KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldENvbmZpZyh7IC4uLnRoaXMuX29wdGlvbnMsIC4uLnQgfSk7XG4gICAgdGhpcy5kaXNwb3NlKCksIHRoaXMuX29wdGlvbnMgPSBlLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9hZGREYXRlcGlja2VyKCksIHRoaXMuX2FkZFRpbWVQaWNrZXIoKSwgdGhpcy5fYXBwZW5kVG9nZ2xlQnV0dG9uKCksIHRoaXMuX2xpc3RlblRvVG9nZ2xlQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9Vc2VySW5wdXQoKSwgdGhpcy5fZGlzYWJsZUlucHV0KCksIHRoaXMuX3NldEluaXRpYWxEZWZhdWx0SW5wdXQoKSwgdGhpcy5fYXBwbHlGb3JtYXRQbGFjZWhvbGRlcigpLCB0aGlzLl9vcHRpb25zLmRpc2FibGVQYXN0ICYmIHRoaXMuX2hhbmRsZVRpbWVwaWNrZXJEaXNhYmxlUGFzdCgpLCB0aGlzLl9vcHRpb25zLmRpc2FibGVGdXR1cmUgJiYgdGhpcy5faGFuZGxlVGltZXBpY2tlckRpc2FibGVGdXR1cmUoKTtcbiAgfVxuICBfcmVtb3ZlRGF0ZXBpY2tlcigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKE1DKTtcbiAgICB0ICYmIHQucmVtb3ZlKCk7XG4gIH1cbiAgX2FkZERhdGVwaWNrZXIoKSB7XG4gICAgY29uc3QgdCA9ICQoXCJkaXZcIik7XG4gICAgdC5pZCA9IHRoaXMuX2VsZW1lbnQuaWQgPyBgZGF0ZXBpY2tlci0ke3RoaXMuX2VsZW1lbnQuaWR9YCA6IGV0KFwiZGF0ZXBpY2tlci1cIik7XG4gICAgY29uc3QgZSA9ICc8aW5wdXQgdHlwZT1cInRleHRcIj4nO1xuICAgIHQuaW5uZXJIVE1MID0gZSwgdC5zZXRBdHRyaWJ1dGUocWgsIFwiXCIpLCB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHQpLCBoLmFkZENsYXNzKHQsIFwiaGlkZGVuXCIpO1xuICAgIGxldCBpID0ge1xuICAgICAgLi4udGhpcy5fb3B0aW9ucy5kYXRlcGlja2VyLFxuICAgICAgY29udGFpbmVyOiB0aGlzLl9vcHRpb25zLmNvbnRhaW5lcixcbiAgICAgIGRpc2FibGVQYXN0OiB0aGlzLl9vcHRpb25zLmRpc2FibGVQYXN0LFxuICAgICAgZGlzYWJsZUZ1dHVyZTogdGhpcy5fb3B0aW9ucy5kaXNhYmxlRnV0dXJlXG4gICAgfTtcbiAgICAodGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5fb3B0aW9ucy5kYXRlcGlja2VyLmlubGluZSkgJiYgKGkgPSB7IC4uLmksIGlubGluZTogITAgfSksIHRoaXMuX2RhdGVwaWNrZXIgPSBuZXcgb2codCwgaSwge1xuICAgICAgLi4udGhpcy5fY2xhc3Nlcy5kYXRlcGlja2VyXG4gICAgfSksIHRoaXMuX2RhdGVwaWNrZXIuX2lucHV0LnZhbHVlID0gdGhpcy5fZGF0ZVZhbHVlO1xuICB9XG4gIF9yZW1vdmVUaW1lUGlja2VyKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoTkMpO1xuICAgIHQgJiYgKHQucmVtb3ZlKCksIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpKTtcbiAgfVxuICBfYWRkVGltZVBpY2tlcigpIHtcbiAgICBjb25zdCB0ID0gJChcImRpdlwiKTtcbiAgICB0LmlkID0gdGhpcy5fZWxlbWVudC5pZCA/IGB0aW1lcGlja2VyLSR7dGhpcy5fZWxlbWVudC5pZH1gIDogZXQoXCJ0aW1lcGlja2VyLVwiKTtcbiAgICBjb25zdCBlID0gJzxpbnB1dCB0eXBlPVwidGV4dFwiPic7XG4gICAgdC5pbm5lckhUTUwgPSBlLCB0LnNldEF0dHJpYnV0ZShaaCwgXCJcIiksIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQodCksIGguYWRkQ2xhc3ModCwgXCJoaWRkZW5cIik7XG4gICAgbGV0IGkgPSB7XG4gICAgICAuLi50aGlzLl9vcHRpb25zLnRpbWVwaWNrZXIsXG4gICAgICBjb250YWluZXI6IHRoaXMuX29wdGlvbnMuY29udGFpbmVyXG4gICAgfTtcbiAgICAodGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5fb3B0aW9ucy50aW1lcGlja2VyLmlubGluZSkgJiYgKGkgPSB7IC4uLmksIGlubGluZTogITAgfSksIHRoaXMuX3RpbWVwaWNrZXIgPSBuZXcgU2codCwgaSwge1xuICAgICAgLi4udGhpcy5fY2xhc3Nlcy50aW1lcGlja2VyXG4gICAgfSksIHRoaXMuX3RpbWVwaWNrZXIuaW5wdXQudmFsdWUgPSB0aGlzLl90aW1lVmFsdWU7XG4gIH1cbiAgX2FkZEljb25CdXR0b25zKCkge1xuICAgIGlmIChoLmFkZENsYXNzKFJlLCB0aGlzLl9jbGFzc2VzLmJ1dHRvbnNDb250YWluZXIpLCBSZS5pbm5lckhUTUwgPSB5QyhcbiAgICAgIHRoaXMuX29wdGlvbnMuZGF0ZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMudGltZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCBSZS5yZW1vdmVBdHRyaWJ1dGUoZWMpLCAhKHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX29wdGlvbnMuZGF0ZXBpY2tlci5pbmxpbmUpKSB7XG4gICAgICBpZiAodGhpcy5fc2Nyb2xsQmFyLmhpZGUoKSwgdGhpcy5fZGF0ZXBpY2tlci5faXNPcGVuKVxuICAgICAgICBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske2tDfV1gLFxuICAgICAgICAgIGRvY3VtZW50LmJvZHlcbiAgICAgICAgKS5hcHBlbmRDaGlsZChSZSk7XG4gICAgICBlbHNlIGlmICh0aGlzLl90aW1lcGlja2VyLl9tb2RhbCAmJiAhdGhpcy5fb3B0aW9ucy50aW1lcGlja2VyLmlubGluZSkge1xuICAgICAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgICAgIFZDLFxuICAgICAgICAgIGRvY3VtZW50LmJvZHlcbiAgICAgICAgKSwgZSA9IGQuZmluZE9uZShcbiAgICAgICAgICBXQyxcbiAgICAgICAgICBkb2N1bWVudC5ib2R5XG4gICAgICAgICk7XG4gICAgICAgIFJlLnNldEF0dHJpYnV0ZShlYywgXCJcIiksIHQuaW5zZXJ0QmVmb3JlKFJlLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2VuYWJsZU9yRGlzYWJsZVRvZ2dsZUJ1dHRvbigpIHtcbiAgICB0aGlzLl9vcHRpb25zLmRpc2FibGVkID8gKHRoaXMudG9nZ2xlQnV0dG9uLmRpc2FibGVkID0gITAsIGguYWRkQ2xhc3ModGhpcy50b2dnbGVCdXR0b24sIFwicG9pbnRlci1ldmVudHMtbm9uZVwiKSkgOiAodGhpcy50b2dnbGVCdXR0b24uZGlzYWJsZWQgPSAhMSwgaC5yZW1vdmVDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbiwgXCJwb2ludGVyLWV2ZW50cy1ub25lXCIpKTtcbiAgfVxuICBfYXBwZW5kVG9nZ2xlQnV0dG9uKCkge1xuICAgIHRoaXMuX29wdGlvbnMudG9nZ2xlQnV0dG9uICYmICh0aGlzLl9lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcbiAgICAgIFwiYmVmb3JlZW5kXCIsXG4gICAgICB3QyhcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5kYXRlVGltZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZSxcbiAgICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICAgKVxuICAgICksIHRoaXMuX2VuYWJsZU9yRGlzYWJsZVRvZ2dsZUJ1dHRvbigpKTtcbiAgfVxuICBfYXBwbHlGb3JtYXRQbGFjZWhvbGRlcigpIHtcbiAgICB0aGlzLl9vcHRpb25zLnNob3dGb3JtYXQgJiYgKHRoaXMuX2lucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5fZm9ybWF0KTtcbiAgfVxuICBfbGlzdGVuVG9DYW5jZWxDbGljaygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgYFske3hDfV1gLFxuICAgICAgZG9jdW1lbnQuYm9keVxuICAgICk7XG4gICAgYy5vbmUodCwgXCJtb3VzZWRvd25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fY2FuY2VsID0gITAsIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpLCBjLm9mZih0LCBcIm1vdXNlZG93blwiKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9Ub2dnbGVDbGljaygpIHtcbiAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgSEMsICh0KSA9PiB7XG4gICAgICB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX29wZW5EYXRlUGlja2VyKCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvVXNlcklucHV0KCkge1xuICAgIGMub24odGhpcy5faW5wdXQsIFwiaW5wdXRcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZUlucHV0KHQudGFyZ2V0LnZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBfZGlzYWJsZUlucHV0KCkge1xuICAgIHRoaXMuX29wdGlvbnMuZGlzYWJsZWQgJiYgKHRoaXMuX2lucHV0LmRpc2FibGVkID0gXCJ0cnVlXCIpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ubmMsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkob24sIHQsIEtDKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnpDLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKG9uLCB0LCBVQyksIHQ7XG4gIH1cbiAgX2hhbmRsZUlucHV0KHQpIHtcbiAgICBjb25zdCBlID0gdC5zcGxpdChcIiwgXCIpLCBpID0gRUModGhpcy5fZm9ybWF0KSwgbiA9IGVbMF0sIG8gPSBlWzFdIHx8IFwiXCIsIHIgPSBDQyhcbiAgICAgIG4sXG4gICAgICB0aGlzLl9mb3JtYXQsXG4gICAgICBpLFxuICAgICAgdGhpcy5fZGF0ZXBpY2tlci5fb3B0aW9uc1xuICAgICk7XG4gICAgZS5sZW5ndGggPT09IDIgJiYgKGJDKHIpICYmIGdDKG8pID8gKHRoaXMuX2RhdGVWYWx1ZSA9IG4sIHRoaXMuX3RpbWVWYWx1ZSA9IG8sIHRoaXMuX2RhdGVwaWNrZXIuX2lucHV0LnZhbHVlID0gdGhpcy5fZGF0ZVZhbHVlLCB0aGlzLl9kYXRlcGlja2VyLl9hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZVZhbHVlLCB0aGlzLl9kYXRlcGlja2VyLl9zZWxlY3RlZFllYXIgPSBUQyhyKSwgdGhpcy5fZGF0ZXBpY2tlci5fc2VsZWN0ZWRNb250aCA9IHZDKHIpLCB0aGlzLl9kYXRlcGlja2VyLl9oZWFkZXJEYXRlID0gciwgdGhpcy5fdGltZXBpY2tlci5pbnB1dC52YWx1ZSA9IHRoaXMuX3RpbWVWYWx1ZSwgdGhpcy5fdGltZXBpY2tlci5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICExKSA6ICh0aGlzLl9kYXRlcGlja2VyLl9hY3RpdmVEYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLl9kYXRlcGlja2VyLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9kYXRlcGlja2VyLl9oZWFkZXJEYXRlID0gbnVsbCwgdGhpcy5fZGF0ZXBpY2tlci5faGVhZGVyTW9udGggPSBudWxsLCB0aGlzLl9kYXRlcGlja2VyLl9oZWFkZXJZZWFyID0gbnVsbCwgdGhpcy5fdGltZXBpY2tlci5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICEwKSk7XG4gIH1cbiAgX29wZW5EYXRlUGlja2VyKCkge1xuICAgIGlmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRkMpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZGF0ZXBpY2tlci5vcGVuKCksIHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX3Njcm9sbEJhci5oaWRlKCksICh0aGlzLl9vcHRpb25zLmlubGluZSB8fCB0aGlzLl9vcHRpb25zLmRhdGVwaWNrZXIuaW5saW5lKSAmJiB0aGlzLl9vcGVuRHJvcGRvd25EYXRlKCksIHRoaXMuX2FkZEljb25CdXR0b25zKCksIHRoaXMuX2xpc3RlblRvQ2FuY2VsQ2xpY2soKSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgJiYgdGhpcy5fZGF0ZXBpY2tlci5faXNPcGVuICYmIGguYWRkQ2xhc3ModGhpcy50b2dnbGVCdXR0b24sIFwicG9pbnRlci1ldmVudHMtbm9uZVwiKSwgYy5vbmUodGhpcy5fZGF0ZXBpY2tlci5fZWxlbWVudCwgaWMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9kYXRlVmFsdWUgPSB0aGlzLl9kYXRlcGlja2VyLl9pbnB1dC52YWx1ZSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl9jYW5jZWwpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsID0gITE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBpID0gITE7XG4gICAgICBjLm9uKHRoaXMuX2RhdGVwaWNrZXIuY29udGFpbmVyLCBcImNsaWNrXCIsIChuKSA9PiB7XG4gICAgICAgICF0aGlzLl9kYXRlcGlja2VyLl9zZWxlY3RlZERhdGUgJiYgbi50YXJnZXQuaGFzQXR0cmlidXRlKE9DKSB8fCBpIHx8ICh0aGlzLl9vcGVuVGltZVBpY2tlcigpLCBpID0gITAsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGkgPSAhMTtcbiAgICAgICAgfSwgNTAwKSk7XG4gICAgICB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7Um99XWAsXG4gICAgICAgICAgZG9jdW1lbnQuYm9keVxuICAgICAgICApIHx8IHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICAgICAgfSwgMTApLCB0aGlzLl9vcHRpb25zLmlubGluZSAmJiBoLnJlbW92ZUNsYXNzKHRoaXMudG9nZ2xlQnV0dG9uLCBcInBvaW50ZXItZXZlbnRzLW5vbmVcIik7XG4gICAgfSk7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcbiAgICAgIFBDLFxuICAgICAgZG9jdW1lbnQuYm9keVxuICAgICk7XG4gICAgYy5vbihlLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2RhdGVwaWNrZXIuY2xvc2UoKSwgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKSwgYy50cmlnZ2VyKHRoaXMuX2RhdGVwaWNrZXIuX2VsZW1lbnQsIGljKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlVGltZXBpY2tlckRpc2FibGVQYXN0KCkge1xuICAgIGNvbnN0IHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICB0LnNldEhvdXJzKDAsIDAsIDAsIDApLCBjLm9uKFxuICAgICAgdGhpcy5fZGF0ZXBpY2tlci5fZWxlbWVudCxcbiAgICAgIFwiZGF0ZUNoYW5nZS50ZS5kYXRlcGlja2VyXCIsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkRGF0ZS5nZXRUaW1lKCkgPT09IHQuZ2V0VGltZSgpID8gdGhpcy5fdGltZXBpY2tlci51cGRhdGUoeyBkaXNhYmxlUGFzdDogITAgfSkgOiB0aGlzLl90aW1lcGlja2VyLnVwZGF0ZSh7IGRpc2FibGVQYXN0OiAhMSB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVUaW1lcGlja2VyRGlzYWJsZUZ1dHVyZSgpIHtcbiAgICBjb25zdCB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgdC5zZXRIb3VycygwLCAwLCAwLCAwKSwgYy5vbihcbiAgICAgIHRoaXMuX2RhdGVwaWNrZXIuX2VsZW1lbnQsXG4gICAgICBcImRhdGVDaGFuZ2UudGUuZGF0ZXBpY2tlclwiLFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VyLl9zZWxlY3RlZERhdGUuZ2V0VGltZSgpID09PSB0LmdldFRpbWUoKSA/IHRoaXMuX3RpbWVwaWNrZXIudXBkYXRlKHsgZGlzYWJsZUZ1dHVyZTogITAgfSkgOiB0aGlzLl90aW1lcGlja2VyLnVwZGF0ZSh7IGRpc2FibGVGdXR1cmU6ICExIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUVzY2FwZUtleSgpIHtcbiAgICBjLm9uZShkb2N1bWVudC5ib2R5LCBcImtleXVwXCIsICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske1JvfV1gLFxuICAgICAgICAgIGRvY3VtZW50LmJvZHlcbiAgICAgICAgKSB8fCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNhbmNlbEJ1dHRvbigpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgYFske3RjfV1gLFxuICAgICAgZG9jdW1lbnQuYm9keVxuICAgICk7XG4gICAgYy5vbmUodCwgXCJtb3VzZWRvd25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG4gICAgfSk7XG4gIH1cbiAgX29wZW5Ecm9wZG93bkRhdGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2RhdGVwaWNrZXIuX3BvcHBlcjtcbiAgICB0LnN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSA9IHRoaXMuX2lucHV0LCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgfVxuICBfb3BlblRpbWVQaWNrZXIoKSB7XG4gICAgYy50cmlnZ2VyKHRoaXMuX3RpbWVwaWNrZXIuZWxlbWVudFRvZ2dsZSwgXCJjbGlja1wiKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fYWRkSWNvbkJ1dHRvbnMoKSwgKHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX29wdGlvbnMudGltZXBpY2tlci5pbmxpbmUpICYmIHRoaXMuX29wZW5Ecm9wZG93blRpbWUoKSwgdGhpcy5fdGltZXBpY2tlci5fbW9kYWwpIHtcbiAgICAgICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7dGN9XWAsXG4gICAgICAgICAgZG9jdW1lbnQuYm9keVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9oYW5kbGVFc2NhcGVLZXkoKSwgdGhpcy5faGFuZGxlQ2FuY2VsQnV0dG9uKCksIGMub24odGhpcy5fdGltZXBpY2tlci5fbW9kYWwsIFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgICAoZS50YXJnZXQuaGFzQXR0cmlidXRlKFJvKSB8fCBlLnRhcmdldC5oYXNBdHRyaWJ1dGUoU0MpKSAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICAgICAgICAgIH0sIDIwMCksIGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZShJQykgJiYgYy50cmlnZ2VyKFxuICAgICAgICAgICAgdGhpcy5fdGltZXBpY2tlci5fZWxlbWVudCxcbiAgICAgICAgICAgIHNjXG4gICAgICAgICAgKSwgZS50YXJnZXQuaGFzQXR0cmlidXRlKCRDKSAmJiAoYy50cmlnZ2VyKHQsIFwiY2xpY2tcIiksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb3BlbkRhdGVQaWNrZXIoKSwgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKTtcbiAgICAgICAgICB9LCAyMDApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSksIGMub25lKHRoaXMuX3RpbWVwaWNrZXIuX2VsZW1lbnQsIHNjLCAoKSA9PiB7XG4gICAgICB0aGlzLl90aW1lVmFsdWUgPSB0aGlzLl90aW1lcGlja2VyLmlucHV0LnZhbHVlLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBZQyk7XG4gICAgfSk7XG4gIH1cbiAgX29wZW5Ecm9wZG93blRpbWUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RpbWVwaWNrZXIuX3BvcHBlcjtcbiAgICB0LnN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSA9IHRoaXMuX2lucHV0LCB0LnVwZGF0ZSgpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgfVxuICBfc2V0SW5pdGlhbERlZmF1bHRJbnB1dCgpIHtcbiAgICAodGhpcy5fb3B0aW9ucy5kZWZhdWx0RGF0ZSB8fCB0aGlzLl9vcHRpb25zLmRlZmF1bHRUaW1lKSAmJiB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCk7XG4gIH1cbiAgX3VwZGF0ZUlucHV0VmFsdWUoKSB7XG4gICAgdGhpcy5fdGltZVZhbHVlICYmIHRoaXMuX2RhdGVWYWx1ZSAmJiAodGhpcy5faW5wdXQudmFsdWUgPSBgJHt0aGlzLl9kYXRlVmFsdWV9LCAke3RoaXMuX3RpbWVWYWx1ZX1gLCBjLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgakMsXG4gICAgICB7IHZhbHVlOiB0aGlzLl9pbnB1dC52YWx1ZSB9XG4gICAgKS5kZWZhdWx0UHJldmVudGVkKSB8fCAoYy50cmlnZ2VyKHRoaXMuX2lucHV0LCBcImZvY3VzXCIpLCB0aGlzLm5vdGNoICYmIHRoaXMubm90Y2gucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1pbnB1dC1mb2N1c2VkXCIpKTtcbiAgfVxuICAvLyBzdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0gQS5nZXREYXRhKHRoaXMsIERpKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgUWgodGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiBBLmdldERhdGEodCwgRGkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IHJuID0gXCJzdGlja3lcIiwgJGkgPSBgdGUuJHtybn1gLCBKaCA9IGAuJHskaX1gLCBYQyA9IGBhY3RpdmUke0pofWAsIEdDID0gYGluYWN0aXZlJHtKaH1gLCBxQyA9IHtcbiAgc3RpY2t5QW5pbWF0aW9uU3RpY2t5OiBcIlwiLFxuICBzdGlja3lBbmltYXRpb25VbnN0aWNreTogXCJcIixcbiAgc3RpY2t5Qm91bmRhcnk6ICExLFxuICBzdGlja3lEZWxheTogMCxcbiAgc3RpY2t5RGlyZWN0aW9uOiBcImRvd25cIixcbiAgc3RpY2t5TWVkaWE6IDAsXG4gIHN0aWNreU9mZnNldDogMCxcbiAgc3RpY2t5UG9zaXRpb246IFwidG9wXCIsXG4gIHN0aWNreVpJbmRleDogMTAwXG59LCBaQyA9IHtcbiAgc3RpY2t5QW5pbWF0aW9uU3RpY2t5OiBcInN0cmluZ1wiLFxuICBzdGlja3lBbmltYXRpb25VbnN0aWNreTogXCJzdHJpbmdcIixcbiAgc3RpY2t5Qm91bmRhcnk6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBzdGlja3lEZWxheTogXCJudW1iZXJcIixcbiAgc3RpY2t5RGlyZWN0aW9uOiBcInN0cmluZ1wiLFxuICBzdGlja3lNZWRpYTogXCJudW1iZXJcIixcbiAgc3RpY2t5T2Zmc2V0OiBcIm51bWJlclwiLFxuICBzdGlja3lQb3NpdGlvbjogXCJzdHJpbmdcIixcbiAgc3RpY2t5WkluZGV4OiBcIihzdHJpbmd8bnVtYmVyKVwiXG59LCBRQyA9IHtcbiAgc3RpY2t5QWN0aXZlOiBcIlwiXG59LCBKQyA9IHtcbiAgc3RpY2t5QWN0aXZlOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgdGQge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2hpZGRlbkVsZW1lbnQgPSBudWxsLCB0aGlzLl9lbGVtZW50UG9zaXRpb25TdHlsZXMgPSB7fSwgdGhpcy5fc2Nyb2xsRGlyZWN0aW9uID0gXCJcIiwgdGhpcy5faXNTdGlja2VkID0gITEsIHRoaXMuX2VsZW1lbnRPZmZzZXRUb3AgPSBudWxsLCB0aGlzLl9zY3JvbGxUb3AgPSAwLCB0aGlzLl9wdXNoUG9pbnQgPSBcIlwiLCB0aGlzLl9tYW51YWxseURlYWN0aXZhdGVkID0gITEsIHRoaXMuX2VsZW1lbnQgJiYgKHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCBBLnNldERhdGEodCwgJGksIHRoaXMpLCB0aGlzLl9pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBybjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICBjb25zdCB7IHN0aWNreUFuaW1hdGlvblVuc3RpY2t5OiB0IH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGxldCB7IGFuaW1hdGlvbkR1cmF0aW9uOiBlIH0gPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpO1xuICAgIGUgPSB0ICE9PSBcIlwiID8gcGFyc2VGbG9hdChlKSAqIDFlMyA6IDAsIHRoaXMuX2Rpc2FibGVTdGlja3koKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBBLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgJGkpLCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMuX2hpZGRlbkVsZW1lbnQgPSBudWxsLCB0aGlzLl9lbGVtZW50UG9zaXRpb25TdHlsZXMgPSBudWxsLCB0aGlzLl9zY3JvbGxEaXJlY3Rpb24gPSBudWxsLCB0aGlzLl9pc1N0aWNrZWQgPSBudWxsLCB0aGlzLl9lbGVtZW50T2Zmc2V0VG9wID0gbnVsbCwgdGhpcy5fc2Nyb2xsVG9wID0gbnVsbCwgdGhpcy5fcHVzaFBvaW50ID0gbnVsbCwgdGhpcy5fbWFudWFsbHlEZWFjdGl2YXRlZCA9IG51bGw7XG4gICAgfSwgZSk7XG4gIH1cbiAgYWN0aXZlKCkge1xuICAgIHRoaXMuX2lzU3RpY2tlZCB8fCAodGhpcy5fY3JlYXRlSGlkZGVuRWxlbWVudCgpLCB0aGlzLl9lbmFibGVTdGlja3koKSwgdGhpcy5fY2hhbmdlQm91bmRhcnlQb3NpdGlvbigpLCB0aGlzLl9pc1N0aWNrZWQgPSAhMCwgdGhpcy5fbWFudWFsbHlEZWFjdGl2YXRlZCA9ICExKTtcbiAgfVxuICBpbmFjdGl2ZSgpIHtcbiAgICB0aGlzLl9pc1N0aWNrZWQgJiYgKHRoaXMuX2Rpc2FibGVTdGlja3koKSwgdGhpcy5faXNTdGlja2VkID0gITEsIHRoaXMuX21hbnVhbGx5RGVhY3RpdmF0ZWQgPSAhMCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl91c2VyQWN0aXZpdHlMaXN0ZW5lcigpO1xuICB9XG4gIF91c2VyQWN0aXZpdHlMaXN0ZW5lcigpIHtcbiAgICBjLm9uKHdpbmRvdywgXCJyZXNpemVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlRWxlbWVudFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUVsZW1lbnRPZmZzZXQoKTtcbiAgICB9KSwgYy5vbih3aW5kb3csIFwic2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZWxlbWVudCB8fCB3aW5kb3cuaW5uZXJXaWR0aCA8PSB0aGlzLl9vcHRpb25zLnN0aWNreU1lZGlhIHx8IHRoaXMuX21hbnVhbGx5RGVhY3RpdmF0ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHsgc3RpY2t5RGlyZWN0aW9uOiBlIH0gPSB0aGlzLl9vcHRpb25zLCBpID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IHQuc2Nyb2xsVG9wO1xuICAgICAgdGhpcy5fdXBkYXRlRWxlbWVudE9mZnNldCgpLCB0aGlzLl91cGRhdGVQdXNoUG9pbnQoKSwgdGhpcy5fdXBkYXRlU2Nyb2xsRGlyZWN0aW9uKGkpLCB0aGlzLl9jbGVhckluUHJvZ3Jlc3NBbmltYXRpb25zKCk7XG4gICAgICBjb25zdCBuID0gW3RoaXMuX3Njcm9sbERpcmVjdGlvbiwgXCJib3RoXCJdLmluY2x1ZGVzKFxuICAgICAgICBlXG4gICAgICApLCBvID0gdGhpcy5fcHVzaFBvaW50IDw9IGksIHIgPSBvICYmICF0aGlzLl9pc1N0aWNrZWQgJiYgbiwgYSA9ICghbyB8fCAhbikgJiYgdGhpcy5faXNTdGlja2VkO1xuICAgICAgciAmJiAodGhpcy5fY3JlYXRlSGlkZGVuRWxlbWVudCgpLCB0aGlzLl9lbmFibGVTdGlja3koKSwgdGhpcy5fY2hhbmdlQm91bmRhcnlQb3NpdGlvbigpLCB0aGlzLl9pc1N0aWNrZWQgPSAhMCksIGEgJiYgKHRoaXMuX2Rpc2FibGVTdGlja3koKSwgdGhpcy5faXNTdGlja2VkID0gITEpLCB0aGlzLl9pc1N0aWNrZWQgJiYgKHRoaXMuX3VwZGF0ZVBvc2l0aW9uKHsgc3R5bGVzOiB0aGlzLl9lbGVtZW50UG9zaXRpb25TdHlsZXMgfSksIHRoaXMuX2NoYW5nZUJvdW5kYXJ5UG9zaXRpb24oKSksIHRoaXMuX3Njcm9sbFRvcCA9IGkgPD0gMCA/IDAgOiBpO1xuICAgIH0pO1xuICB9XG4gIF91cGRhdGVQdXNoUG9pbnQoKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5zdGlja3lQb3NpdGlvbiA9PT0gXCJ0b3BcIiA/IHRoaXMuX3B1c2hQb2ludCA9IHRoaXMuX2VsZW1lbnRPZmZzZXRUb3AgLSB0aGlzLl9vcHRpb25zLnN0aWNreURlbGF5IDogdGhpcy5fcHVzaFBvaW50ID0gdGhpcy5fZWxlbWVudE9mZnNldFRvcCArIHRoaXMuX2VsZW1lbnQuaGVpZ2h0IC0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgKyB0aGlzLl9vcHRpb25zLnN0aWNreURlbGF5O1xuICB9XG4gIF91cGRhdGVFbGVtZW50T2Zmc2V0KCkge1xuICAgIHRoaXMuX2hpZGRlbkVsZW1lbnQgPyB0aGlzLl9lbGVtZW50T2Zmc2V0VG9wID0gdGhpcy5faGlkZGVuRWxlbWVudC5vZmZzZXRUb3AgOiB0aGlzLl9lbGVtZW50T2Zmc2V0VG9wID0gdGhpcy5fZWxlbWVudC5vZmZzZXRUb3AsIHRoaXMuX29wdGlvbnMuc3RpY2t5QW5pbWF0aW9uVW5zdGlja3kgJiYgKHRoaXMuX2VsZW1lbnRPZmZzZXRUb3AgKz0gdGhpcy5fZWxlbWVudC5oZWlnaHQgfHwgMCk7XG4gIH1cbiAgX3VwZGF0ZUVsZW1lbnRQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy5faGlkZGVuRWxlbWVudCkge1xuICAgICAgY29uc3QgeyBsZWZ0OiB0IH0gPSB0aGlzLl9oaWRkZW5FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGhpcy5fZWxlbWVudFBvc2l0aW9uU3R5bGVzID0ge1xuICAgICAgICBsZWZ0OiBgJHt0fXB4YFxuICAgICAgfTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuX2VsZW1lbnRQb3NpdGlvblN0eWxlcyA9IHt9O1xuICAgIHRoaXMuX3NldFN0eWxlKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2VsZW1lbnRQb3NpdGlvblN0eWxlcyk7XG4gIH1cbiAgX3VwZGF0ZVNjcm9sbERpcmVjdGlvbih0KSB7XG4gICAgdCA+IHRoaXMuX3Njcm9sbFRvcCA/IHRoaXMuX3Njcm9sbERpcmVjdGlvbiA9IFwiZG93blwiIDogdGhpcy5fc2Nyb2xsRGlyZWN0aW9uID0gXCJ1cFwiO1xuICB9XG4gIF9jbGVhckluUHJvZ3Jlc3NBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9zY3JvbGxEaXJlY3Rpb24gPT09IFwidXBcIiwgZSA9IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGlja3lBbmltYXRpb25VbnN0aWNreVxuICAgICksIGkgPSB3aW5kb3cuc2Nyb2xsWSA8PSB0aGlzLl9lbGVtZW50T2Zmc2V0VG9wIC0gdGhpcy5fZWxlbWVudC5oZWlnaHQ7XG4gICAgdCAmJiBlICYmIGkgJiYgKHRoaXMuX3JlbW92ZVVuc3RpY2t5QW5pbWF0aW9uKCksIHRoaXMuX3Jlc2V0U3R5bGVzKCksIHRoaXMuX3JlbW92ZUhpZGRlbkVsZW1lbnQoKSk7XG4gIH1cbiAgX2VuYWJsZVN0aWNreSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGlja3lBbmltYXRpb25TdGlja3k6IHQsXG4gICAgICBzdGlja3lBbmltYXRpb25VbnN0aWNreTogZSxcbiAgICAgIHN0aWNreU9mZnNldDogaSxcbiAgICAgIHN0aWNreVBvc2l0aW9uOiBuLFxuICAgICAgc3RpY2t5WkluZGV4OiBvXG4gICAgfSA9IHRoaXMuX29wdGlvbnMsIHsgaGVpZ2h0OiByLCBsZWZ0OiBhLCB3aWR0aDogbCB9ID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0ICE9PSBcIlwiICYmIHRoaXMuX3RvZ2dsZUNsYXNzKFxuICAgICAgdCxcbiAgICAgIGUsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fdG9nZ2xlQ2xhc3ModGhpcy5fY2xhc3Nlcy5zdGlja3lBY3RpdmUsIFwiXCIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9zZXRTdHlsZSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICB0b3A6IG4gPT09IFwidG9wXCIgJiYgYCR7MCArIGl9cHhgLFxuICAgICAgYm90dG9tOiBuID09PSBcImJvdHRvbVwiICYmIGAkezAgKyBpfXB4YCxcbiAgICAgIGhlaWdodDogYCR7cn1weGAsXG4gICAgICB3aWR0aDogYCR7bH1weGAsXG4gICAgICBsZWZ0OiBgJHthfXB4YCxcbiAgICAgIHpJbmRleDogYCR7b31gLFxuICAgICAgcG9zaXRpb246IFwiZml4ZWRcIlxuICAgIH0pLCB0aGlzLl9oaWRkZW5FbGVtZW50LmhpZGRlbiA9ICExLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWEMpO1xuICB9XG4gIF9jaGFuZ2VCb3VuZGFyeVBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHsgc3RpY2t5UG9zaXRpb246IHQsIHN0aWNreUJvdW5kYXJ5OiBlLCBzdGlja3lPZmZzZXQ6IGkgfSA9IHRoaXMuX29wdGlvbnMsIHsgaGVpZ2h0OiBuIH0gPSB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBvID0ge1xuICAgICAgaGVpZ2h0OiB0aGlzLl9lbGVtZW50LnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LFxuICAgICAgLi4udGhpcy5fZ2V0T2Zmc2V0KHRoaXMuX2VsZW1lbnQucGFyZW50RWxlbWVudClcbiAgICB9O1xuICAgIGxldCByO1xuICAgIGNvbnN0IGEgPSBkLmZpbmRPbmUoZSk7XG4gICAgYSA/IHIgPSB0aGlzLl9nZXRPZmZzZXQoYSkudG9wIC0gbiAtIGkgOiByID0gby5oZWlnaHQgKyBvW3RdIC0gbiAtIGk7XG4gICAgY29uc3QgbCA9IHQgPT09IFwidG9wXCIsIHAgPSB0ID09PSBcImJvdHRvbVwiLCB1ID0gZSwgXyA9IHIgPCAwLCBmID0gciA+IG8uaGVpZ2h0IC0gbjtcbiAgICBsZXQgZztcbiAgICBsICYmIChfICYmIHUgPyBnID0geyB0b3A6IGAke2kgKyByfXB4YCB9IDogZyA9IHsgdG9wOiBgJHtpICsgMH1weGAgfSksIHAgJiYgKF8gJiYgdSA/IGcgPSB7IGJvdHRvbTogYCR7aSArIHJ9cHhgIH0gOiBmICYmIHUgPyBnID0geyBib3R0b206IGAke2kgKyBvLmJvdHRvbX1weGAgfSA6IGcgPSB7IGJvdHRvbTogYCR7aSArIDB9cHhgIH0pLCB0aGlzLl9zZXRTdHlsZSh0aGlzLl9lbGVtZW50LCBnKTtcbiAgfVxuICBfZGlzYWJsZVN0aWNreSgpIHtcbiAgICBjb25zdCB7IHN0aWNreUFuaW1hdGlvblVuc3RpY2t5OiB0LCBzdGlja3lBbmltYXRpb25TdGlja3k6IGUgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgbGV0IHsgYW5pbWF0aW9uRHVyYXRpb246IGkgfSA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudCk7XG4gICAgaSA9IHQgIT09IFwiXCIgPyBwYXJzZUZsb2F0KGkpICogMWUzIDogMCwgdGhpcy5fb3B0aW9ucy5zdGlja3lBbmltYXRpb25VbnN0aWNreSAhPT0gXCJcIiAmJiB0aGlzLl90b2dnbGVDbGFzcyhcbiAgICAgIHQsXG4gICAgICBlLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoZSkgfHwgKHRoaXMuX3JlbW92ZVVuc3RpY2t5QW5pbWF0aW9uKCksIHRoaXMuX3Jlc2V0U3R5bGVzKCksIHRoaXMuX3JlbW92ZUhpZGRlbkVsZW1lbnQoKSwgdGhpcy5fdG9nZ2xlQ2xhc3MoXCJcIiwgdGhpcy5fY2xhc3Nlcy5zdGlja3lBY3RpdmUsIHRoaXMuX2VsZW1lbnQpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgR0MpKTtcbiAgICB9LCBpKTtcbiAgfVxuICBfY3JlYXRlSGlkZGVuRWxlbWVudCgpIHtcbiAgICB0aGlzLl9oaWRkZW5FbGVtZW50IHx8ICh0aGlzLl9oaWRkZW5FbGVtZW50ID0gdGhpcy5fY29weUVsZW1lbnQodGhpcy5fZWxlbWVudCkpO1xuICB9XG4gIF9yZW1vdmVIaWRkZW5FbGVtZW50KCkge1xuICAgIHRoaXMuX2hpZGRlbkVsZW1lbnQgJiYgKHRoaXMuX2hpZGRlbkVsZW1lbnQucmVtb3ZlKCksIHRoaXMuX2hpZGRlbkVsZW1lbnQgPSBudWxsKTtcbiAgfVxuICBfcmVtb3ZlVW5zdGlja3lBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fdG9nZ2xlQ2xhc3MoXCJcIiwgdGhpcy5fb3B0aW9ucy5zdGlja3lBbmltYXRpb25VbnN0aWNreSwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgX3Jlc2V0U3R5bGVzKCkge1xuICAgIHRoaXMuX3NldFN0eWxlKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIHRvcDogbnVsbCxcbiAgICAgIGJvdHRvbTogbnVsbCxcbiAgICAgIHBvc2l0aW9uOiBudWxsLFxuICAgICAgbGVmdDogbnVsbCxcbiAgICAgIHpJbmRleDogbnVsbCxcbiAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgaGVpZ2h0OiBudWxsXG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZVBvc2l0aW9uKHsgc3R5bGVzOiB0IH0pIHtcbiAgICB0aGlzLl9zZXRTdHlsZSh0aGlzLl9lbGVtZW50LCB0KTtcbiAgfVxuICBfdG9nZ2xlQ2xhc3ModCwgZSwgaSkge1xuICAgIHQgJiYgaC5hZGRDbGFzcyhpLCB0KSwgZSAmJiBoLnJlbW92ZUNsYXNzKGksIGUpO1xuICB9XG4gIF9nZXRPZmZzZXQodCkge1xuICAgIGNvbnN0IGUgPSBoLm9mZnNldCh0KSwgaSA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG4gPSBlLmxlZnQgPT09IDAgJiYgZS50b3AgPT09IDAgPyAwIDogd2luZG93LmlubmVySGVpZ2h0IC0gaS5ib3R0b207XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmUsXG4gICAgICBib3R0b206IG5cbiAgICB9O1xuICB9XG4gIF9jb3B5RWxlbWVudCh0KSB7XG4gICAgY29uc3QgeyBoZWlnaHQ6IGUsIHdpZHRoOiBpIH0gPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBuID0gdC5jbG9uZU5vZGUoITEpO1xuICAgIHJldHVybiBuLmhpZGRlbiA9ICEwLCB0aGlzLl9zZXRTdHlsZShuLCB7XG4gICAgICBoZWlnaHQ6IGAke2V9cHhgLFxuICAgICAgd2lkdGg6IGAke2l9cHhgLFxuICAgICAgb3BhY2l0eTogXCIwXCJcbiAgICB9KSwgdC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShuLCB0KSwgbjtcbiAgfVxuICBfZ2V0Q29uZmlnKHQgPSB7fSkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ucUMsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkocm4sIHQsIFpDKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlFDLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKHJuLCB0LCBKQyksIHQ7XG4gIH1cbiAgX3NldFN0eWxlKHQsIGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICB0LnN0eWxlW2ldID0gZVtpXTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSBBLmdldERhdGEodGhpcywgJGkpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlfGhpZGUvLnRlc3QodCkpICYmIChpIHx8IChpID0gbmV3IHRkKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsICRpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCB0QSA9IFwiZGF0YS10ZS1hdXRvY29tcGxldGUtZHJvcGRvd24tcmVmXCIsIGVBID0gXCJkYXRhLXRlLWF1dG9jb21wbGV0ZS1pdGVtcy1saXN0LXJlZlwiLCBpQSA9IFwiZGF0YS10ZS1hdXRvY29tcGxldGUtaXRlbS1yZWZcIiwgc0EgPSBcImRhdGEtdGUtYXV0b2NvbXBsZXRlLWxvYWRlci1yZWZcIjtcbmZ1bmN0aW9uIG5BKHMsIHQpIHtcbiAgY29uc3QgeyBpZDogZSwgaXRlbXM6IGksIHdpZHRoOiBuLCBvcHRpb25zOiBvIH0gPSBzLCByID0gJChcImRpdlwiKTtcbiAgaC5hZGRDbGFzcyhyLCB0LmRyb3Bkb3duQ29udGFpbmVyKSwgaC5hZGRTdHlsZShyLCB7IHdpZHRoOiBgJHtufXB4YCB9KSwgci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBlKTtcbiAgY29uc3QgYSA9ICQoXCJkaXZcIik7XG4gIGEuc2V0QXR0cmlidXRlKHRBLCBcIlwiKSwgaC5hZGRDbGFzcyhhLCB0LmRyb3Bkb3duKTtcbiAgY29uc3QgbCA9ICQoXCJ1bFwiKSwgcCA9IG8ubGlzdEhlaWdodDtcbiAgbC5zZXRBdHRyaWJ1dGUoZUEsIFwiXCIpLCBoLmFkZENsYXNzKGwsIHQuYXV0b2NvbXBsZXRlTGlzdCksIGguYWRkQ2xhc3MobCwgdC5zY3JvbGxiYXIpLCBoLmFkZFN0eWxlKGwsIHsgbWF4SGVpZ2h0OiBgJHtwfXB4YCB9KSwgbC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcbiAgY29uc3QgdSA9IGVkKGksIG8pO1xuICByZXR1cm4gbC5pbm5lckhUTUwgPSB1LCBhLmFwcGVuZENoaWxkKGwpLCByLmFwcGVuZENoaWxkKGEpLCByO1xufVxuZnVuY3Rpb24gZWQocyA9IFtdLCB0LCBlKSB7XG4gIGNvbnN0IGkgPSB0LmRpc3BsYXlWYWx1ZSwgbiA9IHQuaXRlbUNvbnRlbnQ7XG4gIHJldHVybiBgXG4gICAgJHtzLm1hcCgobywgcikgPT4ge1xuICAgIGNvbnN0IGEgPSB0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIgPyBwbihuKG8pLCBzaCwgbnVsbCkgOiBpKG8pO1xuICAgIHJldHVybiBgPGxpIGRhdGEtdGUtaW5kZXg9XCIke3J9XCIgcm9sZT1cIm9wdGlvblwiIGNsYXNzPVwiJHtlfVwiICR7aUF9ID4ke2F9PC9saT5gO1xuICB9KS5qb2luKFwiXCIpfVxuICBgO1xufVxuZnVuY3Rpb24gb0Eocykge1xuICBjb25zdCB0ID0gJChcImRpdlwiKTtcbiAgdC5zZXRBdHRyaWJ1dGUoc0EsIFwiXCIpLCBoLmFkZENsYXNzKHQsIHMuYXV0b2NvbXBsZXRlTG9hZGVyKSwgaC5hZGRDbGFzcyh0LCBzLnNwaW5uZXJJY29uKSwgdC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic3RhdHVzXCIpO1xuICBjb25zdCBlID0gJzxzcGFuIGNsYXNzPVwiYWJzb2x1dGUgLW0tcHggaC1weCB3LXB4IG92ZXJmbG93LWhpZGRlbiB3aGl0ZXNwYWNlLW5vd3JhcCBib3JkZXItMCBwLTAgW2NsaXA6cmVjdCgwLDAsMCwwKV1cIj5Mb2FkaW5nLi4uPC9zcGFuPic7XG4gIHJldHVybiB0LmlubmVySFRNTCA9IGUsIHQ7XG59XG5mdW5jdGlvbiByQShzLCB0KSB7XG4gIHJldHVybiBgPGxpIGNsYXNzPVwiJHt0LmF1dG9jb21wbGV0ZUl0ZW19XCI+JHtzfTwvbGk+YDtcbn1cbmNvbnN0IFBvID0gXCJhdXRvY29tcGxldGVcIiwgTGkgPSBcInRlLmF1dG9jb21wbGV0ZVwiLCBQZSA9IFwiZGF0YS10ZS1pbnB1dC1zdGF0ZS1hY3RpdmVcIiwgQm8gPSBcImRhdGEtdGUtYXV0b2NvbXBsZXRlLWl0ZW0tYWN0aXZlXCIsIG9jID0gXCJkYXRhLXRlLWlucHV0LWZvY3VzZWRcIiwgcmMgPSBcImRhdGEtdGUtYXV0b2NvbXBsZXRlLXN0YXRlLW9wZW5cIiwgYUEgPSBcImRhdGEtdGUtYXV0b2NvbXBsZXRlLWN1c3RvbS1jb250ZW50LXJlZlwiLCBsQSA9IFwiW2RhdGEtdGUtYXV0b2NvbXBsZXRlLWRyb3Bkb3duLXJlZl1cIiwgVnMgPSBcIltkYXRhLXRlLWF1dG9jb21wbGV0ZS1pdGVtcy1saXN0LXJlZl1cIiwgYWMgPSBcIltkYXRhLXRlLWF1dG9jb21wbGV0ZS1pdGVtLXJlZl1cIiwgY0EgPSBcIltkYXRhLXRlLWF1dG9jb21wbGV0ZS1sb2FkZXItcmVmXVwiLCBoQSA9IGBbJHthQX1dYCwgZEEgPSBcIltkYXRhLXRlLWlucHV0LW5vdGNoLXJlZl1cIiwgd24gPSBgLiR7TGl9YCwgdUEgPSBgY2xvc2Uke3dufWAsIHBBID0gYG9wZW4ke3dufWAsIGxjID0gYGl0ZW1TZWxlY3Qke3dufWAsIF9BID0gYHVwZGF0ZSR7d259YCwgZkEgPSB7XG4gIGF1dG9TZWxlY3Q6ICExLFxuICBjb250YWluZXI6IFwiYm9keVwiLFxuICBjdXN0b21Db250ZW50OiBcIlwiLFxuICBkZWJvdW5jZTogMzAwLFxuICBkaXNwbGF5VmFsdWU6IChzKSA9PiBzLFxuICBmaWx0ZXI6IG51bGwsXG4gIGl0ZW1Db250ZW50OiBudWxsLFxuICBsaXN0SGVpZ2h0OiAxOTAsXG4gIGxvYWRlckNsb3NlRGVsYXk6IDMwMCxcbiAgbm9SZXN1bHRzOiBcIk5vIHJlc3VsdHMgZm91bmRcIixcbiAgdGhyZXNob2xkOiAwXG59LCBtQSA9IHtcbiAgYXV0b1NlbGVjdDogXCJib29sZWFuXCIsXG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgY3VzdG9tQ29udGVudDogXCJzdHJpbmdcIixcbiAgZGVib3VuY2U6IFwibnVtYmVyXCIsXG4gIGRpc3BsYXlWYWx1ZTogXCJmdW5jdGlvblwiLFxuICBmaWx0ZXI6IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIGl0ZW1Db250ZW50OiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBsaXN0SGVpZ2h0OiBcIm51bWJlclwiLFxuICBsb2FkZXJDbG9zZURlbGF5OiBcIm51bWJlclwiLFxuICBub1Jlc3VsdHM6IFwic3RyaW5nXCIsXG4gIHRocmVzaG9sZDogXCJudW1iZXJcIlxufSwgZ0EgPSB7XG4gIGF1dG9jb21wbGV0ZUl0ZW06IFwiZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIHctZnVsbCBweC00IHB5LVswLjQzNzVyZW1dIHRydW5jYXRlIHRleHQtZ3JheS03MDAgYmctdHJhbnNwYXJlbnQgc2VsZWN0LW5vbmUgY3Vyc29yLXBvaW50ZXIgaG92ZXI6WyY6bm90KFtkYXRhLXRlLWF1dG9jb21wbGV0ZS1vcHRpb24tZGlzYWJsZWRdKV06YmctYmxhY2svNSBkYXRhLVt0ZS1hdXRvY29tcGxldGUtaXRlbS1hY3RpdmVdOmJnLWJsYWNrLzUgZGF0YS1bZGF0YS10ZS1hdXRvY29tcGxldGUtb3B0aW9uLWRpc2FibGVkXTp0ZXh0LWdyYXktNDAwIGRhdGEtW2RhdGEtdGUtYXV0b2NvbXBsZXRlLW9wdGlvbi1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6aG92ZXI6WyY6bm90KFtkYXRhLXRlLWF1dG9jb21wbGV0ZS1vcHRpb24tZGlzYWJsZWRdKV06Ymctd2hpdGUvMzAgZGFyazpkYXRhLVt0ZS1hdXRvY29tcGxldGUtaXRlbS1hY3RpdmVdOmJnLXdoaXRlLzMwXCIsXG4gIGF1dG9jb21wbGV0ZUxpc3Q6IFwibGlzdC1ub25lIG0tMCBwLTAgb3ZlcmZsb3cteS1hdXRvXCIsXG4gIGF1dG9jb21wbGV0ZUxvYWRlcjogXCJhYnNvbHV0ZSByaWdodC0xIHRvcC0yIHctWzEuNHJlbV0gaC1bMS40cmVtXSBib3JkZXItWzAuMTVlbV1cIixcbiAgZHJvcGRvd246IFwicmVsYXRpdmUgb3V0bGluZS1ub25lIG1pbi13LVsxMDBweF0gbS0wIHNjYWxlLXktWzAuOF0gb3BhY2l0eS0wIGJnLXdoaXRlIHNoYWRvdy1bMF8ycHhfNXB4XzBfcmdiYSgwLDAsMCwwLjE2KSxfMF8ycHhfMTBweF8wX3JnYmEoMCwwLDAsMC4xMildIHRyYW5zaXRpb24gZHVyYXRpb24tMjAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhdGEtW3RlLWF1dG9jb21wbGV0ZS1zdGF0ZS1vcGVuXTpzY2FsZS15LTEwMCBkYXRhLVt0ZS1hdXRvY29tcGxldGUtc3RhdGUtb3Blbl06b3BhY2l0eS0xMDAgZGFyazpiZy16aW5jLTcwMFwiLFxuICBkcm9wZG93bkNvbnRhaW5lcjogXCJ6LVsxMDcwXVwiLFxuICBzY3JvbGxiYXI6IFwiWyY6Oi13ZWJraXQtc2Nyb2xsYmFyXTp3LTEgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyXTpoLTEgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbl06YmxvY2sgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbl06aC0wIFsmOjotd2Via2l0LXNjcm9sbGJhci1idXR0b25dOmJnLXRyYW5zcGFyZW50IFsmOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZV06YmctdHJhbnNwYXJlbnQgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXTpyb3VuZGVkLW5vbmUgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXTogWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXTpyb3VuZGVkLWwgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iXTpoLVs1MHB4XSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJdOmJnLVsjOTk5XSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJdOnJvdW5kZWRcIixcbiAgc3Bpbm5lckljb246IFwiaW5saW5lLWJsb2NrIGgtOCB3LTggYW5pbWF0ZS1zcGluIHJvdW5kZWQtZnVsbCBib3JkZXItNCBib3JkZXItc29saWQgYm9yZGVyLWN1cnJlbnQgYm9yZGVyLXItdHJhbnNwYXJlbnQgYWxpZ24tWy0wLjEyNWVtXSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtW3NwaW5fMS41c19saW5lYXJfaW5maW5pdGVdXCJcbn0sIGJBID0ge1xuICBhdXRvY29tcGxldGVJdGVtOiBcInN0cmluZ1wiLFxuICBhdXRvY29tcGxldGVMaXN0OiBcInN0cmluZ1wiLFxuICBhdXRvY29tcGxldGVMb2FkZXI6IFwic3RyaW5nXCIsXG4gIGRyb3Bkb3duOiBcInN0cmluZ1wiLFxuICBkcm9wZG93bkNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgc2Nyb2xsYmFyOiBcInN0cmluZ1wiLFxuICBzcGlubmVySWNvbjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIGlkIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZ2V0Q29udGFpbmVyKCksIHRoaXMuX2lucHV0ID0gZC5maW5kT25lKFwiaW5wdXRcIiwgdCksIHRoaXMuX25vdGNoID0gZC5maW5kT25lKGRBLCB0KSwgdGhpcy5fY3VzdG9tQ29udGVudCA9IGQuZmluZE9uZShcbiAgICAgIGhBLFxuICAgICAgdFxuICAgICksIHRoaXMuX2xvYWRlciA9IG9BKHRoaXMuX2NsYXNzZXMpLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCA9IG51bGwsIHRoaXMuX2xvYWRlclRpbWVvdXQgPSBudWxsLCB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPSAtMSwgdGhpcy5fYWN0aXZlSXRlbSA9IG51bGwsIHRoaXMuX2ZpbHRlcmVkUmVzdWx0cyA9IG51bGwsIHRoaXMuX2xhc3RRdWVyeVZhbHVlID0gbnVsbCwgdGhpcy5fY2FuT3Blbk9uRm9jdXMgPSAhMCwgdGhpcy5faXNPcGVuID0gITEsIHRoaXMuX291dHNpZGVDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVPdXRzaWRlQ2xpY2suYmluZCh0aGlzKSwgdGhpcy5faW5wdXRGb2N1c0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVJbnB1dEZvY3VzLmJpbmQodGhpcyksIHRoaXMuX3VzZXJJbnB1dEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVVc2VySW5wdXQuYmluZCh0aGlzKSwgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcyksIHQgJiYgQS5zZXREYXRhKHQsIExpLCB0aGlzKSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gUG87XG4gIH1cbiAgZ2V0IGZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5maWx0ZXI7XG4gIH1cbiAgZ2V0IGRyb3Bkb3duKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUobEEsIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKTtcbiAgfVxuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIGQuZmluZChhYywgdGhpcy5fZHJvcGRvd25Db250YWluZXIpO1xuICB9XG4gIGdldCBpdGVtc0xpc3QoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShWcywgdGhpcy5fZHJvcGRvd25Db250YWluZXIpO1xuICB9XG4gIGluaXRTZWFyY2godCkge1xuICAgIHRoaXMuX2ZpbHRlclJlc3VsdHModCk7XG4gIH1cbiAgX2dldENvbnRhaW5lcigpIHtcbiAgICB0aGlzLl9jb250YWluZXIgPSBkLmZpbmRPbmUodGhpcy5fb3B0aW9ucy5jb250YWluZXIpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZkEsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoUG8sIHQsIG1BKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmdBLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBJKFBvLCB0LCBiQSksIHQ7XG4gIH1cbiAgX2luaXQoKSB7XG4gICAgdGhpcy5faW5pdERyb3Bkb3duKCksIHRoaXMuX3VwZGF0ZUlucHV0U3RhdGUoKSwgdGhpcy5fc2V0SW5wdXRBcmlhQXR0cmlidXRlcygpLCB0aGlzLl9saXN0ZW5Ub0lucHV0Rm9jdXMoKSwgdGhpcy5fbGlzdGVuVG9Vc2VySW5wdXQoKSwgdGhpcy5fbGlzdGVuVG9LZXlkb3duKCk7XG4gIH1cbiAgX2luaXREcm9wZG93bigpIHtcbiAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcklkID0gdGhpcy5fZWxlbWVudC5pZCA/IGBhdXRvY29tcGxldGUtZHJvcGRvd24tJHt0aGlzLl9lbGVtZW50LmlkfWAgOiBldChcImF1dG9jb21wbGV0ZS1kcm9wZG93bi1cIik7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIGlkOiB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcklkLFxuICAgICAgaXRlbXM6IFtdLFxuICAgICAgd2lkdGg6IHRoaXMuX2lucHV0Lm9mZnNldFdpZHRoLFxuICAgICAgb3B0aW9uczogdGhpcy5fb3B0aW9uc1xuICAgIH07XG4gICAgaWYgKHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyID0gbkEodCwgdGhpcy5fY2xhc3NlcyksIHRoaXMuX29wdGlvbnMuY3VzdG9tQ29udGVudCAhPT0gXCJcIikge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX29wdGlvbnMuY3VzdG9tQ29udGVudCwgaSA9IHBuKFxuICAgICAgICBlLFxuICAgICAgICBzaCxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIHRoaXMuZHJvcGRvd24uaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGkpO1xuICAgIH1cbiAgfVxuICBfc2V0SW5wdXRBcmlhQXR0cmlidXRlcygpIHtcbiAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tYm9ib3hcIiksIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgITEpLCB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLW93bnNcIiwgdGhpcy5fZHJvcGRvd25Db250YWluZXJJZCksIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgITApLCB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVcIiwgXCJvZmZcIik7XG4gIH1cbiAgX3VwZGF0ZUlucHV0U3RhdGUoKSB7XG4gICAgdmFyIHQsIGU7XG4gICAgdGhpcy5faW5wdXQudmFsdWUgIT09IFwiXCIgfHwgdGhpcy5faXNPcGVuID8gKHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShQZSwgXCJcIiksICh0ID0gdGhpcy5fbm90Y2gpID09IG51bGwgfHwgdC5zZXRBdHRyaWJ1dGUoUGUsIFwiXCIpKSA6ICh0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoUGUpLCAoZSA9IHRoaXMuX25vdGNoKSA9PSBudWxsIHx8IGUucmVtb3ZlQXR0cmlidXRlKFBlKSk7XG4gIH1cbiAgX2xpc3RlblRvSW5wdXRGb2N1cygpIHtcbiAgICBjLm9uKHRoaXMuX2lucHV0LCBcImZvY3VzXCIsIHRoaXMuX2lucHV0Rm9jdXNIYW5kbGVyKTtcbiAgfVxuICBfaGFuZGxlSW5wdXRGb2N1cyh0KSB7XG4gICAgY29uc3QgeyB2YWx1ZTogZSB9ID0gdC50YXJnZXQsIGkgPSB0aGlzLl9vcHRpb25zLnRocmVzaG9sZDtcbiAgICBpZiAoIXRoaXMuX2Nhbk9wZW5PbkZvY3VzKSB7XG4gICAgICB0aGlzLl9jYW5PcGVuT25Gb2N1cyA9ICEwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLmxlbmd0aCA8IGkgfHwgKHRoaXMuX2xhc3RRdWVyeVZhbHVlICE9PSBlID8gdGhpcy5fZmlsdGVyUmVzdWx0cyhlKSA6IHRoaXMub3BlbigpKTtcbiAgfVxuICBfbGlzdGVuVG9XaW5kb3dSZXNpemUoKSB7XG4gICAgYy5vbih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgfVxuICBfaGFuZGxlV2luZG93UmVzaXplKCkge1xuICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyICYmIHRoaXMuX3VwZGF0ZURyb3Bkb3duV2lkdGgoKTtcbiAgfVxuICBfdXBkYXRlRHJvcGRvd25XaWR0aCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5faW5wdXQub2Zmc2V0V2lkdGg7XG4gICAgaC5hZGRTdHlsZSh0aGlzLl9kcm9wZG93bkNvbnRhaW5lciwgeyB3aWR0aDogYCR7dH1weGAgfSk7XG4gIH1cbiAgX2xpc3RlblRvVXNlcklucHV0KCkge1xuICAgIGMub24odGhpcy5faW5wdXQsIFwiaW5wdXRcIiwgdGhpcy5fdXNlcklucHV0SGFuZGxlcik7XG4gIH1cbiAgX2hhbmRsZVVzZXJJbnB1dCh0KSB7XG4gICAgY29uc3QgeyB2YWx1ZTogZSB9ID0gdC50YXJnZXQsIGkgPSB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCwgbiA9IHRoaXMuX29wdGlvbnMuZGVib3VuY2U7XG4gICAgaWYgKHRoaXMuZmlsdGVyKSB7XG4gICAgICBpZiAoZS5sZW5ndGggPCBpKSB7XG4gICAgICAgIHRoaXMuX2lzT3BlbiAmJiB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RlYm91bmNlRmlsdGVyKGUsIG4pO1xuICAgIH1cbiAgfVxuICBfZGVib3VuY2VGaWx0ZXIodCwgZSkge1xuICAgIHRoaXMuX2RlYm91bmNlVGltZW91dElkICYmIGNsZWFyVGltZW91dCh0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCksIHRoaXMuX2RlYm91bmNlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9maWx0ZXJSZXN1bHRzKHQpO1xuICAgIH0sIGUpO1xuICB9XG4gIF9maWx0ZXJSZXN1bHRzKHQpIHtcbiAgICB0aGlzLl9sYXN0UXVlcnlWYWx1ZSA9IHQ7XG4gICAgY29uc3QgZSA9IHRoaXMuZmlsdGVyKHQpO1xuICAgIHRoaXMuX2lzUHJvbWlzZShlKSA/IHRoaXMuX2FzeW5jVXBkYXRlUmVzdWx0cyhlKSA6IHRoaXMuX3VwZGF0ZVJlc3VsdHMoZSk7XG4gIH1cbiAgX2lzUHJvbWlzZSh0KSB7XG4gICAgcmV0dXJuICEhdCAmJiB0eXBlb2YgdC50aGVuID09IFwiZnVuY3Rpb25cIjtcbiAgfVxuICBfYXN5bmNVcGRhdGVSZXN1bHRzKHQpIHtcbiAgICB0aGlzLl9yZXNldEFjdGl2ZUl0ZW0oKSwgdGhpcy5fc2hvd0xvYWRlcigpLCB0LnRoZW4oKGUpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZVJlc3VsdHMoZSksIHRoaXMuX2xvYWRlclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5faGlkZUxvYWRlcigpLCB0aGlzLl9sb2FkZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgIH0sIHRoaXMuX29wdGlvbnMubG9hZGVyQ2xvc2VEZWxheSk7XG4gICAgfSk7XG4gIH1cbiAgX3Jlc2V0QWN0aXZlSXRlbSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fYWN0aXZlSXRlbTtcbiAgICB0ICYmICh0LnJlbW92ZUF0dHJpYnV0ZShCbyksIHRoaXMuX2FjdGl2ZUl0ZW0gPSBudWxsLCB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPSAtMSk7XG4gIH1cbiAgX3Nob3dMb2FkZXIoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9sb2FkZXIpO1xuICB9XG4gIF9oaWRlTG9hZGVyKCkge1xuICAgIGQuZmluZE9uZShjQSwgdGhpcy5fZWxlbWVudCkgJiYgdGhpcy5fZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9sb2FkZXIpO1xuICB9XG4gIF91cGRhdGVSZXN1bHRzKHQpIHtcbiAgICB0aGlzLl9yZXNldEFjdGl2ZUl0ZW0oKSwgdGhpcy5fZmlsdGVyZWRSZXN1bHRzID0gdCwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIF9BLCB7IHJlc3VsdHM6IHQgfSk7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcbiAgICAgIFZzLFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJcbiAgICApLCBpID0gZWQoXG4gICAgICB0LFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXMuYXV0b2NvbXBsZXRlSXRlbVxuICAgICksIG4gPSByQShcbiAgICAgIHRoaXMuX29wdGlvbnMubm9SZXN1bHRzLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdC5sZW5ndGggPT09IDAgJiYgdGhpcy5fb3B0aW9ucy5ub1Jlc3VsdHMgIT09IFwiXCIgPyBlLmlubmVySFRNTCA9IG4gOiBlLmlubmVySFRNTCA9IGksIHRoaXMuX2lzT3BlbiB8fCB0aGlzLm9wZW4oKSwgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci5mb3JjZVVwZGF0ZSgpO1xuICB9XG4gIF9saXN0ZW5Ub0tleWRvd24oKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpO1xuICB9XG4gIF9oYW5kbGVLZXlkb3duKHQpIHtcbiAgICB0aGlzLl9pc09wZW4gPyB0aGlzLl9oYW5kbGVPcGVuS2V5ZG93bih0KSA6IHRoaXMuX2hhbmRsZUNsb3NlZEtleWRvd24odCk7XG4gIH1cbiAgX2hhbmRsZU9wZW5LZXlkb3duKHQpIHtcbiAgICBjb25zdCBlID0gdC5rZXlDb2RlO1xuICAgIGlmIChlID09PSBrZSAmJiB0aGlzLl9vcHRpb25zLmF1dG9TZWxlY3QgJiYgdGhpcy5fc2VsZWN0QWN0aXZlSXRlbSgpLCBlID09PSB3ZSB8fCBlID09PSBVICYmIHQuYWx0S2V5KSB7XG4gICAgICB0aGlzLmNsb3NlKCksIHRoaXMuX2lucHV0LmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlID09PSB3ZSB8fCBlID09PSBVICYmIHQuYWx0S2V5IHx8IGUgPT09IGtlKSB7XG4gICAgICB0aGlzLmNsb3NlKCksIHRoaXMuX2lucHV0LmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZSkge1xuICAgICAgY2FzZSB6OlxuICAgICAgICB0aGlzLl9zZXRBY3RpdmVJdGVtKHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCArIDEpLCB0aGlzLl9zY3JvbGxUb0l0ZW0odGhpcy5fYWN0aXZlSXRlbSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBVOlxuICAgICAgICB0aGlzLl9zZXRBY3RpdmVJdGVtKHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCAtIDEpLCB0aGlzLl9zY3JvbGxUb0l0ZW0odGhpcy5fYWN0aXZlSXRlbSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlSXRlbUluZGV4ID4gLTEgPyAodGhpcy5fc2V0QWN0aXZlSXRlbSgwKSwgdGhpcy5fc2Nyb2xsVG9JdGVtKHRoaXMuX2FjdGl2ZUl0ZW0pKSA6IHRoaXMuX2lucHV0LnNldFNlbGVjdGlvblJhbmdlKDAsIDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRWU6XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVJdGVtSW5kZXggPiAtMSlcbiAgICAgICAgICB0aGlzLl9zZXRBY3RpdmVJdGVtKHRoaXMuaXRlbXMubGVuZ3RoIC0gMSksIHRoaXMuX3Njcm9sbFRvSXRlbSh0aGlzLl9hY3RpdmVJdGVtKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgbiA9IHRoaXMuX2lucHV0LnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLl9pbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShuLCBuKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXQ6XG4gICAgICAgIGlmICh0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA+IC0xKSB7XG4gICAgICAgICAgY29uc3QgbiA9IHRoaXMuX2ZpbHRlcmVkUmVzdWx0c1t0aGlzLl9hY3RpdmVJdGVtSW5kZXhdO1xuICAgICAgICAgIHRoaXMuX2hhbmRsZVNlbGVjdGlvbihuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfc2V0QWN0aXZlSXRlbSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaXRlbXM7XG4gICAgZVt0XSAmJiB0aGlzLl91cGRhdGVBY3RpdmVJdGVtKGVbdF0sIHQpO1xuICB9XG4gIF91cGRhdGVBY3RpdmVJdGVtKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fYWN0aXZlSXRlbTtcbiAgICBpICYmIGkucmVtb3ZlQXR0cmlidXRlKEJvKSwgdC5zZXRBdHRyaWJ1dGUoQm8sIFwiXCIpLCB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPSBlLCB0aGlzLl9hY3RpdmVJdGVtID0gdDtcbiAgfVxuICBfc2Nyb2xsVG9JdGVtKHQpIHtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuaXRlbXNMaXN0LCBpID0gZS5vZmZzZXRIZWlnaHQsIG4gPSB0aGlzLml0ZW1zLmluZGV4T2YodCksIG8gPSB0Lm9mZnNldEhlaWdodCwgciA9IGUuc2Nyb2xsVG9wO1xuICAgIGlmIChuID4gLTEpIHtcbiAgICAgIGNvbnN0IGEgPSBuICogbywgbCA9IGEgKyBvID4gciArIGk7XG4gICAgICBhIDwgciA/IGUuc2Nyb2xsVG9wID0gYSA6IGwgPyBlLnNjcm9sbFRvcCA9IGEgLSBpICsgbyA6IGUuc2Nyb2xsVG9wID0gcjtcbiAgICB9XG4gIH1cbiAgX2hhbmRsZUNsb3NlZEtleWRvd24odCkge1xuICAgIHQua2V5ID09PSBcIkVudGVyXCIgJiYgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGUgPSB0LmtleUNvZGU7XG4gICAgKGUgPT09IGl0IHx8IGUgPT09IHogfHwgZSA9PT0geikgJiYgdGhpcy5vcGVuKCk7XG4gIH1cbiAgb3BlbigpIHtcbiAgICB0aGlzLl9sYXN0UXVlcnlWYWx1ZSA9PT0gbnVsbCAmJiB0aGlzLl9maWx0ZXJSZXN1bHRzKFwiXCIpO1xuICAgIGNvbnN0IHQgPSBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgcEEpO1xuICAgIHRoaXMuX2lzT3BlbiB8fCB0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX3VwZGF0ZURyb3Bkb3duV2lkdGgoKSwgdGhpcy5fbGlzdGVuVG9XaW5kb3dSZXNpemUoKSwgdGhpcy5fcG9wcGVyID0gc2UodGhpcy5fZWxlbWVudCwgdGhpcy5fZHJvcGRvd25Db250YWluZXIsIHtcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAxXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pLCB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZHJvcGRvd25Db250YWluZXIpLCB0aGlzLl9saXN0ZW5Ub091dHNpZGVDbGljaygpLCB0aGlzLl9saXN0ZW5Ub0l0ZW1zQ2xpY2soKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmRyb3Bkb3duLnNldEF0dHJpYnV0ZShyYywgXCJcIiksIHRoaXMuX2lzT3BlbiA9ICEwLCB0aGlzLl9zZXRJbnB1dEFjdGl2ZVN0eWxlcygpLCB0aGlzLl91cGRhdGVJbnB1dFN0YXRlKCk7XG4gICAgfSwgMCkpO1xuICB9XG4gIF9saXN0ZW5Ub091dHNpZGVDbGljaygpIHtcbiAgICBjLm9uKGRvY3VtZW50LCBcImNsaWNrXCIsIHRoaXMuX291dHNpZGVDbGlja0hhbmRsZXIpO1xuICB9XG4gIF9oYW5kbGVPdXRzaWRlQ2xpY2sodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9pbnB1dCA9PT0gdC50YXJnZXQsIGkgPSB0LnRhcmdldCA9PT0gdGhpcy5fZHJvcGRvd25Db250YWluZXIsIG4gPSB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciAmJiB0aGlzLl9kcm9wZG93bkNvbnRhaW5lci5jb250YWlucyh0LnRhcmdldCk7XG4gICAgIWUgJiYgIWkgJiYgIW4gJiYgdGhpcy5jbG9zZSgpO1xuICB9XG4gIF9saXN0ZW5Ub0l0ZW1zQ2xpY2soKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgIFZzLFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJcbiAgICApO1xuICAgIGMub24odCwgXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVJdGVtc0NsaWNrLmJpbmQodGhpcykpO1xuICB9XG4gIF9oYW5kbGVJdGVtc0NsaWNrKHQpIHtcbiAgICBjb25zdCBlID0gZC5jbG9zZXN0KHQudGFyZ2V0LCBhYyksIGkgPSBoLmdldERhdGFBdHRyaWJ1dGUoZSwgXCJpbmRleFwiKSwgbiA9IHRoaXMuX2ZpbHRlcmVkUmVzdWx0c1tpXTtcbiAgICB0aGlzLl9oYW5kbGVTZWxlY3Rpb24obik7XG4gIH1cbiAgX3NlbGVjdEFjdGl2ZUl0ZW0oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2ZpbHRlcmVkUmVzdWx0c1t0aGlzLl9hY3RpdmVJdGVtSW5kZXhdO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5fb3B0aW9ucy5kaXNwbGF5VmFsdWUodCk7XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGxjLCB7XG4gICAgICB2YWx1ZTogdFxuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQgfHwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9jYW5PcGVuT25Gb2N1cyA9ICExLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKGUpLCB0aGlzLl91cGRhdGVJbnB1dFN0YXRlKCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX2hhbmRsZVNlbGVjdGlvbih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX29wdGlvbnMuZGlzcGxheVZhbHVlKHQpLCBpID0gYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGxjLCB7XG4gICAgICB2YWx1ZTogdFxuICAgIH0pO1xuICAgIHQgIT09IHZvaWQgMCAmJiAoaS5kZWZhdWx0UHJldmVudGVkIHx8IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fY2FuT3Blbk9uRm9jdXMgPSAhMSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZShlKSwgdGhpcy5fdXBkYXRlSW5wdXRTdGF0ZSgpLCB0aGlzLl9pbnB1dC5mb2N1cygpLCB0aGlzLmNsb3NlKCk7XG4gICAgfSwgMCkpO1xuICB9XG4gIF91cGRhdGVJbnB1dFZhbHVlKHQpIHtcbiAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHQ7XG4gIH1cbiAgX3NldElucHV0QWN0aXZlU3R5bGVzKCkge1xuICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShvYywgXCJcIik7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdmFyIGU7XG4gICAgY29uc3QgdCA9IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB1QSk7XG4gICAgIXRoaXMuX2lzT3BlbiB8fCB0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX3Jlc2V0QWN0aXZlSXRlbSgpLCB0aGlzLl9yZW1vdmVEcm9wZG93bkV2ZW50cygpLCB0aGlzLmRyb3Bkb3duLnJlbW92ZUF0dHJpYnV0ZShyYyksIGMub24oXG4gICAgICB0aGlzLmRyb3Bkb3duLFxuICAgICAgXCJ0cmFuc2l0aW9uZW5kXCIsXG4gICAgICB0aGlzLl9oYW5kbGVEcm9wZG93blRyYW5zaXRpb25FbmQuYmluZCh0aGlzKVxuICAgICksIHRoaXMuX2lucHV0LnJlbW92ZUF0dHJpYnV0ZShvYyksIHRoaXMuX2lucHV0LnZhbHVlIHx8ICh0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoUGUpLCAoZSA9IHRoaXMuX25vdGNoKSA9PSBudWxsIHx8IGUucmVtb3ZlQXR0cmlidXRlKFBlKSkpO1xuICB9XG4gIF9yZW1vdmVEcm9wZG93bkV2ZW50cygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgVnMsXG4gICAgICB0aGlzLl9kcm9wZG93bkNvbnRhaW5lclxuICAgICk7XG4gICAgYy5vZmYodCwgXCJjbGlja1wiKSwgYy5vZmYoZG9jdW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5fb3V0c2lkZUNsaWNrSGFuZGxlciksIGMub2ZmKHdpbmRvdywgXCJyZXNpemVcIiwgdGhpcy5faGFuZGxlV2luZG93UmVzaXplLmJpbmQodGhpcykpO1xuICB9XG4gIF9oYW5kbGVEcm9wZG93blRyYW5zaXRpb25FbmQodCkge1xuICAgIHRoaXMuX2lzT3BlbiAmJiB0ICYmIHQucHJvcGVydHlOYW1lID09PSBcIm9wYWNpdHlcIiAmJiAodGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgdGhpcy5fZHJvcGRvd25Db250YWluZXIgJiYgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyKSwgdGhpcy5faXNPcGVuID0gITEsIGMub2ZmKHRoaXMuZHJvcGRvd24sIFwidHJhbnNpdGlvbmVuZFwiKSwgdGhpcy5fY2FuT3Blbk9uRm9jdXMgPSAhMCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9pc09wZW4gJiYgdGhpcy5jbG9zZSgpLCB0aGlzLl9yZW1vdmVJbnB1dEFuZEVsZW1lbnRFdmVudHMoKSwgdGhpcy5fZHJvcGRvd25Db250YWluZXIucmVtb3ZlKCksIEEucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBMaSk7XG4gIH1cbiAgX3JlbW92ZUlucHV0QW5kRWxlbWVudEV2ZW50cygpIHtcbiAgICBjLm9mZih0aGlzLl9pbnB1dCwgXCJmb2N1c1wiLCB0aGlzLl9pbnB1dEZvY3VzSGFuZGxlciksIGMub2ZmKHRoaXMuX2lucHV0LCBcImlucHV0XCIsIHRoaXMuX3VzZXJJbnB1dEhhbmRsZXIpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaSA9IEEuZ2V0RGF0YSh0aGlzLCBMaSk7XG4gICAgICBjb25zdCBuID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIWkgJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChpIHx8IChpID0gbmV3IGlkKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIExpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCB2QSA9IChzLCB0KSA9PiBgPGRpdiBjbGFzcz1cIiR7cy5jb25uZWN0Q29udGFpbmVyfVwiICR7dH0+XG4gIDxkaXYgY2xhc3M9XCIke3MuY29ubmVjdH1cIj48L2Rpdj5cbiAgPC9kaXY+YCwgVEEgPSAocywgdCkgPT4gYDxkaXYgY2xhc3M9XCIke3MuaGFuZH1cIiAke3R9PlxuICAgIDxzcGFuPjwvc3Bhbj5cbiAgPC9kaXY+YCwgRUEgPSAocywgdCkgPT4gYFxuICAgIDxzcGFuIGNsYXNzPVwiJHtzLnRvb2x0aXB9XCIgJHt0fT5cbiAgICAgIDxzcGFuIGNsYXNzPVwiJHtzLnRvb2x0aXBWYWx1ZX1cIj48L3NwYW4+XG4gICAgPC9zcGFuPlxuICAgIGAsIHBlID0gKHMpID0+IHMudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIiA/IHMudG91Y2hlc1swXS5jbGllbnRYIDogcy5jbGllbnRYLCBhbiA9IFwibXVsdGlSYW5nZVNsaWRlclwiLCBsbiA9IGB0ZS4ke2FufWAsIENBID0gYC4ke2xufWAsIGNjID0gYHZhbHVlQ2hhbmdlZCR7Q0F9YCwgX2UgPSBcImRhdGEtdGUtYWN0aXZlXCIsIGhjID0gXCJkYXRhLXRlLW11bHRpLXJhbmdlLXNsaWRlci1oYW5kLXJlZlwiLCBkYyA9IFwiZGF0YS10ZS1tdWx0aS1yYW5nZS1zbGlkZXItY29ubmVjdC1yZWZcIiwgdWMgPSBcImRhdGEtdGUtbXVsdGktcmFuZ2Utc2xpZGVyLXRvb2x0aXAtcmVmXCIsIEFBID0ge1xuICBtYXg6IFwibnVtYmVyXCIsXG4gIG1pbjogXCJudW1iZXJcIixcbiAgbnVtYmVyT2ZSYW5nZXM6IFwibnVtYmVyXCIsXG4gIHN0YXJ0VmFsdWVzOiBcIihhcnJheXxzdHJpbmcpXCIsXG4gIHN0ZXA6IFwiKHN0cmluZ3xudWxsfG51bWJlcilcIixcbiAgdG9vbHRpcDogXCJib29sZWFuXCJcbn0sIHlBID0ge1xuICBtYXg6IDEwMCxcbiAgbWluOiAwLFxuICBudW1iZXJPZlJhbmdlczogMixcbiAgc3RhcnRWYWx1ZXM6IFswLCAxMDBdLFxuICBzdGVwOiBudWxsLFxuICB0b29sdGlwOiAhMVxufSwgd0EgPSB7XG4gIGNvbm5lY3Q6IFwiei0xMCBoLWZ1bGwgdy1mdWxsIGJnLVsjZWVlXSB3aWxsLWNoYW5nZS10cmFuc2Zvcm0gZGFyazpiZy1bIzRmNGY0Zl1cIixcbiAgY29ubmVjdENvbnRhaW5lcjogXCJyZWxhdGl2ZSBib3JkZXItWzFweF0gYm9yZGVyLVsjZWVlXSB6LTAgaC1mdWxsIHctZnVsbCBvdmVyZmxvdy1oaWRkZW4gZGFyazpib3JkZXItWyM0ZjRmNGZdXCIsXG4gIGNvbnRhaW5lcjogXCJhcHBlcmFuY2Utbm9uZSByZWxhdGl2ZSBtLWF1dG8gdy1mdWxsIGN1cnNvci1wb2ludGVyIGgtMSBib3JkZXItMCBiZy10cmFuc3BhcmVudCBwLTAgZm9jdXM6b3V0bGluZS1ub25lIGRhcms6Ym9yZGVyLVsjNGY0ZjRmXVwiLFxuICBoYW5kOiBcImFwcGVyYW5jZS1ub25lIGFic29sdXRlIHRvcC1bNTAlXSBib3JkZXItMCAtbXQtMSBoLTQgdy00IGN1cnNvci1wb2ludGVyIHJvdW5kZWQtWzUwJV0gYm9yZGVyLTAgYmctcHJpbWFyeSB0cmFuc2l0aW9uLWNvbG9ycyBlYXNlLWluLW91dCB3aWxsLWNoYW5nZS10cmFuc2Zvcm0gYWN0aXZlOmJnLVsjYzRkNGVmXSBhY3RpdmU6ei02MFwiLFxuICB0b29sdGlwOiBcImFic29sdXRlIC10b3AtWzE4cHhdIG9yaWdpbi1bNTAlXzUwJV0gLXRyYW5zbGF0ZS14LVs2cHhdIC1yb3RhdGUtNDUgc2NhbGUtMCByb3VuZGVkLWJsLW5vbmUgcm91bmRlZC1ici0yeGwgcm91bmRlZC10bC0yeGwgcm91bmRlZC10ci0yeGwgYmctcHJpbWFyeSB0ZXh0LXdoaXRlIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLVsyMDBtc10gZGF0YS1bdGUtYWN0aXZlXTotdG9wLVszOHB4XSBkYXRhLVt0ZS1hY3RpdmVdOnNjYWxlLTEwMFwiLFxuICB0b29sdGlwVmFsdWU6IFwiYmxvY2sgaC1bMzBweF0gdy1bMzBweF0gLXRyYW5zbGF0ZS14LVs2cHhdIHRyYW5zbGF0ZS15LVs2cHhdIHJvdGF0ZS00NSB0ZXh0LWNlbnRlciB0ZXh0LVsxMHB4XVwiXG59LCBrQSA9IHtcbiAgY29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBjb25uZWN0Q29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBjb25uZWN0OiBcInN0cmluZ1wiLFxuICBoYW5kOiBcInN0cmluZ1wiLFxuICB0b29sdGlwOiBcInN0cmluZ1wiLFxuICB0b29sdGlwVmFsdWU6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBzZCBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9tb3VzZW1vdmUgPSAhMSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX21heFRyYW5zbGF0aW9uID0gbnVsbCwgdGhpcy5fbWluVHJhbnNsYXRpb24gPSBudWxsLCB0aGlzLl9jdXJyZW50U3RlcFZhbHVlID0gbnVsbCwgdGhpcy5fY2FuQ2hhbmdlU3RlcCA9ICExLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gYW47XG4gIH1cbiAgZ2V0IGhhbmRzKCkge1xuICAgIHJldHVybiBkLmZpbmQoYFske2hjfV1gLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgY29ubmVjdCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKGBbJHtkY31dYCwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IGxlZnRDb25uZWN0UmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gIH1cbiAgZ2V0IGhhbmRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShgWyR7X2V9XWApO1xuICB9XG4gIGdldCBhY3RpdmVUb29sdGlwVmFsdWUoKSB7XG4gICAgcmV0dXJuIGQuZmluZChgWyR7dWN9XWApLmZpbHRlcihcbiAgICAgIChuKSA9PiBuLmhhc0F0dHJpYnV0ZShfZSlcbiAgICApWzBdLmNoaWxkcmVuWzBdO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX3NldENvbnRhaW5lckNsYXNzZXMoKSwgdGhpcy5fc2V0UmFuZ2VDb25uZWN0c0VsZW1lbnQoKSwgdGhpcy5fc2V0UmFuZ2VIYW5kbGVFbGVtZW50cygpLCB0aGlzLl9zZXRNYXhBbmRNaW5UcmFuc2xhdGlvbigpLCB0aGlzLl9zZXRUcmFuc29mcm1hdGlvbk9uU3RhcnQoKSwgdGhpcy5faGFuZGxlQ2xpY2tFdmVudE9uSGFuZCgpLCB0aGlzLl9oYW5kbGVFbmRNb3ZlRXZlbnREb2N1bWVudCgpLCB0aGlzLl9oYW5kbGVDbGlja09uUmFuZ2UoKSwgdGhpcy5fc2V0VG9vbHRpcFRvSGFuZCgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgQS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIGxuKSwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMuX21vdXNlbW92ZSA9IG51bGwsIHRoaXMuX21heFRyYW5zbGF0aW9uID0gbnVsbCwgdGhpcy5fbWluVHJhbnNsYXRpb24gPSBudWxsLCB0aGlzLl9jdXJyZW50U3RlcFZhbHVlID0gbnVsbCwgdGhpcy5fY2FuQ2hhbmdlU3RlcCA9IG51bGwsIHRoaXMuaGFuZHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgSy5vZmYodCwgXCJtb3VzZWRvd24gdG91Y2hzdGFydFwiKSwgSy5vZmYodCwgXCJtb3VzZXVwIHRvdWNoZW5kXCIpO1xuICAgIH0pLCBLLm9mZihkb2N1bWVudCwgXCJtb3VzZW1vdmUgdG91Y2htb3ZlXCIpLCBLLm9mZihkb2N1bWVudCwgXCJtb3VzZXVwIHRvdWNoZW5kXCIpLCBLLm9mZih0aGlzLmNvbm5lY3QsIFwibW91c2Vkb3duIHRvdWNoc3RhcnRcIik7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfc2V0TWF4QW5kTWluVHJhbnNsYXRpb24oKSB7XG4gICAgdGhpcy5fbWF4VHJhbnNsYXRpb24gPSB0aGlzLmNvbm5lY3Qub2Zmc2V0V2lkdGggLSB0aGlzLmhhbmRzWzBdLm9mZnNldFdpZHRoIC8gMiwgdGhpcy5fbWluVHJhbnNsYXRpb24gPSB0aGlzLmNvbm5lY3Qub2Zmc2V0TGVmdCAtIHRoaXMuaGFuZHNbMF0ub2Zmc2V0V2lkdGggLyAyO1xuICB9XG4gIF9zZXRUcmFuc29mcm1hdGlvbk9uU3RhcnQoKSB7XG4gICAgY29uc3QgeyBtYXg6IHQsIG1pbjogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBsZXQgeyBzdGFydFZhbHVlczogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICB0eXBlb2YgaSA9PSBcInN0cmluZ1wiICYmIChpID0gSlNPTi5wYXJzZShpLnJlcGxhY2UoLycvZywgJ1wiJykpKSwgaS5sZW5ndGggPT09IDAgPyB0aGlzLmhhbmRzLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGguc2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgICAgbixcbiAgICAgICAgXCJ0cmFuc2xhdGlvblwiLFxuICAgICAgICBNYXRoLnJvdW5kKHRoaXMuX21pblRyYW5zbGF0aW9uKVxuICAgICAgKSwgaC5hZGRTdHlsZShuLCB7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3RoaXMuX21pblRyYW5zbGF0aW9ufXB4LC0yNSUpYFxuICAgICAgfSk7XG4gICAgfSkgOiB0aGlzLmhhbmRzLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIGlmIChpW29dID4gdCB8fCBpW29dIDwgZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGlbb10gPT09IHZvaWQgMCkge1xuICAgICAgICBoLnNldERhdGFBdHRyaWJ1dGUoXG4gICAgICAgICAgbixcbiAgICAgICAgICBcInRyYW5zbGF0aW9uXCIsXG4gICAgICAgICAgTWF0aC5yb3VuZCh0aGlzLl9tYXhUcmFuc2xhdGlvbilcbiAgICAgICAgKSwgaC5hZGRTdHlsZShuLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7dGhpcy5fbWF4VHJhbnNsYXRpb259cHgsLTI1JSlgLFxuICAgICAgICAgIHpJbmRleDogdGhpcy5oYW5kcy5sZW5ndGggLSBvXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhID0gKGlbb10gLSBlKSAvICh0IC0gZSkgKiB0aGlzLmNvbm5lY3Qub2Zmc2V0V2lkdGggLSBuLm9mZnNldFdpZHRoIC8gMjtcbiAgICAgIGguc2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgICAgbixcbiAgICAgICAgXCJ0cmFuc2xhdGlvblwiLFxuICAgICAgICBNYXRoLnJvdW5kKGEpXG4gICAgICApLCBoLmFkZFN0eWxlKG4sIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7YX1weCwtMjUlKWAsXG4gICAgICAgIHpJbmRleDogdGhpcy5oYW5kcy5sZW5ndGggLSBvXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlT3V0T2ZNYXhSYW5nZVZhbHVlKHQsIGUpIHtcbiAgICB0aGlzLl91cGRhdGVIYW5kKHQsIHRoaXMuX21heFRyYW5zbGF0aW9uKSwgdGhpcy5fb3B0aW9ucy50b29sdGlwICYmICh0aGlzLmFjdGl2ZVRvb2x0aXBWYWx1ZS5pbm5lclRleHQgPSBlKTtcbiAgfVxuICBfaGFuZGxlT3V0T2ZNaW5SYW5nZVZhbHVlKHQsIGUpIHtcbiAgICB0aGlzLl91cGRhdGVIYW5kKHQsIHRoaXMuX21pblRyYW5zbGF0aW9uKSwgdGhpcy5fb3B0aW9ucy50b29sdGlwICYmICh0aGlzLmFjdGl2ZVRvb2x0aXBWYWx1ZS5pbm5lclRleHQgPSBlKTtcbiAgfVxuICBfaGFuZGxlTm9ybWFsTW92ZSh0LCBlLCBpKSB7XG4gICAgdGhpcy5fdXBkYXRlSGFuZCh0LCBlKSwgdGhpcy5fb3B0aW9ucy50b29sdGlwICYmICh0aGlzLmFjdGl2ZVRvb2x0aXBWYWx1ZS5pbm5lclRleHQgPSBNYXRoLnJvdW5kKGkpKTtcbiAgfVxuICBfaGFuZGxlQ2xpY2tFdmVudE9uSGFuZCgpIHtcbiAgICBjb25zdCB7IG1heDogdCwgbWluOiBlLCBzdGVwOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHRoaXMuaGFuZHMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgSy5vbihuLCBcIm1vdXNlZG93biB0b3VjaHN0YXJ0XCIsIChvKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9tb3VzZW1vdmUgPSAhMCwgbi5zZXRBdHRyaWJ1dGUoX2UsIFwiXCIpLCB0aGlzLl9vcHRpb25zLnRvb2x0aXAgJiYgbi5jaGlsZHJlblsxXS5zZXRBdHRyaWJ1dGUoX2UsIFwiXCIpLCB0aGlzLl9oYW5kbGVNb3ZlRXZlbnQobiksIHRoaXMuX2hhbmRsZUVuZE1vdmVFdmVudChuLCBvKSwgIXRoaXMuX2NhbkNoYW5nZVN0ZXAgJiYgaSAhPT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHIgPSBwZShvKSAtIHRoaXMubGVmdENvbm5lY3RSZWN0IC0gbi5vZmZzZXRXaWR0aCAvIDIsIGEgPSAocGUobykgLSB0aGlzLmxlZnRDb25uZWN0UmVjdCkgLyAodGhpcy5jb25uZWN0Lm9mZnNldFdpZHRoIC8gKHQgLSBlKSkgJSAodCAtIGUpO1xuICAgICAgICByID49IHRoaXMuX21heFRyYW5zbGF0aW9uID8gdGhpcy5faGFuZGxlT3V0T2ZNYXhSYW5nZVZhbHVlKG4sIHQpIDogciA8PSB0aGlzLl9taW5UcmFuc2xhdGlvbiA/IHRoaXMuX2hhbmRsZU91dE9mTWluUmFuZ2VWYWx1ZShuLCBlKSA6IHRoaXMuX2hhbmRsZU5vcm1hbE1vdmUobiwgciwgYSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfc2V0Q29udGFpbmVyQ2xhc3NlcygpIHtcbiAgICBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuY29udGFpbmVyKTtcbiAgfVxuICBfc2V0UmFuZ2VDb25uZWN0c0VsZW1lbnQoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5pbnNlcnRBZGphY2VudEhUTUwoXG4gICAgICBcImFmdGVyYmVnaW5cIixcbiAgICAgIHZBKFxuICAgICAgICB7XG4gICAgICAgICAgY29ubmVjdENvbnRhaW5lcjogdGhpcy5fY2xhc3Nlcy5jb25uZWN0Q29udGFpbmVyLFxuICAgICAgICAgIGNvbm5lY3Q6IHRoaXMuX2NsYXNzZXMuY29ubmVjdFxuICAgICAgICB9LFxuICAgICAgICBkY1xuICAgICAgKVxuICAgICk7XG4gIH1cbiAgX3NldFJhbmdlSGFuZGxlRWxlbWVudHMoKSB7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLl9vcHRpb25zLm51bWJlck9mUmFuZ2VzOyB0KyspXG4gICAgICB0aGlzLl9lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcbiAgICAgICAgXCJiZWZvcmVlbmRcIixcbiAgICAgICAgVEEoeyBoYW5kOiB0aGlzLl9jbGFzc2VzLmhhbmQgfSwgaGMpXG4gICAgICApO1xuICAgIHRoaXMuaGFuZHMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIFwiaG9yaXpvbnRhbFwiKSwgdC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic2xpZGVyXCIpLCBoLnNldERhdGFBdHRyaWJ1dGUodCwgXCJoYW5kbGVcIiwgZSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldFRvb2x0aXBUb0hhbmQoKSB7XG4gICAgdGhpcy5fb3B0aW9ucy50b29sdGlwICYmIHRoaXMuaGFuZHMuZm9yRWFjaCgodCkgPT4gdC5pbnNlcnRBZGphY2VudEhUTUwoXG4gICAgICBcImJlZm9yZWVuZFwiLFxuICAgICAgRUEoXG4gICAgICAgIHtcbiAgICAgICAgICB0b29sdGlwOiB0aGlzLl9jbGFzc2VzLnRvb2x0aXAsXG4gICAgICAgICAgdG9vbHRpcFZhbHVlOiB0aGlzLl9jbGFzc2VzLnRvb2x0aXBWYWx1ZVxuICAgICAgICB9LFxuICAgICAgICB1Y1xuICAgICAgKVxuICAgICkpO1xuICB9XG4gIF9oYW5kbGVNb3ZlRXZlbnQodCkge1xuICAgIGNvbnN0IHsgdG9vbHRpcDogZSwgc3RlcDogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBLLm9uKGRvY3VtZW50LCBcIm1vdXNlbW92ZSB0b3VjaG1vdmVcIiwgKG4pID0+IHtcbiAgICAgIG4udHlwZSA9PT0gXCJtb3VzZW1vdmVcIiAmJiBuLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCB7IG1heDogbywgbWluOiByLCBudW1iZXJPZlJhbmdlczogYSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgIGlmICh0Lmhhc0F0dHJpYnV0ZShfZSkpIHtcbiAgICAgICAgY29uc3QgbCA9IChwZShuKSAtIHRoaXMubGVmdENvbm5lY3RSZWN0KSAvIHRoaXMuY29ubmVjdC5vZmZzZXRXaWR0aCAqIG87XG4gICAgICAgIGxldCBwID0gKHBlKG4pIC0gdGhpcy5sZWZ0Q29ubmVjdFJlY3QpIC8gKHRoaXMuY29ubmVjdC5vZmZzZXRXaWR0aCAvIChvIC0gcikpICUgKG8gLSByKSArIHI7XG4gICAgICAgIGlmICgodGhpcy5fY3VycmVudFN0ZXBWYWx1ZSA9PT0gTWF0aC5yb3VuZChwKSB8fCBNYXRoLnJvdW5kKHApICUgaSAhPT0gMCkgJiYgaSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX2NhbkNoYW5nZVN0ZXAgPSAhMTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FuQ2hhbmdlU3RlcCA9ICEwO1xuICAgICAgICBsZXQgdSA9IHBlKG4pIC0gdGhpcy5sZWZ0Q29ubmVjdFJlY3QgLSB0Lm9mZnNldFdpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgXyA9IGguZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgICAgICB0aGlzLmhhbmRBY3RpdmUsXG4gICAgICAgICAgXCJoYW5kbGVcIlxuICAgICAgICApLCBmID0gaC5nZXREYXRhQXR0cmlidXRlKFxuICAgICAgICAgIHRoaXMuaGFuZEFjdGl2ZSxcbiAgICAgICAgICBcInRyYW5zbGF0aW9uXCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHAgPCByKVxuICAgICAgICAgIHUgPSByIC0gdC5vZmZzZXRXaWR0aCAvIDIsIHAgPSByO1xuICAgICAgICBlbHNlIGlmIChsID49IG8pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBnID0gdGhpcy5oYW5kcy5tYXAoXG4gICAgICAgICAgKG0pID0+IGguZ2V0RGF0YUF0dHJpYnV0ZShtLCBcInRyYW5zbGF0aW9uXCIpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChhIDwgMilcbiAgICAgICAgICBNYXRoLnJvdW5kKHApICUgaSA9PT0gMCAmJiBpICE9PSBudWxsID8gKHRoaXMuX2N1cnJlbnRTdGVwVmFsdWUgPSBNYXRoLnJvdW5kKHApLCBoLmFkZFN0eWxlKHQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3V9cHgsLTI1JSlgXG4gICAgICAgICAgfSksIGUgJiYgKHRoaXMuYWN0aXZlVG9vbHRpcFZhbHVlLmlubmVyVGV4dCA9IE1hdGgucm91bmQocCkpKSA6IGkgPT09IG51bGwgJiYgKGguYWRkU3R5bGUodCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7dX1weCwtMjUlKWBcbiAgICAgICAgICB9KSwgZSAmJiAodGhpcy5hY3RpdmVUb29sdGlwVmFsdWUuaW5uZXJUZXh0ID0gTWF0aC5yb3VuZChwKSkpLCBoLnNldERhdGFBdHRyaWJ1dGUodCwgXCJ0cmFuc2xhdGlvblwiLCB1KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgbSA9IF8gPiAwICYmIF8gPCBhIC0gMTtcbiAgICAgICAgICBsZXQgYiA9IHUsIHYgPSAhMTtcbiAgICAgICAgICBjb25zdCBUID0gZ1tfICsgMV0sIHkgPSBnW18gLSAxXTtcbiAgICAgICAgICBfID09PSAwICYmIGYgPj0gVCA/IChiID0gVCwgdiA9IHUgPD0gYikgOiBfID09PSBhIC0gMSAmJiBmIDw9IHkgPyAoYiA9IHksIHYgPSB1ID49IGIpIDogbSAmJiAoZiA+PSBUIHx8IGYgPD0geSkgJiYgKGIgPSBmID49IFQgPyBUIDogeSwgdiA9IGIgPT09IFQgPyB1IDw9IGIgOiB1ID49IGIpLCBNYXRoLnJvdW5kKHApICUgaSA9PT0gMCAmJiBpICE9PSBudWxsID8gKHRoaXMuX2N1cnJlbnRTdGVwVmFsdWUgPSBNYXRoLnJvdW5kKHApLCBoLmFkZFN0eWxlKHQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke2J9cHgsLTI1JSlgXG4gICAgICAgICAgfSksIGUgJiYgYiA9PT0gdSAmJiB0aGlzLmFjdGl2ZVRvb2x0aXBWYWx1ZSAhPT0gbnVsbCAmJiAodGhpcy5hY3RpdmVUb29sdGlwVmFsdWUuaW5uZXJUZXh0ID0gTWF0aC5yb3VuZChwKSkpIDogaSA9PT0gbnVsbCAmJiAoaC5hZGRTdHlsZSh0LCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtifXB4LC0yNSUpYFxuICAgICAgICAgIH0pLCBlICYmIGIgPT09IHUgJiYgdGhpcy5hY3RpdmVUb29sdGlwVmFsdWUgIT09IG51bGwgJiYgKHRoaXMuYWN0aXZlVG9vbHRpcFZhbHVlLmlubmVyVGV4dCA9IE1hdGgucm91bmQocCkpKSwgaC5zZXREYXRhQXR0cmlidXRlKFxuICAgICAgICAgICAgdCxcbiAgICAgICAgICAgIFwidHJhbnNsYXRpb25cIixcbiAgICAgICAgICAgIHYgPyB1IDogYlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FuQ2hhbmdlU3RlcCAmJiB0aGlzLl9oYW5kbGVFdmVudENoYW5nZVZhbHVlc09uUmFuZ2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlRXZlbnRDaGFuZ2VWYWx1ZXNPblJhbmdlKCkge1xuICAgIGNvbnN0IHsgbWF4OiB0LCBtaW46IGUsIG51bWJlck9mUmFuZ2VzOiBpIH0gPSB0aGlzLl9vcHRpb25zLCBuID0gKHIpID0+IHtcbiAgICAgIGNvbnN0IGEgPSByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSB0aGlzLmxlZnRDb25uZWN0UmVjdCArIHIub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgbGV0IGwgPSBhIC8gKHRoaXMuY29ubmVjdC5vZmZzZXRXaWR0aCAvICh0IC0gZSkpICUgKHQgLSBlKTtcbiAgICAgIHJldHVybiBhID09PSB0aGlzLmNvbm5lY3Qub2Zmc2V0V2lkdGggPyBsID0gdCA6IGwgKz0gZSwgaC5zZXREYXRhQXR0cmlidXRlKHIsIFwidmFsdWVcIiwgTWF0aC5yb3VuZChsICogMTApIC8gMTApLCB7IHZhbHVlOiBsIH07XG4gICAgfTtcbiAgICBpZiAoaSA8IDIpIHtcbiAgICAgIGNvbnN0IHsgdmFsdWU6IHIgfSA9IG4odGhpcy5oYW5kc1swXSk7XG4gICAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgY2MsIHtcbiAgICAgICAgdmFsdWVzOiB7IHZhbHVlOiByICsgZSwgcm91bmRlZDogTWF0aC5yb3VuZChyICsgZSkgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG8gPSB0aGlzLmhhbmRzLm1hcCgocikgPT4gbihyKSk7XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGNjLCB7XG4gICAgICB2YWx1ZXM6IHtcbiAgICAgICAgdmFsdWU6IG8ubWFwKCh7IHZhbHVlOiByIH0pID0+IHIgKyBlKSxcbiAgICAgICAgcm91bmRlZDogby5tYXAoKHsgdmFsdWU6IHIgfSkgPT4gTWF0aC5yb3VuZChyICsgZSkpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3Jlc2V0SGFuZFN0YXRlKHQsIGUpIHtcbiAgICBjLm9mZih0LCBlKSwgdC5yZW1vdmVBdHRyaWJ1dGUoX2UpLCB0aGlzLl9vcHRpb25zLnRvb2x0aXAgJiYgdC5jaGlsZHJlblsxXS5yZW1vdmVBdHRyaWJ1dGUoX2UpO1xuICB9XG4gIF9oYW5kbGVFbmRNb3ZlRXZlbnREb2N1bWVudCgpIHtcbiAgICBLLm9uKGRvY3VtZW50LCBcIm1vdXNldXAgdG91Y2hlbmRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fbW91c2Vtb3ZlICYmICh0aGlzLmhhbmRzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgdGhpcy5fcmVzZXRIYW5kU3RhdGUodCwgXCJtb3VzZW1vdmVcIik7XG4gICAgICB9KSwgSy5vZmYoZG9jdW1lbnQsIFwibW91c2Vtb3ZlIHRvdWNobW92ZVwiKSwgdGhpcy5fbW91c2Vtb3ZlID0gITEpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVFbmRNb3ZlRXZlbnQodCkge1xuICAgIEsub24odCwgXCJtb3VzZXVwIHRvdWNoZW5kXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3Jlc2V0SGFuZFN0YXRlKHQsIFwibW91c2Vtb3ZlXCIpLCBLLm9mZihkb2N1bWVudCwgXCJtb3VzZW1vdmUgdG91Y2htb3ZlXCIpLCB0aGlzLl9tb3VzZW1vdmUgPSAhMTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQ2xpY2tPblJhbmdlKCkge1xuICAgIHRoaXMuX29wdGlvbnMuc3RlcCA9PT0gbnVsbCAmJiBLLm9uKHRoaXMuY29ubmVjdCwgXCJtb3VzZWRvd24gdG91Y2hzdGFydFwiLCAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IFtdO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgaWYgKHRoaXMuaGFuZHMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICB0aGlzLl9tb3VzZW1vdmUgPSAhMDtcbiAgICAgICAgY29uc3QgbyA9IHBlKHQpLCByID0gbi5vZmZzZXRXaWR0aCwgYSA9IGguZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgICAgICBuLFxuICAgICAgICAgIFwidHJhbnNsYXRpb25cIlxuICAgICAgICApLCBsID0gbyAtIHRoaXMubGVmdENvbm5lY3RSZWN0IC0gciAvIDI7XG4gICAgICAgIHRoaXMuX29wdGlvbnMubnVtYmVyT2ZSYW5nZXMgPCAyID8gdGhpcy5fdXBkYXRlSGFuZChuLCBsKSA6IChlLnB1c2goTWF0aC5hYnMobCAtIGEpKSwgZS5mb3JFYWNoKChwLCB1KSA9PiB7XG4gICAgICAgICAgcCA8IGVbaV0gJiYgKGkgPSB1KTtcbiAgICAgICAgfSkpO1xuICAgICAgfSksIHRoaXMuX29wdGlvbnMubnVtYmVyT2ZSYW5nZXMgPj0gMikge1xuICAgICAgICBjb25zdCBuID0gcGUodCkgLSB0aGlzLmxlZnRDb25uZWN0UmVjdCAtIHRoaXMuaGFuZHNbaV0ub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICB0aGlzLl91cGRhdGVBZGphY2VudEhhbmRzKGksIG4pO1xuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlRXZlbnRDaGFuZ2VWYWx1ZXNPblJhbmdlKCk7XG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZUhhbmQodCwgZSkge1xuICAgIGguYWRkU3R5bGUodCwge1xuICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7ZX1weCwtMjUlKWBcbiAgICB9KSwgaC5zZXREYXRhQXR0cmlidXRlKHQsIFwidHJhbnNsYXRpb25cIiwgZSk7XG4gIH1cbiAgX3VwZGF0ZUFkamFjZW50SGFuZHModCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLmhhbmRzW3QgKyAxXSwgbiA9IHRoaXMuaGFuZHNbdCAtIDFdLCBvID0gaSA/IGguZ2V0RGF0YUF0dHJpYnV0ZShpLCBcInRyYW5zbGF0aW9uXCIpIDogdm9pZCAwLCByID0gbiA/IGguZ2V0RGF0YUF0dHJpYnV0ZShuLCBcInRyYW5zbGF0aW9uXCIpIDogdm9pZCAwO1xuICAgIGkgJiYgZSA+IG8gPyB0aGlzLl91cGRhdGVIYW5kKGksIGUpIDogbiAmJiBlIDwgciA/IHRoaXMuX3VwZGF0ZUhhbmQobiwgZSkgOiB0aGlzLl91cGRhdGVIYW5kKHRoaXMuaGFuZHNbdF0sIGUpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi55QSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gSShhbiwgZSwgQUEpLCBlO1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ud0EsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEkoYW4sIHQsIGtBKSwgdDtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSBBLmdldERhdGEodGhpcywgbG4pO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlfGhpZGUvLnRlc3QodCkpICYmIChpIHx8IChpID0gbmV3IHNkKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4gQS5nZXREYXRhKHQsIGxuKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCB4QSA9IChzKSA9PiB7XG4gIGdjKCgpID0+IHtcbiAgICBjb25zdCB0ID0gbWMoKTtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgZSA9IHMuTkFNRSwgaSA9IHQuZm5bZV07XG4gICAgICB0LmZuW2VdID0gcy5qUXVlcnlJbnRlcmZhY2UsIHQuZm5bZV0uQ29uc3RydWN0b3IgPSBzLCB0LmZuW2VdLm5vQ29uZmxpY3QgPSAoKSA9PiAodC5mbltlXSA9IGksIHMualF1ZXJ5SW50ZXJmYWNlKTtcbiAgICB9XG4gIH0pO1xufSwgT0EgPSAocywgdCkgPT4ge1xuICBjLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX1gLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCBzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykudG9nZ2xlKCk7XG4gICAgfVxuICApO1xufSwgU0EgPSAocywgdCkgPT4ge1xuICBjLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX0uZGF0YS1hcGlgLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKFtcIkFcIiwgXCJBUkVBXCJdLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkgJiYgZS5wcmV2ZW50RGVmYXVsdCgpLCBiZSh0aGlzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcy5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnNob3coKTtcbiAgICB9XG4gICk7XG59LCBJQSA9IChzLCB0KSA9PiB7XG4gIGMub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfS5kYXRhLWFwaWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBjb25zdCBpID0gdGUodGhpcyk7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBlLnByZXZlbnREZWZhdWx0KCksIGJlKHRoaXMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjLm9uZShpLCBzLkVWRU5UX0hJRERFTiwgKCkgPT4ge1xuICAgICAgICBNdCh0aGlzKSAmJiB0aGlzLmZvY3VzKCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG4gPSBkLmZpbmRPbmUocy5PUEVOX1NFTEVDVE9SKTtcbiAgICAgIG4gJiYgbiAhPT0gaSAmJiBzLmdldEluc3RhbmNlKG4pLmhpZGUoKSwgcy5nZXRPckNyZWF0ZUluc3RhbmNlKGkpLnRvZ2dsZSh0aGlzKTtcbiAgICB9XG4gICk7XG59LCBEQSA9IChzLCB0KSA9PiB7XG4gIGMub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfWAsXG4gICAgdCxcbiAgICAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgaSA9IGUudGFyZ2V0LmNsb3Nlc3QodCk7XG4gICAgICBzLmdldE9yQ3JlYXRlSW5zdGFuY2UoaSkudG9nZ2xlKCk7XG4gICAgfVxuICApO1xufSwgJEEgPSAocywgdCkgPT4ge1xuICBjLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX1gLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgY29uc3QgaSA9IHRlKHRoaXMpO1xuICAgICAgW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBlLnByZXZlbnREZWZhdWx0KCksIGMub25lKGksIHMuRVZFTlRfU0hPVywgKHIpID0+IHtcbiAgICAgICAgci5kZWZhdWx0UHJldmVudGVkIHx8IGMub25lKGksIHMuRVZFTlRfSElEREVOLCAoKSA9PiB7XG4gICAgICAgICAgTXQodGhpcykgJiYgdGhpcy5mb2N1cygpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbiA9IGQuZmluZE9uZShcbiAgICAgICAgYFske3MuT1BFTl9TRUxFQ1RPUn09XCJ0cnVlXCJdYFxuICAgICAgKTtcbiAgICAgIG4gJiYgcy5nZXRJbnN0YW5jZShuKS5oaWRlKCksIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZShpKS50b2dnbGUodGhpcyk7XG4gICAgfVxuICApO1xufSwgTEEgPSAocywgdCkgPT4ge1xuICBjLm9uZShcbiAgICBkb2N1bWVudCxcbiAgICBcIm1vdXNlZG93blwiLFxuICAgIHQsXG4gICAgcy5hdXRvSW5pdGlhbChuZXcgcygpKVxuICApO1xufSwgTkEgPSAocywgdCkgPT4ge1xuICBjLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX0uZGF0YS1hcGlgLFxuICAgIHQsXG4gICAgZnVuY3Rpb24oZSkge1xuICAgICAgKGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiQVwiIHx8IGUuZGVsZWdhdGVUYXJnZXQgJiYgZS5kZWxlZ2F0ZVRhcmdldC50YWdOYW1lID09PSBcIkFcIikgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgaSA9IGxyKHRoaXMpO1xuICAgICAgZC5maW5kKGkpLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgcy5nZXRPckNyZWF0ZUluc3RhbmNlKG8sIHsgdG9nZ2xlOiAhMSB9KS50b2dnbGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbn0sIE1BID0gKHMsIHQpID0+IHtcbiAgW10uc2xpY2UuY2FsbChcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHQpXG4gICkubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gbmV3IHMoaSk7XG4gIH0pO1xufSwgUkEgPSAocywgdCkgPT4ge1xuICBbXS5zbGljZS5jYWxsKFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodClcbiAgKS5tYXAoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBuZXcgcyhpKTtcbiAgfSk7XG59LCBQQSA9IChzLCB0KSA9PiB7XG4gIGQuZmluZCh0KS5mb3JFYWNoKChlKSA9PiB7XG4gICAgbmV3IHMoZSk7XG4gIH0pLCBjLm9uKFxuICAgIGRvY3VtZW50LFxuICAgIGBjbGljay50ZS4ke3MuTkFNRX0uZGF0YS1hcGlgLFxuICAgIGAke3R9IGltZzpub3QoW2RhdGEtdGUtbGlnaHRib3gtZGlzYWJsZWRdKWAsXG4gICAgcy50b2dnbGUoKVxuICApO1xufSwgQkEgPSAocywgdCkgPT4ge1xuICBjb25zdCBlID0gKG8pID0+IG9bMF0gPT09IFwie1wiICYmIG9bby5sZW5ndGggLSAxXSA9PT0gXCJ9XCIgfHwgb1swXSA9PT0gXCJbXCIgJiYgb1tvLmxlbmd0aCAtIDFdID09PSBcIl1cIiwgaSA9IChvKSA9PiB0eXBlb2YgbyAhPSBcInN0cmluZ1wiID8gbyA6IGUobykgPyBKU09OLnBhcnNlKG8ucmVwbGFjZSgvJy9nLCAnXCInKSkgOiBvLCBuID0gKG8pID0+IHtcbiAgICBjb25zdCByID0ge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGlmIChhLm1hdGNoKC9kYXRhc2V0LiovKSkge1xuICAgICAgICBjb25zdCBsID0gYS5zbGljZSg3LCA4KS50b0xvd2VyQ2FzZSgpLmNvbmNhdChhLnNsaWNlKDgpKTtcbiAgICAgICAgcltsXSA9IGkob1thXSk7XG4gICAgICB9XG4gICAgfSksIHI7XG4gIH07XG4gIGQuZmluZCh0KS5mb3JFYWNoKChvKSA9PiB7XG4gICAgaWYgKGguZ2V0RGF0YUF0dHJpYnV0ZShvLCBcImNoYXJ0XCIpICE9PSBcImJ1YmJsZVwiICYmIGguZ2V0RGF0YUF0dHJpYnV0ZShvLCBcImNoYXJ0XCIpICE9PSBcInNjYXR0ZXJcIikge1xuICAgICAgY29uc3QgciA9IGguZ2V0RGF0YUF0dHJpYnV0ZXMobyksIGEgPSB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkYXRhc2V0czogW24ocildXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gci5jaGFydCAmJiAoYS50eXBlID0gci5jaGFydCksIHIubGFiZWxzICYmIChhLmRhdGEubGFiZWxzID0gSlNPTi5wYXJzZShyLmxhYmVscy5yZXBsYWNlKC8nL2csICdcIicpKSksIG5ldyBzKG8sIHtcbiAgICAgICAgLi4uYSxcbiAgICAgICAgLi4ud2lbYS50eXBlXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbn07XG5jbGFzcyBIQSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdHMgPSBbXTtcbiAgfVxuICBnZXQgaW5pdGlhbGl6ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdHM7XG4gIH1cbiAgaXNJbml0ZWQodCkge1xuICAgIHJldHVybiB0aGlzLmluaXRzLmluY2x1ZGVzKHQpO1xuICB9XG4gIGFkZCh0KSB7XG4gICAgdGhpcy5pc0luaXRlZCh0KSB8fCB0aGlzLmluaXRzLnB1c2godCk7XG4gIH1cbn1cbmNvbnN0IGFyID0gbmV3IEhBKCksIE5pID0ge1xuICBhbGVydDoge1xuICAgIG5hbWU6IFwiQWxlcnRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1hbGVydC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgYW5pbWF0aW9uOiB7XG4gICAgbmFtZTogXCJBbmltYXRlXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtYW5pbWF0aW9uLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBjYXJvdXNlbDoge1xuICAgIG5hbWU6IFwiQ2Fyb3VzZWxcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jYXJvdXNlbC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgY2hpcHM6IHtcbiAgICBuYW1lOiBcIkNoaXBzSW5wdXRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jaGlwcy1pbnB1dC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgY2hpcDoge1xuICAgIG5hbWU6IFwiQ2hpcFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNoaXAtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExLFxuICAgIG9uSW5pdDogXCJpbml0XCJcbiAgfSxcbiAgZGF0ZXBpY2tlcjoge1xuICAgIG5hbWU6IFwiRGF0ZXBpY2tlclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWRhdGVwaWNrZXItaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGRhdGV0aW1lcGlja2VyOiB7XG4gICAgbmFtZTogXCJEYXRldGltZXBpY2tlclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWRhdGUtdGltZXBpY2tlci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgaW5wdXQ6IHtcbiAgICBuYW1lOiBcIklucHV0XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtaW5wdXQtd3JhcHBlci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgcGVyZmVjdFNjcm9sbGJhcjoge1xuICAgIG5hbWU6IFwiUGVyZmVjdFNjcm9sbGJhclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXBlcmZlY3Qtc2Nyb2xsYmFyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICByYXRpbmc6IHtcbiAgICBuYW1lOiBcIlJhdGluZ1wiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXJhdGluZy1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgc2Nyb2xsc3B5OiB7XG4gICAgbmFtZTogXCJTY3JvbGxTcHlcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1zcHk9J3Njcm9sbCddXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBzZWxlY3Q6IHtcbiAgICBuYW1lOiBcIlNlbGVjdFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXNlbGVjdC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgc2lkZW5hdjoge1xuICAgIG5hbWU6IFwiU2lkZW5hdlwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXNpZGVuYXYtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHN0ZXBwZXI6IHtcbiAgICBuYW1lOiBcIlN0ZXBwZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1zdGVwcGVyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICB0aW1lcGlja2VyOiB7XG4gICAgbmFtZTogXCJUaW1lcGlja2VyXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdGltZXBpY2tlci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgdG9hc3Q6IHtcbiAgICBuYW1lOiBcIlRvYXN0XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9hc3QtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGRhdGF0YWJsZToge1xuICAgIG5hbWU6IFwiRGF0YXRhYmxlXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtZGF0YXRhYmxlLWluaXRdXCJcbiAgfSxcbiAgcG9wY29uZmlybToge1xuICAgIG5hbWU6IFwiUG9wY29uZmlybVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvZ2dsZT0ncG9wY29uZmlybSddXCJcbiAgfSxcbiAgdmFsaWRhdGlvbjoge1xuICAgIG5hbWU6IFwiVmFsaWRhdGlvblwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXZhbGlkYXRpb24taW5pdF1cIlxuICB9LFxuICBzbW9vdGhTY3JvbGw6IHtcbiAgICBuYW1lOiBcIlNtb290aFNjcm9sbFwiLFxuICAgIHNlbGVjdG9yOiBcImFbZGF0YS10ZS1zbW9vdGgtc2Nyb2xsLWluaXRdXCJcbiAgfSxcbiAgbGF6eUxvYWQ6IHtcbiAgICBuYW1lOiBcIkxhenlMb2FkXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtbGF6eS1sb2FkLWluaXRdXCJcbiAgfSxcbiAgY2xpcGJvYXJkOiB7XG4gICAgbmFtZTogXCJDbGlwYm9hcmRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jbGlwYm9hcmQtaW5pdF1cIlxuICB9LFxuICBpbmZpbml0ZVNjcm9sbDoge1xuICAgIG5hbWU6IFwiSW5maW5pdGVTY3JvbGxcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1pbmZpbml0ZS1zY3JvbGwtaW5pdF1cIlxuICB9LFxuICBsb2FkaW5nTWFuYWdlbWVudDoge1xuICAgIG5hbWU6IFwiTG9hZGluZ01hbmFnZW1lbnRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1sb2FkaW5nLW1hbmFnZW1lbnQtaW5pdF1cIlxuICB9LFxuICBzdGlja3k6IHtcbiAgICBuYW1lOiBcIlN0aWNreVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXN0aWNreS1pbml0XVwiXG4gIH0sXG4gIG11bHRpUmFuZ2VTbGlkZXI6IHtcbiAgICBuYW1lOiBcIk11bHRpUmFuZ2VTbGlkZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1tdWx0aS1yYW5nZS1zbGlkZXItaW5pdF1cIlxuICB9LFxuICAvLyBhZHZhbmNlZEluaXRzXG4gIGNoYXJ0OiB7XG4gICAgbmFtZTogXCJDaGFydFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNoYXJ0XVwiLFxuICAgIGlzVG9nZ2xlcjogITEsXG4gICAgYWR2YW5jZWQ6IEJBXG4gIH0sXG4gIC8vIHRvZ2dsZXJzXG4gIGJ1dHRvbjoge1xuICAgIG5hbWU6IFwiQnV0dG9uXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSdidXR0b24nXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IERBXG4gIH0sXG4gIGNvbGxhcHNlOiB7XG4gICAgbmFtZTogXCJDb2xsYXBzZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNvbGxhcHNlLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogTkFcbiAgfSxcbiAgZHJvcGRvd246IHtcbiAgICBuYW1lOiBcIkRyb3Bkb3duXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtZHJvcGRvd24tdG9nZ2xlLXJlZl1cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBPQVxuICB9LFxuICBtb2RhbDoge1xuICAgIG5hbWU6IFwiTW9kYWxcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J21vZGFsJ11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiAkQVxuICB9LFxuICByaXBwbGU6IHtcbiAgICBuYW1lOiBcIlJpcHBsZVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXJpcHBsZS1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IExBXG4gIH0sXG4gIG9mZmNhbnZhczoge1xuICAgIG5hbWU6IFwiT2ZmY2FudmFzXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtb2ZmY2FudmFzLXRvZ2dsZV1cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBJQVxuICB9LFxuICB0YWI6IHtcbiAgICBuYW1lOiBcIlRhYlwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvZ2dsZT0ndGFiJ10sIFtkYXRhLXRlLXRvZ2dsZT0ncGlsbCddLCBbZGF0YS10ZS10b2dnbGU9J2xpc3QnXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IFNBXG4gIH0sXG4gIHRvb2x0aXA6IHtcbiAgICBuYW1lOiBcIlRvb2x0aXBcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J3Rvb2x0aXAnXVwiLFxuICAgIGlzVG9nZ2xlcjogITEsXG4gICAgY2FsbGJhY2s6IE1BXG4gIH0sXG4gIHBvcG92ZXI6IHtcbiAgICBuYW1lOiBcIlBvcG92ZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J3BvcG92ZXInXVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IFJBXG4gIH0sXG4gIGxpZ2h0Ym94OiB7XG4gICAgbmFtZTogXCJMaWdodGJveFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWxpZ2h0Ym94LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogUEFcbiAgfSxcbiAgdG91Y2g6IHtcbiAgICBuYW1lOiBcIlRvdWNoXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG91Y2gtaW5pdF1cIlxuICB9XG59LCBWQSA9IChzKSA9PiBOaVtzLk5BTUVdIHx8IG51bGwsIFdBID0gKHMsIHQpID0+IHtcbiAgaWYgKCFzIHx8ICF0LmFsbG93UmVpbml0cyAmJiBhci5pc0luaXRlZChzLk5BTUUpKVxuICAgIHJldHVybjtcbiAgYXIuYWRkKHMuTkFNRSk7XG4gIGNvbnN0IGUgPSBWQShzKSwgaSA9IChlID09IG51bGwgPyB2b2lkIDAgOiBlLmlzVG9nZ2xlcikgfHwgITE7XG4gIGlmICh4QShzKSwgZSAhPSBudWxsICYmIGUuYWR2YW5jZWQpIHtcbiAgICBlID09IG51bGwgfHwgZS5hZHZhbmNlZChzLCBlID09IG51bGwgPyB2b2lkIDAgOiBlLnNlbGVjdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGkpIHtcbiAgICBlID09IG51bGwgfHwgZS5jYWxsYmFjayhzLCBlID09IG51bGwgPyB2b2lkIDAgOiBlLnNlbGVjdG9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZC5maW5kKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuc2VsZWN0b3IpLmZvckVhY2goKG4pID0+IHtcbiAgICBsZXQgbyA9IHMuZ2V0SW5zdGFuY2Uobik7XG4gICAgbyB8fCAobyA9IG5ldyBzKG4pLCBlICE9IG51bGwgJiYgZS5vbkluaXQgJiYgb1tlLm9uSW5pdF0oKSk7XG4gIH0pO1xufSwgRkEgPSAocywgdCkgPT4ge1xuICBzLmZvckVhY2goKGUpID0+IFdBKGUsIHQpKTtcbn0sIFlBID0ge1xuICBhbGxvd1JlaW5pdHM6ICExLFxuICBjaGVja090aGVySW1wb3J0czogITFcbn0sIHFBID0gKHMsIHQgPSB7fSkgPT4ge1xuICB0ID0geyAuLi5ZQSwgLi4udCB9O1xuICBjb25zdCBlID0gT2JqZWN0LmtleXMoTmkpLm1hcCgoaSkgPT4ge1xuICAgIGlmICghIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoTmlbaV0uc2VsZWN0b3IpKSB7XG4gICAgICBjb25zdCBvID0gc1tOaVtpXS5uYW1lXTtcbiAgICAgIHJldHVybiAhbyAmJiAhYXIuaXNJbml0ZWQoaSkgJiYgdC5jaGVja090aGVySW1wb3J0cyAmJiBjb25zb2xlLndhcm4oXG4gICAgICAgIGBQbGVhc2UgaW1wb3J0ICR7TmlbaV0ubmFtZX0gZnJvbSBcInR3LWVsZW1lbnRzXCIgcGFja2FnZSBhbmQgYWRkIGl0IHRvIGEgb2JqZWN0IHBhcmFtZXRlciBpbnNpZGUgXCJpbml0VEVcIiBmdW5jdGlvbmBcbiAgICAgICksIG87XG4gICAgfVxuICB9KTtcbiAgRkEoZSwgdCk7XG59O1xuZXhwb3J0IHtcbiAgS28gYXMgQWxlcnQsXG4gIHdyIGFzIEFuaW1hdGUsXG4gIGlkIGFzIEF1dG9jb21wbGV0ZSxcbiAga2MgYXMgQnV0dG9uLFxuICBYdCBhcyBDYXJvdXNlbCxcbiAgTGggYXMgQ2hhcnQsXG4gIHZpIGFzIENoaXAsXG4gIFhBIGFzIENoaXBzSW5wdXQsXG4gIFVoIGFzIENsaXBib2FyZCxcbiAgUXQgYXMgQ29sbGFwc2UsXG4gIEhoIGFzIERhdGF0YWJsZSxcbiAgb2cgYXMgRGF0ZXBpY2tlcixcbiAgUWggYXMgRGF0ZXRpbWVwaWNrZXIsXG4gICR0IGFzIERyb3Bkb3duLFxuICBYaCBhcyBJbmZpbml0ZVNjcm9sbCxcbiAgViBhcyBJbnB1dCxcbiAgb3IgYXMgTGF6eUxvYWQsXG4gIG5uIGFzIExpZ2h0Ym94LFxuICBHaCBhcyBMb2FkaW5nTWFuYWdlbWVudCxcbiAgem8gYXMgTW9kYWwsXG4gIHNkIGFzIE11bHRpUmFuZ2VTbGlkZXIsXG4gIGpzIGFzIE9mZmNhbnZhcyxcbiAgQmggYXMgUGVyZmVjdFNjcm9sbGJhcixcbiAgV2ggYXMgUG9wY29uZmlybSxcbiAgbmggYXMgUG9wb3ZlcixcbiAgR0EgYXMgUmF0aW5nLFxuICBlaSBhcyBSaXBwbGUsXG4gIGFoIGFzIFNjcm9sbFNweSxcbiAga3IgYXMgU2VsZWN0LFxuICBDaSBhcyBTaWRlbmF2LFxuICB6aCBhcyBTbW9vdGhTY3JvbGwsXG4gIFVBIGFzIFN0ZXBwZXIsXG4gIHRkIGFzIFN0aWNreSxcbiAgbGggYXMgVGFiLFxuICBTZyBhcyBUaW1lcGlja2VyLFxuICBYbyBhcyBUb2FzdCxcbiAgcmkgYXMgVG9vbHRpcCxcbiAgS2ggYXMgVG91Y2gsXG4gIGpoIGFzIFZhbGlkYXRpb24sXG4gIHFBIGFzIGluaXRURVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR3LWVsZW1lbnRzLmVzLm1pbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==